(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _jsonEditor = require("@json-editor/json-editor");
_jsonEditor.JSONEditor.defaults.options.theme = 'bootstrap5';
_jsonEditor.JSONEditor.defaults.options.iconlib = 'fontawesome5';
var _default = exports["default"] = _jsonEditor.JSONEditor;

},{"@json-editor/json-editor":5}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
/**
 * SeamlessLoop.js 2.0 - Reproduces seamless loops on HTML5/Javascript
 * https://github.com/Hivenfour/SeamlessLoop
 *
 * Copyright (c) 2012 Main Software,
 * Written by DarÃ­o Tejedor Rico. Contact mail: hivenfour@gmail.com
 * The source code is freely distributable under the terms of LGPL license.
 * License details at http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 * USAGE:
 * - Create the Seamlessloop object
 * 		var loop = new SeamlessLoop();
 *
 * - Add as many sounds as you will use, providing duration in miliseconds
 * (sounds must be pre-loaded if you want to update the loop without gaps)
 * 		loop.addUri(uri, length, "sound1");
 * 		loop.addUri(uri, length, "sound2");
 * ...
 *
 * - Establish your callback function that will be called when all sounds are pre-loaded
 * 		loop.callback(soundsLoaded);
 *
 * - Start reproducing the seamless loop:
 * 		function soundsLoaded() {
 * 			var n = 1;
 * 			loop.start("sound" + n);
 * 		};
 *
 * - Update the looping sound, you can do this
 * synchronously (waiting the loop to finish)
 * or asynchronously (change sound immediately):
 * 		n++;
 * 		loop.update("sound" + n, false);
 *
 * - Modify the seamless loop volume:
 * 		loop.volume(0.5);
 * 		loop.volume(loop.volume() + 0.1);
 *
 * - Stop the seamless loop:
 * 		loop.stop();
 */

function SeamlessLoop() {
  this.is = {
    ff: Boolean(!(window.mozInnerScreenX == null) && /firefox/.test(navigator.userAgent.toLowerCase())),
    ie: Boolean(document.all && !window.opera),
    opera: Boolean(window.opera),
    chrome: Boolean(window.chrome),
    safari: Boolean(!window.chrome && /safari/.test(navigator.userAgent.toLowerCase()) && window.getComputedStyle && !window.globalStorage && !window.opera)
  };
  //console.debug("ff: " + this.is.ff);
  //console.debug("ie: " + this.is.ie);
  //console.debug("opera: " + this.is.opera);
  //console.debug("chrome: " + this.is.chrome);
  //console.debug("safari: " + this.is.safari);
  this._total = 0;
  this._load = 0;
  this.cb_loaded;
  this.cb_loaded_flag = new Boolean();
  this.timeout;
  this.playDelay = -30;
  this.stopDelay = 30;
  if (this.is.chrome) this.playDelay = -25;
  if (this.is.chrome) this.stopDelay = 25;
  if (this.is.ff) this.playDelay = -25;
  if (this.is.ff) this.stopDelay = 85;
  if (this.is.opera) this.playDelay = 5;
  if (this.is.opera) this.stopDelay = 0;
  //console.debug(this.playDelay + ", " + this.stopDelay);
  this.next = 1;
  this.audios = new Array();
  this.actual = new Array();
  this.dropOld = new Boolean();
  this.old;
  this._volume = 1;
  var t = this;
  this._eventCanplaythrough = function (audBool) {
    if (audBool == false) {
      audBool = true;
      t._load++;
      if (t._load == t._total) {
        t.loaded = true;
        if (t.cb_loaded_flag == true) {
          t.cb_loaded();
          t.cb_loaded_flag = false;
        }
      }
    }
  };
  this._eventPlaying = function (audMute) {
    setTimeout(function () {
      audMute.pause();
      try {
        audMute.currentTime = 0;
      } catch (e) {
        console.error(e);
      }
    }, t.stopDelay);
    if (t.dropOld == true) {
      setTimeout(function () {
        if (t.old.paused == false) {
          t.old.pause();
          try {
            t.old.currentTime = 0;
          } catch (e) {
            console.error(e);
          }
        }
      }, t.stopDelay);
      t.dropOld = false;
    }
  };
  this._eventEnded = function (aud) {
    aud.volume = this._volume;
  };
  this.doLoop = function () {
    var key = this.next == 1 ? '_1' : '_2';
    var antikey = this.next == 1 ? '_2' : '_1';
    var t = this;
    this.timeout = setTimeout(function () {
      t.doLoop();
    }, this.actual._length + this.playDelay);
    if (this.is.opera) this.actual[antikey].pause();
    this.actual[key].play();
    this.next *= -1;
  };
  this.isLoaded = function () {
    return Boolean(this._load == this._total);
  };
}
SeamlessLoop.prototype.start = function (id) {
  if (id != '') {
    this.actual = this.audios[id];
  }
  this.doLoop();
};
SeamlessLoop.prototype.volume = function (vol) {
  if (typeof vol != 'undefined') {
    this.actual._1.volume = vol;
    this.actual._2.volume = vol;
    this._volume = vol;
  }
  return vol;
};
SeamlessLoop.prototype.stop = function () {
  clearTimeout(this.timeout);
  this.actual._1.currentTime = 0;
  this.actual._1.pause();
  this.actual._2.currentTime = 0;
  this.actual._2.pause();
};
SeamlessLoop.prototype.callback = function (cb_loaded) {
  this.cb_loaded = cb_loaded;
  if (this.isLoaded() == true) cb_loaded();else this.cb_loaded_flag = true;
};
SeamlessLoop.prototype.update = function (id, sync) {
  //var key = (this.next == 1 ? "_1" : "_2");
  var antikey = this.next == 1 ? '_2' : '_1';
  this.old = this.actual[antikey];
  this.actual = this.audios[id];
  if (sync == false) {
    if (this.old.paused == false) {
      this.dropOld = true;
      if (this.is.opera) this.old.pause();
    }
    clearTimeout(this.timeout);
    this.doLoop();
  }
};
SeamlessLoop.prototype.addUri = function (uri, length, id) {
  this.audios[id] = new Array();
  this.audios[id]._length = length;
  var t = this;
  this.audios[id]._1_isLoaded = new Boolean();
  this.audios[id]._2_isLoaded = new Boolean();
  this.audios[id]._1 = new Audio(uri);
  this.audios[id]._2 = new Audio(uri);
  this._total++;
  this.audios[id]._1.addEventListener('canplaythrough', function () {
    t._eventCanplaythrough(t.audios[id]._1_isLoaded);
  });
  this.audios[id]._2.addEventListener('canplaythrough', function () {
    t._eventCanplaythrough(t.audios[id]._2_isLoaded);
  });
  this.audios[id]._1.addEventListener('playing', function () {
    t._eventPlaying(t.audios[id]._2);
  });
  this.audios[id]._2.addEventListener('playing', function () {
    t._eventPlaying(t.audios[id]._1);
  });
  this.audios[id]._1.addEventListener('ended', function () {
    t._eventEnded(t.audios[id]._1);
  });
  this.audios[id]._2.addEventListener('ended', function () {
    t._eventEnded(t.audios[id]._2);
  });
  this.audios[id]._1.load();
  this.audios[id]._2.load();
  this.audios[id]._1.volume = this._volume;
  this.audios[id]._2.volume = this._volume;
};
var _default = exports["default"] = SeamlessLoop;

},{}],3:[function(require,module,exports){
"use strict";

var _jquery = _interopRequireDefault(require("jquery"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * bootstrap-paginator.js v0.6
 * --
 * Copyright 2013 Yun Lai <lyonlai1984@gmail.com>
 * Copyright 2022 Bootstrap 4 Version adapted by Yasmin Seidel (JasminDreasond)
 * --
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* https://jacobmarshall-etc.github.io/bootstrap-paginator/ */

var BootstrapPaginator = function BootstrapPaginator(element, options) {
    this.init(element, options);
  },
  old = null;
BootstrapPaginator.prototype = {
  /**
   * Initialization function of the paginator, accepting an element and the options as parameters
   *
   * @param element element of the paginator
   * @param options the options to config the paginator
   *
   * */
  init: function init(element, options) {
    this.$element = (0, _jquery["default"])(element);
    this.currentPage = 1;
    this.lastPage = 1;
    this.setOptions(options);
    this.initialized = true;
  },
  /**
   * Update the properties of the paginator element
   *
   * @param options options to config the paginator
   * */
  setOptions: function setOptions(options) {
    this.options = _jquery["default"].extend({}, this.options || _jquery["default"].fn.bootstrapPaginator.defaults, options);
    this.totalPages = parseInt(this.options.totalPages, 10); //setup the total pages property.
    this.numberOfPages = parseInt(this.options.numberOfPages, 10); //setup the numberOfPages to be shown

    //move the set current page after the setting of total pages. otherwise it will cause out of page exception.
    if (options && typeof options.currentPage !== 'undefined') {
      this.setCurrentPage(options.currentPage);
    }
    this.listen();

    //render the paginator
    this.render();
    if (!this.initialized && this.lastPage !== this.currentPage) {
      this.$element.trigger('page-changed', [this.lastPage, this.currentPage]);
    }
  },
  /**
   * Sets up the events listeners. Currently the pageclicked and pagechanged events are linked if available.
   *
   * */
  listen: function listen() {
    this.$element.off('page-clicked');
    this.$element.off('page-changed'); // unload the events for the element

    if (typeof this.options.onPageClicked === 'function') {
      this.$element.bind('page-clicked', this.options.onPageClicked);
    }
    if (typeof this.options.onPageChanged === 'function') {
      this.$element.on('page-changed', this.options.onPageChanged);
    }
    this.$element.bind('page-clicked', this.onPageClicked);
  },
  /**
   *
   *  Destroys the paginator element, it unload the event first, then empty the content inside.
   *
   * */
  destroy: function destroy() {
    this.$element.off('page-clicked');
    this.$element.off('page-changed');
    this.$element.removeData('bootstrapPaginator');
    this.$element.empty();
  },
  /**
   * Shows the page
   *
   * */
  show: function show(page) {
    this.setCurrentPage(page);
    this.render();
    if (this.lastPage !== this.currentPage) {
      this.$element.trigger('page-changed', [this.lastPage, this.currentPage]);
    }
  },
  /**
   * Shows the next page
   *
   * */
  showNext: function showNext() {
    var pages = this.getPages();
    if (pages.next) {
      this.show(pages.next);
    }
  },
  /**
   * Shows the previous page
   *
   * */
  showPrevious: function showPrevious() {
    var pages = this.getPages();
    if (pages.prev) {
      this.show(pages.prev);
    }
  },
  /**
   * Shows the first page
   *
   * */
  showFirst: function showFirst() {
    var pages = this.getPages();
    if (pages.first) {
      this.show(pages.first);
    }
  },
  /**
   * Shows the last page
   *
   * */
  showLast: function showLast() {
    var pages = this.getPages();
    if (pages.last) {
      this.show(pages.last);
    }
  },
  /**
   * Internal on page item click handler, when the page item is clicked, change the current page to the corresponding page and
   * trigger the pageclick event for the listeners.
   *
   *
   * */
  onPageItemClicked: function onPageItemClicked(event) {
    var type = event.data.type,
      page = event.data.page;
    this.$element.trigger('page-clicked', [event, type, page]);
  },
  onPageClicked: function onPageClicked(event, originalEvent, type, page) {
    //show the corresponding page and retrieve the newly built item related to the page clicked before for the event return

    var currentTarget = (0, _jquery["default"])(event.currentTarget);
    switch (type) {
      case 'first':
        currentTarget.bootstrapPaginator('showFirst');
        break;
      case 'prev':
        currentTarget.bootstrapPaginator('showPrevious');
        break;
      case 'next':
        currentTarget.bootstrapPaginator('showNext');
        break;
      case 'last':
        currentTarget.bootstrapPaginator('showLast');
        break;
      case 'page':
        currentTarget.bootstrapPaginator('show', page);
        break;
    }
  },
  /**
   * Renders the paginator according to the internal properties and the settings.
   *
   *
   * */
  render: function render() {
    //fetch the container class and add them to the container
    var containerClass = this.getValueFromOption(this.options.containerClass, this.$element),
      size = this.options.size || 'normal',
      alignment = this.options.alignment || 'left',
      pages = this.getPages(),
      listContainer = (0, _jquery["default"])('<ul class="pagination"></ul>'),
      listContainerClass = this.getValueFromOption(this.options.listContainerClass, listContainer),
      first = null,
      prev = null,
      next = null,
      last = null,
      p = null,
      i = 0;
    switch (size.toLowerCase()) {
      case 'large':
      case 'small':
      case 'mini':
        listContainer.addClass(_jquery["default"].fn.bootstrapPaginator.sizeArray[size.toLowerCase()]);
        break;
      default:
        break;
    }
    switch (alignment.toLowerCase()) {
      case 'center':
        listContainer.addClass('justify-content-center');
        break;
      case 'right':
        listContainer.addClass('justify-content-end');
        break;
      default:
        break;
    }
    this.$element.addClass(containerClass);

    //empty the outter most container then add the listContainer inside.
    this.$element.empty();
    this.$element.append(listContainer);
    listContainer.addClass(listContainerClass);

    //update the page element reference
    this.pageRef = [];
    if (pages.first) {
      //if the there is first page element
      first = this.buildPageItem('first', pages.first);
      if (first) {
        listContainer.append(first);
      }
    }
    if (pages.prev) {
      //if the there is previous page element

      prev = this.buildPageItem('prev', pages.prev);
      if (prev) {
        listContainer.append(prev);
      }
    }
    for (i = 0; i < pages.length; i = i + 1) {
      //fill the numeric pages.

      p = this.buildPageItem('page', pages[i]);
      if (p) {
        listContainer.append(p);
      }
    }
    if (pages.next) {
      //if there is next page

      next = this.buildPageItem('next', pages.next);
      if (next) {
        listContainer.append(next);
      }
    }
    if (pages.last) {
      //if there is last page

      last = this.buildPageItem('last', pages.last);
      if (last) {
        listContainer.append(last);
      }
    }
  },
  /**
   *
   * Creates a page item base on the type and page number given.
   *
   * @param page page number
   * @param type type of the page, whether it is the first, prev, page, next, last
   *
   * @return Object the constructed page element
   * */
  buildPageItem: function buildPageItem(type, page) {
    var itemContainer = (0, _jquery["default"])('<li class="page-item"></li>'),
      //creates the item container
      itemContent = (0, _jquery["default"])('<a class="page-link"></a>'),
      //creates the item content
      text = '',
      title = '',
      itemContainerClass = this.options.itemContainerClass(type, page, this.currentPage),
      itemContentClass = this.getValueFromOption(this.options.itemContentClass, type, page, this.currentPage),
      tooltipOpts = null;
    switch (type) {
      case 'first':
        if (!this.getValueFromOption(this.options.shouldShowPage, type, page, this.currentPage)) {
          return;
        }
        text = this.options.itemTexts(type, page, this.currentPage);
        title = this.options.tooltipTitles(type, page, this.currentPage);
        break;
      case 'last':
        if (!this.getValueFromOption(this.options.shouldShowPage, type, page, this.currentPage)) {
          return;
        }
        text = this.options.itemTexts(type, page, this.currentPage);
        title = this.options.tooltipTitles(type, page, this.currentPage);
        break;
      case 'prev':
        if (!this.getValueFromOption(this.options.shouldShowPage, type, page, this.currentPage)) {
          return;
        }
        text = this.options.itemTexts(type, page, this.currentPage);
        title = this.options.tooltipTitles(type, page, this.currentPage);
        break;
      case 'next':
        if (!this.getValueFromOption(this.options.shouldShowPage, type, page, this.currentPage)) {
          return;
        }
        text = this.options.itemTexts(type, page, this.currentPage);
        title = this.options.tooltipTitles(type, page, this.currentPage);
        break;
      case 'page':
        if (!this.getValueFromOption(this.options.shouldShowPage, type, page, this.currentPage)) {
          return;
        }
        text = this.options.itemTexts(type, page, this.currentPage);
        title = this.options.tooltipTitles(type, page, this.currentPage);
        break;
    }
    itemContainer.addClass(itemContainerClass).append(itemContent);
    itemContent.addClass(itemContentClass).html(text).on('click', null, {
      type: type,
      page: page
    }, _jquery["default"].proxy(this.onPageItemClicked, this));
    if (this.options.pageUrl) {
      itemContent.attr('href', this.getValueFromOption(this.options.pageUrl, type, page, this.currentPage));
    }
    if (this.options.useBootstrapTooltip) {
      tooltipOpts = _jquery["default"].extend({}, this.options.bootstrapTooltipOptions, {
        title: title
      });
      itemContent.tooltip(tooltipOpts);
    } else {
      itemContent.attr('title', title);
    }
    return itemContainer;
  },
  setCurrentPage: function setCurrentPage(page) {
    if (page > this.totalPages || page < 1) {
      // if the current page is out of range, throw exception.

      throw 'Page out of range';
    }
    this.lastPage = this.currentPage;
    this.currentPage = parseInt(page, 10);
  },
  /**
   * Gets an array that represents the current status of the page object. Numeric pages can be access via array mode. length attributes describes how many numeric pages are there. First, previous, next and last page can be accessed via attributes first, prev, next and last. Current attribute marks the current page within the pages.
   *
   * @return object output objects that has first, prev, next, last and also the number of pages in between.
   * */
  getPages: function getPages() {
    var totalPages = this.totalPages,
      // get or calculate the total pages via the total records
      pageStart = this.currentPage % this.numberOfPages === 0 ? (parseInt(this.currentPage / this.numberOfPages, 10) - 1) * this.numberOfPages + 1 : parseInt(this.currentPage / this.numberOfPages, 10) * this.numberOfPages + 1,
      //calculates the start page.
      output = [],
      i = 0,
      counter = 0;
    pageStart = pageStart < 1 ? 1 : pageStart; //check the range of the page start to see if its less than 1.

    for (i = pageStart, counter = 0; counter < this.numberOfPages && i <= totalPages; i = i + 1, counter = counter + 1) {
      //fill the pages
      output.push(i);
    }
    output.first = 1; //add the first when the current page leaves the 1st page.

    if (this.currentPage > 1) {
      // add the previous when the current page leaves the 1st page
      output.prev = this.currentPage - 1;
    } else {
      output.prev = 1;
    }
    if (this.currentPage < totalPages) {
      // add the next page when the current page doesn't reach the last page
      output.next = this.currentPage + 1;
    } else {
      output.next = totalPages;
    }
    output.last = totalPages; // add the last page when the current page doesn't reach the last page

    output.current = this.currentPage; //mark the current page.

    output.total = totalPages;
    output.numberOfPages = this.options.numberOfPages;
    return output;
  },
  /**
   * Gets the value from the options, this is made to handle the situation where value is the return value of a function.
   *
   * @return mixed value that depends on the type of parameters, if the given parameter is a function, then the evaluated result is returned. Otherwise the parameter itself will get returned.
   * */
  getValueFromOption: function getValueFromOption(value) {
    var output = null,
      args = Array.prototype.slice.call(arguments, 1);
    if (typeof value === 'function') {
      output = value.apply(this, args);
    } else {
      output = value;
    }
    return output;
  }
};

/* TYPEAHEAD PLUGIN DEFINITION
 * =========================== */

old = _jquery["default"].fn.bootstrapPaginator;
_jquery["default"].fn.bootstrapPaginator = function (option) {
  var args = arguments,
    result = null;
  (0, _jquery["default"])(this).each(function (index, item) {
    var $this = (0, _jquery["default"])(item),
      data = $this.data('bootstrapPaginator'),
      options = _typeof(option) !== 'object' ? null : option;
    if (!data) {
      data = new BootstrapPaginator(this, options);
      $this = (0, _jquery["default"])(data.$element);
      $this.data('bootstrapPaginator', data);
      return;
    }
    if (typeof option === 'string') {
      if (data[option]) {
        result = data[option].apply(data, Array.prototype.slice.call(args, 1));
      } else {
        throw 'Method ' + option + ' does not exist';
      }
    } else {
      result = data.setOptions(option);
    }
  });
  return result;
};
_jquery["default"].fn.bootstrapPaginator.sizeArray = {
  large: 'pagination-lg',
  small: 'pagination-sm',
  mini: ''
};
_jquery["default"].fn.bootstrapPaginator.defaults = {
  containerClass: '',
  size: 'normal',
  alignment: 'left',
  listContainerClass: '',
  itemContainerClass: function itemContainerClass(type, page, current) {
    return page === current ? 'active' : '';
  },
  itemContentClass: function itemContentClass(type, page, current) {
    return '';
  },
  currentPage: 1,
  numberOfPages: 5,
  totalPages: 1,
  pageUrl: function pageUrl(type, page, current) {
    return null;
  },
  onPageClicked: null,
  onPageChanged: null,
  useBootstrapTooltip: false,
  shouldShowPage: function shouldShowPage(type, page, current) {
    var result = true;
    switch (type) {
      case 'first':
        result = current !== 1;
        break;
      case 'prev':
        result = current !== 1;
        break;
      case 'next':
        result = current !== this.totalPages;
        break;
      case 'last':
        result = current !== this.totalPages;
        break;
      case 'page':
        result = true;
        break;
    }
    return result;
  },
  itemTexts: function itemTexts(type, page, current) {
    switch (type) {
      case 'first':
        return '&lt;&lt;';
      case 'prev':
        return '&lt;';
      case 'next':
        return '&gt;';
      case 'last':
        return '&gt;&gt;';
      case 'page':
        return page;
    }
  },
  tooltipTitles: function tooltipTitles(type, page, current) {
    switch (type) {
      case 'first':
        return 'Go to first page';
      case 'prev':
        return 'Go to previous page';
      case 'next':
        return 'Go to next page';
      case 'last':
        return 'Go to last page';
      case 'page':
        return page === current ? 'Current page is ' + page : 'Go to page ' + page;
    }
  },
  bootstrapTooltipOptions: {
    animation: true,
    html: true,
    placement: 'top',
    selector: false,
    title: '',
    container: false
  }
};
_jquery["default"].fn.bootstrapPaginator.Constructor = BootstrapPaginator;

},{"jquery":97}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
/**
 * BuffAudio.js - http://github.com/eipark/buffaudio
 * A wrapper around the HTML5 Web Audio API to easily play, pause,
 * and skip around an AudioBuffer.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer
 * https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 Ernie Park
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var BuffAudio = function BuffAudio(audioContext, buffer) {
  this._audioContext = audioContext;
  this._buffer = buffer; // AudioBuffer
  this._source; // AudioBufferSourceNode
  this._playbackTime = 0; // time of the audio playback, seconds
  this._startTimestamp = 0; // timestamp of last playback start, milliseconds
  this._isPlaying = false;
  this._bufferDuration = 0; // seconds

  // Whenever we get a new AudioBuffer, we create a new AudioBufferSourceNode and reset
  // the playback time. Make sure any existing audio is stopped beforehand.
  this.initNewBuffer = function (buffer) {
    this.stop();
    this._buffer = buffer;
    this._playbackTime = 0;
  };

  // Create a new AudioBufferSourceNode
  this.initSource = function () {
    this._source = this._audioContext.createBufferSource();
    this._source.buffer = this._buffer;
    this._source.connect(this._audioContext.destination);
    // Bind the callback to this
    var endOfPlayback = this.endOfPlayback.bind(this);
    this._source.onended = endOfPlayback;
  };

  // Play the currently loaded buffer
  this.play = function () {
    console.log('Play');
    if (this._isPlaying) return;
    var when = 0; // when to schedule playback, 0 is immediately
    this.initSource();
    this._source.start(0, this._playbackTime);
    this._startTimestamp = Date.now();
    this._isPlaying = true;
  };

  // Seek to a specific playbackTime (seconds) in the audio buffer. Do not change
  // playback state.
  this.seek = function (playbackTime) {
    if (playbackTime === undefined) return;
    if (playbackTime > this._buffer.duration) {
      console.log('[ERROR] Seek time is greater than duration of audio buffer.');
      return;
    }
    if (this._isPlaying) {
      this.stop(); // Stop any existing playback if there is any
      this._playbackTime = playbackTime;
      this.play(); // Resume playback at new time
    } else {
      this._playbackTime = playbackTime;
    }
  };

  // Pause playback, keep track of where playback stopped
  this.pause = function () {
    this.stop(true);
  };

  // Stops or pauses playback and sets playbackTime accordingly
  this.stop = function (pause) {
    console.log('Stop');
    if (!this._isPlaying) return;
    this._isPlaying = false; // Set to flag to endOfPlayback callback that this was set manually
    this._source.stop(0);
    // If paused, calculate time where we stopped. Otherwise go back to beginning of playback (0).
    this._playbackTime = pause ? (Date.now() - this._startTimestamp) / 1000 + this._playbackTime : 0;
  };

  // Callback for any time playback stops/pauses
  this.endOfPlayback = function (endEvent) {
    console.log('end of playback');

    // If playback stopped because end of buffer was reached
    if (this._isPlaying) this._playbackTime = 0;
    this._isPlaying = false;
  };
  this.init = function () {
    this.initNewBuffer(this._buffer);
  };
};

// Set BuffAudio on the global window object
var _default = exports["default"] = BuffAudio;

},{}],5:[function(require,module,exports){
/*! For license information please see jsoneditor.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r=e();for(var n in r)("object"==typeof exports?exports:t)[n]=r[n]}}(self,(()=>(()=>{"use strict";var t={9306:(t,e,r)=>{var n=r(4901),i=r(6823),o=TypeError;t.exports=function(t){if(n(t))return t;throw new o(i(t)+" is not a function")}},5548:(t,e,r)=>{var n=r(3517),i=r(6823),o=TypeError;t.exports=function(t){if(n(t))return t;throw new o(i(t)+" is not a constructor")}},3506:(t,e,r)=>{var n=r(3925),i=String,o=TypeError;t.exports=function(t){if(n(t))return t;throw new o("Can't set "+i(t)+" as a prototype")}},6469:(t,e,r)=>{var n=r(8227),i=r(2360),o=r(4913).f,a=n("unscopables"),s=Array.prototype;void 0===s[a]&&o(s,a,{configurable:!0,value:i(null)}),t.exports=function(t){s[a][t]=!0}},7829:(t,e,r)=>{var n=r(8183).charAt;t.exports=function(t,e,r){return e+(r?n(t,e).length:1)}},679:(t,e,r)=>{var n=r(1625),i=TypeError;t.exports=function(t,e){if(n(e,t))return t;throw new i("Incorrect invocation")}},8551:(t,e,r)=>{var n=r(34),i=String,o=TypeError;t.exports=function(t){if(n(t))return t;throw new o(i(t)+" is not an object")}},235:(t,e,r)=>{var n=r(9213).forEach,i=r(4598)("forEach");t.exports=i?[].forEach:function(t){return n(this,t,arguments.length>1?arguments[1]:void 0)}},7916:(t,e,r)=>{var n=r(6080),i=r(9565),o=r(8981),a=r(6319),s=r(4209),l=r(3517),c=r(6198),u=r(4659),h=r(81),p=r(851),d=Array;t.exports=function(t){var e=o(t),r=l(this),f=arguments.length,y=f>1?arguments[1]:void 0,m=void 0!==y;m&&(y=n(y,f>2?arguments[2]:void 0));var v,b,g,w,_,k,j=p(e),O=0;if(!j||this===d&&s(j))for(v=c(e),b=r?new this(v):d(v);v>O;O++)k=m?y(e[O],O):e[O],u(b,O,k);else for(b=r?new this:[],_=(w=h(e,j)).next;!(g=i(_,w)).done;O++)k=m?a(w,y,[g.value,O],!0):g.value,u(b,O,k);return b.length=O,b}},9617:(t,e,r)=>{var n=r(5397),i=r(5610),o=r(6198),a=function(t){return function(e,r,a){var s=n(e),l=o(s);if(0===l)return!t&&-1;var c,u=i(a,l);if(t&&r!=r){for(;l>u;)if((c=s[u++])!=c)return!0}else for(;l>u;u++)if((t||u in s)&&s[u]===r)return t||u||0;return!t&&-1}};t.exports={includes:a(!0),indexOf:a(!1)}},9213:(t,e,r)=>{var n=r(6080),i=r(9504),o=r(7055),a=r(8981),s=r(6198),l=r(1469),c=i([].push),u=function(t){var e=1===t,r=2===t,i=3===t,u=4===t,h=6===t,p=7===t,d=5===t||h;return function(f,y,m,v){for(var b,g,w=a(f),_=o(w),k=s(_),j=n(y,m),O=0,x=v||l,C=e?x(f,k):r||p?x(f,0):void 0;k>O;O++)if((d||O in _)&&(g=j(b=_[O],O,w),t))if(e)C[O]=g;else if(g)switch(t){case 3:return!0;case 5:return b;case 6:return O;case 2:c(C,b)}else switch(t){case 4:return!1;case 7:c(C,b)}return h?-1:i||u?u:C}};t.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6),filterReject:u(7)}},597:(t,e,r)=>{var n=r(9039),i=r(8227),o=r(7388),a=i("species");t.exports=function(t){return o>=51||!n((function(){var e=[];return(e.constructor={})[a]=function(){return{foo:1}},1!==e[t](Boolean).foo}))}},4598:(t,e,r)=>{var n=r(9039);t.exports=function(t,e){var r=[][t];return!!r&&n((function(){r.call(null,e||function(){return 1},1)}))}},926:(t,e,r)=>{var n=r(9306),i=r(8981),o=r(7055),a=r(6198),s=TypeError,l="Reduce of empty array with no initial value",c=function(t){return function(e,r,c,u){var h=i(e),p=o(h),d=a(h);if(n(r),0===d&&c<2)throw new s(l);var f=t?d-1:0,y=t?-1:1;if(c<2)for(;;){if(f in p){u=p[f],f+=y;break}if(f+=y,t?f<0:d<=f)throw new s(l)}for(;t?f>=0:d>f;f+=y)f in p&&(u=r(u,p[f],f,h));return u}};t.exports={left:c(!1),right:c(!0)}},4527:(t,e,r)=>{var n=r(3724),i=r(4376),o=TypeError,a=Object.getOwnPropertyDescriptor,s=n&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(t){return t instanceof TypeError}}();t.exports=s?function(t,e){if(i(t)&&!a(t,"length").writable)throw new o("Cannot set read only .length");return t.length=e}:function(t,e){return t.length=e}},7680:(t,e,r)=>{var n=r(9504);t.exports=n([].slice)},4488:(t,e,r)=>{var n=r(7680),i=Math.floor,o=function(t,e){var r=t.length;if(r<8)for(var a,s,l=1;l<r;){for(s=l,a=t[l];s&&e(t[s-1],a)>0;)t[s]=t[--s];s!==l++&&(t[s]=a)}else for(var c=i(r/2),u=o(n(t,0,c),e),h=o(n(t,c),e),p=u.length,d=h.length,f=0,y=0;f<p||y<d;)t[f+y]=f<p&&y<d?e(u[f],h[y])<=0?u[f++]:h[y++]:f<p?u[f++]:h[y++];return t};t.exports=o},7433:(t,e,r)=>{var n=r(4376),i=r(3517),o=r(34),a=r(8227)("species"),s=Array;t.exports=function(t){var e;return n(t)&&(e=t.constructor,(i(e)&&(e===s||n(e.prototype))||o(e)&&null===(e=e[a]))&&(e=void 0)),void 0===e?s:e}},1469:(t,e,r)=>{var n=r(7433);t.exports=function(t,e){return new(n(t))(0===e?0:e)}},6319:(t,e,r)=>{var n=r(8551),i=r(9539);t.exports=function(t,e,r,o){try{return o?e(n(r)[0],r[1]):e(r)}catch(e){i(t,"throw",e)}}},4428:(t,e,r)=>{var n=r(8227)("iterator"),i=!1;try{var o=0,a={next:function(){return{done:!!o++}},return:function(){i=!0}};a[n]=function(){return this},Array.from(a,(function(){throw 2}))}catch(t){}t.exports=function(t,e){try{if(!e&&!i)return!1}catch(t){return!1}var r=!1;try{var o={};o[n]=function(){return{next:function(){return{done:r=!0}}}},t(o)}catch(t){}return r}},4576:(t,e,r)=>{var n=r(9504),i=n({}.toString),o=n("".slice);t.exports=function(t){return o(i(t),8,-1)}},6955:(t,e,r)=>{var n=r(2140),i=r(4901),o=r(4576),a=r(8227)("toStringTag"),s=Object,l="Arguments"===o(function(){return arguments}());t.exports=n?o:function(t){var e,r,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,e){try{return t[e]}catch(t){}}(e=s(t),a))?r:l?o(e):"Object"===(n=o(e))&&i(e.callee)?"Arguments":n}},7740:(t,e,r)=>{var n=r(9297),i=r(5031),o=r(7347),a=r(4913);t.exports=function(t,e,r){for(var s=i(e),l=a.f,c=o.f,u=0;u<s.length;u++){var h=s[u];n(t,h)||r&&n(r,h)||l(t,h,c(e,h))}}},1436:(t,e,r)=>{var n=r(8227)("match");t.exports=function(t){var e=/./;try{"/./"[t](e)}catch(r){try{return e[n]=!1,"/./"[t](e)}catch(t){}}return!1}},2211:(t,e,r)=>{var n=r(9039);t.exports=!n((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype}))},2529:t=>{t.exports=function(t,e){return{value:t,done:e}}},6699:(t,e,r)=>{var n=r(3724),i=r(4913),o=r(6980);t.exports=n?function(t,e,r){return i.f(t,e,o(1,r))}:function(t,e,r){return t[e]=r,t}},6980:t=>{t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},4659:(t,e,r)=>{var n=r(3724),i=r(4913),o=r(6980);t.exports=function(t,e,r){n?i.f(t,e,o(0,r)):t[e]=r}},380:(t,e,r)=>{var n=r(9504),i=r(9039),o=r(533).start,a=RangeError,s=isFinite,l=Math.abs,c=Date.prototype,u=c.toISOString,h=n(c.getTime),p=n(c.getUTCDate),d=n(c.getUTCFullYear),f=n(c.getUTCHours),y=n(c.getUTCMilliseconds),m=n(c.getUTCMinutes),v=n(c.getUTCMonth),b=n(c.getUTCSeconds);t.exports=i((function(){return"0385-07-25T07:06:39.999Z"!==u.call(new Date(-50000000000001))}))||!i((function(){u.call(new Date(NaN))}))?function(){if(!s(h(this)))throw new a("Invalid time value");var t=this,e=d(t),r=y(t),n=e<0?"-":e>9999?"+":"";return n+o(l(e),n?6:4,0)+"-"+o(v(t)+1,2,0)+"-"+o(p(t),2,0)+"T"+o(f(t),2,0)+":"+o(m(t),2,0)+":"+o(b(t),2,0)+"."+o(r,3,0)+"Z"}:u},3640:(t,e,r)=>{var n=r(8551),i=r(4270),o=TypeError;t.exports=function(t){if(n(this),"string"===t||"default"===t)t="string";else if("number"!==t)throw new o("Incorrect hint");return i(this,t)}},2106:(t,e,r)=>{var n=r(283),i=r(4913);t.exports=function(t,e,r){return r.get&&n(r.get,e,{getter:!0}),r.set&&n(r.set,e,{setter:!0}),i.f(t,e,r)}},6840:(t,e,r)=>{var n=r(4901),i=r(4913),o=r(283),a=r(9433);t.exports=function(t,e,r,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(n(r)&&o(r,c,s),s.global)l?t[e]=r:a(e,r);else{try{s.unsafe?t[e]&&(l=!0):delete t[e]}catch(t){}l?t[e]=r:i.f(t,e,{value:r,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return t}},9433:(t,e,r)=>{var n=r(4475),i=Object.defineProperty;t.exports=function(t,e){try{i(n,t,{value:e,configurable:!0,writable:!0})}catch(r){n[t]=e}return e}},4606:(t,e,r)=>{var n=r(6823),i=TypeError;t.exports=function(t,e){if(!delete t[e])throw new i("Cannot delete property "+n(e)+" of "+n(t))}},3724:(t,e,r)=>{var n=r(9039);t.exports=!n((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},4055:(t,e,r)=>{var n=r(4475),i=r(34),o=n.document,a=i(o)&&i(o.createElement);t.exports=function(t){return a?o.createElement(t):{}}},6837:t=>{var e=TypeError;t.exports=function(t){if(t>9007199254740991)throw e("Maximum allowed index exceeded");return t}},7400:t=>{t.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},9296:(t,e,r)=>{var n=r(4055)("span").classList,i=n&&n.constructor&&n.constructor.prototype;t.exports=i===Object.prototype?void 0:i},8834:(t,e,r)=>{var n=r(9392).match(/firefox\/(\d+)/i);t.exports=!!n&&+n[1]},7290:(t,e,r)=>{var n=r(516),i=r(9088);t.exports=!n&&!i&&"object"==typeof window&&"object"==typeof document},6763:t=>{t.exports="function"==typeof Bun&&Bun&&"string"==typeof Bun.version},516:t=>{t.exports="object"==typeof Deno&&Deno&&"object"==typeof Deno.version},3202:(t,e,r)=>{var n=r(9392);t.exports=/MSIE|Trident/.test(n)},28:(t,e,r)=>{var n=r(9392);t.exports=/ipad|iphone|ipod/i.test(n)&&"undefined"!=typeof Pebble},8119:(t,e,r)=>{var n=r(9392);t.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(n)},9088:(t,e,r)=>{var n=r(4475),i=r(4576);t.exports="process"===i(n.process)},6765:(t,e,r)=>{var n=r(9392);t.exports=/web0s(?!.*chrome)/i.test(n)},9392:t=>{t.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},7388:(t,e,r)=>{var n,i,o=r(4475),a=r(9392),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(i=(n=u.split("."))[0]>0&&n[0]<4?1:+(n[0]+n[1])),!i&&a&&(!(n=a.match(/Edge\/(\d+)/))||n[1]>=74)&&(n=a.match(/Chrome\/(\d+)/))&&(i=+n[1]),t.exports=i},9160:(t,e,r)=>{var n=r(9392).match(/AppleWebKit\/(\d+)\./);t.exports=!!n&&+n[1]},8727:t=>{t.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},6518:(t,e,r)=>{var n=r(4475),i=r(7347).f,o=r(6699),a=r(6840),s=r(9433),l=r(7740),c=r(2796);t.exports=function(t,e){var r,u,h,p,d,f=t.target,y=t.global,m=t.stat;if(r=y?n:m?n[f]||s(f,{}):n[f]&&n[f].prototype)for(u in e){if(p=e[u],h=t.dontCallGetSet?(d=i(r,u))&&d.value:r[u],!c(y?u:f+(m?".":"#")+u,t.forced)&&void 0!==h){if(typeof p==typeof h)continue;l(p,h)}(t.sham||h&&h.sham)&&o(p,"sham",!0),a(r,u,p,t)}}},9039:t=>{t.exports=function(t){try{return!!t()}catch(t){return!0}}},9228:(t,e,r)=>{r(7495);var n=r(9565),i=r(6840),o=r(7323),a=r(9039),s=r(8227),l=r(6699),c=s("species"),u=RegExp.prototype;t.exports=function(t,e,r,h){var p=s(t),d=!a((function(){var e={};return e[p]=function(){return 7},7!==""[t](e)})),f=d&&!a((function(){var e=!1,r=/a/;return"split"===t&&((r={}).constructor={},r.constructor[c]=function(){return r},r.flags="",r[p]=/./[p]),r.exec=function(){return e=!0,null},r[p](""),!e}));if(!d||!f||r){var y=/./[p],m=e(p,""[t],(function(t,e,r,i,a){var s=e.exec;return s===o||s===u.exec?d&&!a?{done:!0,value:n(y,e,r,i)}:{done:!0,value:n(t,r,e,i)}:{done:!1}}));i(String.prototype,t,m[0]),i(u,p,m[1])}h&&l(u[p],"sham",!0)}},8745:(t,e,r)=>{var n=r(616),i=Function.prototype,o=i.apply,a=i.call;t.exports="object"==typeof Reflect&&Reflect.apply||(n?a.bind(o):function(){return a.apply(o,arguments)})},6080:(t,e,r)=>{var n=r(7476),i=r(9306),o=r(616),a=n(n.bind);t.exports=function(t,e){return i(t),void 0===e?t:o?a(t,e):function(){return t.apply(e,arguments)}}},616:(t,e,r)=>{var n=r(9039);t.exports=!n((function(){var t=function(){}.bind();return"function"!=typeof t||t.hasOwnProperty("prototype")}))},566:(t,e,r)=>{var n=r(9504),i=r(9306),o=r(34),a=r(9297),s=r(7680),l=r(616),c=Function,u=n([].concat),h=n([].join),p={};t.exports=l?c.bind:function(t){var e=i(this),r=e.prototype,n=s(arguments,1),l=function(){var r=u(n,s(arguments));return this instanceof l?function(t,e,r){if(!a(p,e)){for(var n=[],i=0;i<e;i++)n[i]="a["+i+"]";p[e]=c("C,a","return new C("+h(n,",")+")")}return p[e](t,r)}(e,r.length,r):e.apply(t,r)};return o(r)&&(l.prototype=r),l}},9565:(t,e,r)=>{var n=r(616),i=Function.prototype.call;t.exports=n?i.bind(i):function(){return i.apply(i,arguments)}},350:(t,e,r)=>{var n=r(3724),i=r(9297),o=Function.prototype,a=n&&Object.getOwnPropertyDescriptor,s=i(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!n||n&&a(o,"name").configurable);t.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},6706:(t,e,r)=>{var n=r(9504),i=r(9306);t.exports=function(t,e,r){try{return n(i(Object.getOwnPropertyDescriptor(t,e)[r]))}catch(t){}}},7476:(t,e,r)=>{var n=r(4576),i=r(9504);t.exports=function(t){if("Function"===n(t))return i(t)}},9504:(t,e,r)=>{var n=r(616),i=Function.prototype,o=i.call,a=n&&i.bind.bind(o,o);t.exports=n?a:function(t){return function(){return o.apply(t,arguments)}}},7751:(t,e,r)=>{var n=r(4475),i=r(4901);t.exports=function(t,e){return arguments.length<2?(r=n[t],i(r)?r:void 0):n[t]&&n[t][e];var r}},851:(t,e,r)=>{var n=r(6955),i=r(5966),o=r(4117),a=r(6269),s=r(8227)("iterator");t.exports=function(t){if(!o(t))return i(t,s)||i(t,"@@iterator")||a[n(t)]}},81:(t,e,r)=>{var n=r(9565),i=r(9306),o=r(8551),a=r(6823),s=r(851),l=TypeError;t.exports=function(t,e){var r=arguments.length<2?s(t):e;if(i(r))return o(n(r,t));throw new l(a(t)+" is not iterable")}},6933:(t,e,r)=>{var n=r(9504),i=r(4376),o=r(4901),a=r(4576),s=r(655),l=n([].push);t.exports=function(t){if(o(t))return t;if(i(t)){for(var e=t.length,r=[],n=0;n<e;n++){var c=t[n];"string"==typeof c?l(r,c):"number"!=typeof c&&"Number"!==a(c)&&"String"!==a(c)||l(r,s(c))}var u=r.length,h=!0;return function(t,e){if(h)return h=!1,e;if(i(this))return e;for(var n=0;n<u;n++)if(r[n]===t)return e}}}},5966:(t,e,r)=>{var n=r(9306),i=r(4117);t.exports=function(t,e){var r=t[e];return i(r)?void 0:n(r)}},2478:(t,e,r)=>{var n=r(9504),i=r(8981),o=Math.floor,a=n("".charAt),s=n("".replace),l=n("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,u=/\$([$&'`]|\d{1,2})/g;t.exports=function(t,e,r,n,h,p){var d=r+t.length,f=n.length,y=u;return void 0!==h&&(h=i(h),y=c),s(p,y,(function(i,s){var c;switch(a(s,0)){case"$":return"$";case"&":return t;case"`":return l(e,0,r);case"'":return l(e,d);case"<":c=h[l(s,1,-1)];break;default:var u=+s;if(0===u)return i;if(u>f){var p=o(u/10);return 0===p?i:p<=f?void 0===n[p-1]?a(s,1):n[p-1]+a(s,1):i}c=n[u-1]}return void 0===c?"":c}))}},4475:function(t,e,r){var n=function(t){return t&&t.Math===Math&&t};t.exports=n("object"==typeof globalThis&&globalThis)||n("object"==typeof window&&window)||n("object"==typeof self&&self)||n("object"==typeof r.g&&r.g)||n("object"==typeof this&&this)||function(){return this}()||Function("return this")()},9297:(t,e,r)=>{var n=r(9504),i=r(8981),o=n({}.hasOwnProperty);t.exports=Object.hasOwn||function(t,e){return o(i(t),e)}},421:t=>{t.exports={}},3138:t=>{t.exports=function(t,e){try{1===arguments.length?console.error(t):console.error(t,e)}catch(t){}}},397:(t,e,r)=>{var n=r(7751);t.exports=n("document","documentElement")},5917:(t,e,r)=>{var n=r(3724),i=r(9039),o=r(4055);t.exports=!n&&!i((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},7055:(t,e,r)=>{var n=r(9504),i=r(9039),o=r(4576),a=Object,s=n("".split);t.exports=i((function(){return!a("z").propertyIsEnumerable(0)}))?function(t){return"String"===o(t)?s(t,""):a(t)}:a},3167:(t,e,r)=>{var n=r(4901),i=r(34),o=r(2967);t.exports=function(t,e,r){var a,s;return o&&n(a=e.constructor)&&a!==r&&i(s=a.prototype)&&s!==r.prototype&&o(t,s),t}},3706:(t,e,r)=>{var n=r(9504),i=r(4901),o=r(7629),a=n(Function.toString);i(o.inspectSource)||(o.inspectSource=function(t){return a(t)}),t.exports=o.inspectSource},1181:(t,e,r)=>{var n,i,o,a=r(8622),s=r(4475),l=r(34),c=r(6699),u=r(9297),h=r(7629),p=r(6119),d=r(421),f="Object already initialized",y=s.TypeError,m=s.WeakMap;if(a||h.state){var v=h.state||(h.state=new m);v.get=v.get,v.has=v.has,v.set=v.set,n=function(t,e){if(v.has(t))throw new y(f);return e.facade=t,v.set(t,e),e},i=function(t){return v.get(t)||{}},o=function(t){return v.has(t)}}else{var b=p("state");d[b]=!0,n=function(t,e){if(u(t,b))throw new y(f);return e.facade=t,c(t,b,e),e},i=function(t){return u(t,b)?t[b]:{}},o=function(t){return u(t,b)}}t.exports={set:n,get:i,has:o,enforce:function(t){return o(t)?i(t):n(t,{})},getterFor:function(t){return function(e){var r;if(!l(e)||(r=i(e)).type!==t)throw new y("Incompatible receiver, "+t+" required");return r}}}},4209:(t,e,r)=>{var n=r(8227),i=r(6269),o=n("iterator"),a=Array.prototype;t.exports=function(t){return void 0!==t&&(i.Array===t||a[o]===t)}},4376:(t,e,r)=>{var n=r(4576);t.exports=Array.isArray||function(t){return"Array"===n(t)}},4901:t=>{var e="object"==typeof document&&document.all;t.exports=void 0===e&&void 0!==e?function(t){return"function"==typeof t||t===e}:function(t){return"function"==typeof t}},3517:(t,e,r)=>{var n=r(9504),i=r(9039),o=r(4901),a=r(6955),s=r(7751),l=r(3706),c=function(){},u=s("Reflect","construct"),h=/^\s*(?:class|function)\b/,p=n(h.exec),d=!h.test(c),f=function(t){if(!o(t))return!1;try{return u(c,[],t),!0}catch(t){return!1}},y=function(t){if(!o(t))return!1;switch(a(t)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return d||!!p(h,l(t))}catch(t){return!0}};y.sham=!0,t.exports=!u||i((function(){var t;return f(f.call)||!f(Object)||!f((function(){t=!0}))||t}))?y:f},6575:(t,e,r)=>{var n=r(9297);t.exports=function(t){return void 0!==t&&(n(t,"value")||n(t,"writable"))}},2796:(t,e,r)=>{var n=r(9039),i=r(4901),o=/#|\.prototype\./,a=function(t,e){var r=l[s(t)];return r===u||r!==c&&(i(e)?n(e):!!e)},s=a.normalize=function(t){return String(t).replace(o,".").toLowerCase()},l=a.data={},c=a.NATIVE="N",u=a.POLYFILL="P";t.exports=a},4117:t=>{t.exports=function(t){return null==t}},34:(t,e,r)=>{var n=r(4901);t.exports=function(t){return"object"==typeof t?null!==t:n(t)}},3925:(t,e,r)=>{var n=r(34);t.exports=function(t){return n(t)||null===t}},6395:t=>{t.exports=!1},788:(t,e,r)=>{var n=r(34),i=r(4576),o=r(8227)("match");t.exports=function(t){var e;return n(t)&&(void 0!==(e=t[o])?!!e:"RegExp"===i(t))}},757:(t,e,r)=>{var n=r(7751),i=r(4901),o=r(1625),a=r(7040),s=Object;t.exports=a?function(t){return"symbol"==typeof t}:function(t){var e=n("Symbol");return i(e)&&o(e.prototype,s(t))}},2652:(t,e,r)=>{var n=r(6080),i=r(9565),o=r(8551),a=r(6823),s=r(4209),l=r(6198),c=r(1625),u=r(81),h=r(851),p=r(9539),d=TypeError,f=function(t,e){this.stopped=t,this.result=e},y=f.prototype;t.exports=function(t,e,r){var m,v,b,g,w,_,k,j=r&&r.that,O=!(!r||!r.AS_ENTRIES),x=!(!r||!r.IS_RECORD),C=!(!r||!r.IS_ITERATOR),E=!(!r||!r.INTERRUPTED),S=n(e,j),P=function(t){return m&&p(m,"normal",t),new f(!0,t)},L=function(t){return O?(o(t),E?S(t[0],t[1],P):S(t[0],t[1])):E?S(t,P):S(t)};if(x)m=t.iterator;else if(C)m=t;else{if(!(v=h(t)))throw new d(a(t)+" is not iterable");if(s(v)){for(b=0,g=l(t);g>b;b++)if((w=L(t[b]))&&c(y,w))return w;return new f(!1)}m=u(t,v)}for(_=x?t.next:m.next;!(k=i(_,m)).done;){try{w=L(k.value)}catch(t){p(m,"throw",t)}if("object"==typeof w&&w&&c(y,w))return w}return new f(!1)}},9539:(t,e,r)=>{var n=r(9565),i=r(8551),o=r(5966);t.exports=function(t,e,r){var a,s;i(t);try{if(!(a=o(t,"return"))){if("throw"===e)throw r;return r}a=n(a,t)}catch(t){s=!0,a=t}if("throw"===e)throw r;if(s)throw a;return i(a),r}},3994:(t,e,r)=>{var n=r(7657).IteratorPrototype,i=r(2360),o=r(6980),a=r(687),s=r(6269),l=function(){return this};t.exports=function(t,e,r,c){var u=e+" Iterator";return t.prototype=i(n,{next:o(+!c,r)}),a(t,u,!1,!0),s[u]=l,t}},1088:(t,e,r)=>{var n=r(6518),i=r(9565),o=r(6395),a=r(350),s=r(4901),l=r(3994),c=r(2787),u=r(2967),h=r(687),p=r(6699),d=r(6840),f=r(8227),y=r(6269),m=r(7657),v=a.PROPER,b=a.CONFIGURABLE,g=m.IteratorPrototype,w=m.BUGGY_SAFARI_ITERATORS,_=f("iterator"),k="keys",j="values",O="entries",x=function(){return this};t.exports=function(t,e,r,a,f,m,C){l(r,e,a);var E,S,P,L=function(t){if(t===f&&B)return B;if(!w&&t&&t in R)return R[t];switch(t){case k:case j:case O:return function(){return new r(this,t)}}return function(){return new r(this)}},T=e+" Iterator",A=!1,R=t.prototype,I=R[_]||R["@@iterator"]||f&&R[f],B=!w&&I||L(f),N="Array"===e&&R.entries||I;if(N&&(E=c(N.call(new t)))!==Object.prototype&&E.next&&(o||c(E)===g||(u?u(E,g):s(E[_])||d(E,_,x)),h(E,T,!0,!0),o&&(y[T]=x)),v&&f===j&&I&&I.name!==j&&(!o&&b?p(R,"name",j):(A=!0,B=function(){return i(I,this)})),f)if(S={values:L(j),keys:m?B:L(k),entries:L(O)},C)for(P in S)(w||A||!(P in R))&&d(R,P,S[P]);else n({target:e,proto:!0,forced:w||A},S);return o&&!C||R[_]===B||d(R,_,B,{name:f}),y[e]=B,S}},7657:(t,e,r)=>{var n,i,o,a=r(9039),s=r(4901),l=r(34),c=r(2360),u=r(2787),h=r(6840),p=r(8227),d=r(6395),f=p("iterator"),y=!1;[].keys&&("next"in(o=[].keys())?(i=u(u(o)))!==Object.prototype&&(n=i):y=!0),!l(n)||a((function(){var t={};return n[f].call(t)!==t}))?n={}:d&&(n=c(n)),s(n[f])||h(n,f,(function(){return this})),t.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:y}},6269:t=>{t.exports={}},6198:(t,e,r)=>{var n=r(8014);t.exports=function(t){return n(t.length)}},283:(t,e,r)=>{var n=r(9504),i=r(9039),o=r(4901),a=r(9297),s=r(3724),l=r(350).CONFIGURABLE,c=r(3706),u=r(1181),h=u.enforce,p=u.get,d=String,f=Object.defineProperty,y=n("".slice),m=n("".replace),v=n([].join),b=s&&!i((function(){return 8!==f((function(){}),"length",{value:8}).length})),g=String(String).split("String"),w=t.exports=function(t,e,r){"Symbol("===y(d(e),0,7)&&(e="["+m(d(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),r&&r.getter&&(e="get "+e),r&&r.setter&&(e="set "+e),(!a(t,"name")||l&&t.name!==e)&&(s?f(t,"name",{value:e,configurable:!0}):t.name=e),b&&r&&a(r,"arity")&&t.length!==r.arity&&f(t,"length",{value:r.arity});try{r&&a(r,"constructor")&&r.constructor?s&&f(t,"prototype",{writable:!1}):t.prototype&&(t.prototype=void 0)}catch(t){}var n=h(t);return a(n,"source")||(n.source=v(g,"string"==typeof e?e:"")),t};Function.prototype.toString=w((function(){return o(this)&&p(this).source||c(this)}),"toString")},741:t=>{var e=Math.ceil,r=Math.floor;t.exports=Math.trunc||function(t){var n=+t;return(n>0?r:e)(n)}},1955:(t,e,r)=>{var n,i,o,a,s,l=r(4475),c=r(3389),u=r(6080),h=r(9225).set,p=r(8265),d=r(8119),f=r(28),y=r(6765),m=r(9088),v=l.MutationObserver||l.WebKitMutationObserver,b=l.document,g=l.process,w=l.Promise,_=c("queueMicrotask");if(!_){var k=new p,j=function(){var t,e;for(m&&(t=g.domain)&&t.exit();e=k.get();)try{e()}catch(t){throw k.head&&n(),t}t&&t.enter()};d||m||y||!v||!b?!f&&w&&w.resolve?((a=w.resolve(void 0)).constructor=w,s=u(a.then,a),n=function(){s(j)}):m?n=function(){g.nextTick(j)}:(h=u(h,l),n=function(){h(j)}):(i=!0,o=b.createTextNode(""),new v(j).observe(o,{characterData:!0}),n=function(){o.data=i=!i}),_=function(t){k.head||n(),k.add(t)}}t.exports=_},6043:(t,e,r)=>{var n=r(9306),i=TypeError,o=function(t){var e,r;this.promise=new t((function(t,n){if(void 0!==e||void 0!==r)throw new i("Bad Promise constructor");e=t,r=n})),this.resolve=n(e),this.reject=n(r)};t.exports.f=function(t){return new o(t)}},5749:(t,e,r)=>{var n=r(788),i=TypeError;t.exports=function(t){if(n(t))throw new i("The method doesn't accept regular expressions");return t}},3904:(t,e,r)=>{var n=r(4475),i=r(9039),o=r(9504),a=r(655),s=r(3802).trim,l=r(7452),c=o("".charAt),u=n.parseFloat,h=n.Symbol,p=h&&h.iterator,d=1/u(l+"-0")!=-1/0||p&&!i((function(){u(Object(p))}));t.exports=d?function(t){var e=s(a(t)),r=u(e);return 0===r&&"-"===c(e,0)?-0:r}:u},2703:(t,e,r)=>{var n=r(4475),i=r(9039),o=r(9504),a=r(655),s=r(3802).trim,l=r(7452),c=n.parseInt,u=n.Symbol,h=u&&u.iterator,p=/^[+-]?0x/i,d=o(p.exec),f=8!==c(l+"08")||22!==c(l+"0x16")||h&&!i((function(){c(Object(h))}));t.exports=f?function(t,e){var r=s(a(t));return c(r,e>>>0||(d(p,r)?16:10))}:c},4213:(t,e,r)=>{var n=r(3724),i=r(9504),o=r(9565),a=r(9039),s=r(1072),l=r(3717),c=r(8773),u=r(8981),h=r(7055),p=Object.assign,d=Object.defineProperty,f=i([].concat);t.exports=!p||a((function(){if(n&&1!==p({b:1},p(d({},"a",{enumerable:!0,get:function(){d(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var t={},e={},r=Symbol("assign detection"),i="abcdefghijklmnopqrst";return t[r]=7,i.split("").forEach((function(t){e[t]=t})),7!==p({},t)[r]||s(p({},e)).join("")!==i}))?function(t,e){for(var r=u(t),i=arguments.length,a=1,p=l.f,d=c.f;i>a;)for(var y,m=h(arguments[a++]),v=p?f(s(m),p(m)):s(m),b=v.length,g=0;b>g;)y=v[g++],n&&!o(d,m,y)||(r[y]=m[y]);return r}:p},2360:(t,e,r)=>{var n,i=r(8551),o=r(6801),a=r(8727),s=r(421),l=r(397),c=r(4055),u=r(6119),h="prototype",p="script",d=u("IE_PROTO"),f=function(){},y=function(t){return"<"+p+">"+t+"</"+p+">"},m=function(t){t.write(y("")),t.close();var e=t.parentWindow.Object;return t=null,e},v=function(){try{n=new ActiveXObject("htmlfile")}catch(t){}var t,e,r;v="undefined"!=typeof document?document.domain&&n?m(n):(e=c("iframe"),r="java"+p+":",e.style.display="none",l.appendChild(e),e.src=String(r),(t=e.contentWindow.document).open(),t.write(y("document.F=Object")),t.close(),t.F):m(n);for(var i=a.length;i--;)delete v[h][a[i]];return v()};s[d]=!0,t.exports=Object.create||function(t,e){var r;return null!==t?(f[h]=i(t),r=new f,f[h]=null,r[d]=t):r=v(),void 0===e?r:o.f(r,e)}},6801:(t,e,r)=>{var n=r(3724),i=r(8686),o=r(4913),a=r(8551),s=r(5397),l=r(1072);e.f=n&&!i?Object.defineProperties:function(t,e){a(t);for(var r,n=s(e),i=l(e),c=i.length,u=0;c>u;)o.f(t,r=i[u++],n[r]);return t}},4913:(t,e,r)=>{var n=r(3724),i=r(5917),o=r(8686),a=r(8551),s=r(6969),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor,h="enumerable",p="configurable",d="writable";e.f=n?o?function(t,e,r){if(a(t),e=s(e),a(r),"function"==typeof t&&"prototype"===e&&"value"in r&&d in r&&!r[d]){var n=u(t,e);n&&n[d]&&(t[e]=r.value,r={configurable:p in r?r[p]:n[p],enumerable:h in r?r[h]:n[h],writable:!1})}return c(t,e,r)}:c:function(t,e,r){if(a(t),e=s(e),a(r),i)try{return c(t,e,r)}catch(t){}if("get"in r||"set"in r)throw new l("Accessors not supported");return"value"in r&&(t[e]=r.value),t}},7347:(t,e,r)=>{var n=r(3724),i=r(9565),o=r(8773),a=r(6980),s=r(5397),l=r(6969),c=r(9297),u=r(5917),h=Object.getOwnPropertyDescriptor;e.f=n?h:function(t,e){if(t=s(t),e=l(e),u)try{return h(t,e)}catch(t){}if(c(t,e))return a(!i(o.f,t,e),t[e])}},298:(t,e,r)=>{var n=r(4576),i=r(5397),o=r(8480).f,a=r(7680),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return s&&"Window"===n(t)?function(t){try{return o(t)}catch(t){return a(s)}}(t):o(i(t))}},8480:(t,e,r)=>{var n=r(1828),i=r(8727).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return n(t,i)}},3717:(t,e)=>{e.f=Object.getOwnPropertySymbols},2787:(t,e,r)=>{var n=r(9297),i=r(4901),o=r(8981),a=r(6119),s=r(2211),l=a("IE_PROTO"),c=Object,u=c.prototype;t.exports=s?c.getPrototypeOf:function(t){var e=o(t);if(n(e,l))return e[l];var r=e.constructor;return i(r)&&e instanceof r?r.prototype:e instanceof c?u:null}},1625:(t,e,r)=>{var n=r(9504);t.exports=n({}.isPrototypeOf)},1828:(t,e,r)=>{var n=r(9504),i=r(9297),o=r(5397),a=r(9617).indexOf,s=r(421),l=n([].push);t.exports=function(t,e){var r,n=o(t),c=0,u=[];for(r in n)!i(s,r)&&i(n,r)&&l(u,r);for(;e.length>c;)i(n,r=e[c++])&&(~a(u,r)||l(u,r));return u}},1072:(t,e,r)=>{var n=r(1828),i=r(8727);t.exports=Object.keys||function(t){return n(t,i)}},8773:(t,e)=>{var r={}.propertyIsEnumerable,n=Object.getOwnPropertyDescriptor,i=n&&!r.call({1:2},1);e.f=i?function(t){var e=n(this,t);return!!e&&e.enumerable}:r},2967:(t,e,r)=>{var n=r(6706),i=r(34),o=r(7750),a=r(3506);t.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{(t=n(Object.prototype,"__proto__","set"))(r,[]),e=r instanceof Array}catch(t){}return function(r,n){return o(r),a(n),i(r)?(e?t(r,n):r.__proto__=n,r):r}}():void 0)},2357:(t,e,r)=>{var n=r(3724),i=r(9039),o=r(9504),a=r(2787),s=r(1072),l=r(5397),c=o(r(8773).f),u=o([].push),h=n&&i((function(){var t=Object.create(null);return t[2]=2,!c(t,2)})),p=function(t){return function(e){for(var r,i=l(e),o=s(i),p=h&&null===a(i),d=o.length,f=0,y=[];d>f;)r=o[f++],n&&!(p?r in i:c(i,r))||u(y,t?[r,i[r]]:i[r]);return y}};t.exports={entries:p(!0),values:p(!1)}},3179:(t,e,r)=>{var n=r(2140),i=r(6955);t.exports=n?{}.toString:function(){return"[object "+i(this)+"]"}},4270:(t,e,r)=>{var n=r(9565),i=r(4901),o=r(34),a=TypeError;t.exports=function(t,e){var r,s;if("string"===e&&i(r=t.toString)&&!o(s=n(r,t)))return s;if(i(r=t.valueOf)&&!o(s=n(r,t)))return s;if("string"!==e&&i(r=t.toString)&&!o(s=n(r,t)))return s;throw new a("Can't convert object to primitive value")}},5031:(t,e,r)=>{var n=r(7751),i=r(9504),o=r(8480),a=r(3717),s=r(8551),l=i([].concat);t.exports=n("Reflect","ownKeys")||function(t){var e=o.f(s(t)),r=a.f;return r?l(e,r(t)):e}},9167:(t,e,r)=>{var n=r(4475);t.exports=n},1103:t=>{t.exports=function(t){try{return{error:!1,value:t()}}catch(t){return{error:!0,value:t}}}},916:(t,e,r)=>{var n=r(4475),i=r(550),o=r(4901),a=r(2796),s=r(3706),l=r(8227),c=r(7290),u=r(516),h=r(6395),p=r(7388),d=i&&i.prototype,f=l("species"),y=!1,m=o(n.PromiseRejectionEvent),v=a("Promise",(function(){var t=s(i),e=t!==String(i);if(!e&&66===p)return!0;if(h&&(!d.catch||!d.finally))return!0;if(!p||p<51||!/native code/.test(t)){var r=new i((function(t){t(1)})),n=function(t){t((function(){}),(function(){}))};if((r.constructor={})[f]=n,!(y=r.then((function(){}))instanceof n))return!0}return!e&&(c||u)&&!m}));t.exports={CONSTRUCTOR:v,REJECTION_EVENT:m,SUBCLASSING:y}},550:(t,e,r)=>{var n=r(4475);t.exports=n.Promise},3438:(t,e,r)=>{var n=r(8551),i=r(34),o=r(6043);t.exports=function(t,e){if(n(t),i(e)&&e.constructor===t)return e;var r=o.f(t);return(0,r.resolve)(e),r.promise}},537:(t,e,r)=>{var n=r(550),i=r(4428),o=r(916).CONSTRUCTOR;t.exports=o||!i((function(t){n.all(t).then(void 0,(function(){}))}))},1056:(t,e,r)=>{var n=r(4913).f;t.exports=function(t,e,r){r in t||n(t,r,{configurable:!0,get:function(){return e[r]},set:function(t){e[r]=t}})}},8265:t=>{var e=function(){this.head=null,this.tail=null};e.prototype={add:function(t){var e={item:t,next:null},r=this.tail;r?r.next=e:this.head=e,this.tail=e},get:function(){var t=this.head;if(t)return null===(this.head=t.next)&&(this.tail=null),t.item}},t.exports=e},6682:(t,e,r)=>{var n=r(9565),i=r(8551),o=r(4901),a=r(4576),s=r(7323),l=TypeError;t.exports=function(t,e){var r=t.exec;if(o(r)){var c=n(r,t,e);return null!==c&&i(c),c}if("RegExp"===a(t))return n(s,t,e);throw new l("RegExp#exec called on incompatible receiver")}},7323:(t,e,r)=>{var n,i,o=r(9565),a=r(9504),s=r(655),l=r(7979),c=r(8429),u=r(5745),h=r(2360),p=r(1181).get,d=r(3635),f=r(8814),y=u("native-string-replace",String.prototype.replace),m=RegExp.prototype.exec,v=m,b=a("".charAt),g=a("".indexOf),w=a("".replace),_=a("".slice),k=(i=/b*/g,o(m,n=/a/,"a"),o(m,i,"a"),0!==n.lastIndex||0!==i.lastIndex),j=c.BROKEN_CARET,O=void 0!==/()??/.exec("")[1];(k||O||j||d||f)&&(v=function(t){var e,r,n,i,a,c,u,d=this,f=p(d),x=s(t),C=f.raw;if(C)return C.lastIndex=d.lastIndex,e=o(v,C,x),d.lastIndex=C.lastIndex,e;var E=f.groups,S=j&&d.sticky,P=o(l,d),L=d.source,T=0,A=x;if(S&&(P=w(P,"y",""),-1===g(P,"g")&&(P+="g"),A=_(x,d.lastIndex),d.lastIndex>0&&(!d.multiline||d.multiline&&"\n"!==b(x,d.lastIndex-1))&&(L="(?: "+L+")",A=" "+A,T++),r=new RegExp("^(?:"+L+")",P)),O&&(r=new RegExp("^"+L+"$(?!\\s)",P)),k&&(n=d.lastIndex),i=o(m,S?r:d,A),S?i?(i.input=_(i.input,T),i[0]=_(i[0],T),i.index=d.lastIndex,d.lastIndex+=i[0].length):d.lastIndex=0:k&&i&&(d.lastIndex=d.global?i.index+i[0].length:n),O&&i&&i.length>1&&o(y,i[0],r,(function(){for(a=1;a<arguments.length-2;a++)void 0===arguments[a]&&(i[a]=void 0)})),i&&E)for(i.groups=c=h(null),a=0;a<E.length;a++)c[(u=E[a])[0]]=i[u[1]];return i}),t.exports=v},7979:(t,e,r)=>{var n=r(8551);t.exports=function(){var t=n(this),e="";return t.hasIndices&&(e+="d"),t.global&&(e+="g"),t.ignoreCase&&(e+="i"),t.multiline&&(e+="m"),t.dotAll&&(e+="s"),t.unicode&&(e+="u"),t.unicodeSets&&(e+="v"),t.sticky&&(e+="y"),e}},1034:(t,e,r)=>{var n=r(9565),i=r(9297),o=r(1625),a=r(7979),s=RegExp.prototype;t.exports=function(t){var e=t.flags;return void 0!==e||"flags"in s||i(t,"flags")||!o(s,t)?e:n(a,t)}},8429:(t,e,r)=>{var n=r(9039),i=r(4475).RegExp,o=n((function(){var t=i("a","y");return t.lastIndex=2,null!==t.exec("abcd")})),a=o||n((function(){return!i("a","y").sticky})),s=o||n((function(){var t=i("^r","gy");return t.lastIndex=2,null!==t.exec("str")}));t.exports={BROKEN_CARET:s,MISSED_STICKY:a,UNSUPPORTED_Y:o}},3635:(t,e,r)=>{var n=r(9039),i=r(4475).RegExp;t.exports=n((function(){var t=i(".","s");return!(t.dotAll&&t.test("\n")&&"s"===t.flags)}))},8814:(t,e,r)=>{var n=r(9039),i=r(4475).RegExp;t.exports=n((function(){var t=i("(?<a>b)","g");return"b"!==t.exec("b").groups.a||"bc"!=="b".replace(t,"$<a>c")}))},7750:(t,e,r)=>{var n=r(4117),i=TypeError;t.exports=function(t){if(n(t))throw new i("Can't call method on "+t);return t}},3389:(t,e,r)=>{var n=r(4475),i=r(3724),o=Object.getOwnPropertyDescriptor;t.exports=function(t){if(!i)return n[t];var e=o(n,t);return e&&e.value}},9472:(t,e,r)=>{var n,i=r(4475),o=r(8745),a=r(4901),s=r(6763),l=r(9392),c=r(7680),u=r(2812),h=i.Function,p=/MSIE .\./.test(l)||s&&((n=i.Bun.version.split(".")).length<3||"0"===n[0]&&(n[1]<3||"3"===n[1]&&"0"===n[2]));t.exports=function(t,e){var r=e?2:1;return p?function(n,i){var s=u(arguments.length,1)>r,l=a(n)?n:h(n),p=s?c(arguments,r):[],d=s?function(){o(l,this,p)}:l;return e?t(d,i):t(d)}:t}},7633:(t,e,r)=>{var n=r(7751),i=r(2106),o=r(8227),a=r(3724),s=o("species");t.exports=function(t){var e=n(t);a&&e&&!e[s]&&i(e,s,{configurable:!0,get:function(){return this}})}},687:(t,e,r)=>{var n=r(4913).f,i=r(9297),o=r(8227)("toStringTag");t.exports=function(t,e,r){t&&!r&&(t=t.prototype),t&&!i(t,o)&&n(t,o,{configurable:!0,value:e})}},6119:(t,e,r)=>{var n=r(5745),i=r(3392),o=n("keys");t.exports=function(t){return o[t]||(o[t]=i(t))}},7629:(t,e,r)=>{var n=r(6395),i=r(4475),o=r(9433),a="__core-js_shared__",s=t.exports=i[a]||o(a,{});(s.versions||(s.versions=[])).push({version:"3.36.1",mode:n?"pure":"global",copyright:"Â© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.36.1/LICENSE",source:"https://github.com/zloirock/core-js"})},5745:(t,e,r)=>{var n=r(7629);t.exports=function(t,e){return n[t]||(n[t]=e||{})}},2293:(t,e,r)=>{var n=r(8551),i=r(5548),o=r(4117),a=r(8227)("species");t.exports=function(t,e){var r,s=n(t).constructor;return void 0===s||o(r=n(s)[a])?e:i(r)}},8183:(t,e,r)=>{var n=r(9504),i=r(1291),o=r(655),a=r(7750),s=n("".charAt),l=n("".charCodeAt),c=n("".slice),u=function(t){return function(e,r){var n,u,h=o(a(e)),p=i(r),d=h.length;return p<0||p>=d?t?"":void 0:(n=l(h,p))<55296||n>56319||p+1===d||(u=l(h,p+1))<56320||u>57343?t?s(h,p):n:t?c(h,p,p+2):u-56320+(n-55296<<10)+65536}};t.exports={codeAt:u(!1),charAt:u(!0)}},533:(t,e,r)=>{var n=r(9504),i=r(8014),o=r(655),a=r(2333),s=r(7750),l=n(a),c=n("".slice),u=Math.ceil,h=function(t){return function(e,r,n){var a,h,p=o(s(e)),d=i(r),f=p.length,y=void 0===n?" ":o(n);return d<=f||""===y?p:((h=l(y,u((a=d-f)/y.length))).length>a&&(h=c(h,0,a)),t?p+h:h+p)}};t.exports={start:h(!1),end:h(!0)}},2333:(t,e,r)=>{var n=r(1291),i=r(655),o=r(7750),a=RangeError;t.exports=function(t){var e=i(o(this)),r="",s=n(t);if(s<0||s===1/0)throw new a("Wrong number of repetitions");for(;s>0;(s>>>=1)&&(e+=e))1&s&&(r+=e);return r}},706:(t,e,r)=>{var n=r(350).PROPER,i=r(9039),o=r(7452);t.exports=function(t){return i((function(){return!!o[t]()||"âÂá "!=="âÂá "[t]()||n&&o[t].name!==t}))}},3802:(t,e,r)=>{var n=r(9504),i=r(7750),o=r(655),a=r(7452),s=n("".replace),l=RegExp("^["+a+"]+"),c=RegExp("(^|[^"+a+"])["+a+"]+$"),u=function(t){return function(e){var r=o(i(e));return 1&t&&(r=s(r,l,"")),2&t&&(r=s(r,c,"$1")),r}};t.exports={start:u(1),end:u(2),trim:u(3)}},4495:(t,e,r)=>{var n=r(7388),i=r(9039),o=r(4475).String;t.exports=!!Object.getOwnPropertySymbols&&!i((function(){var t=Symbol("symbol detection");return!o(t)||!(Object(t)instanceof Symbol)||!Symbol.sham&&n&&n<41}))},8242:(t,e,r)=>{var n=r(9565),i=r(7751),o=r(8227),a=r(6840);t.exports=function(){var t=i("Symbol"),e=t&&t.prototype,r=e&&e.valueOf,s=o("toPrimitive");e&&!e[s]&&a(e,s,(function(t){return n(r,this)}),{arity:1})}},1296:(t,e,r)=>{var n=r(4495);t.exports=n&&!!Symbol.for&&!!Symbol.keyFor},9225:(t,e,r)=>{var n,i,o,a,s=r(4475),l=r(8745),c=r(6080),u=r(4901),h=r(9297),p=r(9039),d=r(397),f=r(7680),y=r(4055),m=r(2812),v=r(8119),b=r(9088),g=s.setImmediate,w=s.clearImmediate,_=s.process,k=s.Dispatch,j=s.Function,O=s.MessageChannel,x=s.String,C=0,E={},S="onreadystatechange";p((function(){n=s.location}));var P=function(t){if(h(E,t)){var e=E[t];delete E[t],e()}},L=function(t){return function(){P(t)}},T=function(t){P(t.data)},A=function(t){s.postMessage(x(t),n.protocol+"//"+n.host)};g&&w||(g=function(t){m(arguments.length,1);var e=u(t)?t:j(t),r=f(arguments,1);return E[++C]=function(){l(e,void 0,r)},i(C),C},w=function(t){delete E[t]},b?i=function(t){_.nextTick(L(t))}:k&&k.now?i=function(t){k.now(L(t))}:O&&!v?(a=(o=new O).port2,o.port1.onmessage=T,i=c(a.postMessage,a)):s.addEventListener&&u(s.postMessage)&&!s.importScripts&&n&&"file:"!==n.protocol&&!p(A)?(i=A,s.addEventListener("message",T,!1)):i=S in y("script")?function(t){d.appendChild(y("script"))[S]=function(){d.removeChild(this),P(t)}}:function(t){setTimeout(L(t),0)}),t.exports={set:g,clear:w}},1240:(t,e,r)=>{var n=r(9504);t.exports=n(1..valueOf)},5610:(t,e,r)=>{var n=r(1291),i=Math.max,o=Math.min;t.exports=function(t,e){var r=n(t);return r<0?i(r+e,0):o(r,e)}},5397:(t,e,r)=>{var n=r(7055),i=r(7750);t.exports=function(t){return n(i(t))}},1291:(t,e,r)=>{var n=r(741);t.exports=function(t){var e=+t;return e!=e||0===e?0:n(e)}},8014:(t,e,r)=>{var n=r(1291),i=Math.min;t.exports=function(t){var e=n(t);return e>0?i(e,9007199254740991):0}},8981:(t,e,r)=>{var n=r(7750),i=Object;t.exports=function(t){return i(n(t))}},2777:(t,e,r)=>{var n=r(9565),i=r(34),o=r(757),a=r(5966),s=r(4270),l=r(8227),c=TypeError,u=l("toPrimitive");t.exports=function(t,e){if(!i(t)||o(t))return t;var r,l=a(t,u);if(l){if(void 0===e&&(e="default"),r=n(l,t,e),!i(r)||o(r))return r;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(t,e)}},6969:(t,e,r)=>{var n=r(2777),i=r(757);t.exports=function(t){var e=n(t,"string");return i(e)?e:e+""}},2140:(t,e,r)=>{var n={};n[r(8227)("toStringTag")]="z",t.exports="[object z]"===String(n)},655:(t,e,r)=>{var n=r(6955),i=String;t.exports=function(t){if("Symbol"===n(t))throw new TypeError("Cannot convert a Symbol value to a string");return i(t)}},6823:t=>{var e=String;t.exports=function(t){try{return e(t)}catch(t){return"Object"}}},3392:(t,e,r)=>{var n=r(9504),i=0,o=Math.random(),a=n(1..toString);t.exports=function(t){return"Symbol("+(void 0===t?"":t)+")_"+a(++i+o,36)}},7040:(t,e,r)=>{var n=r(4495);t.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},8686:(t,e,r)=>{var n=r(3724),i=r(9039);t.exports=n&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},2812:t=>{var e=TypeError;t.exports=function(t,r){if(t<r)throw new e("Not enough arguments");return t}},8622:(t,e,r)=>{var n=r(4475),i=r(4901),o=n.WeakMap;t.exports=i(o)&&/native code/.test(String(o))},511:(t,e,r)=>{var n=r(9167),i=r(9297),o=r(1951),a=r(4913).f;t.exports=function(t){var e=n.Symbol||(n.Symbol={});i(e,t)||a(e,t,{value:o.f(t)})}},1951:(t,e,r)=>{var n=r(8227);e.f=n},8227:(t,e,r)=>{var n=r(4475),i=r(5745),o=r(9297),a=r(3392),s=r(4495),l=r(7040),c=n.Symbol,u=i("wks"),h=l?c.for||c:c&&c.withoutSetter||a;t.exports=function(t){return o(u,t)||(u[t]=s&&o(c,t)?c[t]:h("Symbol."+t)),u[t]}},7452:t=>{t.exports="\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff"},8706:(t,e,r)=>{var n=r(6518),i=r(9039),o=r(4376),a=r(34),s=r(8981),l=r(6198),c=r(6837),u=r(4659),h=r(1469),p=r(597),d=r(8227),f=r(7388),y=d("isConcatSpreadable"),m=f>=51||!i((function(){var t=[];return t[y]=!1,t.concat()[0]!==t})),v=function(t){if(!a(t))return!1;var e=t[y];return void 0!==e?!!e:o(t)};n({target:"Array",proto:!0,arity:1,forced:!m||!p("concat")},{concat:function(t){var e,r,n,i,o,a=s(this),p=h(a,0),d=0;for(e=-1,n=arguments.length;e<n;e++)if(v(o=-1===e?a:arguments[e]))for(i=l(o),c(d+i),r=0;r<i;r++,d++)r in o&&u(p,d,o[r]);else c(d+1),u(p,d++,o);return p.length=d,p}})},8431:(t,e,r)=>{var n=r(6518),i=r(9213).every;n({target:"Array",proto:!0,forced:!r(4598)("every")},{every:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},2008:(t,e,r)=>{var n=r(6518),i=r(9213).filter;n({target:"Array",proto:!0,forced:!r(597)("filter")},{filter:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},113:(t,e,r)=>{var n=r(6518),i=r(9213).find,o=r(6469),a="find",s=!0;a in[]&&Array(1)[a]((function(){s=!1})),n({target:"Array",proto:!0,forced:s},{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),o(a)},1629:(t,e,r)=>{var n=r(6518),i=r(235);n({target:"Array",proto:!0,forced:[].forEach!==i},{forEach:i})},3418:(t,e,r)=>{var n=r(6518),i=r(7916);n({target:"Array",stat:!0,forced:!r(4428)((function(t){Array.from(t)}))},{from:i})},4423:(t,e,r)=>{var n=r(6518),i=r(9617).includes,o=r(9039),a=r(6469);n({target:"Array",proto:!0,forced:o((function(){return!Array(1).includes()}))},{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),a("includes")},5276:(t,e,r)=>{var n=r(6518),i=r(7476),o=r(9617).indexOf,a=r(4598),s=i([].indexOf),l=!!s&&1/s([1],1,-0)<0;n({target:"Array",proto:!0,forced:l||!a("indexOf")},{indexOf:function(t){var e=arguments.length>1?arguments[1]:void 0;return l?s(this,t,e)||0:o(this,t,e)}})},4346:(t,e,r)=>{r(6518)({target:"Array",stat:!0},{isArray:r(4376)})},3792:(t,e,r)=>{var n=r(5397),i=r(6469),o=r(6269),a=r(1181),s=r(4913).f,l=r(1088),c=r(2529),u=r(6395),h=r(3724),p="Array Iterator",d=a.set,f=a.getterFor(p);t.exports=l(Array,"Array",(function(t,e){d(this,{type:p,target:n(t),index:0,kind:e})}),(function(){var t=f(this),e=t.target,r=t.index++;if(!e||r>=e.length)return t.target=void 0,c(void 0,!0);switch(t.kind){case"keys":return c(r,!1);case"values":return c(e[r],!1)}return c([r,e[r]],!1)}),"values");var y=o.Arguments=o.Array;if(i("keys"),i("values"),i("entries"),!u&&h&&"values"!==y.name)try{s(y,"name",{value:"values"})}catch(t){}},8598:(t,e,r)=>{var n=r(6518),i=r(9504),o=r(7055),a=r(5397),s=r(4598),l=i([].join);n({target:"Array",proto:!0,forced:o!==Object||!s("join",",")},{join:function(t){return l(a(this),void 0===t?",":t)}})},2062:(t,e,r)=>{var n=r(6518),i=r(9213).map;n({target:"Array",proto:!0,forced:!r(597)("map")},{map:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},2712:(t,e,r)=>{var n=r(6518),i=r(926).left,o=r(4598),a=r(7388);n({target:"Array",proto:!0,forced:!r(9088)&&a>79&&a<83||!o("reduce")},{reduce:function(t){var e=arguments.length;return i(this,t,e,e>1?arguments[1]:void 0)}})},4490:(t,e,r)=>{var n=r(6518),i=r(9504),o=r(4376),a=i([].reverse),s=[1,2];n({target:"Array",proto:!0,forced:String(s)===String(s.reverse())},{reverse:function(){return o(this)&&(this.length=this.length),a(this)}})},4782:(t,e,r)=>{var n=r(6518),i=r(4376),o=r(3517),a=r(34),s=r(5610),l=r(6198),c=r(5397),u=r(4659),h=r(8227),p=r(597),d=r(7680),f=p("slice"),y=h("species"),m=Array,v=Math.max;n({target:"Array",proto:!0,forced:!f},{slice:function(t,e){var r,n,h,p=c(this),f=l(p),b=s(t,f),g=s(void 0===e?f:e,f);if(i(p)&&(r=p.constructor,(o(r)&&(r===m||i(r.prototype))||a(r)&&null===(r=r[y]))&&(r=void 0),r===m||void 0===r))return d(p,b,g);for(n=new(void 0===r?m:r)(v(g-b,0)),h=0;b<g;b++,h++)b in p&&u(n,h,p[b]);return n.length=h,n}})},5086:(t,e,r)=>{var n=r(6518),i=r(9213).some;n({target:"Array",proto:!0,forced:!r(4598)("some")},{some:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},6910:(t,e,r)=>{var n=r(6518),i=r(9504),o=r(9306),a=r(8981),s=r(6198),l=r(4606),c=r(655),u=r(9039),h=r(4488),p=r(4598),d=r(8834),f=r(3202),y=r(7388),m=r(9160),v=[],b=i(v.sort),g=i(v.push),w=u((function(){v.sort(void 0)})),_=u((function(){v.sort(null)})),k=p("sort"),j=!u((function(){if(y)return y<70;if(!(d&&d>3)){if(f)return!0;if(m)return m<603;var t,e,r,n,i="";for(t=65;t<76;t++){switch(e=String.fromCharCode(t),t){case 66:case 69:case 70:case 72:r=3;break;case 68:case 71:r=4;break;default:r=2}for(n=0;n<47;n++)v.push({k:e+n,v:r})}for(v.sort((function(t,e){return e.v-t.v})),n=0;n<v.length;n++)e=v[n].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));n({target:"Array",proto:!0,forced:w||!_||!k||!j},{sort:function(t){void 0!==t&&o(t);var e=a(this);if(j)return void 0===t?b(e):b(e,t);var r,n,i=[],u=s(e);for(n=0;n<u;n++)n in e&&g(i,e[n]);for(h(i,function(t){return function(e,r){return void 0===r?-1:void 0===e?1:void 0!==t?+t(e,r)||0:c(e)>c(r)?1:-1}}(t)),r=s(i),n=0;n<r;)e[n]=i[n++];for(;n<u;)l(e,n++);return e}})},4554:(t,e,r)=>{var n=r(6518),i=r(8981),o=r(5610),a=r(1291),s=r(6198),l=r(4527),c=r(6837),u=r(1469),h=r(4659),p=r(4606),d=r(597)("splice"),f=Math.max,y=Math.min;n({target:"Array",proto:!0,forced:!d},{splice:function(t,e){var r,n,d,m,v,b,g=i(this),w=s(g),_=o(t,w),k=arguments.length;for(0===k?r=n=0:1===k?(r=0,n=w-_):(r=k-2,n=y(f(a(e),0),w-_)),c(w+r-n),d=u(g,n),m=0;m<n;m++)(v=_+m)in g&&h(d,m,g[v]);if(d.length=n,r<n){for(m=_;m<w-n;m++)b=m+r,(v=m+n)in g?g[b]=g[v]:p(g,b);for(m=w;m>w-n+r;m--)p(g,m-1)}else if(r>n)for(m=w-n;m>_;m--)b=m+r-1,(v=m+n-1)in g?g[b]=g[v]:p(g,b);for(m=0;m<r;m++)g[m+_]=arguments[m+2];return l(g,w-n+r),d}})},1688:(t,e,r)=>{var n=r(6518),i=r(380);n({target:"Date",proto:!0,forced:Date.prototype.toISOString!==i},{toISOString:i})},739:(t,e,r)=>{var n=r(6518),i=r(9039),o=r(8981),a=r(2777);n({target:"Date",proto:!0,arity:1,forced:i((function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}))},{toJSON:function(t){var e=o(this),r=a(e,"number");return"number"!=typeof r||isFinite(r)?e.toISOString():null}})},9572:(t,e,r)=>{var n=r(9297),i=r(6840),o=r(3640),a=r(8227)("toPrimitive"),s=Date.prototype;n(s,a)||i(s,a,o)},3288:(t,e,r)=>{var n=r(9504),i=r(6840),o=Date.prototype,a="Invalid Date",s="toString",l=n(o[s]),c=n(o.getTime);String(new Date(NaN))!==a&&i(o,s,(function(){var t=c(this);return t==t?l(this):a}))},4170:(t,e,r)=>{var n=r(6518),i=r(566);n({target:"Function",proto:!0,forced:Function.bind!==i},{bind:i})},2010:(t,e,r)=>{var n=r(3724),i=r(350).EXISTS,o=r(9504),a=r(2106),s=Function.prototype,l=o(s.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,u=o(c.exec);n&&!i&&a(s,"name",{configurable:!0,get:function(){try{return u(c,l(this))[1]}catch(t){return""}}})},3110:(t,e,r)=>{var n=r(6518),i=r(7751),o=r(8745),a=r(9565),s=r(9504),l=r(9039),c=r(4901),u=r(757),h=r(7680),p=r(6933),d=r(4495),f=String,y=i("JSON","stringify"),m=s(/./.exec),v=s("".charAt),b=s("".charCodeAt),g=s("".replace),w=s(1..toString),_=/[\uD800-\uDFFF]/g,k=/^[\uD800-\uDBFF]$/,j=/^[\uDC00-\uDFFF]$/,O=!d||l((function(){var t=i("Symbol")("stringify detection");return"[null]"!==y([t])||"{}"!==y({a:t})||"{}"!==y(Object(t))})),x=l((function(){return'"\\udf06\\ud834"'!==y("\udf06\ud834")||'"\\udead"'!==y("\udead")})),C=function(t,e){var r=h(arguments),n=p(e);if(c(n)||void 0!==t&&!u(t))return r[1]=function(t,e){if(c(n)&&(e=a(n,this,f(t),e)),!u(e))return e},o(y,null,r)},E=function(t,e,r){var n=v(r,e-1),i=v(r,e+1);return m(k,t)&&!m(j,i)||m(j,t)&&!m(k,n)?"\\u"+w(b(t,0),16):t};y&&n({target:"JSON",stat:!0,arity:3,forced:O||x},{stringify:function(t,e,r){var n=h(arguments),i=o(O?C:y,null,n);return x&&"string"==typeof i?g(i,_,E):i}})},4731:(t,e,r)=>{var n=r(4475);r(687)(n.JSON,"JSON",!0)},479:(t,e,r)=>{r(687)(Math,"Math",!0)},2892:(t,e,r)=>{var n=r(6518),i=r(6395),o=r(3724),a=r(4475),s=r(9167),l=r(9504),c=r(2796),u=r(9297),h=r(3167),p=r(1625),d=r(757),f=r(2777),y=r(9039),m=r(8480).f,v=r(7347).f,b=r(4913).f,g=r(1240),w=r(3802).trim,_="Number",k=a[_],j=s[_],O=k.prototype,x=a.TypeError,C=l("".slice),E=l("".charCodeAt),S=c(_,!k(" 0o1")||!k("0b1")||k("+0x1")),P=function(t){var e,r=arguments.length<1?0:k(function(t){var e=f(t,"number");return"bigint"==typeof e?e:function(t){var e,r,n,i,o,a,s,l,c=f(t,"number");if(d(c))throw new x("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=w(c),43===(e=E(c,0))||45===e){if(88===(r=E(c,2))||120===r)return NaN}else if(48===e){switch(E(c,1)){case 66:case 98:n=2,i=49;break;case 79:case 111:n=8,i=55;break;default:return+c}for(a=(o=C(c,2)).length,s=0;s<a;s++)if((l=E(o,s))<48||l>i)return NaN;return parseInt(o,n)}return+c}(e)}(t));return p(O,e=this)&&y((function(){g(e)}))?h(Object(r),this,P):r};P.prototype=O,S&&!i&&(O.constructor=P),n({global:!0,constructor:!0,wrap:!0,forced:S},{Number:P});var L=function(t,e){for(var r,n=o?m(e):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),i=0;n.length>i;i++)u(e,r=n[i])&&!u(t,r)&&b(t,r,v(e,r))};i&&j&&L(s[_],j),(S||i)&&L(s[_],k)},9868:(t,e,r)=>{var n=r(6518),i=r(9504),o=r(1291),a=r(1240),s=r(2333),l=r(9039),c=RangeError,u=String,h=Math.floor,p=i(s),d=i("".slice),f=i(1..toFixed),y=function(t,e,r){return 0===e?r:e%2==1?y(t,e-1,r*t):y(t*t,e/2,r)},m=function(t,e,r){for(var n=-1,i=r;++n<6;)i+=e*t[n],t[n]=i%1e7,i=h(i/1e7)},v=function(t,e){for(var r=6,n=0;--r>=0;)n+=t[r],t[r]=h(n/e),n=n%e*1e7},b=function(t){for(var e=6,r="";--e>=0;)if(""!==r||0===e||0!==t[e]){var n=u(t[e]);r=""===r?n:r+p("0",7-n.length)+n}return r};n({target:"Number",proto:!0,forced:l((function(){return"0.000"!==f(8e-5,3)||"1"!==f(.9,0)||"1.25"!==f(1.255,2)||"1000000000000000128"!==f(0xde0b6b3a7640080,0)}))||!l((function(){f({})}))},{toFixed:function(t){var e,r,n,i,s=a(this),l=o(t),h=[0,0,0,0,0,0],f="",g="0";if(l<0||l>20)throw new c("Incorrect fraction digits");if(s!=s)return"NaN";if(s<=-1e21||s>=1e21)return u(s);if(s<0&&(f="-",s=-s),s>1e-21)if(r=(e=function(t){for(var e=0,r=t;r>=4096;)e+=12,r/=4096;for(;r>=2;)e+=1,r/=2;return e}(s*y(2,69,1))-69)<0?s*y(2,-e,1):s/y(2,e,1),r*=4503599627370496,(e=52-e)>0){for(m(h,0,r),n=l;n>=7;)m(h,1e7,0),n-=7;for(m(h,y(10,n,1),0),n=e-1;n>=23;)v(h,1<<23),n-=23;v(h,1<<n),m(h,1,1),v(h,2),g=b(h)}else m(h,0,r),m(h,1<<-e,0),g=b(h)+p("0",l);return l>0?f+((i=g.length)<=l?"0."+p("0",l-i)+g:d(g,0,i-l)+"."+d(g,i-l)):f+g}})},9085:(t,e,r)=>{var n=r(6518),i=r(4213);n({target:"Object",stat:!0,arity:2,forced:Object.assign!==i},{assign:i})},9904:(t,e,r)=>{r(6518)({target:"Object",stat:!0,sham:!r(3724)},{create:r(2360)})},7945:(t,e,r)=>{var n=r(6518),i=r(3724),o=r(6801).f;n({target:"Object",stat:!0,forced:Object.defineProperties!==o,sham:!i},{defineProperties:o})},4185:(t,e,r)=>{var n=r(6518),i=r(3724),o=r(4913).f;n({target:"Object",stat:!0,forced:Object.defineProperty!==o,sham:!i},{defineProperty:o})},5506:(t,e,r)=>{var n=r(6518),i=r(2357).entries;n({target:"Object",stat:!0},{entries:function(t){return i(t)}})},3851:(t,e,r)=>{var n=r(6518),i=r(9039),o=r(5397),a=r(7347).f,s=r(3724);n({target:"Object",stat:!0,forced:!s||i((function(){a(1)})),sham:!s},{getOwnPropertyDescriptor:function(t,e){return a(o(t),e)}})},1278:(t,e,r)=>{var n=r(6518),i=r(3724),o=r(5031),a=r(5397),s=r(7347),l=r(4659);n({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(t){for(var e,r,n=a(t),i=s.f,c=o(n),u={},h=0;c.length>h;)void 0!==(r=i(n,e=c[h++]))&&l(u,e,r);return u}})},9773:(t,e,r)=>{var n=r(6518),i=r(4495),o=r(9039),a=r(3717),s=r(8981);n({target:"Object",stat:!0,forced:!i||o((function(){a.f(1)}))},{getOwnPropertySymbols:function(t){var e=a.f;return e?e(s(t)):[]}})},875:(t,e,r)=>{var n=r(6518),i=r(9039),o=r(8981),a=r(2787),s=r(2211);n({target:"Object",stat:!0,forced:i((function(){a(1)})),sham:!s},{getPrototypeOf:function(t){return a(o(t))}})},9432:(t,e,r)=>{var n=r(6518),i=r(8981),o=r(1072);n({target:"Object",stat:!0,forced:r(9039)((function(){o(1)}))},{keys:function(t){return o(i(t))}})},287:(t,e,r)=>{r(6518)({target:"Object",stat:!0},{setPrototypeOf:r(2967)})},6099:(t,e,r)=>{var n=r(2140),i=r(6840),o=r(3179);n||i(Object.prototype,"toString",o,{unsafe:!0})},6034:(t,e,r)=>{var n=r(6518),i=r(2357).values;n({target:"Object",stat:!0},{values:function(t){return i(t)}})},8459:(t,e,r)=>{var n=r(6518),i=r(3904);n({global:!0,forced:parseFloat!==i},{parseFloat:i})},8940:(t,e,r)=>{var n=r(6518),i=r(2703);n({global:!0,forced:parseInt!==i},{parseInt:i})},6499:(t,e,r)=>{var n=r(6518),i=r(9565),o=r(9306),a=r(6043),s=r(1103),l=r(2652);n({target:"Promise",stat:!0,forced:r(537)},{all:function(t){var e=this,r=a.f(e),n=r.resolve,c=r.reject,u=s((function(){var r=o(e.resolve),a=[],s=0,u=1;l(t,(function(t){var o=s++,l=!1;u++,i(r,e,t).then((function(t){l||(l=!0,a[o]=t,--u||n(a))}),c)})),--u||n(a)}));return u.error&&c(u.value),r.promise}})},2003:(t,e,r)=>{var n=r(6518),i=r(6395),o=r(916).CONSTRUCTOR,a=r(550),s=r(7751),l=r(4901),c=r(6840),u=a&&a.prototype;if(n({target:"Promise",proto:!0,forced:o,real:!0},{catch:function(t){return this.then(void 0,t)}}),!i&&l(a)){var h=s("Promise").prototype.catch;u.catch!==h&&c(u,"catch",h,{unsafe:!0})}},436:(t,e,r)=>{var n,i,o,a=r(6518),s=r(6395),l=r(9088),c=r(4475),u=r(9565),h=r(6840),p=r(2967),d=r(687),f=r(7633),y=r(9306),m=r(4901),v=r(34),b=r(679),g=r(2293),w=r(9225).set,_=r(1955),k=r(3138),j=r(1103),O=r(8265),x=r(1181),C=r(550),E=r(916),S=r(6043),P="Promise",L=E.CONSTRUCTOR,T=E.REJECTION_EVENT,A=E.SUBCLASSING,R=x.getterFor(P),I=x.set,B=C&&C.prototype,N=C,D=B,F=c.TypeError,V=c.document,H=c.process,z=S.f,M=z,q=!!(V&&V.createEvent&&c.dispatchEvent),U="unhandledrejection",G=function(t){var e;return!(!v(t)||!m(e=t.then))&&e},$=function(t,e){var r,n,i,o=e.value,a=1===e.state,s=a?t.ok:t.fail,l=t.resolve,c=t.reject,h=t.domain;try{s?(a||(2===e.rejection&&Q(e),e.rejection=1),!0===s?r=o:(h&&h.enter(),r=s(o),h&&(h.exit(),i=!0)),r===t.promise?c(new F("Promise-chain cycle")):(n=G(r))?u(n,r,l,c):l(r)):c(o)}catch(t){h&&!i&&h.exit(),c(t)}},J=function(t,e){t.notified||(t.notified=!0,_((function(){for(var r,n=t.reactions;r=n.get();)$(r,t);t.notified=!1,e&&!t.rejection&&Z(t)})))},W=function(t,e,r){var n,i;q?((n=V.createEvent("Event")).promise=e,n.reason=r,n.initEvent(t,!1,!0),c.dispatchEvent(n)):n={promise:e,reason:r},!T&&(i=c["on"+t])?i(n):t===U&&k("Unhandled promise rejection",r)},Z=function(t){u(w,c,(function(){var e,r=t.facade,n=t.value;if(Y(t)&&(e=j((function(){l?H.emit("unhandledRejection",n,r):W(U,r,n)})),t.rejection=l||Y(t)?2:1,e.error))throw e.value}))},Y=function(t){return 1!==t.rejection&&!t.parent},Q=function(t){u(w,c,(function(){var e=t.facade;l?H.emit("rejectionHandled",e):W("rejectionhandled",e,t.value)}))},K=function(t,e,r){return function(n){t(e,n,r)}},X=function(t,e,r){t.done||(t.done=!0,r&&(t=r),t.value=e,t.state=2,J(t,!0))},tt=function(t,e,r){if(!t.done){t.done=!0,r&&(t=r);try{if(t.facade===e)throw new F("Promise can't be resolved itself");var n=G(e);n?_((function(){var r={done:!1};try{u(n,e,K(tt,r,t),K(X,r,t))}catch(e){X(r,e,t)}})):(t.value=e,t.state=1,J(t,!1))}catch(e){X({done:!1},e,t)}}};if(L&&(D=(N=function(t){b(this,D),y(t),u(n,this);var e=R(this);try{t(K(tt,e),K(X,e))}catch(t){X(e,t)}}).prototype,(n=function(t){I(this,{type:P,done:!1,notified:!1,parent:!1,reactions:new O,rejection:!1,state:0,value:void 0})}).prototype=h(D,"then",(function(t,e){var r=R(this),n=z(g(this,N));return r.parent=!0,n.ok=!m(t)||t,n.fail=m(e)&&e,n.domain=l?H.domain:void 0,0===r.state?r.reactions.add(n):_((function(){$(n,r)})),n.promise})),i=function(){var t=new n,e=R(t);this.promise=t,this.resolve=K(tt,e),this.reject=K(X,e)},S.f=z=function(t){return t===N||void 0===t?new i(t):M(t)},!s&&m(C)&&B!==Object.prototype)){o=B.then,A||h(B,"then",(function(t,e){var r=this;return new N((function(t,e){u(o,r,t,e)})).then(t,e)}),{unsafe:!0});try{delete B.constructor}catch(t){}p&&p(B,D)}a({global:!0,constructor:!0,wrap:!0,forced:L},{Promise:N}),d(N,P,!1,!0),f(P)},3362:(t,e,r)=>{r(436),r(6499),r(2003),r(7743),r(1481),r(280)},7743:(t,e,r)=>{var n=r(6518),i=r(9565),o=r(9306),a=r(6043),s=r(1103),l=r(2652);n({target:"Promise",stat:!0,forced:r(537)},{race:function(t){var e=this,r=a.f(e),n=r.reject,c=s((function(){var a=o(e.resolve);l(t,(function(t){i(a,e,t).then(r.resolve,n)}))}));return c.error&&n(c.value),r.promise}})},1481:(t,e,r)=>{var n=r(6518),i=r(6043);n({target:"Promise",stat:!0,forced:r(916).CONSTRUCTOR},{reject:function(t){var e=i.f(this);return(0,e.reject)(t),e.promise}})},280:(t,e,r)=>{var n=r(6518),i=r(7751),o=r(6395),a=r(550),s=r(916).CONSTRUCTOR,l=r(3438),c=i("Promise"),u=o&&!s;n({target:"Promise",stat:!0,forced:o||s},{resolve:function(t){return l(u&&this===c?a:this,t)}})},825:(t,e,r)=>{var n=r(6518),i=r(7751),o=r(8745),a=r(566),s=r(5548),l=r(8551),c=r(34),u=r(2360),h=r(9039),p=i("Reflect","construct"),d=Object.prototype,f=[].push,y=h((function(){function t(){}return!(p((function(){}),[],t)instanceof t)})),m=!h((function(){p((function(){}))})),v=y||m;n({target:"Reflect",stat:!0,forced:v,sham:v},{construct:function(t,e){s(t),l(e);var r=arguments.length<3?t:s(arguments[2]);if(m&&!y)return p(t,e,r);if(t===r){switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3])}var n=[null];return o(f,n,e),new(o(a,t,n))}var i=r.prototype,h=u(c(i)?i:d),v=o(t,h,e);return c(v)?v:h}})},888:(t,e,r)=>{var n=r(6518),i=r(9565),o=r(34),a=r(8551),s=r(6575),l=r(7347),c=r(2787);n({target:"Reflect",stat:!0},{get:function t(e,r){var n,u,h=arguments.length<3?e:arguments[2];return a(e)===h?e[r]:(n=l.f(e,r))?s(n)?n.value:void 0===n.get?void 0:i(n.get,h):o(u=c(e))?t(u,r,h):void 0}})},4864:(t,e,r)=>{var n=r(3724),i=r(4475),o=r(9504),a=r(2796),s=r(3167),l=r(6699),c=r(2360),u=r(8480).f,h=r(1625),p=r(788),d=r(655),f=r(1034),y=r(8429),m=r(1056),v=r(6840),b=r(9039),g=r(9297),w=r(1181).enforce,_=r(7633),k=r(8227),j=r(3635),O=r(8814),x=k("match"),C=i.RegExp,E=C.prototype,S=i.SyntaxError,P=o(E.exec),L=o("".charAt),T=o("".replace),A=o("".indexOf),R=o("".slice),I=/^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,B=/a/g,N=/a/g,D=new C(B)!==B,F=y.MISSED_STICKY,V=y.UNSUPPORTED_Y;if(a("RegExp",n&&(!D||F||j||O||b((function(){return N[x]=!1,C(B)!==B||C(N)===N||"/a/i"!==String(C(B,"i"))}))))){for(var H=function(t,e){var r,n,i,o,a,u,y=h(E,this),m=p(t),v=void 0===e,b=[],_=t;if(!y&&m&&v&&t.constructor===H)return t;if((m||h(E,t))&&(t=t.source,v&&(e=f(_))),t=void 0===t?"":d(t),e=void 0===e?"":d(e),_=t,j&&"dotAll"in B&&(n=!!e&&A(e,"s")>-1)&&(e=T(e,/s/g,"")),r=e,F&&"sticky"in B&&(i=!!e&&A(e,"y")>-1)&&V&&(e=T(e,/y/g,"")),O&&(o=function(t){for(var e,r=t.length,n=0,i="",o=[],a=c(null),s=!1,l=!1,u=0,h="";n<=r;n++){if("\\"===(e=L(t,n)))e+=L(t,++n);else if("]"===e)s=!1;else if(!s)switch(!0){case"["===e:s=!0;break;case"("===e:P(I,R(t,n+1))&&(n+=2,l=!0),i+=e,u++;continue;case">"===e&&l:if(""===h||g(a,h))throw new S("Invalid capture group name");a[h]=!0,o[o.length]=[h,u],l=!1,h="";continue}l?h+=e:i+=e}return[i,o]}(t),t=o[0],b=o[1]),a=s(C(t,e),y?this:E,H),(n||i||b.length)&&(u=w(a),n&&(u.dotAll=!0,u.raw=H(function(t){for(var e,r=t.length,n=0,i="",o=!1;n<=r;n++)"\\"!==(e=L(t,n))?o||"."!==e?("["===e?o=!0:"]"===e&&(o=!1),i+=e):i+="[\\s\\S]":i+=e+L(t,++n);return i}(t),r)),i&&(u.sticky=!0),b.length&&(u.groups=b)),t!==_)try{l(a,"source",""===_?"(?:)":_)}catch(t){}return a},z=u(C),M=0;z.length>M;)m(H,C,z[M++]);E.constructor=H,H.prototype=E,v(i,"RegExp",H,{constructor:!0})}_("RegExp")},7495:(t,e,r)=>{var n=r(6518),i=r(7323);n({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},8781:(t,e,r)=>{var n=r(350).PROPER,i=r(6840),o=r(8551),a=r(655),s=r(9039),l=r(1034),c="toString",u=RegExp.prototype,h=u[c],p=s((function(){return"/a/b"!==h.call({source:"a",flags:"b"})})),d=n&&h.name!==c;(p||d)&&i(u,c,(function(){var t=o(this);return"/"+a(t.source)+"/"+a(l(t))}),{unsafe:!0})},1699:(t,e,r)=>{var n=r(6518),i=r(9504),o=r(5749),a=r(7750),s=r(655),l=r(1436),c=i("".indexOf);n({target:"String",proto:!0,forced:!l("includes")},{includes:function(t){return!!~c(s(a(this)),s(o(t)),arguments.length>1?arguments[1]:void 0)}})},7764:(t,e,r)=>{var n=r(8183).charAt,i=r(655),o=r(1181),a=r(1088),s=r(2529),l="String Iterator",c=o.set,u=o.getterFor(l);a(String,"String",(function(t){c(this,{type:l,string:i(t),index:0})}),(function(){var t,e=u(this),r=e.string,i=e.index;return i>=r.length?s(void 0,!0):(t=n(r,i),e.index+=t.length,s(t,!1))}))},1761:(t,e,r)=>{var n=r(9565),i=r(9228),o=r(8551),a=r(4117),s=r(8014),l=r(655),c=r(7750),u=r(5966),h=r(7829),p=r(6682);i("match",(function(t,e,r){return[function(e){var r=c(this),i=a(e)?void 0:u(e,t);return i?n(i,e,r):new RegExp(e)[t](l(r))},function(t){var n=o(this),i=l(t),a=r(e,n,i);if(a.done)return a.value;if(!n.global)return p(n,i);var c=n.unicode;n.lastIndex=0;for(var u,d=[],f=0;null!==(u=p(n,i));){var y=l(u[0]);d[f]=y,""===y&&(n.lastIndex=h(i,s(n.lastIndex),c)),f++}return 0===f?null:d}]}))},5440:(t,e,r)=>{var n=r(8745),i=r(9565),o=r(9504),a=r(9228),s=r(9039),l=r(8551),c=r(4901),u=r(4117),h=r(1291),p=r(8014),d=r(655),f=r(7750),y=r(7829),m=r(5966),v=r(2478),b=r(6682),g=r(8227)("replace"),w=Math.max,_=Math.min,k=o([].concat),j=o([].push),O=o("".indexOf),x=o("".slice),C="$0"==="a".replace(/./,"$0"),E=!!/./[g]&&""===/./[g]("a","$0");a("replace",(function(t,e,r){var o=E?"$":"$0";return[function(t,r){var n=f(this),o=u(t)?void 0:m(t,g);return o?i(o,t,n,r):i(e,d(n),t,r)},function(t,i){var a=l(this),s=d(t);if("string"==typeof i&&-1===O(i,o)&&-1===O(i,"$<")){var u=r(e,a,s,i);if(u.done)return u.value}var f=c(i);f||(i=d(i));var m,g=a.global;g&&(m=a.unicode,a.lastIndex=0);for(var C,E=[];null!==(C=b(a,s))&&(j(E,C),g);)""===d(C[0])&&(a.lastIndex=y(s,p(a.lastIndex),m));for(var S,P="",L=0,T=0;T<E.length;T++){for(var A,R=d((C=E[T])[0]),I=w(_(h(C.index),s.length),0),B=[],N=1;N<C.length;N++)j(B,void 0===(S=C[N])?S:String(S));var D=C.groups;if(f){var F=k([R],B,I,s);void 0!==D&&j(F,D),A=d(n(i,void 0,F))}else A=v(R,s,I,B,D,i);I>=L&&(P+=x(s,L,I)+A,L=I+R.length)}return P+x(s,L)}]}),!!s((function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")}))||!C||E)},1392:(t,e,r)=>{var n,i=r(6518),o=r(7476),a=r(7347).f,s=r(8014),l=r(655),c=r(5749),u=r(7750),h=r(1436),p=r(6395),d=o("".slice),f=Math.min,y=h("startsWith");i({target:"String",proto:!0,forced:!(!p&&!y&&(n=a(String.prototype,"startsWith"),n&&!n.writable)||y)},{startsWith:function(t){var e=l(u(this));c(t);var r=s(f(arguments.length>1?arguments[1]:void 0,e.length)),n=l(t);return d(e,r,r+n.length)===n}})},2762:(t,e,r)=>{var n=r(6518),i=r(3802).trim;n({target:"String",proto:!0,forced:r(706)("trim")},{trim:function(){return i(this)}})},6412:(t,e,r)=>{r(511)("asyncIterator")},6761:(t,e,r)=>{var n=r(6518),i=r(4475),o=r(9565),a=r(9504),s=r(6395),l=r(3724),c=r(4495),u=r(9039),h=r(9297),p=r(1625),d=r(8551),f=r(5397),y=r(6969),m=r(655),v=r(6980),b=r(2360),g=r(1072),w=r(8480),_=r(298),k=r(3717),j=r(7347),O=r(4913),x=r(6801),C=r(8773),E=r(6840),S=r(2106),P=r(5745),L=r(6119),T=r(421),A=r(3392),R=r(8227),I=r(1951),B=r(511),N=r(8242),D=r(687),F=r(1181),V=r(9213).forEach,H=L("hidden"),z="Symbol",M="prototype",q=F.set,U=F.getterFor(z),G=Object[M],$=i.Symbol,J=$&&$[M],W=i.RangeError,Z=i.TypeError,Y=i.QObject,Q=j.f,K=O.f,X=_.f,tt=C.f,et=a([].push),rt=P("symbols"),nt=P("op-symbols"),it=P("wks"),ot=!Y||!Y[M]||!Y[M].findChild,at=function(t,e,r){var n=Q(G,e);n&&delete G[e],K(t,e,r),n&&t!==G&&K(G,e,n)},st=l&&u((function(){return 7!==b(K({},"a",{get:function(){return K(this,"a",{value:7}).a}})).a}))?at:K,lt=function(t,e){var r=rt[t]=b(J);return q(r,{type:z,tag:t,description:e}),l||(r.description=e),r},ct=function(t,e,r){t===G&&ct(nt,e,r),d(t);var n=y(e);return d(r),h(rt,n)?(r.enumerable?(h(t,H)&&t[H][n]&&(t[H][n]=!1),r=b(r,{enumerable:v(0,!1)})):(h(t,H)||K(t,H,v(1,b(null))),t[H][n]=!0),st(t,n,r)):K(t,n,r)},ut=function(t,e){d(t);var r=f(e),n=g(r).concat(ft(r));return V(n,(function(e){l&&!o(ht,r,e)||ct(t,e,r[e])})),t},ht=function(t){var e=y(t),r=o(tt,this,e);return!(this===G&&h(rt,e)&&!h(nt,e))&&(!(r||!h(this,e)||!h(rt,e)||h(this,H)&&this[H][e])||r)},pt=function(t,e){var r=f(t),n=y(e);if(r!==G||!h(rt,n)||h(nt,n)){var i=Q(r,n);return!i||!h(rt,n)||h(r,H)&&r[H][n]||(i.enumerable=!0),i}},dt=function(t){var e=X(f(t)),r=[];return V(e,(function(t){h(rt,t)||h(T,t)||et(r,t)})),r},ft=function(t){var e=t===G,r=X(e?nt:f(t)),n=[];return V(r,(function(t){!h(rt,t)||e&&!h(G,t)||et(n,rt[t])})),n};c||(E(J=($=function(){if(p(J,this))throw new Z("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?m(arguments[0]):void 0,e=A(t),r=function(t){var n=void 0===this?i:this;n===G&&o(r,nt,t),h(n,H)&&h(n[H],e)&&(n[H][e]=!1);var a=v(1,t);try{st(n,e,a)}catch(t){if(!(t instanceof W))throw t;at(n,e,a)}};return l&&ot&&st(G,e,{configurable:!0,set:r}),lt(e,t)})[M],"toString",(function(){return U(this).tag})),E($,"withoutSetter",(function(t){return lt(A(t),t)})),C.f=ht,O.f=ct,x.f=ut,j.f=pt,w.f=_.f=dt,k.f=ft,I.f=function(t){return lt(R(t),t)},l&&(S(J,"description",{configurable:!0,get:function(){return U(this).description}}),s||E(G,"propertyIsEnumerable",ht,{unsafe:!0}))),n({global:!0,constructor:!0,wrap:!0,forced:!c,sham:!c},{Symbol:$}),V(g(it),(function(t){B(t)})),n({target:z,stat:!0,forced:!c},{useSetter:function(){ot=!0},useSimple:function(){ot=!1}}),n({target:"Object",stat:!0,forced:!c,sham:!l},{create:function(t,e){return void 0===e?b(t):ut(b(t),e)},defineProperty:ct,defineProperties:ut,getOwnPropertyDescriptor:pt}),n({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:dt}),N(),D($,z),T[H]=!0},9463:(t,e,r)=>{var n=r(6518),i=r(3724),o=r(4475),a=r(9504),s=r(9297),l=r(4901),c=r(1625),u=r(655),h=r(2106),p=r(7740),d=o.Symbol,f=d&&d.prototype;if(i&&l(d)&&(!("description"in f)||void 0!==d().description)){var y={},m=function(){var t=arguments.length<1||void 0===arguments[0]?void 0:u(arguments[0]),e=c(f,this)?new d(t):void 0===t?d():d(t);return""===t&&(y[e]=!0),e};p(m,d),m.prototype=f,f.constructor=m;var v="Symbol(description detection)"===String(d("description detection")),b=a(f.valueOf),g=a(f.toString),w=/^Symbol\((.*)\)[^)]+$/,_=a("".replace),k=a("".slice);h(f,"description",{configurable:!0,get:function(){var t=b(this);if(s(y,t))return"";var e=g(t),r=v?k(e,7,-1):_(e,w,"$1");return""===r?void 0:r}}),n({global:!0,constructor:!0,forced:!0},{Symbol:m})}},1510:(t,e,r)=>{var n=r(6518),i=r(7751),o=r(9297),a=r(655),s=r(5745),l=r(1296),c=s("string-to-symbol-registry"),u=s("symbol-to-string-registry");n({target:"Symbol",stat:!0,forced:!l},{for:function(t){var e=a(t);if(o(c,e))return c[e];var r=i("Symbol")(e);return c[e]=r,u[r]=e,r}})},2259:(t,e,r)=>{r(511)("iterator")},2675:(t,e,r)=>{r(6761),r(1510),r(7812),r(3110),r(9773)},7812:(t,e,r)=>{var n=r(6518),i=r(9297),o=r(757),a=r(6823),s=r(5745),l=r(1296),c=s("symbol-to-string-registry");n({target:"Symbol",stat:!0,forced:!l},{keyFor:function(t){if(!o(t))throw new TypeError(a(t)+" is not a symbol");if(i(c,t))return c[t]}})},5700:(t,e,r)=>{var n=r(511),i=r(8242);n("toPrimitive"),i()},8125:(t,e,r)=>{var n=r(7751),i=r(511),o=r(687);i("toStringTag"),o(n("Symbol"),"Symbol")},3500:(t,e,r)=>{var n=r(4475),i=r(7400),o=r(9296),a=r(235),s=r(6699),l=function(t){if(t&&t.forEach!==a)try{s(t,"forEach",a)}catch(e){t.forEach=a}};for(var c in i)i[c]&&l(n[c]&&n[c].prototype);l(o)},2953:(t,e,r)=>{var n=r(4475),i=r(7400),o=r(9296),a=r(3792),s=r(6699),l=r(687),c=r(8227)("iterator"),u=a.values,h=function(t,e){if(t){if(t[c]!==u)try{s(t,c,u)}catch(e){t[c]=u}if(l(t,e,!0),i[e])for(var r in a)if(t[r]!==a[r])try{s(t,r,a[r])}catch(e){t[r]=a[r]}}};for(var p in i)h(n[p]&&n[p].prototype,p);h(o,"DOMTokenList")},5575:(t,e,r)=>{var n=r(6518),i=r(4475),o=r(9472)(i.setInterval,!0);n({global:!0,bind:!0,forced:i.setInterval!==o},{setInterval:o})},4599:(t,e,r)=>{var n=r(6518),i=r(4475),o=r(9472)(i.setTimeout,!0);n({global:!0,bind:!0,forced:i.setTimeout!==o},{setTimeout:o})},6031:(t,e,r)=>{r(5575),r(4599)}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n].call(o.exports,o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};return(()=>{r.r(n),r.d(n,{JSONEditor:()=>Wl}),r(2675),r(9463),r(6412),r(2259),r(5700),r(8125),r(8706),r(113),r(1629),r(3418),r(4346),r(3792),r(2712),r(4490),r(4782),r(739),r(9572),r(3288),r(2010),r(4731),r(479),r(2892),r(9085),r(9904),r(4185),r(875),r(9432),r(287),r(6099),r(6034),r(3362),r(7495),r(8781),r(7764),r(3500),r(2953),r(5506),r(4864),r(5440),r(4423);var t=["actionscript","batchfile","c","c++","cpp","coffee","csharp","css","dart","django","ejs","erlang","golang","groovy","handlebars","haskell","haxe","html","ini","jade","java","javascript","json","less","lisp","lua","makefile","matlab","mysql","objectivec","pascal","perl","pgsql","php","python","prql","r","ruby","rust","sass","scala","scss","sh","smarty","sql","sqlserver","stylus","svg","typescript","twig","vbscript","xml","yaml","zig"],e=[function(t){return"string"===t.type&&"color"===t.format&&"colorpicker"},function(t){return"string"===t.type&&["ip","ipv4","ipv6","hostname"].includes(t.format)&&"ip"},function(e){return"string"===e.type&&t.includes(e.format)&&"ace"},function(t){return"string"===t.type&&["xhtml","bbcode"].includes(t.format)&&"sceditor"},function(t){return"string"===t.type&&"markdown"===t.format&&"simplemde"},function(t){return"string"===t.type&&"jodit"===t.format&&"jodit"},function(t){return"string"===t.type&&"autocomplete"===t.format&&"autocomplete"},function(t){return"string"===t.type&&"uuid"===t.format&&"uuid"},function(t){return"info"===t.format&&"info"},function(t){return"button"===t.format&&"button"},function(t){if(("integer"===t.type||"number"===t.type)&&"stepper"===t.format)return"stepper"},function(t){if(t.links)for(var e=0;e<t.links.length;e++)if(t.links[e].rel&&"describedby"===t.links[e].rel.toLowerCase())return"describedBy"},function(t){return["string","integer"].includes(t.type)&&["starrating","rating"].includes(t.format)&&"starrating"},function(t){return["string","integer"].includes(t.type)&&["date","time","datetime-local"].includes(t.format)&&"datetime"},function(t){var e,r;return(t.oneOf||t.anyOf)&&!0===(null===(e=null===(r=t.options)||void 0===r?void 0:r.switcher)||void 0===e||e)&&"multiple"},function(t){return t.if&&"multiple"},function(t,e){if(t.items&&(t.items=e.expandSchema(t.items)),"array"===t.type&&t.items&&!Array.isArray(t.items)&&["string","number","integer"].includes(t.items.type)){if("choices"===t.format)return"arrayChoices";if(t.uniqueItems){if("selectize"===t.format)return"arraySelectize";if("select2"===t.format)return"arraySelect2";if(t.items.enum)return"multiselect"}}},function(t){if(t.enum){if("array"===t.type||"object"===t.type)return"enum";if("number"===t.type||"integer"===t.type||"string"===t.type)return"radio"===t.format?"radio":"select2"===t.format?"select2":"selectize"===t.format?"selectize":"choices"===t.format?"choices":"select"}},function(t){if(t.enumSource)return"radio"===t.format?"radio":"select2"===t.format?"select2":"selectize"===t.format?"selectize":"choices"===t.format?"choices":"select"},function(t){return"array"===t.type&&"table"===t.format&&"table"},function(t){return"string"===t.type&&"url"===t.format&&window.FileReader&&t.options&&t.options.upload===Object(t.options.upload)&&"upload"},function(t){return"string"===t.type&&t.media&&"base64"===t.media.binaryEncoding&&"base64"},function(t){return"any"===t.type&&"multiple"},function(t){if("boolean"===t.type)return"checkbox"===t.format||t.options&&t.options.checkbox?"checkbox":"select2"===t.format?"select2":"selectize"===t.format?"selectize":"choices"===t.format?"choices":"select"},function(t){return"string"===t.type&&"signature"===t.format&&"signature"},function(t){return"string"==typeof t.type&&["string","number","integer","boolean","null","array","object"].includes(t.type)&&t.type},function(t){return!t.type&&t.properties&&"object"},function(t){return"string"!=typeof t.type&&"multiple"},function(t){return"string"==typeof t.type&&"string"}];function i(t,e,r){var n;return n=function(t,e){if("object"!=o(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=o(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(e),(e="symbol"==o(n)?n:n+"")in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function o(t){return o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},o(t)}function a(t){return!(null===t||"object"!==o(t)||t.nodeType||t===t.window||t.constructor&&!h(t.constructor.prototype,"isPrototypeOf"))}function s(t){return a(t)?l({},t):Array.isArray(t)?t.map(s):t}function l(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),n=1;n<e;n++)r[n-1]=arguments[n];return r.forEach((function(e){e&&Object.keys(e).forEach((function(r){e[r]&&a(e[r])?(h(t,r)||(t[r]={}),l(t[r],e[r])):Array.isArray(e[r])?t[r]=s(e[r]):t[r]=e[r]}))})),t}function c(t,e){var r=document.createEvent("HTMLEvents");r.initEvent(e,!0,!0),t.dispatchEvent(r)}function u(t){return t&&("[object ShadowRoot]"===t.toString()?t:u(t.parentNode))}function h(t,e){return t&&Object.prototype.hasOwnProperty.call(t,e)}r(4170),r(3851),r(825),r(888),r(8598),r(1699),r(1761),r(5276),r(5086),r(1392),r(2062),r(8459),r(8940);var p=/^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,d=/^\s*(-|\+)?(\d+)\s*$/;function f(){var t=(new Date).getTime();return"undefined"!=typeof performance&&"function"==typeof performance.now&&(t+=performance.now()),"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(e){var r=(t+16*Math.random())%16|0;return t=Math.floor(t/16),("x"===e?r:3&r|8).toString(16)}))}function y(t){return t&&"object"===o(t)&&!Array.isArray(t)}function m(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),n=1;n<e;n++)r[n-1]=arguments[n];if(!r.length)return t;var o=r.shift();if(y(t)&&y(o))for(var a in o)y(o[a])?(t[a]||Object.assign(t,i({},a,{})),m(t[a],o[a])):Object.assign(t,i({},a,o[a]));return m.apply(void 0,[t].concat(r))}function v(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function b(t){return b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},b(t)}function g(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,w(n.key),n)}}function w(t){var e=function(t,e){if("object"!=b(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=b(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==b(e)?e:e+""}var _=function(){return t=function t(e,r){var n,i;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.defaults=r,this.jsoneditor=e.jsoneditor,this.theme=this.jsoneditor.theme,this.template_engine=this.jsoneditor.template,this.iconlib=this.jsoneditor.iconlib,this.translate=this.jsoneditor.translate||this.defaults.translate,this.translateProperty=this.jsoneditor.translateProperty||this.defaults.translateProperty,this.original_schema=e.schema,this.schema=this.jsoneditor.expandSchema(this.original_schema),this.active=!0,this.isUiOnly=!1,this.options=l({},this.options||{},this.schema.options||{},e.schema.options||{},e),this.enforceConstEnabled=null!==(n=this.options.enforce_const)&&void 0!==n?n:this.jsoneditor.options.enforce_const,this.formname=this.jsoneditor.options.form_name_root||"root",e.path||this.schema.id||(this.schema.id=this.formname),this.path=e.path||this.formname,this.formname=e.formname||this.path.replace(/\.([^.]+)/g,"[$1]"),this.parent=e.parent,this.key=void 0!==this.parent?this.path.split(".").slice(this.parent.path.split(".").length).join("."):this.path,this.link_watchers=[],this.watchLoop=!1,this.optInWidget=null!==(i=this.options.opt_in_widget)&&void 0!==i?i:this.jsoneditor.options.opt_in_widget,e.container&&this.setContainer(e.container),this.registerDependencies()},e=[{key:"onChildEditorChange",value:function(t,e){this.onChange(!0,!1,e)}},{key:"notify",value:function(){this.path&&this.jsoneditor.notifyWatchers(this.path)}},{key:"change",value:function(t){this.parent?this.parent.onChildEditorChange(this,t):this.jsoneditor&&this.jsoneditor.onChange(t)}},{key:"onChange",value:function(t,e,r){this.notify(),e||this.watch_listener&&this.watch_listener(),t&&this.change(r)}},{key:"register",value:function(){if(this.jsoneditor.registerEditor(this),this.input&&!this.label){var t=this.getTitle()||this.formname;this.input.setAttribute("aria-label",t)}this.onChange()}},{key:"unregister",value:function(){this.jsoneditor&&this.jsoneditor.unregisterEditor(this)}},{key:"getNumColumns",value:function(){return 12}},{key:"isActive",value:function(){return this.active}},{key:"activate",value:function(){this.active=!0,this.optInCheckbox.checked=!0,this.enable(),this.change()}},{key:"deactivate",value:function(){this.isRequired()||(this.active=!1,this.optInCheckbox.checked=!1,this.disable(),this.change())}},{key:"registerDependencies",value:function(){var t=this;this.dependenciesFulfilled=!0;var e=this.options.dependencies;e&&Object.keys(e).forEach((function(e){var r;e.startsWith(t.jsoneditor.root.path)?r=e:((r=t.path.split("."))[r.length-1]=e,r=r.join(".")),t.jsoneditor.watch(r,(function(){t.evaluateDependencies()}))}))}},{key:"evaluateDependencies",value:function(){var t=this,e=this.container||this.control;if(e&&null!==this.jsoneditor){var r=this.options.dependencies;if(r){var n=this.dependenciesFulfilled;this.dependenciesFulfilled=!0,Object.keys(r).forEach((function(e){var n;e.startsWith(t.jsoneditor.root.path)?n=e:((n=t.path.split("."))[n.length-1]=e,n=n.join("."));var i=r[e];t.checkDependency(n,i)})),this.dependenciesFulfilled!==n&&this.notify();var i=this.dependenciesFulfilled?"block":"none";this.options.hidden&&(i="none"),"TD"===e.tagName?Object.keys(e.childNodes).forEach((function(t){return e.childNodes[t].style.display=i})):e.style.display=i}}}},{key:"checkDependency",value:function(t,e){var r=this;if(this.path!==t&&null!==this.jsoneditor){var n=this.jsoneditor.getEditor(t),i=n?n.getValue():void 0;n&&n.dependenciesFulfilled&&i?Array.isArray(e)?this.dependenciesFulfilled=e.some((function(t){if(JSON.stringify(i)===JSON.stringify(t))return!0})):"object"===b(e)?"object"!==b(i)?this.dependenciesFulfilled=e===i:Object.keys(e).some((function(t){return!!h(e,t)&&(h(i,t)&&e[t]===i[t]?void 0:(r.dependenciesFulfilled=!1,!0))})):"string"==typeof e||"number"==typeof e?this.dependenciesFulfilled=this.dependenciesFulfilled&&i===e:"boolean"==typeof e&&(this.dependenciesFulfilled=e?this.dependenciesFulfilled&&(i||i.length>0):this.dependenciesFulfilled&&(!i||0===i.length)):this.dependenciesFulfilled=!1}}},{key:"setContainer",value:function(t){this.container=t,this.setContainerAttributes(),this.schema.id&&this.container.setAttribute("data-schemaid",this.schema.id),this.schema.type&&"string"==typeof this.schema.type&&this.container.setAttribute("data-schematype",this.schema.type),this.container.setAttribute("data-schemapath",this.path)}},{key:"setOptInCheckbox",value:function(){var t,e=this;t="switch"===this.optInWidget?this.theme.getOptInSwitch(this.formname):this.theme.getOptInCheckbox(this.formname),this.optInCheckbox=t.checkbox,this.optInContainer=t.container,this.optInCheckbox.addEventListener("click",(function(){e.isActive()?e.deactivate():e.activate()}));var r=this.jsoneditor.options.show_opt_in,n=void 0!==this.parent.options.show_opt_in,i=n&&!0===this.parent.options.show_opt_in,o=n&&!1===this.parent.options.show_opt_in;(i||!o&&r||!n&&r)&&this.parent&&"object"===this.parent.schema.type&&!this.isRequired()&&this.header&&(this.header.insertBefore(this.optInContainer,this.header.firstChild),this.optInAppended=!0)}},{key:"preBuild",value:function(){}},{key:"build",value:function(){}},{key:"postBuild",value:function(){this.setupWatchListeners(),this.addLinks(),this.register(),this.setValue(this.getDefault(),!0),this.updateHeaderText(),this.onWatchedFieldChange(),this.options.titleHidden&&(this.theme.visuallyHidden(this.label),this.theme.visuallyHidden(this.header)),this.enforceConstEnabled&&this.schema.const&&this.disable()}},{key:"setupWatchListeners",value:function(){var t=this;if(this.watched={},this.schema.vars&&(this.schema.watch=this.schema.vars),this.watched_values={},this.watch_listener=function(){t.refreshWatchedFieldValues()&&t.onWatchedFieldChange()},h(this.schema,"watch")){var e,r,n,i,o,a=this.container.getAttribute("data-schemapath");Object.keys(this.schema.watch).forEach((function(s){if(e=t.schema.watch[s],Array.isArray(e)){if(e.length<2)return;r=[e[0]].concat(e[1].split("."))}else r=e.split("."),t.theme.closest(t.container,'[data-schemaid="'.concat(r[0],'"]'))||r.unshift("#");if("#"===(n=r.shift())&&(n=t.jsoneditor.schema.id||t.jsoneditor.root.formname),!(i=t.theme.closest(t.container,'[data-schemaid="'.concat(n,'"]'))))throw new Error("Could not find ancestor node with id ".concat(n));o="".concat(i.getAttribute("data-schemapath"),".").concat(r.join(".")),a.startsWith(o)&&(t.watchLoop=!0),t.jsoneditor.watch(o,t.watch_listener),t.watched[s]=o}))}this.schema.headerTemplate&&(this.header_template=this.jsoneditor.compileTemplate(this.schema.headerTemplate,this.template_engine))}},{key:"addLinks",value:function(){if(!this.no_link_holder&&(this.link_holder=this.theme.getLinksHolder(),void 0!==this.description?this.description.parentNode.insertBefore(this.link_holder,this.description):this.container.appendChild(this.link_holder),this.schema.links))for(var t=0;t<this.schema.links.length;t++)this.addLink(this.getLink(this.schema.links[t]))}},{key:"onMove",value:function(){}},{key:"getButton",value:function(t,e,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],i="json-editor-btn-".concat(e);e=this.iconlib?this.iconlib.getIcon(e):null,t=this.translate(t,n),r=this.translate(r,n),!e&&r&&(t=r,r=null);var o=this.theme.getButton(t,e,r);return o.classList.add(i),o}},{key:"setButtonText",value:function(t,e,r,n){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];return r=this.iconlib?this.iconlib.getIcon(r):null,e=this.translate(e,i),n=this.translate(n,i),!r&&n&&(e=n,n=null),this.theme.setButtonText(t,e,r,n)}},{key:"addLink",value:function(t){this.link_holder&&this.link_holder.appendChild(t)}},{key:"getLink",value:function(t){var e,r,n=(t.mediaType||"application/javascript").split("/")[0],i=this.jsoneditor.compileTemplate(t.href,this.template_engine),o=this.jsoneditor.compileTemplate(t.rel?t.rel:t.href,this.template_engine),a=null;if(t.download&&(a=t.download),a&&!0!==a&&(a=this.jsoneditor.compileTemplate(a,this.template_engine)),"image"===n){e=this.theme.getBlockLinkHolder(),(r=document.createElement("a")).setAttribute("target","_blank");var s=document.createElement("img");this.theme.createImageLink(e,r,s),this.link_watchers.push((function(t){var e=i(t),n=o(t);r.setAttribute("href",e),r.setAttribute("title",n||e),s.setAttribute("src",e)}))}else if(["audio","video"].includes(n)){e=this.theme.getBlockLinkHolder(),(r=this.theme.getBlockLink()).setAttribute("target","_blank");var l=document.createElement(n);l.setAttribute("controls","controls"),this.theme.createMediaLink(e,r,l),this.link_watchers.push((function(t){var e=i(t),n=o(t);r.setAttribute("href",e),r.textContent=n||e,l.setAttribute("src",e)}))}else r=e=this.theme.getBlockLink(),e.setAttribute("target","_blank"),e.textContent=t.rel,e.style.display="none",this.link_watchers.push((function(t){var r=i(t),n=o(t);r&&(e.style.display=""),e.setAttribute("href",r),e.textContent=n||r}));return a&&r&&(!0===a?r.setAttribute("download",""):this.link_watchers.push((function(t){r.setAttribute("download",a(t))}))),t.class&&t.class.split(" ").forEach((function(t){r.classList.add(t)})),e}},{key:"refreshWatchedFieldValues",value:function(){var t=this;if(this.watched_values){var e={},r=!1;return this.watched&&Object.keys(this.watched).forEach((function(n){var i=t.jsoneditor.getEditor(t.watched[n]),o=i?i.getValue():null;t.watched_values[n]!==o&&(r=!0),e[n]=o})),e.self=this.getValue(),this.watched_values.self!==e.self&&(r=!0),this.watched_values=e,r}}},{key:"getWatchedFieldValues",value:function(){return this.watched_values}},{key:"updateHeaderText",value:function(){if(this.header){var t=this.getHeaderText();if(this.header.children.length){for(var e=0;e<this.header.childNodes.length;e++)if(3===this.header.childNodes[e].nodeType){this.header.childNodes[e].nodeValue=this.cleanText(t);break}}else window.DOMPurify?this.header.innerHTML=window.DOMPurify.sanitize(t):this.header.textContent=this.cleanText(t)}}},{key:"getHeaderText",value:function(t){return this.header_text?this.header_text:t?this.translateProperty(this.schema.title):this.getTitle()}},{key:"getPathDepth",value:function(){return this.path.split(".").length}},{key:"cleanText",value:function(t){var e=document.createElement("div");return e.innerHTML=t,e.textContent||e.innerText}},{key:"onWatchedFieldChange",value:function(){var t,e=this;if(this.header_template){t=l(this.getWatchedFieldValues(),{key:this.key,i:this.key,i0:1*this.key,i1:1*this.key+1,title:this.getTitle()}),this.editors&&Object.keys(this.editors).length&&(t.properties={},Object.keys(this.editors).forEach((function(r){var n=e.editors[r];if(n.schema&&n.schema.enum&&n.schema.options&&n.schema.options.enum_titles){var i=n.schema.enum.indexOf(n.value),o=n.options.enum_titles[i];t.properties[r]={enumTitle:o}}})));var r=this.header_template(t);r!==this.header_text&&(this.header_text=r,this.updateHeaderText(),this.notify())}if(this.link_watchers.length){t=this.getWatchedFieldValues();for(var n=0;n<this.link_watchers.length;n++)this.link_watchers[n](t)}}},{key:"setValue",value:function(t){t=this.applyConstFilter(t),this.value=t}},{key:"applyConstFilter",value:function(t){return this.enforceConstEnabled&&void 0!==this.schema.const&&(t=this.schema.const),t}},{key:"getValue",value:function(){if(this.dependenciesFulfilled)return this.value}},{key:"refreshValue",value:function(){}},{key:"getChildEditors",value:function(){return!1}},{key:"destroy",value:function(){var t=this;this.unregister(this),this.watched&&Object.values(this.watched).forEach((function(e){return t.jsoneditor.unwatch(e,t.watch_listener)})),this.watched=null,this.watched_values=null,this.watch_listener=null,this.header_text=null,this.header_template=null,this.value=null,this.container&&this.container.parentNode&&this.container.parentNode.removeChild(this.container),this.container=null,this.jsoneditor=null,this.schema=null,this.path=null,this.key=null,this.parent=null}},{key:"isDefaultRequired",value:function(){return this.isRequired()||!!this.jsoneditor.options.use_default_values}},{key:"getDefault",value:function(){if(this.enforceConstEnabled&&this.schema.const)return this.schema.const;if(void 0!==this.schema.default)return this.schema.default;if(void 0!==this.schema.enum)return this.schema.enum[0];var t=this.schema.type||this.schema.oneOf;if(t&&Array.isArray(t)&&(t=t[0]),t&&"object"===b(t)&&(t=t.type),t&&Array.isArray(t)&&(t=t[0]),"string"==typeof t){if("number"===t)return this.isDefaultRequired()?0:void 0;if("boolean"===t)return!this.isDefaultRequired()&&void 0;if("integer"===t)return this.isDefaultRequired()?0:void 0;if("string"===t)return this.isDefaultRequired()?"":void 0;if("null"===t)return null;if("object"===t)return{};if("array"===t)return[]}}},{key:"getTitle",value:function(){return this.translateProperty(this.schema.title||this.key||this.formname)}},{key:"enable",value:function(){this.disabled=!1}},{key:"disable",value:function(){this.disabled=!0}},{key:"isEnabled",value:function(){return!this.disabled}},{key:"isRequired",value:function(){return"boolean"==typeof this.schema.required?this.schema.required:this.parent&&this.parent.schema&&Array.isArray(this.parent.schema.required)?this.parent.schema.required.includes(this.key):!!this.jsoneditor.options.required_by_default}},{key:"getDisplayText",value:function(t){var e=[],r={};t.forEach((function(t){t.title&&(r[t.title]=r[t.title]||0,r[t.title]++),t.description&&(r[t.description]=r[t.description]||0,r[t.description]++),t.format&&(r[t.format]=r[t.format]||0,r[t.format]++),t.type&&(r[t.type]=r[t.type]||0,r[t.type]++)})),t.forEach((function(t){var n;n="string"==typeof t?t:t.title&&r[t.title]<=1?t.title:t.format&&r[t.format]<=1?t.format:t.type&&r[t.type]<=1?t.type:t.description&&r[t.description]<=1?t.description:t.title?t.title:t.format?t.format:t.type?t.type:t.description?t.description:JSON.stringify(t).length<500?JSON.stringify(t):"type",e.push(n)}));var n={};return e.forEach((function(t,i){n[t]=n[t]||0,n[t]++,r[t]>1&&(e[i]="".concat(t," ").concat(n[t]))})),e}},{key:"getValidId",value:function(t){return(t=void 0===t?"":t.toString()).replace(/\s+/g,"-")}},{key:"setInputAttributes",value:function(t,e){if(this.schema.options&&this.schema.options.inputAttributes){var r=this.schema.options.inputAttributes,n=["name","type"].concat(t),i=e||this.input;Object.keys(r).forEach((function(t){n.includes(t.toLowerCase())||i.setAttribute(t,r[t])}))}}},{key:"setContainerAttributes",value:function(){var t=this;if(this.schema.options&&this.schema.options.containerAttributes){var e=this.schema.options.containerAttributes,r=["data-schemapath","data-schematype","data-schemaid"];Object.keys(e).forEach((function(n){r.includes(n.toLowerCase())||t.container.setAttribute(n,e[n])}))}}},{key:"expandCallbacks",value:function(t,e){var r=this,n=this.defaults.callbacks[t];return Object.entries(e).forEach((function(i){var o,a,s=(a=2,function(t){if(Array.isArray(t))return t}(o=i)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,i,o,a,s=[],l=!0,c=!1;try{if(o=(r=r.call(t)).next,0===e){if(Object(r)!==r)return;l=!1}else for(;!(l=(n=o.call(r)).done)&&(s.push(n.value),s.length!==e);l=!0);}catch(t){c=!0,i=t}finally{try{if(!l&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw i}}return s}}(o,a)||function(t,e){if(t){if("string"==typeof t)return v(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?v(t,e):void 0}}(o,a)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),l=s[0],c=s[1];c===Object(c)?e[l]=r.expandCallbacks(t,c):"string"==typeof c&&"object"===b(n)&&"function"==typeof n[c]&&(e[l]=n[c].bind(null,r))})),e}},{key:"showValidationErrors",value:function(t){}}],e&&g(t.prototype,e),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,e}();function k(t){return k="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},k(t)}function j(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,O(n.key),n)}}function O(t){var e=function(t,e){if("object"!=k(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=k(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==k(e)?e:e+""}function x(t,e,r){return e=S(e),function(t,e){if(e&&("object"===k(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,C()?Reflect.construct(e,r||[],S(t).constructor):e.apply(t,r))}function C(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(C=function(){return!!t})()}function E(){return E="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=S(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},E.apply(this,arguments)}function S(t){return S=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},S(t)}function P(t,e){return P=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},P(t,e)}var L=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),x(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&P(t,e)}(e,t),r=e,(n=[{key:"register",value:function(){E(S(e.prototype),"register",this).call(this),this.input&&this.jsoneditor.options.use_name_attributes&&this.input.setAttribute("name",this.formname)}},{key:"unregister",value:function(){E(S(e.prototype),"unregister",this).call(this),this.input&&(this.input.removeAttribute("name"),this.input.removeAttribute("aria-label"))}},{key:"setValue",value:function(t,e,r){if(t=this.applyConstFilter(t),(!this.template||r)&&(this.shouldBeUnset()||null!=t?"object"===k(t)?t=JSON.stringify(t):this.shouldBeUnset()||"string"==typeof t||(t="".concat(t)):t="",t!==this.serialized)){var n=this.sanitize(t);if(this.input.value!==n){if(this.setValueToInputField(n),"range"===this.format){var i=this.control.querySelector("output");i&&(i.value=n)}var o=r||this.getValue()!==t;return this.refreshValue(),e?this.is_dirty=!1:"change"===this.jsoneditor.options.show_errors&&(this.is_dirty=!0),this.adjust_height&&this.adjust_height(this.input),o&&this.onChange(!0,r),{changed:o,value:n}}}}},{key:"setValueToInputField",value:function(t){this.input.value=void 0===t?"":t}},{key:"getNumColumns",value:function(){var t,e=Math.ceil(Math.max(this.getTitle().length,this.schema.maxLength||0,this.schema.minLength||0)/5);return t="textarea"===this.input_type?6:["text","email"].includes(this.input_type)?4:2,Math.min(12,Math.max(e,t))}},{key:"build",value:function(){var t,e=this;if(this.options.compact||(this.header=this.label=this.theme.getFormInputLabel(this.getTitle(),this.isRequired())),this.schema.description&&(this.description=this.theme.getFormInputDescription(this.translateProperty(this.schema.description))),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText))),this.format=this.schema.format,!this.format&&this.schema.media&&this.schema.media.type&&(this.format=this.schema.media.type.replace(/(^(application|text)\/(x-)?(script\.)?)|(-source$)/g,"")),!this.format&&this.options.default_format&&(this.format=this.options.default_format),this.options.format&&(this.format=this.options.format),this.format)if("textarea"===this.format)this.input_type="textarea",this.input=this.theme.getTextareaInput();else if("range"===this.format){this.input_type="range";var r=this.schema.minimum||0,n=this.schema.maximum||Math.max(100,r+1),i=1;this.schema.multipleOf&&(r%this.schema.multipleOf&&(r=Math.ceil(r/this.schema.multipleOf)*this.schema.multipleOf),n%this.schema.multipleOf&&(n=Math.floor(n/this.schema.multipleOf)*this.schema.multipleOf),i=this.schema.multipleOf),this.input=this.theme.getRangeInput(r,n,i,this.description,this.formname),this.input.setAttribute("id",this.formname)}else this.input_type="text",["button","checkbox","color","date","datetime-local","email","file","hidden","image","month","number","password","radio","reset","search","submit","tel","text","time","url","week"].includes(this.format)&&(this.input_type=this.format),this.input=this.theme.getFormInputField(this.input_type);else this.input_type="text",this.input=this.theme.getFormInputField(this.input_type);void 0!==this.schema.maxLength&&this.input.setAttribute("maxlength",this.schema.maxLength),void 0!==this.schema.pattern?this.input.setAttribute("pattern",this.schema.pattern):void 0!==this.schema.minLength&&this.input.setAttribute("pattern",".{".concat(this.schema.minLength,",}")),this.options.compact?this.container.classList.add("compact"):this.options.input_width&&(this.input.style.width=this.options.input_width),(this.schema.readOnly||this.schema.readonly||this.schema.template)&&(this.disable(!0),this.input.setAttribute("readonly","true")),this.setInputAttributes(["maxlength","pattern","readonly","min","max","step"]),this.input.addEventListener("change",(function(t){if(t.preventDefault(),t.stopPropagation(),e.schema.template)t.currentTarget.value=e.value;else{var r=t.currentTarget.value,n=e.sanitize(r);r!==n&&(t.currentTarget.value=n),e.is_dirty=!0,e.refreshValue(),e.onChange(!0)}})),this.options.input_height&&(this.input.style.height=this.options.input_height),this.options.expand_height&&(this.adjust_height=function(t){if(t){var e,r=t.offsetHeight;if(t.offsetHeight<t.scrollHeight)for(e=0;t.offsetHeight<t.scrollHeight+3&&!(e>100);)e++,r++,t.style.height="".concat(r,"px");else{for(e=0;t.offsetHeight>=t.scrollHeight+3&&!(e>100);)e++,r--,t.style.height="".concat(r,"px");t.style.height="".concat(r+1,"px")}}},this.input.addEventListener("keyup",(function(t){e.adjust_height(t.currentTarget)})),this.input.addEventListener("change",(function(t){e.adjust_height(t.currentTarget)})),this.adjust_height());var o=null!==(t=this.options.prompt_paste_max_length_reached)&&void 0!==t?t:this.jsoneditor.options.prompt_paste_max_length_reached,a=void 0!==this.schema.maxLength;o&&a&&this.input.addEventListener("paste",(function(t){(t.clipboardData||window.clipboardData).getData("text").length+e.input.value.length>e.schema.maxLength&&alert(e.translate("paste_max_length_reached",[e.schema.maxLength]))})),this.format&&this.input.setAttribute("data-schemaformat",this.format);var s=this.input;if("range"===this.format&&(s=this.theme.getRangeControl(this.input,this.theme.getRangeOutput(this.input,this.schema.default||Math.max(this.schema.minimum||0,0)))),this.control=this.theme.getFormControl(this.label,s,this.description,this.infoButton,this.formname),this.container.appendChild(this.control),window.requestAnimationFrame((function(){e.input.parentNode&&e.afterInputReady(),e.adjust_height&&e.adjust_height(e.input),"range"===e.format&&(e.control.querySelector("output").value=e.input.value)})),this.schema.template){var l=this.expandCallbacks("template",{template:this.schema.template});"function"==typeof l.template?this.template=l.template:this.template=this.jsoneditor.compileTemplate(this.schema.template,this.template_engine),this.refreshValue()}else this.refreshValue()}},{key:"setupCleave",value:function(t){var e=this.expandCallbacks("cleave",l({},this.defaults.options.cleave||{},this.options.cleave||{}));"object"===k(e)&&Object.keys(e).length>0&&(this.cleave_instance=new window.Cleave(t,e))}},{key:"setupImask",value:function(t){var e=this.expandCallbacks("imask",l({},this.defaults.options.imask||{},this.options.imask||{}));"object"===k(e)&&Object.keys(e).length>0&&(this.imask_instance=window.IMask(t,this.ajustIMaskOptions(e)))}},{key:"ajustIMaskOptions",value:function(t){var e=this;return Object.keys(t).forEach((function(r){if(t[r]===Object(t[r]))t[r]=e.ajustIMaskOptions(t[r]);else if("mask"===r)if("regex:"===t[r].substr(0,6)){var n=t[r].match(/^regex:\/(.*)\/([gimsuy]*)$/);if(null!==n)try{t[r]=new RegExp(n[1],n[2])}catch(t){}}else t[r]=e.getGlobalPropertyFromString(t[r])})),t}},{key:"getGlobalPropertyFromString",value:function(t){if(t.includes(".")){var e=t.split("."),r=e[0],n=e[1];if(void 0!==window[r]&&void 0!==window[r][n])return window[r][n]}else if(void 0!==window[t])return window[t];return t}},{key:"shouldBeUnset",value:function(){return!this.jsoneditor.options.use_default_values&&!this.is_dirty}},{key:"getValue",value:function(){var t=!(!this.input||!this.input.value);if(!this.shouldBeUnset()||t)return this.imask_instance&&this.dependenciesFulfilled&&this.options.imask.returnUnmasked?this.imask_instance.unmaskedValue:E(S(e.prototype),"getValue",this).call(this)}},{key:"enable",value:function(){this.always_disabled||(this.input.disabled=!1,E(S(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){t&&(this.always_disabled=!0),this.input.disabled=!0,E(S(e.prototype),"disable",this).call(this)}},{key:"afterInputReady",value:function(){this.theme.afterInputReady(this.input),window.Cleave&&!this.cleave_instance?this.setupCleave(this.input):window.IMask&&!this.imask_instance&&this.setupImask(this.input)}},{key:"refreshValue",value:function(){this.input&&(this.value=this.input.value,"string"==typeof this.value||this.shouldBeUnset()||(this.value=""),this.serialized=this.value)}},{key:"destroy",value:function(){this.cleave_instance&&this.cleave_instance.destroy(),this.imask_instance&&this.imask_instance.destroy(),this.template=null,this.input&&this.input.parentNode&&this.input.parentNode.removeChild(this.input),this.label&&this.label.parentNode&&this.label.parentNode.removeChild(this.label),this.description&&this.description.parentNode&&this.description.parentNode.removeChild(this.description),E(S(e.prototype),"destroy",this).call(this)}},{key:"sanitize",value:function(t){return t}},{key:"onWatchedFieldChange",value:function(){var t;this.template&&(t=this.getWatchedFieldValues(),this.setValue(this.template(t),!1,!0)),E(S(e.prototype),"onWatchedFieldChange",this).call(this)}},{key:"showValidationErrors",value:function(t){var e=this;if("always"===this.jsoneditor.options.show_errors);else if(!this.is_dirty&&this.previous_error_setting===this.jsoneditor.options.show_errors)return;this.previous_error_setting=this.jsoneditor.options.show_errors;var r=t.reduce((function(t,r){return r.path===e.path&&t.push(r.message),t}),[]);r.length?this.theme.addInputError(this.input,"".concat(r.join(". "),".")):this.theme.removeInputError(this.input)}}])&&j(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function T(t){return T="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},T(t)}function A(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,R(n.key),n)}}function R(t){var e=function(t,e){if("object"!=T(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=T(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==T(e)?e:e+""}function I(t,e,r){return e=D(e),function(t,e){if(e&&("object"===T(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,B()?Reflect.construct(e,r||[],D(t).constructor):e.apply(t,r))}function B(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(B=function(){return!!t})()}function N(){return N="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=D(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},N.apply(this,arguments)}function D(t){return D=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},D(t)}function F(t,e){return F=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},F(t,e)}var V=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),I(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&F(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r,n){t=this.applyConstFilter(t);var i=N(D(e.prototype),"setValue",this).call(this,t,r,n);void 0!==i&&i.changed&&this.ace_editor_instance&&(this.ace_editor_instance.setValue(i.value),this.ace_editor_instance.session.getSelection().clearSelection(),this.ace_editor_instance.resize())}},{key:"build",value:function(){this.options.format="textarea",N(D(e.prototype),"build",this).call(this),this.input_type=this.schema.format,this.input.setAttribute("data-schemaformat",this.input_type)}},{key:"afterInputReady",value:function(){var t,r=this;if(window.ace){var n=this.input_type;"cpp"!==n&&"c++"!==n&&"c"!==n||(n="c_cpp"),t=this.expandCallbacks("ace",l({},{selectionStyle:"text",minLines:30,maxLines:30},this.defaults.options.ace||{},this.options.ace||{},{mode:"ace/mode/".concat(n)})),this.ace_container=document.createElement("div"),this.ace_container.style.width="100%",this.ace_container.style.position="relative",this.input.parentNode.insertBefore(this.ace_container,this.input),this.input.style.display="none",this.ace_editor_instance=window.ace.edit(this.ace_container,t),this.ace_editor_instance.setValue(this.getValue()),this.ace_editor_instance.session.getSelection().clearSelection(),this.ace_editor_instance.resize(),(this.schema.readOnly||this.schema.readonly||this.schema.template)&&this.ace_editor_instance.setReadOnly(!0),this.ace_editor_instance.on("change",(function(){r.input.value=r.ace_editor_instance.getValue(),r.refreshValue(),r.is_dirty=!0,r.onChange(!0)})),this.theme.afterInputReady(this.input)}else N(D(e.prototype),"afterInputReady",this).call(this)}},{key:"getNumColumns",value:function(){return 6}},{key:"enable",value:function(){!this.always_disabled&&this.ace_editor_instance&&this.ace_editor_instance.setReadOnly(!1),N(D(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.ace_editor_instance&&this.ace_editor_instance.setReadOnly(!0),N(D(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.ace_editor_instance&&(this.ace_editor_instance.destroy(),this.ace_editor_instance=null),N(D(e.prototype),"destroy",this).call(this)}}])&&A(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function H(t){return H="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},H(t)}function z(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,M(n.key),n)}}function M(t){var e=function(t,e){if("object"!=H(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=H(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==H(e)?e:e+""}function q(t,e,r){return e=$(e),function(t,e){if(e&&("object"===H(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,U()?Reflect.construct(e,r||[],$(t).constructor):e.apply(t,r))}function U(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(U=function(){return!!t})()}function G(){return G="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=$(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},G.apply(this,arguments)}function $(t){return $=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},$(t)}function J(t,e){return J=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},J(t,e)}r(2008),r(4554);var W=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),q(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&J(t,e)}(e,t),r=e,n=[{key:"askConfirmation",value:function(){return!0!==this.jsoneditor.options.prompt_before_delete||!1!==window.confirm(this.translate("button_delete_node_warning"))}},{key:"register",value:function(){G($(e.prototype),"register",this).call(this),this.rows&&this.rows.forEach((function(t){return t.register()}))}},{key:"unregister",value:function(){G($(e.prototype),"unregister",this).call(this),this.rows&&this.rows.forEach((function(t){return t.unregister()}))}},{key:"getNumColumns",value:function(){var t=this.getItemInfo(0);return this.tabs_holder&&"tabs-top"!==this.schema.format?Math.max(Math.min(12,t.width+2),4):t.width}},{key:"enable",value:function(){var t=this;this.always_disabled||(this.setAvailability(this,!1),this.rows&&this.rows.forEach((function(e){e.enable(),t.setAvailability(e,!1)})),G($(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){var r=this;t&&(this.always_disabled=!0),this.setAvailability(this,!0),this.rows&&this.rows.forEach((function(e){e.disable(t),r.setAvailability(e,!0)})),G($(e.prototype),"disable",this).call(this)}},{key:"setAvailability",value:function(t,e){t.add_row_button&&(t.add_row_button.disabled=e),t.remove_all_rows_button&&(t.remove_all_rows_button.disabled=e),t.delete_last_row_button&&(t.delete_last_row_button.disabled=e),t.copy_button&&(t.copy_button.disabled=e),t.delete_button&&(t.delete_button.disabled=e),t.moveup_button&&(t.moveup_button.disabled=e),t.movedown_button&&(t.movedown_button.disabled=e)}},{key:"preBuild",value:function(){G($(e.prototype),"preBuild",this).call(this),this.rows=[],this.row_cache=[],this.hide_delete_buttons=this.options.disable_array_delete||this.jsoneditor.options.disable_array_delete,this.hide_delete_all_rows_buttons=this.hide_delete_buttons||this.options.disable_array_delete_all_rows||this.jsoneditor.options.disable_array_delete_all_rows,this.hide_delete_last_row_buttons=this.hide_delete_buttons||this.options.disable_array_delete_last_row||this.jsoneditor.options.disable_array_delete_last_row,this.hide_move_buttons=this.options.disable_array_reorder||this.jsoneditor.options.disable_array_reorder,this.hide_add_button=this.options.disable_array_add||this.jsoneditor.options.disable_array_add,this.show_copy_button=this.options.enable_array_copy||this.jsoneditor.options.enable_array_copy,this.array_controls_top=this.options.array_controls_top||this.jsoneditor.options.array_controls_top}},{key:"build",value:function(){this.options.compact?(this.title=this.theme.getHeader("",this.getPathDepth()),this.container.appendChild(this.title),this.panel=this.theme.getIndentedPanel(),this.container.appendChild(this.panel),this.title_controls=this.theme.getHeaderButtonHolder(),this.title.appendChild(this.title_controls),this.controls=this.theme.getHeaderButtonHolder(),this.title.appendChild(this.controls),this.row_holder=document.createElement("div"),this.panel.appendChild(this.row_holder)):(this.header=document.createElement("span"),this.header.textContent=this.getTitle(),this.title=this.theme.getHeader(this.header,this.getPathDepth()),this.container.appendChild(this.title),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText)),this.container.appendChild(this.infoButton)),this.title_controls=this.theme.getHeaderButtonHolder(),this.title.appendChild(this.title_controls),this.schema.description&&(this.description=this.theme.getDescription(this.translateProperty(this.schema.description)),this.container.appendChild(this.description)),this.error_holder=document.createElement("div"),this.container.appendChild(this.error_holder),"tabs-top"===this.schema.format?(this.controls=this.theme.getHeaderButtonHolder(),this.title.appendChild(this.controls),this.tabs_holder=this.theme.getTopTabHolder(this.getValidId(this.getItemTitle())),this.container.appendChild(this.tabs_holder),this.row_holder=this.theme.getTopTabContentHolder(this.tabs_holder),this.active_tab=null):"tabs"===this.schema.format?(this.controls=this.theme.getHeaderButtonHolder(),this.title.appendChild(this.controls),this.tabs_holder=this.theme.getTabHolder(this.getValidId(this.getItemTitle())),this.container.appendChild(this.tabs_holder),this.row_holder=this.theme.getTabContentHolder(this.tabs_holder),this.active_tab=null):(this.panel=this.theme.getIndentedPanel(),this.container.appendChild(this.panel),this.row_holder=document.createElement("div"),this.panel.appendChild(this.row_holder),this.controls=this.theme.getButtonHolder(),this.array_controls_top?this.title.appendChild(this.controls):this.panel.appendChild(this.controls))),this.addControls()}},{key:"postBuild",value:function(){G($(e.prototype),"postBuild",this).call(this),(this.schema.readOnly||this.schema.readonly)&&this.disable()}},{key:"onChildEditorChange",value:function(t,r){this.refreshValue(),this.refreshTabs(!0),this.is_dirty=!0,G($(e.prototype),"onChildEditorChange",this).call(this,t,r)}},{key:"getItemTitle",value:function(){if(!this.item_title)if(this.schema.items&&!Array.isArray(this.schema.items)){var t=this.jsoneditor.expandRefs(this.schema.items);this.item_title=this.translateProperty(t.title)||this.translate("default_array_item_title")}else this.item_title=this.translate("default_array_item_title");return this.cleanText(this.item_title)}},{key:"getItemSchema",value:function(t){return Array.isArray(this.schema.items)?t>=this.schema.items.length?!0===this.schema.additionalItems?{}:this.schema.additionalItems?l({},this.schema.additionalItems):void 0:l({},this.schema.items[t]):this.schema.items?l({},this.schema.items):{}}},{key:"getItemInfo",value:function(t){var e=this.getItemSchema(t);this.item_info=this.item_info||{};var r=JSON.stringify(e);return void 0!==this.item_info[r]||(e=this.jsoneditor.expandRefs(e),this.item_info[r]={title:this.translateProperty(e.title)||this.translate("default_array_item_title"),default:e.default,width:12,child_editors:e.properties||e.items}),this.item_info[r]}},{key:"getElementEditor",value:function(t){var e=this.getItemInfo(t),r=this.getItemSchema(t);(r=this.jsoneditor.expandRefs(r)).title="".concat(e.title," ").concat(t+1);var n,i=this.jsoneditor.getEditorClass(r);this.tabs_holder?(n="tabs-top"===this.schema.format?this.theme.getTopTabContent():this.theme.getTabContent()).id="".concat(this.path,".").concat(t):n=e.child_editors?this.theme.getChildEditorHolder():this.theme.getIndentedPanel(),this.row_holder.appendChild(n);var o=this.jsoneditor.createEditor(i,{jsoneditor:this.jsoneditor,schema:r,container:n,path:"".concat(this.path,".").concat(t),parent:this,required:!0});return o.preBuild(),o.build(),o.postBuild(),o.title_controls||(o.array_controls=this.theme.getButtonHolder(),n.appendChild(o.array_controls)),o}},{key:"checkParent",value:function(t){return t&&t.parentNode}},{key:"destroy",value:function(){this.empty(!0),this.checkParent(this.title)&&this.title.parentNode.removeChild(this.title),this.checkParent(this.description)&&this.description.parentNode.removeChild(this.description),this.checkParent(this.row_holder)&&this.row_holder.parentNode.removeChild(this.row_holder),this.checkParent(this.controls)&&this.controls.parentNode.removeChild(this.controls),this.checkParent(this.panel)&&this.panel.parentNode.removeChild(this.panel),this.rows=this.row_cache=this.title=this.description=this.row_holder=this.panel=this.controls=null,G($(e.prototype),"destroy",this).call(this)}},{key:"empty",value:function(t){var e=this;if(null!==this.rows){if(this.rows.forEach((function(r,n){t&&(e.checkParent(r.tab)&&r.tab.parentNode.removeChild(r.tab),e.destroyRow(r,!0),e.row_cache[n]=null),e.rows[n]=null})),t)for(var r=this.rows.length;r<this.row_cache.length;r++)this.destroyRow(this.row_cache[r],!0),this.row_cache[r]=null;this.rows=[],t&&(this.row_cache=[])}}},{key:"destroyRow",value:function(t,e){var r=t.container;e?(t.destroy(),r.parentNode&&r.parentNode.removeChild(r),this.checkParent(t.tab)&&t.tab.parentNode.removeChild(t.tab)):(t.tab&&(t.tab.style.display="none"),r.style.display="none",t.unregister())}},{key:"getMax",value:function(){return Array.isArray(this.schema.items)&&!1===this.schema.additionalItems?Math.min(this.schema.items.length,this.schema.maxItems||1/0):this.schema.maxItems||1/0}},{key:"refreshTabs",value:function(t){var e=this;this.rows.forEach((function(r){r.tab&&(t?r.tab_text.textContent=r.getHeaderText():r.tab===e.active_tab?e.theme.markTabActive(r):e.theme.markTabInactive(r))}))}},{key:"ensureArraySize",value:function(t){if(Array.isArray(t)||(t=[t]),this.schema.minItems)for(;t.length<this.schema.minItems;)t.push(this.getItemInfo(t.length).default);return this.getMax()&&t.length>this.getMax()&&(t=t.slice(0,this.getMax())),t}},{key:"setValue",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],r=arguments.length>1?arguments[1]:void 0;if(e=this.applyConstFilter(e),e=this.ensureArraySize(e),JSON.stringify(e)!==this.serialized){e.forEach((function(e,n){if(t.rows[n])t.rows[n].setValue(e,r);else if(t.row_cache[n])t.rows[n]=t.row_cache[n],t.rows[n].setValue(e,r),t.rows[n].container.style.display="",t.rows[n].tab&&(t.rows[n].tab.style.display=""),t.rows[n].register(),t.jsoneditor.trigger("addRow",t.rows[n]);else{var i=t.addRow(e,r);t.jsoneditor.trigger("addRow",i)}}));for(var n=e.length;n<this.rows.length;n++)this.destroyRow(this.rows[n]),this.rows[n]=null;this.rows=this.rows.slice(0,e.length);var i=this.rows.find((function(e){return e.tab===t.active_tab})),o=void 0!==i?i.tab:null;!o&&this.rows.length&&(o=this.rows[0].tab),this.active_tab=o,this.refreshValue(r),this.refreshTabs(!0),this.refreshTabs(),this.onChange()}else r&&this.refreshValue(r)}},{key:"setButtonState",value:function(t,e){switch(this.options.button_state_mode||this.jsoneditor.options.button_state_mode){case 1:default:t.style.display=e?"":"none";break;case 2:t.disabled=!e}}},{key:"setupButtons",value:function(t){var e=[];if(this.value.length)if(1===this.value.length){this.setButtonState(this.remove_all_rows_button,!1);var r=!(t||this.hide_delete_last_row_buttons);this.setButtonState(this.delete_last_row_button,r),e.push(r)}else{var n=!(t||this.hide_delete_last_row_buttons);this.setButtonState(this.delete_last_row_button,n),e.push(n);var i=!(t||this.hide_delete_all_rows_buttons);this.setButtonState(this.remove_all_rows_button,i),e.push(i)}else this.setButtonState(this.delete_last_row_button,!1),this.setButtonState(this.remove_all_rows_button,!1);var o=!(this.getMax()&&this.getMax()<=this.rows.length||this.hide_add_button);return this.setButtonState(this.add_row_button,o),e.push(o),e.some((function(t){return t}))}},{key:"refreshValue",value:function(t){var e=this,r=this.value?this.value.length:0;if(this.value=this.rows.map((function(t){return t.getValue()})),r!==this.value.length||t){var n=this.schema.minItems&&this.schema.minItems>=this.rows.length;this.rows.forEach((function(t,r){if(t.movedown_button){var i=r!==e.rows.length-1;e.setButtonState(t.movedown_button,i)}t.delete_button&&e.setButtonState(t.delete_button,!n),e.value[r]=t.getValue()})),this.setupButtons(n)&&!this.collapsed?this.controls.style.display="inline-block":this.controls.style.display="none"}this.serialized=JSON.stringify(this.value)}},{key:"addRow",value:function(t,e){var r=this,n=this.rows.length;this.rows[n]=this.getElementEditor(n),this.row_cache[n]=this.rows[n],this.tabs_holder?(this.rows[n].tab_text=document.createElement("span"),this.rows[n].tab_text.textContent=this.rows[n].getHeaderText(),"tabs-top"===this.schema.format?(this.rows[n].tab=this.theme.getTopTab(this.rows[n].tab_text,this.getValidId(this.rows[n].path)),this.theme.addTopTab(this.tabs_holder,this.rows[n].tab)):(this.rows[n].tab=this.theme.getTab(this.rows[n].tab_text,this.getValidId(this.rows[n].path)),this.theme.addTab(this.tabs_holder,this.rows[n].tab)),this.rows[n].tab.addEventListener("click",(function(t){r.active_tab=r.rows[n].tab,r.refreshTabs(),t.preventDefault(),t.stopPropagation()})),this._supportDragDrop(this.rows[n].tab)):this._supportDragDrop(this.rows[n].container,!0);var i=this.rows[n].title_controls||this.rows[n].array_controls;return this.hide_delete_buttons||(this.rows[n].delete_button=this._createDeleteButton(n,i)),this.show_copy_button&&(this.rows[n].copy_button=this._createCopyButton(n,i)),n&&!this.hide_move_buttons&&(this.rows[n].moveup_button=this._createMoveUpButton(n,i)),this.hide_move_buttons||(this.rows[n].movedown_button=this._createMoveDownButton(n,i)),void 0!==t&&this.rows[n].setValue(t,e),this.refreshTabs(),this.rows[n]}},{key:"_createDeleteButton",value:function(t,e){var r=this,n=this.getButton(this.getItemTitle(),"delete","button_delete_row_title",[this.getItemTitle()]);return n.classList.add("delete","json-editor-btntype-delete"),n.setAttribute("data-i",t),n.addEventListener("click",(function(t){if(t.preventDefault(),t.stopPropagation(),!r.askConfirmation())return!1;var e=1*t.currentTarget.getAttribute("data-i"),n=r.getValue().filter((function(t,r){return r!==e})),i=null,o=r.rows[e].getValue();r.setValue(n),r.rows[e]?i=r.rows[e].tab:r.rows[e-1]&&(i=r.rows[e-1].tab),i&&(r.active_tab=i,r.refreshTabs()),r.onChange(!0),r.jsoneditor.trigger("deleteRow",o)})),e&&e.appendChild(n),n}},{key:"_createCopyButton",value:function(t,e){var r=this,n=this.getButton(this.getItemTitle(),"copy","button_copy_row_title",[this.getItemTitle()]),i=this.schema;return n.classList.add("copy","json-editor-btntype-copy"),n.setAttribute("data-i",t),n.addEventListener("click",(function(t){var e=r.getValue();t.preventDefault(),t.stopPropagation();var n=1*t.currentTarget.getAttribute("data-i");e.forEach((function(t,r){if(r===n){if("string"===i.items.type&&"uuid"===i.items.format)t=f();else if("object"===i.items.type&&i.items.properties)for(var o=0,a=Object.keys(t);o<a.length;o++){var s=a[o];i.items.properties&&i.items.properties[s]&&"uuid"===i.items.properties[s].format&&(t[s]=f())}e.push(t)}})),r.setValue(e),r.refreshValue(!0),r.onChange(!0),r.jsoneditor.trigger("copyRow",r.rows[n-1])})),e.appendChild(n),n}},{key:"_createMoveUpButton",value:function(t,e){var r=this,n=this.getButton("","tabs-top"===this.schema.format?"moveleft":"moveup","button_move_up_title");return n.classList.add("moveup","json-editor-btntype-move"),n.setAttribute("data-i",t),n.addEventListener("click",(function(t){t.preventDefault(),t.stopPropagation();var e=1*t.currentTarget.getAttribute("data-i");if(!(e<=0)){var n=r.getValue(),i=n[e-1];n[e-1]=n[e],n[e]=i,r.setValue(n),r.active_tab=r.rows[e-1].tab,r.refreshTabs(),r.onChange(!0),r.jsoneditor.trigger("moveRow",r.rows[e-1])}})),e&&e.appendChild(n),n}},{key:"_createMoveDownButton",value:function(t,e){var r=this,n=this.getButton("","tabs-top"===this.schema.format?"moveright":"movedown","button_move_down_title");return n.classList.add("movedown","json-editor-btntype-move"),n.setAttribute("data-i",t),n.addEventListener("click",(function(t){t.preventDefault(),t.stopPropagation();var e=1*t.currentTarget.getAttribute("data-i"),n=r.getValue();if(!(e>=n.length-1)){var i=n[e+1];n[e+1]=n[e],n[e]=i,r.setValue(n),r.active_tab=r.rows[e+1].tab,r.refreshTabs(),r.onChange(!0),r.jsoneditor.trigger("moveRow",r.rows[e+1])}})),e&&e.appendChild(n),n}},{key:"_supportDragDrop",value:function(t,e){var r=this;Z(t,(function(t,e){var n=r.getValue(),i=n[t];n.splice(t,1),n.splice(e,0,i),r.setValue(n),r.active_tab=r.rows[e].tab,r.refreshTabs(),r.onChange(!0),r.jsoneditor.trigger("moveRow",r.rows[e])}),{useTrigger:e})}},{key:"addControls",value:function(){this.collapsed=!1,this.toggle_button=this._createToggleButton(),this.options.collapsed&&c(this.toggle_button,"click"),this.schema.options&&void 0!==this.schema.options.disable_collapse?this.schema.options.disable_collapse&&(this.toggle_button.style.display="none"):this.jsoneditor.options.disable_collapse&&(this.toggle_button.style.display="none"),this.add_row_button=this._createAddRowButton(),this.delete_last_row_button=this._createDeleteLastRowButton(),this.remove_all_rows_button=this._createRemoveAllRowsButton(),this.tabs&&(this.add_row_button.classList.add("je-array-control-btn"),this.delete_last_row_button.classList.add("je-array-control-btn"),this.remove_all_rows_button.classList.add("je-array-control-btn"))}},{key:"_createToggleButton",value:function(){var t=this,e=this.getButton("","collapse","button_collapse");e.classList.add("json-editor-btntype-toggle"),this.title.insertBefore(e,this.title.childNodes[0]);var r=this.row_holder.style.display,n=this.controls.style.display;return e.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.panel&&t.setButtonState(t.panel,t.collapsed),t.tabs_holder&&t.setButtonState(t.tabs_holder,t.collapsed),t.collapsed?(t.collapsed=!1,t.row_holder.style.display=r,t.controls.style.display=n,t.setButtonText(e.currentTarget,"","collapse","button_collapse")):(t.collapsed=!0,t.row_holder.style.display="none",t.controls.style.display="none",t.setButtonText(e.currentTarget,"","expand","button_expand"))})),e}},{key:"_createAddRowButton",value:function(){var t=this,e=this.getButton(this.getItemTitle(),"add","button_add_row_title",[this.getItemTitle()]);return e.classList.add("json-editor-btntype-add"),e.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation();var r,n=t.rows.length;t.row_cache[n]?(r=t.rows[n]=t.row_cache[n],t.rows[n].setValue(t.rows[n].getDefault(),!0),"function"==typeof t.rows[n].deactivateNonRequiredProperties&&t.rows[n].deactivateNonRequiredProperties(!0),t.rows[n].container.style.display="",t.rows[n].tab&&(t.rows[n].tab.style.display=""),t.rows[n].register()):r=t.addRow(),t.active_tab=t.rows[n].tab,t.refreshTabs(),t.refreshValue(),t.onChange(!0),t.jsoneditor.trigger("addRow",r)})),this.controls.appendChild(e),e}},{key:"_createDeleteLastRowButton",value:function(){var t=this,e=this.getButton("button_delete_last","subtract","button_delete_last_title",[this.getItemTitle()]);return e.classList.add("json-editor-btntype-deletelast"),e.addEventListener("click",(function(e){if(e.preventDefault(),e.stopPropagation(),!t.askConfirmation())return!1;var r=t.getValue(),n=null,i=r.pop();t.setValue(r),t.rows[t.rows.length-1]&&(n=t.rows[t.rows.length-1].tab),n&&(t.active_tab=n,t.refreshTabs()),t.onChange(!0),t.jsoneditor.trigger("deleteRow",i)})),this.controls.appendChild(e),e}},{key:"_createRemoveAllRowsButton",value:function(){var t=this,e=this.getButton("button_delete_all","delete","button_delete_all_title");return e.classList.add("json-editor-btntype-deleteall"),e.addEventListener("click",(function(e){if(e.preventDefault(),e.stopPropagation(),!t.askConfirmation())return!1;var r=t.getValue();t.empty(!0),t.setValue([]),t.onChange(!0),t.jsoneditor.trigger("deleteAllRows",r)})),this.controls.appendChild(e),e}},{key:"showValidationErrors",value:function(t){var e=this,r=[],n=[];t.forEach((function(t){t.path===e.path?r.push(t):n.push(t)})),this.error_holder&&(r.length?(this.error_holder.innerHTML="",this.error_holder.style.display="",r.forEach((function(t){e.error_holder.appendChild(e.theme.getErrorMessage(t.message))}))):this.error_holder.style.display="none"),this.rows.forEach((function(t){return t.showValidationErrors(n)}))}}],n&&z(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function Z(t,e){(arguments.length>2&&void 0!==arguments[2]?arguments[2]:{}).useTrigger?t.addEventListener("mousedown",(function(e){if(e.ctrlKey){t.draggable=!0;var r=function e(r){t.draggable=!1,document.removeEventListener("dragend",e),document.removeEventListener("mouseup",e)};document.addEventListener("dragend",r),document.addEventListener("mouseup",r)}})):t.draggable=!0,t.addEventListener("dragstart",(function(e){window.curDrag=t})),t.addEventListener("dragover",(function(e){null===window.curDrag||window.curDrag===t||window.curDrag.parentElement!==t.parentElement?e.dataTransfer.dropEffect="none":e.dataTransfer.dropEffect="move",e.preventDefault()})),t.addEventListener("drop",(function(r){if(r.preventDefault(),r.stopPropagation(),null!==window.curDrag&&window.curDrag!==t&&window.curDrag.parentElement===t.parentElement){var n=function(t){for(var e=0,r=t.parentElement.firstElementChild;r!==t&&null!==r;)r=r.nextSibling,++e;return e},i=n(window.curDrag),o=n(t);e(i,o,window.curDrag,t),window.curDrag=null}}))}function Y(t){return Y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Y(t)}function Q(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,K(n.key),n)}}function K(t){var e=function(t,e){if("object"!=Y(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Y(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Y(e)?e:e+""}function X(t,e,r){return e=rt(e),function(t,e){if(e&&("object"===Y(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,tt()?Reflect.construct(e,r||[],rt(t).constructor):e.apply(t,r))}function tt(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(tt=function(){return!!t})()}function et(){return et="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=rt(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},et.apply(this,arguments)}function rt(t){return rt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},rt(t)}function nt(t,e){return nt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},nt(t,e)}W.rules={".json-editor-btntype-toggle":"margin:0%2010px%200%200",".je-array-control-btn":"width:100%25;text-align:left;margin-bottom:3px"};var it=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),X(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&nt(t,e)}(e,t),r=e,(n=[{key:"onInputChange",value:function(){this.value=this.input.value,this.onChange(!0)}},{key:"register",value:function(){et(rt(e.prototype),"register",this).call(this),this.input&&this.jsoneditor.options.use_name_attributes&&this.input.setAttribute("name",this.formname)}},{key:"unregister",value:function(){et(rt(e.prototype),"unregister",this).call(this),this.input&&this.input.removeAttribute("name")}},{key:"getNumColumns",value:function(){var t=this,e=this.getTitle().length;return Object.keys(this.select_values).forEach((function(r){return e=Math.max(e,"".concat(t.select_values[r]).length+4)})),Math.min(12,Math.max(e/7,2))}},{key:"preBuild",value:function(){var t;et(rt(e.prototype),"preBuild",this).call(this),this.select_options={},this.select_values={},this.option_titles=[],this.option_keys=[],this.option_enum=[];var r=this.jsoneditor.expandRefs(this.schema.items||{}),n=r.enum||[],i=r.options&&r.options.enum||[],o=r.options&&r.options.enum_titles||[];for(t=0;t<n.length;t++)if(this.sanitize(n[t])===n[t]){var a=i[t]||{};"title"in a||(a.title="".concat(o[t]||n[t])),this.option_keys.push("".concat(n[t])),this.option_enum.push(a),this.select_values["".concat(n[t])]=n[t]}}},{key:"build",value:function(){var t,e=this;if(this.options.compact||(this.header=this.label=this.theme.getLabelLike(this.getTitle(),this.isRequired())),this.schema.description&&(this.description=this.theme.getFormInputDescription(this.translateProperty(this.schema.description))),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText))),this.options.compact&&this.container.classList.add("compact"),!this.schema.format&&this.option_keys.length<8||"checkbox"===this.schema.format){for(this.input_type="checkboxes",this.inputs={},this.controls={},t=0;t<this.option_keys.length;t++){var r=this.formname+t.toString();this.inputs[this.option_keys[t]]=this.theme.getCheckbox(),this.inputs[this.option_keys[t]].id=r,this.select_options[this.option_keys[t]]=this.inputs[this.option_keys[t]];var n=this.theme.getCheckboxLabel(this.option_enum[t].title);if(n.htmlFor=r,this.option_enum[t].infoText){var i=this.theme.getInfoButton(this.translateProperty(this.option_enum[t].infoText));n.appendChild(i)}this.controls["_"+this.option_keys[t]]=this.theme.getFormControl(n,this.inputs[this.option_keys[t]])}this.control=this.theme.getMultiCheckboxHolder(this.controls,this.label,this.description,this.infoButton),this.inputs.controlgroup=this.inputs.controls=this.control}else{for(this.options.compact||(this.header=this.label=this.theme.getFormInputLabel(this.getTitle(),this.isRequired())),this.input_type="select",this.input=this.theme.getSelectInput(this.option_keys,!0),this.theme.setSelectOptions(this.input,this.option_keys,this.option_enum.map((function(t){return t.title}))),this.input.setAttribute("multiple","multiple"),this.input.size=Math.min(10,this.option_keys.length),t=0;t<this.option_keys.length;t++)this.select_options[this.option_keys[t]]=this.input.children[t];this.control=this.theme.getFormControl(this.label,this.input,this.description,this.infoButton,this.formname)}(this.schema.readOnly||this.schema.readonly)&&this.disable(!0),this.container.appendChild(this.control),this.multiselectChangeHandler=function(r){var n=[];for(t=0;t<e.option_keys.length;t++)e.select_options[e.option_keys[t]]&&(e.select_options[e.option_keys[t]].selected||e.select_options[e.option_keys[t]].checked)&&n.push(e.select_values[e.option_keys[t]]);e.updateValue(n),e.onChange(!0)},this.control.addEventListener("change",this.multiselectChangeHandler,!1),window.requestAnimationFrame((function(){e.afterInputReady()}))}},{key:"postBuild",value:function(){et(rt(e.prototype),"postBuild",this).call(this)}},{key:"afterInputReady",value:function(){this.theme.afterInputReady(this.input||this.inputs)}},{key:"setValue",value:function(t,e){var r=this;t=(t=this.applyConstFilter(t))||[],Array.isArray(t)||(t=[t]),t=t.map((function(t){return"".concat(t)})),Object.keys(this.select_options).forEach((function(e){r.select_options[e]["select"===r.input_type?"selected":"checked"]=t.includes(e)})),this.updateValue(t),this.onChange(!0)}},{key:"removeValue",value:function(t){t=[].concat(t),this.setValue(this.getValue().filter((function(e){return!t.includes(e)})))}},{key:"addValue",value:function(t){this.setValue(this.getValue().concat(t))}},{key:"updateValue",value:function(t){for(var e=!1,r=[],n=0;n<t.length;n++)if(this.select_options["".concat(t[n])]){var i=this.sanitize(this.select_values[t[n]]);r.push(i),i!==t[n]&&(e=!0)}else e=!0;return this.value=r,e}},{key:"sanitize",value:function(t){return"boolean"===this.schema.items.type?!!t:"number"===this.schema.items.type?1*t||0:"integer"===this.schema.items.type?Math.floor(1*t||0):"".concat(t)}},{key:"enable",value:function(){var t=this;this.always_disabled||(this.input?this.input.disabled=!1:this.inputs&&Object.keys(this.inputs).forEach((function(e){return t.inputs[e].disabled=!1})),et(rt(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){var r=this;t&&(this.always_disabled=!0),this.input?this.input.disabled=!0:this.inputs&&Object.keys(this.inputs).forEach((function(t){return r.inputs[t].disabled=!0})),et(rt(e.prototype),"disable",this).call(this)}},{key:"destroy",value:function(){et(rt(e.prototype),"destroy",this).call(this)}},{key:"escapeRegExp",value:function(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}},{key:"showValidationErrors",value:function(t){var e=new RegExp("^".concat(this.escapeRegExp(this.path),"(\\.\\d+)?$")),r=t.reduce((function(t,r){return r.path.match(e)&&t.push(r.message),t}),[]);r.length?this.theme.addInputError(this.input||this.inputs,"".concat(r.join(". "),".")):this.theme.removeInputError(this.input||this.inputs)}}])&&Q(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function ot(t){return ot="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ot(t)}function at(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,st(n.key),n)}}function st(t){var e=function(t,e){if("object"!=ot(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=ot(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==ot(e)?e:e+""}function lt(t,e,r){return e=ht(e),function(t,e){if(e&&("object"===ot(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,ct()?Reflect.construct(e,r||[],ht(t).constructor):e.apply(t,r))}function ct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(ct=function(){return!!t})()}function ut(){return ut="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=ht(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},ut.apply(this,arguments)}function ht(t){return ht=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},ht(t)}function pt(t,e){return pt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},pt(t,e)}var dt=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),lt(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&pt(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r){this.choices_instance?(t=this.applyConstFilter(t),t=[].concat(t).map((function(t){return"".concat(t)})),this.updateValue(t),this.choices_instance.removeActiveItems(),this.choices_instance.setChoiceByValue(this.value),this.onChange(!0)):ut(ht(e.prototype),"setValue",this).call(this,t,r)}},{key:"afterInputReady",value:function(){var t=this;if(window.Choices&&!this.choices_instance){var r=this.expandCallbacks("choices",l({},{removeItems:!0,removeItemButton:!0},this.defaults.options.choices||{},this.options.choices||{},{addItems:!0,editItems:!1,duplicateItemsAllowed:!1}));this.newEnumAllowed=!1,this.choices_instance=new window.Choices(this.input,r),this.control.removeEventListener("change",this.multiselectChangeHandler),this.multiselectChangeHandler=function(e){var r=t.choices_instance.getValue(!0);t.updateValue(r),t.onChange(!0)},this.control.addEventListener("change",this.multiselectChangeHandler,!1)}ut(ht(e.prototype),"afterInputReady",this).call(this)}},{key:"updateValue",value:function(t){t=[].concat(t);for(var e=!1,r=[],n=0;n<t.length;n++){if(!this.select_values["".concat(t[n])]){if(e=!0,!this.newEnumAllowed)continue;if(!this.addNewOption(t[n]))continue}var i=this.sanitize(this.select_values[t[n]]);r.push(i),i!==t[n]&&(e=!0)}return this.value=r,e}},{key:"addNewOption",value:function(t){return this.option_keys.push("".concat(t)),this.option_titles.push("".concat(t)),this.select_values["".concat(t)]=t,this.schema.items.enum.push(t),this.choices_instance.setChoices([{value:"".concat(t),label:"".concat(t)}],"value","label",!1),!0}},{key:"enable",value:function(){!this.always_disabled&&this.choices_instance&&this.choices_instance.enable(),ut(ht(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.choices_instance&&this.choices_instance.disable(),ut(ht(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.choices_instance&&(this.choices_instance.destroy(),this.choices_instance=null),ut(ht(e.prototype),"destroy",this).call(this)}}])&&at(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(it);function ft(t){return ft="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ft(t)}function yt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,mt(n.key),n)}}function mt(t){var e=function(t,e){if("object"!=ft(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=ft(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==ft(e)?e:e+""}function vt(t,e,r){return e=wt(e),function(t,e){if(e&&("object"===ft(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,bt()?Reflect.construct(e,r||[],wt(t).constructor):e.apply(t,r))}function bt(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(bt=function(){return!!t})()}function gt(){return gt="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=wt(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},gt.apply(this,arguments)}function wt(t){return wt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},wt(t)}function _t(t,e){return _t=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_t(t,e)}var kt=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),vt(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_t(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r){t=this.applyConstFilter(t),this.select2_instance?(t=[].concat(t).map((function(t){return"".concat(t)})),this.updateValue(t),this.select2v4?this.select2_instance.val(this.value).change():this.select2_instance.select2("val",this.value),this.onChange(!0)):gt(wt(e.prototype),"setValue",this).call(this,t,r)}},{key:"afterInputReady",value:function(){var t,r=this;window.jQuery&&window.jQuery.fn&&window.jQuery.fn.select2&&!this.select2_instance&&(t=this.expandCallbacks("select2",l({},{tags:!0,width:"100%"},this.defaults.options.select2||{},this.options.select2||{})),this.newEnumAllowed=t.tags=!!t.tags&&this.schema.items&&"string"===this.schema.items.type,this.select2_instance=window.jQuery(this.input).select2(t),this.select2v4=h(this.select2_instance.select2,"amd"),this.selectChangeHandler=function(){var t=r.select2v4?r.select2_instance.val():r.select2_instance.select2("val");r.updateValue(t),r.onChange(!0)},this.select2_instance.on("select2-blur",this.selectChangeHandler),this.select2_instance.on("change",this.selectChangeHandler)),gt(wt(e.prototype),"afterInputReady",this).call(this)}},{key:"updateValue",value:function(t){t=[].concat(t);for(var e=!1,r=[],n=0;n<t.length;n++){if(!this.select_values["".concat(t[n])]){if(e=!0,!this.newEnumAllowed)continue;if(!this.addNewOption(t[n]))continue}var i=this.sanitize(this.select_values[t[n]]);r.push(i),i!==t[n]&&(e=!0)}return this.value=r,e}},{key:"addNewOption",value:function(t){this.option_keys.push("".concat(t)),this.option_titles.push("".concat(t)),this.select_values["".concat(t)]=t,this.schema.items.enum.push(t);var e=this.input.querySelector('option[value="'.concat(t,'"]'));return e?e.removeAttribute("data-select2-tag"):this.input.appendChild(new Option(t,t,!1,!1)).trigger("change"),!0}},{key:"enable",value:function(){!this.always_disabled&&this.select2_instance&&(this.select2v4?this.select2_instance.prop("disabled",!1):this.select2_instance.select2("enable",!0)),gt(wt(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.select2_instance&&(this.select2v4?this.select2_instance.prop("disabled",!0):this.select2_instance.select2("enable",!1)),gt(wt(e.prototype),"disable",this).call(this)}},{key:"destroy",value:function(){this.select2_instance&&(this.select2_instance.select2("destroy"),this.select2_instance=null),gt(wt(e.prototype),"destroy",this).call(this)}}])&&yt(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(it);function jt(t){return jt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},jt(t)}function Ot(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,xt(n.key),n)}}function xt(t){var e=function(t,e){if("object"!=jt(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=jt(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==jt(e)?e:e+""}function Ct(t,e,r){return e=Pt(e),function(t,e){if(e&&("object"===jt(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Et()?Reflect.construct(e,r||[],Pt(t).constructor):e.apply(t,r))}function Et(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Et=function(){return!!t})()}function St(){return St="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Pt(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},St.apply(this,arguments)}function Pt(t){return Pt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Pt(t)}function Lt(t,e){return Lt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Lt(t,e)}var Tt=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ct(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Lt(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r){t=this.applyConstFilter(t),this.selectize_instance?(t=[].concat(t).map((function(t){return"".concat(t)})),this.updateValue(t),this.selectize_instance.setValue(this.value),this.onChange(!0)):St(Pt(e.prototype),"setValue",this).call(this,t,r)}},{key:"afterInputReady",value:function(){var t,r=this;if(window.jQuery&&window.jQuery.fn&&window.jQuery.fn.selectize&&!this.selectize_instance){t=this.expandCallbacks("selectize",l({},{plugins:["remove_button"],delimiter:!1,createOnBlur:!0,create:!0},this.defaults.options.selectize||{},this.options.selectize||{})),this.newEnumAllowed=t.create=!!t.create&&this.schema.items&&"string"===this.schema.items.type,this.selectize_instance=window.jQuery(this.input).selectize(t)[0].selectize,this.control.removeEventListener("change",this.multiselectChangeHandler),this.multiselectChangeHandler=function(t){var e=r.selectize_instance.getValue();r.updateValue(e),r.onChange(!0)},this.selectize_instance.on("change",this.multiselectChangeHandler);var n=this.theme.getHiddenLabel(this.formname);this.input.setAttribute("id",this.formname+"-hidden-input"),n.setAttribute("for",this.formname+"-hidden-input"),this.input.parentNode.insertBefore(n,this.input);var i=this.selectize_instance.$control[0];if(i){var o=this.theme.getHiddenLabel(this.formname);o.setAttribute("for",this.formname+"-selectized"),i.appendChild(o)}}St(Pt(e.prototype),"afterInputReady",this).call(this)}},{key:"updateValue",value:function(t){t=[].concat(t);for(var e=!1,r=[],n=0;n<t.length;n++){if(!this.select_values["".concat(t[n])]){if(e=!0,!this.newEnumAllowed)continue;if(!this.addNewOption(t[n]))continue}var i=this.sanitize(this.select_values[t[n]]);r.push(i),i!==t[n]&&(e=!0)}return this.value=r,e}},{key:"addNewOption",value:function(t){return this.option_keys.push("".concat(t)),this.option_titles.push("".concat(t)),this.select_values["".concat(t)]=t,this.selectize_instance.addOption({text:t,value:t}),!0}},{key:"enable",value:function(){!this.always_disabled&&this.selectize_instance&&this.selectize_instance.unlock(),St(Pt(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.selectize_instance&&this.selectize_instance.lock(),St(Pt(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.selectize_instance&&(this.selectize_instance.destroy(),this.selectize_instance=null),St(Pt(e.prototype),"destroy",this).call(this)}}])&&Ot(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(it);function At(t){return At="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},At(t)}function Rt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,It(n.key),n)}}function It(t){var e=function(t,e){if("object"!=At(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=At(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==At(e)?e:e+""}function Bt(t,e,r){return e=Ft(e),function(t,e){if(e&&("object"===At(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Nt()?Reflect.construct(e,r||[],Ft(t).constructor):e.apply(t,r))}function Nt(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Nt=function(){return!!t})()}function Dt(){return Dt="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Ft(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Dt.apply(this,arguments)}function Ft(t){return Ft=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Ft(t)}function Vt(t,e){return Vt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Vt(t,e)}var Ht=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Bt(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Vt(t,e)}(e,t),r=e,(n=[{key:"postBuild",value:function(){window.Autocomplete&&(this.autocomplete_wrapper=document.createElement("div"),this.input.parentNode.insertBefore(this.autocomplete_wrapper,this.input.nextSibling),this.autocomplete_wrapper.appendChild(this.input),this.autocomplete_dropdown=document.createElement("ul"),this.input.parentNode.insertBefore(this.autocomplete_dropdown,this.input.nextSibling)),Dt(Ft(e.prototype),"postBuild",this).call(this)}},{key:"afterInputReady",value:function(){var t,r=this;window.Autocomplete&&!this.autocomplete_instance&&(t=this.expandCallbacks("autocomplete",l({},{search:function(t){return console.log('No "search" callback defined for autocomplete in property "'.concat(t.key,'"')),[]},onSubmit:function(){r.input.blur()},baseClass:"autocomplete"},this.defaults.options.autocomplete||{},this.options.autocomplete||{})),this.autocomplete_wrapper.classList.add(t.baseClass),this.autocomplete_dropdown.classList.add("".concat(t.baseClass,"-result-list")),this.autocomplete_instance=new window.Autocomplete(this.autocomplete_wrapper,t)),Dt(Ft(e.prototype),"afterInputReady",this).call(this)}},{key:"destroy",value:function(){this.autocomplete_instance&&(this.input&&this.input.parentNode&&this.input.parentNode.removeChild(this.input),this.autocomplete_dropdown&&this.autocomplete_dropdown.parentNode&&this.autocomplete_dropdown.parentNode.removeChild(this.autocomplete_dropdown),this.autocomplete_wrapper&&this.autocomplete_wrapper.parentNode&&this.autocomplete_wrapper.parentNode.removeChild(this.autocomplete_wrapper),this.autocomplete_instance=null),Dt(Ft(e.prototype),"destroy",this).call(this)}}])&&Rt(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function zt(t){return zt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},zt(t)}function Mt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,qt(n.key),n)}}function qt(t){var e=function(t,e){if("object"!=zt(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=zt(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==zt(e)?e:e+""}function Ut(t,e,r){return e=Jt(e),function(t,e){if(e&&("object"===zt(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Gt()?Reflect.construct(e,r||[],Jt(t).constructor):e.apply(t,r))}function Gt(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Gt=function(){return!!t})()}function $t(){return $t="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Jt(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},$t.apply(this,arguments)}function Jt(t){return Jt=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Jt(t)}function Wt(t,e){return Wt=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Wt(t,e)}var Zt=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ut(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Wt(t,e)}(e,t),r=e,(n=[{key:"getNumColumns",value:function(){return 4}},{key:"setFileReaderListener",value:function(t){var e=this;t.addEventListener("load",(function(t){if(e.count===e.current_item_index)e.value[e.count][e.key]=t.target.result;else{var r={};for(var n in e.parent.schema.properties)r[n]="";r[e.key]=t.target.result,e.value.splice(e.count,0,r)}e.count+=1,e.count===e.total+e.current_item_index&&e.arrayEditor.setValue(e.value)}))}},{key:"build",value:function(){var t=this;if(this.options.compact||(this.title=this.header=this.label=this.theme.getFormInputLabel(this.getTitle(),this.isRequired())),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText))),this.input=this.theme.getFormInputField("hidden"),this.container.appendChild(this.input),!this.schema.readOnly&&!this.schema.readonly){if(!window.FileReader)throw new Error("FileReader required for base64 editor");this.uploader=this.theme.getFormInputField("file"),this.uploader.style.display="none",this.schema.options&&this.schema.options.multiple&&!0===this.schema.options.multiple&&this.parent&&"object"===this.parent.schema.type&&this.parent.parent&&"array"===this.parent.parent.schema.type&&this.uploader.setAttribute("multiple",""),this.uploader.addEventListener("change",(function(e){if(e.preventDefault(),e.stopPropagation(),e.currentTarget.files&&e.currentTarget.files.length)if(e.currentTarget.files.length>1&&t.schema.options&&t.schema.options.multiple&&!0===t.schema.options.multiple&&t.parent&&"object"===t.parent.schema.type&&t.parent.parent&&"array"===t.parent.parent.schema.type){t.arrayEditor=t.jsoneditor.getEditor(t.parent.parent.path),t.value=t.arrayEditor.getValue(),t.total=e.currentTarget.files.length,t.current_item_index=parseInt(t.parent.key),t.count=t.current_item_index;for(var r=0;r<t.total;r++){var n=new FileReader;t.setFileReaderListener(n),n.readAsDataURL(e.currentTarget.files[r])}}else{var i=new FileReader;i.onload=function(e){t.value=e.target.result,t.refreshPreview(),t.onChange(!0),i=null},i.readAsDataURL(e.currentTarget.files[0])}}))}this.preview=this.theme.getFormInputDescription(this.translateProperty(this.schema.description)),this.container.appendChild(this.preview),this.control=this.theme.getFormControl(this.label,this.uploader||this.input,this.preview,this.infoButton),this.container.appendChild(this.control);var e=this.getButton("button_upload","upload","button_upload");e.addEventListener("click",(function(){t.uploader.click()})),this.control.appendChild(e),this.setInputAttributes(["multiple"],e)}},{key:"refreshPreview",value:function(){if(this.last_preview!==this.value&&(this.last_preview=this.value,this.preview.innerHTML="",this.value)){var t=this.value.match(/^data:([^;,]+)[;,]/);if(t&&(t=t[1]),t){if(this.preview.innerHTML="<strong>Type:</strong> ".concat(t,", <strong>Size:</strong> ").concat(Math.floor((this.value.length-this.value.split(",")[0].length-1)/1.33333)," bytes"),"image"===t.substr(0,5)){this.preview.innerHTML+="<br>";var e=document.createElement("img");e.style.maxWidth="100%",e.style.maxHeight="100px",e.src=this.value,this.preview.appendChild(e)}}else this.preview.innerHTML="<em>Invalid data URI</em>"}}},{key:"enable",value:function(){this.always_disabled||(this.uploader&&(this.uploader.disabled=!1),$t(Jt(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){t&&(this.always_disabled=!0),this.uploader&&(this.uploader.disabled=!0),$t(Jt(e.prototype),"disable",this).call(this)}},{key:"setValue",value:function(t){t=this.applyConstFilter(t),this.value!==t&&(this.schema.readOnly&&this.schema.enum&&!this.schema.enum.includes(t)?this.value=this.schema.enum[0]:this.value=t,this.input.value=this.value,this.refreshPreview(),this.onChange())}},{key:"destroy",value:function(){this.preview&&this.preview.parentNode&&this.preview.parentNode.removeChild(this.preview),this.title&&this.title.parentNode&&this.title.parentNode.removeChild(this.title),this.input&&this.input.parentNode&&this.input.parentNode.removeChild(this.input),this.uploader&&this.uploader.parentNode&&this.uploader.parentNode.removeChild(this.uploader),$t(Jt(e.prototype),"destroy",this).call(this)}}])&&Mt(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function Yt(t){return Yt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Yt(t)}function Qt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Kt(n.key),n)}}function Kt(t){var e=function(t,e){if("object"!=Yt(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Yt(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Yt(e)?e:e+""}function Xt(t,e,r){return e=re(e),function(t,e){if(e&&("object"===Yt(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,te()?Reflect.construct(e,r||[],re(t).constructor):e.apply(t,r))}function te(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(te=function(){return!!t})()}function ee(){return ee="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=re(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},ee.apply(this,arguments)}function re(t){return re=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},re(t)}function ne(t,e){return ne=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},ne(t,e)}var ie=function(t){function e(t,r){var n;return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),(n=Xt(this,e,[t,r])).active=!1,n.isUiOnly=!0,n.parent&&n.parent.schema&&(Array.isArray(n.parent.schema.required)?n.parent.schema.required.includes(n.key)||n.parent.schema.required.push(n.key):n.parent.schema.required=[n.key]),n}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ne(t,e)}(e,t),r=e,(n=[{key:"build",value:function(){var t=this;this.options.compact=!0;var e=this.expandCallbacks("button",l({},{icon:"",validated:!1,align:"left",action:function(t,e){window.alert('No button action defined for "'.concat(t.path,'"'))}},this.defaults.options.button||{},this.options.button||{})),r=this.translateProperty(e.text||this.schema.title)||this.key;this.input=this.getButton(r,e.icon,r),"function"!=typeof e.action?window.alert('No button action defined for "'.concat(this.path,'"')):this.input.addEventListener("click",e.action,!1),(this.schema.readOnly||this.schema.readonly||this.schema.template)&&(this.disable(!0),this.input.setAttribute("readonly","true")),this.setInputAttributes(["readonly"]),this.control=this.theme.getFormButtonHolder(e.align),this.control.appendChild(this.input),this.container.appendChild(this.control),this.changeHandler=function(){t.jsoneditor.validate(t.jsoneditor.getValue()).length>0?t.disable():t.enable()},e.validated&&this.jsoneditor.on("change",this.changeHandler)}},{key:"enable",value:function(){this.always_disabled||(this.input.disabled=!1,ee(re(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){t&&(this.always_disabled=!0),this.input.disabled=!0,ee(re(e.prototype),"disable",this).call(this)}},{key:"getNumColumns",value:function(){return 2}},{key:"activate",value:function(){this.active=!1,this.enable()}},{key:"deactivate",value:function(){this.isRequired()||(this.active=!1,this.disable())}},{key:"destroy",value:function(){this.jsoneditor.off("change",this.changeHandler),this.changeHandler=null,ee(re(e.prototype),"destroy",this).call(this)}}])&&Qt(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function oe(t){return oe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},oe(t)}function ae(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,se(n.key),n)}}function se(t){var e=function(t,e){if("object"!=oe(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=oe(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==oe(e)?e:e+""}function le(t,e,r){return e=he(e),function(t,e){if(e&&("object"===oe(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,ce()?Reflect.construct(e,r||[],he(t).constructor):e.apply(t,r))}function ce(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(ce=function(){return!!t})()}function ue(){return ue="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=he(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},ue.apply(this,arguments)}function he(t){return he=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},he(t)}function pe(t,e){return pe=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},pe(t,e)}var de=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),le(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&pe(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,e){t=!!(t=this.applyConstFilter(t));var r=this.getValue()!==t;this.value=t,this.input.checked=this.value,e||(this.is_dirty=!0),this.onChange(r)}},{key:"register",value:function(){ue(he(e.prototype),"register",this).call(this),this.input&&this.jsoneditor.options.use_name_attributes&&this.input.setAttribute("name",this.formname)}},{key:"unregister",value:function(){ue(he(e.prototype),"unregister",this).call(this),this.input&&this.input.removeAttribute("name")}},{key:"getNumColumns",value:function(){return Math.min(12,Math.max(this.getTitle().length/7,2))}},{key:"setOptInCheckbox",value:function(){ue(he(e.prototype),"setOptInCheckbox",this).call(this),this.optInAppended&&(this.container.insertBefore(this.optInContainer,this.container.firstChild),this.optInContainer.style.verticalAlign="top",this.control.style.marginTop="0")}},{key:"build",value:function(){var t=this;this.parent.options.table_row||(this.label=this.header=this.theme.getCheckboxLabel(this.getTitle(),this.isRequired()),this.label.htmlFor=this.formname),this.schema.description&&(this.description=this.theme.getFormInputDescription(this.translateProperty(this.schema.description))),this.options.infoText&&!this.options.compact&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText))),this.options.compact&&this.container.classList.add("compact"),this.input=this.theme.getCheckbox(),this.input.id=this.formname,this.control=this.theme.getFormControl(this.label,this.input,this.description,this.infoButton),this.control.style.display="inline-block",(this.schema.readOnly||this.schema.readonly)&&(this.disable(!0),this.input.disabled=!0),this.input.addEventListener("change",(function(e){e.preventDefault(),e.stopPropagation(),t.value=e.currentTarget.checked,t.is_dirty=!0,t.onChange(!0)})),this.container.appendChild(this.control)}},{key:"enable",value:function(){this.always_disabled||(this.input.disabled=!1,ue(he(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){t&&(this.always_disabled=!0),this.input.disabled=!0,ue(he(e.prototype),"disable",this).call(this)}},{key:"destroy",value:function(){this.label&&this.label.parentNode&&this.label.parentNode.removeChild(this.label),this.description&&this.description.parentNode&&this.description.parentNode.removeChild(this.description),this.input&&this.input.parentNode&&this.input.parentNode.removeChild(this.input),ue(he(e.prototype),"destroy",this).call(this)}},{key:"showValidationErrors",value:function(t){var e=this,r=this.jsoneditor.options.show_errors,n="change"===r||"interaction"===r;if(("never"!==r||this.is_dirty)&&(!n||this.is_dirty)){var i=t.reduce((function(t,r){return r.path===e.path&&t.push(r.message),t}),[]);this.input.controlgroup=this.control,i.length?this.theme.addInputError(this.input,"".concat(i.join(". "),".")):this.theme.removeInputError(this.input)}}}])&&ae(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function fe(t){return fe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},fe(t)}function ye(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,me(n.key),n)}}function me(t){var e=function(t,e){if("object"!=fe(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=fe(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==fe(e)?e:e+""}function ve(t,e,r){return e=we(e),function(t,e){if(e&&("object"===fe(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,be()?Reflect.construct(e,r||[],we(t).constructor):e.apply(t,r))}function be(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(be=function(){return!!t})()}function ge(){return ge="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=we(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},ge.apply(this,arguments)}function we(t){return we=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},we(t)}function _e(t,e){return _e=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_e(t,e)}r(6910);var ke=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),ve(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_e(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,e){t=this.applyConstFilter(t);var r=this.typecast(t),n=this.enum_options.length>0&&this.enum_values.includes(r),i=!!this.jsoneditor.options.use_default_values||void 0!==this.schema.default;if(this.hasPlaceholderOption||n&&(!e||this.isRequired()||i)||(r=this.enum_values[0]),this.value!==r){var o=this.enum_values.indexOf(r);n&&-1!==o?this.input.value=this.enum_options[o]:this.hasPlaceholderOption?this.input.value="_placeholder_":this.input.value=r,this.value=r,e||(this.is_dirty=!0),this.onChange(),this.change()}}},{key:"register",value:function(){ge(we(e.prototype),"register",this).call(this),this.input&&this.jsoneditor.options.use_name_attributes&&this.input.setAttribute("name",this.formname)}},{key:"unregister",value:function(){ge(we(e.prototype),"unregister",this).call(this),this.input&&this.input.removeAttribute("name")}},{key:"getNumColumns",value:function(){if(!this.enum_options)return 3;for(var t=this.getTitle().length,e=0;e<this.enum_options.length;e++)t=Math.max(t,this.enum_options[e].length+4);return Math.min(12,Math.max(t/7,2))}},{key:"typecast",value:function(t){return"boolean"===this.schema.type?"undefined"===t||void 0===t?void 0:!!t:"number"===this.schema.type?1*t||0:"integer"===this.schema.type?Math.floor(1*t||0):this.schema.enum&&void 0===t?void 0:"".concat(t)}},{key:"getValue",value:function(){if(this.dependenciesFulfilled)return this.typecast(this.value)}},{key:"preBuild",value:function(){var t,e,r,n,i=this;if(this.input_type="select",this.enum_options=[],this.enum_values=[],this.enum_display=[],this.hasPlaceholderOption=(null===(t=this.schema)||void 0===t||null===(t=t.options)||void 0===t?void 0:t.has_placeholder_option)||!1,this.placeholderOptionText=(null===(e=this.schema)||void 0===e||null===(e=e.options)||void 0===e?void 0:e.placeholder_option_text)||" ",this.enforceConst&&this.schema.const){var o=this.schema.const;this.enum_options=["".concat(o)],this.enum_display=["".concat(this.translateProperty(o)||o)],this.enum_values=[this.typecast(o)]}else if(this.schema.enum){var a=this.schema.options&&this.schema.options.enum_titles||[];this.schema.enum.forEach((function(t,e){i.enum_options[e]="".concat(t),i.enum_display[e]="".concat(i.translateProperty(a[e])||t),i.enum_values[e]=i.typecast(t)}))}else if("boolean"===this.schema.type)this.enum_display=this.schema.options&&this.schema.options.enum_titles||["true","false"],this.enum_options=["1",""],this.enum_values=[!0,!1],this.isRequired()||(this.enum_display.unshift(" "),this.enum_options.unshift("undefined"),this.enum_values.unshift(void 0));else{if(!this.schema.enumSource)throw new Error("'select' editor requires the enum property to be set.");if(this.enumSource=[],this.enum_display=[],this.enum_options=[],this.enum_values=[],Array.isArray(this.schema.enumSource))for(r=0;r<this.schema.enumSource.length;r++)"string"==typeof this.schema.enumSource[r]?this.enumSource[r]={source:this.schema.enumSource[r]}:Array.isArray(this.schema.enumSource[r])?this.enumSource[r]=this.schema.enumSource[r]:this.enumSource[r]=l({},this.schema.enumSource[r]);else this.schema.enumValue?this.enumSource=[{source:this.schema.enumSource,value:this.schema.enumValue}]:this.enumSource=[{source:this.schema.enumSource}];for(r=0;r<this.enumSource.length;r++)this.enumSource[r].value&&("function"==typeof(n=this.expandCallbacks("template",{template:this.enumSource[r].value})).template?this.enumSource[r].value=n.template:this.enumSource[r].value=this.jsoneditor.compileTemplate(this.enumSource[r].value,this.template_engine)),this.enumSource[r].title&&("function"==typeof(n=this.expandCallbacks("template",{template:this.enumSource[r].title})).template?this.enumSource[r].title=n.template:this.enumSource[r].title=this.jsoneditor.compileTemplate(this.enumSource[r].title,this.template_engine)),this.enumSource[r].filter&&this.enumSource[r].value&&("function"==typeof(n=this.expandCallbacks("template",{template:this.enumSource[r].filter})).template?this.enumSource[r].filter=n.template:this.enumSource[r].filter=this.jsoneditor.compileTemplate(this.enumSource[r].filter,this.template_engine))}}},{key:"build",value:function(){var t=this;this.options.compact||(this.header=this.label=this.theme.getFormInputLabel(this.getTitle(),this.isRequired())),this.schema.description&&(this.description=this.theme.getFormInputDescription(this.translateProperty(this.schema.description))),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText))),this.options.compact&&this.container.classList.add("compact"),this.input=this.theme.getSelectInput(this.enum_options,!1),this.theme.setSelectOptions(this.input,this.enum_options,this.enum_display,this.hasPlaceholderOption,this.placeholderOptionText),(this.schema.readOnly||this.schema.readonly)&&(this.disable(!0),this.input.disabled=!0),this.setInputAttributes([]),this.input.addEventListener("change",(function(e){e.preventDefault(),e.stopPropagation(),t.onInputChange()})),this.control=this.theme.getFormControl(this.label,this.input,this.description,this.infoButton,this.formname),this.container.appendChild(this.control),this.value=this.enum_values[0],window.requestAnimationFrame((function(){t.input.parentNode&&t.afterInputReady()}))}},{key:"afterInputReady",value:function(){this.theme.afterInputReady(this.input)}},{key:"onInputChange",value:function(){var t,e=this.typecast(this.input.value);(t=this.enum_values.includes(e)?this.enum_values[this.enum_values.indexOf(e)]:this.enum_values[0])!==this.value&&(this.is_dirty=!0,this.value=t,this.onChange(!0))}},{key:"onWatchedFieldChange",value:function(){var t,r,n=[],i=[];if(this.enumSource){t=this.getWatchedFieldValues();for(var o=0;o<this.enumSource.length;o++)if(Array.isArray(this.enumSource[o]))n=n.concat(this.enumSource[o]),i=i.concat(this.enumSource[o]);else{var a=[];if(a=Array.isArray(this.enumSource[o].source)?this.enumSource[o].source:t[this.enumSource[o].source]){if(this.enumSource[o].slice&&(a=Array.prototype.slice.apply(a,this.enumSource[o].slice)),this.enumSource[o].filter){var s=[];for(r=0;r<a.length;r++)this.enumSource[o].filter({i:r,item:a[r],watched:t})&&s.push(a[r]);a=s}var l=[],c=[];for(r=0;r<a.length;r++){var u=a[r];this.enumSource[o].value?c[r]=this.typecast(this.enumSource[o].value({i:r,item:u})):c[r]=a[r],this.enumSource[o].title?l[r]=this.enumSource[o].title({i:r,item:u}):l[r]=c[r]}this.enumSource[o].sort&&function(t,e,r){t.map((function(t,r){return{v:t,t:e[r]}})).sort((function(t,e){return t.v<e.v?-r:t.v===e.v?0:r})).forEach((function(r,n){t[n]=r.v,e[n]=r.t}))}.bind(null,c,l,"desc"===this.enumSource[o].sort?1:-1)(),n=n.concat(c),i=i.concat(l)}}var h=this.value;this.theme.setSelectOptions(this.input,n,i),this.enum_options=n,this.enum_display=i,this.enum_values=n,n.includes(h)||!1!==this.jsoneditor.options.enum_source_value_auto_select?(this.input.value=h,this.value=h):(this.input.value=n[0],this.value=this.typecast(n[0]||""),this.parent&&!this.watchLoop?this.parent.onChildEditorChange(this):this.jsoneditor.onChange(),this.jsoneditor.notifyWatchers(this.path))}ge(we(e.prototype),"onWatchedFieldChange",this).call(this)}},{key:"enable",value:function(){this.always_disabled||(this.input.disabled=!1,ge(we(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){t&&(this.always_disabled=!0),this.input.disabled=!0,ge(we(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.label&&this.label.parentNode&&this.label.parentNode.removeChild(this.label),this.description&&this.description.parentNode&&this.description.parentNode.removeChild(this.description),this.input&&this.input.parentNode&&this.input.parentNode.removeChild(this.input),ge(we(e.prototype),"destroy",this).call(this)}},{key:"showValidationErrors",value:function(t){var e=this,r=this.jsoneditor.options.show_errors,n="change"===r||"interaction"===r;if(("never"!==r||this.is_dirty)&&(!n||this.is_dirty)){var i=t.reduce((function(t,r){return r.path===e.path&&t.push(r.message),t}),[]);i.length?this.theme.addInputError(this.input,"".concat(i.join(". "),".")):this.theme.removeInputError(this.input)}}}])&&ye(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function je(t){return je="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},je(t)}function Oe(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,xe(n.key),n)}}function xe(t){var e=function(t,e){if("object"!=je(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=je(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==je(e)?e:e+""}function Ce(t,e,r){return e=Pe(e),function(t,e){if(e&&("object"===je(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ee()?Reflect.construct(e,r||[],Pe(t).constructor):e.apply(t,r))}function Ee(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ee=function(){return!!t})()}function Se(){return Se="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Pe(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Se.apply(this,arguments)}function Pe(t){return Pe=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Pe(t)}function Le(t,e){return Le=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Le(t,e)}var Te=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ce(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Le(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r){if(t=this.applyConstFilter(t),this.choices_instance){var n=this.typecast(t||"");if(this.enum_values.includes(n)||(n=this.enum_values[0]),this.value===n)return;r?this.is_dirty=!1:"change"===this.jsoneditor.options.show_errors&&(this.is_dirty=!0),this.input.value=this.enum_options[this.enum_values.indexOf(n)],this.choices_instance.setChoiceByValue(this.input.value),this.value=n,this.onChange()}else Se(Pe(e.prototype),"setValue",this).call(this,t,r)}},{key:"afterInputReady",value:function(){if(window.Choices&&!this.choices_instance){var t=this.expandCallbacks("choices",l({},this.defaults.options.choices||{},this.options.choices||{}));this.choices_instance=new window.Choices(this.input,t)}Se(Pe(e.prototype),"afterInputReady",this).call(this)}},{key:"onWatchedFieldChange",value:function(){var t=this;if(Se(Pe(e.prototype),"onWatchedFieldChange",this).call(this),this.choices_instance){var r=this.enum_options.map((function(e,r){return{value:e,label:t.enum_display[r]}}));this.choices_instance.setChoices(r,"value","label",!0),this.choices_instance.setChoiceByValue("".concat(this.value))}}},{key:"enable",value:function(){!this.always_disabled&&this.choices_instance&&this.choices_instance.enable(),Se(Pe(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.choices_instance&&this.choices_instance.disable(),Se(Pe(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.choices_instance&&(this.choices_instance.destroy(),this.choices_instance=null),Se(Pe(e.prototype),"destroy",this).call(this)}}])&&Oe(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(ke);function Ae(t){return Ae="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ae(t)}function Re(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Ie(n.key),n)}}function Ie(t){var e=function(t,e){if("object"!=Ae(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Ae(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Ae(e)?e:e+""}function Be(t,e,r){return e=Fe(e),function(t,e){if(e&&("object"===Ae(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ne()?Reflect.construct(e,r||[],Fe(t).constructor):e.apply(t,r))}function Ne(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ne=function(){return!!t})()}function De(){return De="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Fe(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},De.apply(this,arguments)}function Fe(t){return Fe=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Fe(t)}function Ve(t,e){return Ve=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Ve(t,e)}Te.rules={".choices > *":"box-sizing:border-box"};var He=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Be(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Ve(t,e)}(e,t),r=e,(n=[{key:"build",value:function(){if(De(Fe(e.prototype),"build",this).call(this),this.input&&(this.schema.max&&"string"==typeof this.schema.max&&this.input.setAttribute("max",this.schema.max),this.schema.min&&"string"==typeof this.schema.max&&this.input.setAttribute("min",this.schema.min),window.flatpickr&&"object"===Ae(this.options.flatpickr))){this.options.flatpickr.enableTime="date"!==this.schema.format,this.options.flatpickr.noCalendar="time"===this.schema.format,"integer"===this.schema.type&&(this.options.flatpickr.mode="single"),this.input.setAttribute("data-input","");var t=this.input;if(!0===this.options.flatpickr.wrap){var r=[];if(!1!==this.options.flatpickr.showToggleButton){var n=this.getButton("","time"===this.schema.format?"time":"calendar","flatpickr_toggle_button");n.setAttribute("data-toggle",""),r.push(n)}if(!1!==this.options.flatpickr.showClearButton){var i=this.getButton("","clear","flatpickr_clear_button");i.setAttribute("data-clear",""),r.push(i)}var o=this.input.parentNode,a=this.input.nextSibling,s=this.theme.getInputGroup(this.input,r);void 0!==s?(this.options.flatpickr.inline=!1,o.insertBefore(s,a),t=s):this.options.flatpickr.wrap=!1}this.flatpickr=window.flatpickr(t,this.options.flatpickr),!0===this.options.flatpickr.inline&&!0===this.options.flatpickr.inlineHideInput&&this.input.setAttribute("type","hidden")}}},{key:"getValue",value:function(){if(this.dependenciesFulfilled){if("string"===this.schema.type)return this.value;if(""!==this.value&&void 0!==this.value){var t="time"===this.schema.format?"1970-01-01 ".concat(this.value):this.value;return parseInt(new Date(t).getTime()/1e3)}}}},{key:"setValue",value:function(t,r,n){if(t=this.applyConstFilter(t),"string"===this.schema.type)De(Fe(e.prototype),"setValue",this).call(this,t,r,n),this.flatpickr&&this.flatpickr.setDate(t);else if(t>0){var i=new Date(1e3*t),o=i.getFullYear(),a=this.zeroPad(i.getMonth()+1),s=this.zeroPad(i.getDate()),l=this.zeroPad(i.getHours()),c=this.zeroPad(i.getMinutes()),u=this.zeroPad(i.getSeconds()),h=[o,a,s].join("-"),p=[l,c,u].join(":"),d="".concat(h,"T").concat(p);"date"===this.schema.format?d=h:"time"===this.schema.format&&(d=p),this.input.value=d,this.refreshValue(),this.flatpickr&&this.flatpickr.setDate(d)}}},{key:"destroy",value:function(){this.flatpickr&&this.flatpickr.destroy(),this.flatpickr=null,De(Fe(e.prototype),"destroy",this).call(this)}},{key:"zeroPad",value:function(t){return"0".concat(t).slice(-2)}}])&&Re(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function ze(t){return ze="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ze(t)}function Me(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,qe(n.key),n)}}function qe(t){var e=function(t,e){if("object"!=ze(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=ze(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==ze(e)?e:e+""}function Ue(t,e,r){return e=Je(e),function(t,e){if(e&&("object"===ze(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ge()?Reflect.construct(e,r||[],Je(t).constructor):e.apply(t,r))}function Ge(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ge=function(){return!!t})()}function $e(){return $e="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Je(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},$e.apply(this,arguments)}function Je(t){return Je=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Je(t)}function We(t,e){return We=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},We(t,e)}var Ze=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ue(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&We(t,e)}(e,t),r=e,(n=[{key:"register",value:function(){if(this.editors){for(var t=0;t<this.editors.length;t++)this.editors[t]&&this.editors[t].unregister();this.editors[this.currentEditor]&&this.editors[this.currentEditor].register()}$e(Je(e.prototype),"register",this).call(this)}},{key:"unregister",value:function(){if($e(Je(e.prototype),"unregister",this).call(this),this.editors)for(var t=0;t<this.editors.length;t++)this.editors[t]&&this.editors[t].unregister()}},{key:"getNumColumns",value:function(){return this.editors[this.currentEditor]?Math.max(this.editors[this.currentEditor].getNumColumns(),4):4}},{key:"enable",value:function(){if(this.editors)for(var t=0;t<this.editors.length;t++)this.editors[t]&&this.editors[t].enable();$e(Je(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(){if(this.editors)for(var t=0;t<this.editors.length;t++)this.editors[t]&&this.editors[t].disable();$e(Je(e.prototype),"disable",this).call(this)}},{key:"switchEditor",value:function(){var t=this,e=this.getWatchedFieldValues();if(e){var r=document.location.origin+document.location.pathname+this.template(e);this.editors[this.refs[r]]||this.buildChildEditor(r),this.currentEditor=this.refs[r],this.register(),this.editors.forEach((function(e,r){e&&(t.currentEditor===r?e.container.style.display="":e.container.style.display="none")})),this.refreshValue(),this.onChange(!0)}}},{key:"buildChildEditor",value:function(t){this.refs[t]=this.editors.length;var e=this.theme.getChildEditorHolder();this.editor_holder.appendChild(e);var r=l({},this.schema,this.jsoneditor.refs[t]),n=this.jsoneditor.getEditorClass(r,this.jsoneditor),i=this.jsoneditor.createEditor(n,{jsoneditor:this.jsoneditor,schema:r,container:e,path:this.path,parent:this,required:!0});this.editors.push(i),i.preBuild(),i.build(),i.postBuild()}},{key:"preBuild",value:function(){var t;for(this.refs={},this.editors=[],this.currentEditor="",t=0;t<this.schema.links.length;t++)if("describedby"===this.schema.links[t].rel.toLowerCase()){this.template=this.jsoneditor.compileTemplate(this.schema.links[t].href,this.template_engine);break}this.schema.links=this.schema.links.slice(0,t).concat(this.schema.links.slice(t+1)),0===this.schema.links.length&&delete this.schema.links,this.baseSchema=l({},this.schema)}},{key:"build",value:function(){this.editor_holder=document.createElement("div"),this.container.appendChild(this.editor_holder),this.switchEditor()}},{key:"onWatchedFieldChange",value:function(){this.switchEditor()}},{key:"onChildEditorChange",value:function(t,r){this.editors[this.currentEditor]&&this.refreshValue(),$e(Je(e.prototype),"onChildEditorChange",this).call(this,t,r)}},{key:"refreshValue",value:function(){this.editors[this.currentEditor]&&(this.value=this.editors[this.currentEditor].getValue())}},{key:"setValue",value:function(t,e){t=this.applyConstFilter(t),this.editors[this.currentEditor]&&(this.editors[this.currentEditor].setValue(t,e),this.refreshValue(),this.onChange())}},{key:"destroy",value:function(){this.editors.forEach((function(t){t&&t.destroy()})),this.editor_holder&&this.editor_holder.parentNode&&this.editor_holder.parentNode.removeChild(this.editor_holder),$e(Je(e.prototype),"destroy",this).call(this)}},{key:"showValidationErrors",value:function(t){this.editors.forEach((function(e){e&&e.showValidationErrors(t)}))}}])&&Me(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function Ye(t){return Ye="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ye(t)}function Qe(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Ke(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Xe(n.key),n)}}function Xe(t){var e=function(t,e){if("object"!=Ye(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Ye(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Ye(e)?e:e+""}function tr(t,e,r){return e=nr(e),function(t,e){if(e&&("object"===Ye(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,er()?Reflect.construct(e,r||[],nr(t).constructor):e.apply(t,r))}function er(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(er=function(){return!!t})()}function rr(){return rr="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=nr(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},rr.apply(this,arguments)}function nr(t){return nr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},nr(t)}function ir(t,e){return ir=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},ir(t,e)}var or=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),tr(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ir(t,e)}(e,t),r=e,(n=[{key:"getNumColumns",value:function(){return 4}},{key:"build",value:function(){var t=this;this.title=this.header=this.label=this.theme.getFormInputLabel(this.getTitle(),this.isRequired()),this.container.appendChild(this.title),this.options.enum_titles=this.options.enum_titles||[],this.enforceConstEnabled&&this.schema.const?this.enum=[this.schema.const]:this.enum=this.schema.enum,this.selected=0,this.select_options=[],this.html_values=[];for(var e=0;e<this.enum.length;e++)this.select_options[e]=this.options.enum_titles[e]||"Value ".concat(e+1),this.html_values[e]=this.getHTML(this.enum[e]);this.switcher=this.theme.getSwitcher(this.select_options),this.container.appendChild(this.switcher),this.display_area=this.theme.getIndentedPanel(),this.container.appendChild(this.display_area),this.options.hide_display&&(this.display_area.style.display="none"),this.switcher.addEventListener("change",(function(e){t.selected=t.select_options.indexOf(e.currentTarget.value),t.value=t.enum[t.selected],t.refreshValue(),t.onChange(!0)})),this.value=this.enum[0],this.refreshValue(),1===this.enum.length&&(this.switcher.style.display="none")}},{key:"refreshValue",value:function(){var t=this;if(this.enum){this.selected=-1;var e=JSON.stringify(this.value);this.enum.forEach((function(r,n){if(e===JSON.stringify(r))return t.selected=n,!1})),this.selected<0?this.setValue(this.enum[0]):(this.switcher.value=this.select_options[this.selected],this.display_area.innerHTML=this.html_values[this.selected])}}},{key:"enable",value:function(){this.always_disabled||(this.switcher.disabled=!1,rr(nr(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){t&&(this.always_disabled=!0),this.switcher.disabled=!0,rr(nr(e.prototype),"disable",this).call(this)}},{key:"getHTML",value:function(t){var e,r,n=this;if(null===t)return"<em>null</em>";if("object"===Ye(t)){var i="";return e=t,r=function(e,r){var o=n.getHTML(r);Array.isArray(t)||(o="<div><em>".concat(e,"</em>: ").concat(o,"</div>")),i+="<li>".concat(o,"</li>")},Array.isArray(e)||"number"==typeof e.length&&e.length>0&&e.length-1 in e?Array.from(e).forEach((function(t,e){return r(e,t)})):Object.entries(e).forEach((function(t){var e,n,i=(n=2,function(t){if(Array.isArray(t))return t}(e=t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,i,o,a,s=[],l=!0,c=!1;try{if(o=(r=r.call(t)).next,0===e){if(Object(r)!==r)return;l=!1}else for(;!(l=(n=o.call(r)).done)&&(s.push(n.value),s.length!==e);l=!0);}catch(t){c=!0,i=t}finally{try{if(!l&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw i}}return s}}(e,n)||function(t,e){if(t){if("string"==typeof t)return Qe(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Qe(t,e):void 0}}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),o=i[0],a=i[1];return r(o,a)})),i=Array.isArray(t)?"<ol>".concat(i,"</ol>"):"<ul style='margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;'>".concat(i,"</ul>")}return"boolean"==typeof t?t?"true":"false":"string"==typeof t?t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"):t}},{key:"setValue",value:function(t){t=this.applyConstFilter(t),this.value!==t&&(this.value=t,this.refreshValue(),this.onChange())}},{key:"destroy",value:function(){this.display_area&&this.display_area.parentNode&&this.display_area.parentNode.removeChild(this.display_area),this.title&&this.title.parentNode&&this.title.parentNode.removeChild(this.title),this.switcher&&this.switcher.parentNode&&this.switcher.parentNode.removeChild(this.switcher),rr(nr(e.prototype),"destroy",this).call(this)}}])&&Ke(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function ar(t){return ar="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ar(t)}function sr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,lr(n.key),n)}}function lr(t){var e=function(t,e){if("object"!=ar(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=ar(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==ar(e)?e:e+""}function cr(t,e,r){return e=pr(e),function(t,e){if(e&&("object"===ar(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,ur()?Reflect.construct(e,r||[],pr(t).constructor):e.apply(t,r))}function ur(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(ur=function(){return!!t})()}function hr(){return hr="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=pr(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},hr.apply(this,arguments)}function pr(t){return pr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},pr(t)}function dr(t,e){return dr=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},dr(t,e)}var fr=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),cr(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&dr(t,e)}(e,t),r=e,(n=[{key:"register",value:function(){hr(pr(e.prototype),"register",this).call(this),this.input&&this.jsoneditor.options.use_name_attributes&&this.input.setAttribute("name",this.formname)}},{key:"unregister",value:function(){hr(pr(e.prototype),"unregister",this).call(this),this.input&&this.input.removeAttribute("name")}},{key:"setValue",value:function(t,e,r){if(t=this.applyConstFilter(t),(!this.template||r)&&(null==t?t="":"object"===ar(t)?t=JSON.stringify(t):"string"!=typeof t&&(t="".concat(t)),t!==this.serialized)){var n=this.sanitize(t);if(this.input.value!==n){this.input.value=n;var i=r||this.getValue()!==t;this.refreshValue(),e?this.is_dirty=!1:"change"===this.jsoneditor.options.show_errors&&(this.is_dirty=!0),this.adjust_height&&this.adjust_height(this.input),this.onChange(i)}}}},{key:"getNumColumns",value:function(){return 2}},{key:"enable",value:function(){hr(pr(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(){hr(pr(e.prototype),"disable",this).call(this)}},{key:"refreshValue",value:function(){this.value=this.input.value,"string"!=typeof this.value&&(this.value=""),this.serialized=this.value}},{key:"destroy",value:function(){this.template=null,this.input&&this.input.parentNode&&this.input.parentNode.removeChild(this.input),this.label&&this.label.parentNode&&this.label.parentNode.removeChild(this.label),this.description&&this.description.parentNode&&this.description.parentNode.removeChild(this.description),hr(pr(e.prototype),"destroy",this).call(this)}},{key:"sanitize",value:function(t){return t}},{key:"onWatchedFieldChange",value:function(){var t;this.template&&(t=this.getWatchedFieldValues(),this.setValue(this.template(t),!1,!0)),hr(pr(e.prototype),"onWatchedFieldChange",this).call(this)}},{key:"build",value:function(){if(this.format=this.schema.format,!this.format&&this.options.default_format&&(this.format=this.options.default_format),this.options.format&&(this.format=this.options.format),this.input_type="hidden",this.input=this.theme.getFormInputField(this.input_type),this.format&&this.input.setAttribute("data-schemaformat",this.format),this.container.appendChild(this.input),this.schema.template){var t=this.expandCallbacks("template",{template:this.schema.template});"function"==typeof t.template?this.template=t.template:this.template=this.jsoneditor.compileTemplate(this.schema.template,this.template_engine),this.refreshValue()}else this.refreshValue()}}])&&sr(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function yr(t){return yr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},yr(t)}function mr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,vr(n.key),n)}}function vr(t){var e=function(t,e){if("object"!=yr(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=yr(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==yr(e)?e:e+""}function br(t,e,r){return e=wr(e),function(t,e){if(e&&("object"===yr(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,gr()?Reflect.construct(e,r||[],wr(t).constructor):e.apply(t,r))}function gr(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(gr=function(){return!!t})()}function wr(t){return wr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},wr(t)}function _r(t,e){return _r=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_r(t,e)}var kr=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),br(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_r(t,e)}(e,t),r=e,(n=[{key:"build",value:function(){this.options.compact=!1,this.header=this.label=this.theme.getLabelLike(this.getTitle()),this.description=this.theme.getDescription(this.schema.description||""),this.control=this.theme.getFormControl(this.label,this.description,null),this.container.appendChild(this.control)}},{key:"getTitle",value:function(){return this.translateProperty(this.schema.title)}},{key:"getNumColumns",value:function(){return 12}},{key:"disable",value:function(){return!1}},{key:"enable",value:function(){return!1}}])&&mr(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(ie);function jr(t){return jr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},jr(t)}function Or(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,xr(n.key),n)}}function xr(t){var e=function(t,e){if("object"!=jr(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=jr(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==jr(e)?e:e+""}function Cr(t,e,r){return e=Pr(e),function(t,e){if(e&&("object"===jr(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Er()?Reflect.construct(e,r||[],Pr(t).constructor):e.apply(t,r))}function Er(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Er=function(){return!!t})()}function Sr(){return Sr="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Pr(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Sr.apply(this,arguments)}function Pr(t){return Pr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Pr(t)}function Lr(t,e){return Lr=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Lr(t,e)}var Tr=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Cr(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Lr(t,e)}(e,t),r=e,(n=[{key:"build",value:function(){if(Sr(Pr(e.prototype),"build",this).call(this),void 0!==this.schema.minimum){var t=this.schema.minimum;void 0!==this.schema.exclusiveMinimum&&(t+=1),this.input.setAttribute("min",t)}if(void 0!==this.schema.maximum){var r=this.schema.maximum;void 0!==this.schema.exclusiveMaximum&&(r-=1),this.input.setAttribute("max",r)}if(void 0!==this.schema.step){var n=this.schema.step||1;this.input.setAttribute("step",n)}this.setInputAttributes(["maxlength","pattern","readonly","min","max","step"])}},{key:"getNumColumns",value:function(){return 2}},{key:"getValue",value:function(){if(this.dependenciesFulfilled)return this.schema.default||this.jsoneditor.options.use_default_values||""!==this.value?function(t){if(null==t)return!1;var e=t.match(p),r=parseFloat(t);return null!==e&&!isNaN(r)&&isFinite(r)}(this.value)?parseFloat(this.value):this.value:void(this.shouldBeUnset()&&(this.input.value=""))}}])&&Or(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function Ar(t){return Ar="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ar(t)}function Rr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Ir(n.key),n)}}function Ir(t){var e=function(t,e){if("object"!=Ar(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Ar(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Ar(e)?e:e+""}function Br(t,e,r){return e=Dr(e),function(t,e){if(e&&("object"===Ar(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Nr()?Reflect.construct(e,r||[],Dr(t).constructor):e.apply(t,r))}function Nr(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Nr=function(){return!!t})()}function Dr(t){return Dr=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Dr(t)}function Fr(t,e){return Fr=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Fr(t,e)}var Vr=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Br(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Fr(t,e)}(e,t),r=e,(n=[{key:"getNumColumns",value:function(){return 2}},{key:"getValue",value:function(){if(this.dependenciesFulfilled)return this.schema.default||this.jsoneditor.options.use_default_values||""!==this.value?function(t){if(null==t)return!1;var e=t.match(d),r=parseInt(t);return null!==e&&!isNaN(r)&&isFinite(r)}(this.value)?parseInt(this.value):this.value:void this.shouldBeUnset()}}])&&Rr(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(Tr);function Hr(t){return Hr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Hr(t)}function zr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Mr(n.key),n)}}function Mr(t){var e=function(t,e){if("object"!=Hr(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Hr(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Hr(e)?e:e+""}function qr(t,e,r){return e=$r(e),function(t,e){if(e&&("object"===Hr(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ur()?Reflect.construct(e,r||[],$r(t).constructor):e.apply(t,r))}function Ur(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ur=function(){return!!t})()}function Gr(){return Gr="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=$r(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Gr.apply(this,arguments)}function $r(t){return $r=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},$r(t)}function Jr(t,e){return Jr=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Jr(t,e)}var Wr=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),qr(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Jr(t,e)}(e,t),r=e,(n=[{key:"preBuild",value:function(){if(Gr($r(e.prototype),"preBuild",this).call(this),this.schema.options||(this.schema.options={}),!this.schema.options.cleave)switch(this.format){case"ipv6":this.schema.options.cleave={delimiters:[":"],blocks:[4,4,4,4,4,4,4,4],uppercase:!0};break;case"ipv4":this.schema.options.cleave={delimiters:["."],blocks:[3,3,3,3],numericOnly:!0}}this.options=l(this.options,this.schema.options||{})}}])&&zr(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function Zr(t){return Zr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Zr(t)}function Yr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Qr(n.key),n)}}function Qr(t){var e=function(t,e){if("object"!=Zr(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Zr(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Zr(e)?e:e+""}function Kr(t,e,r){return e=en(e),function(t,e){if(e&&("object"===Zr(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Xr()?Reflect.construct(e,r||[],en(t).constructor):e.apply(t,r))}function Xr(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Xr=function(){return!!t})()}function tn(){return tn="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=en(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},tn.apply(this,arguments)}function en(t){return en=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},en(t)}function rn(t,e){return rn=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},rn(t,e)}var nn=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Kr(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&rn(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r,n){t=this.applyConstFilter(t);var i=tn(en(e.prototype),"setValue",this).call(this,t,r,n);void 0!==i&&i.changed&&this.jodit_instance&&this.jodit_instance.setEditorValue(i.value)}},{key:"build",value:function(){this.options.format="textarea",tn(en(e.prototype),"build",this).call(this),this.input_type=this.schema.format,this.input.setAttribute("data-schemaformat",this.input_type)}},{key:"afterInputReady",value:function(){var t,r=this;window.Jodit?(t=this.expandCallbacks("jodit",l({},{height:300},this.defaults.options.jodit||{},this.options.jodit||{})),this.jodit_instance=new window.Jodit(this.input,t),(this.schema.readOnly||this.schema.readonly||this.schema.template)&&this.jodit_instance.setReadOnly(!0),this.jodit_instance.events.on("change",(function(){r.value=r.jodit_instance.getEditorValue(),r.is_dirty=!0,r.onChange(!0)})),this.theme.afterInputReady(this.input)):tn(en(e.prototype),"afterInputReady",this).call(this)}},{key:"getNumColumns",value:function(){return 6}},{key:"enable",value:function(){!this.always_disabled&&this.jodit_instance&&this.jodit_instance.setReadOnly(!1),tn(en(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.jodit_instance&&this.jodit_instance.setReadOnly(!0),tn(en(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.jodit_instance&&(this.jodit_instance.destruct(),this.jodit_instance=null),tn(en(e.prototype),"destroy",this).call(this)}}])&&Yr(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function on(t,e,r,n){try{switch(t.format){case"ipv4":!function(t){var e=t.split(".");if(4!==e.length)throw new Error("error_ipv4");e.forEach((function(t){if(isNaN(+t)||+t<0||+t>255)throw new Error("error_ipv4")}))}(e);break;case"ipv6":!function(t){if(!t.match("^(?:(?:(?:[a-fA-F0-9]{1,4}:){6}|(?=(?:[a-fA-F0-9]{0,4}:){2,6}(?:[0-9]{1,3}.){3}[0-9]{1,3}$)(([0-9a-fA-F]{1,4}:){1,5}|:)((:[0-9a-fA-F]{1,4}){1,5}:|:)|::(?:[a-fA-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]).){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])|(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}|(?=(?:[a-fA-F0-9]{0,4}:){0,7}[a-fA-F0-9]{0,4}$)(([0-9a-fA-F]{1,4}:){1,7}|:)((:[0-9a-fA-F]{1,4}){1,7}|:)|(?:[a-fA-F0-9]{1,4}:){7}:|:(:[a-fA-F0-9]{1,4}){7})$"))throw new Error("error_ipv6")}(e);break;case"hostname":!function(t){if(!t.match("(?=^.{4,253}$)(^((?!-)[a-zA-Z0-9-]{0,62}[a-zA-Z0-9].)+[a-zA-Z]{2,63}$)"))throw new Error("error_hostname")}(e)}return[]}catch(t){return[{path:r,property:"format",message:n(t.message)}]}}function an(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function sn(t,e,r){return(e=fn(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function ln(t){return ln="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ln(t)}function cn(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,i,o,a,s=[],l=!0,c=!1;try{if(o=(r=r.call(t)).next,0===e){if(Object(r)!==r)return;l=!1}else for(;!(l=(n=o.call(r)).done)&&(s.push(n.value),s.length!==e);l=!0);}catch(t){c=!0,i=t}finally{try{if(!l&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw i}}return s}}(t,e)||hn(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function un(t){return function(t){if(Array.isArray(t))return pn(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||hn(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function hn(t,e){if(t){if("string"==typeof t)return pn(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?pn(t,e):void 0}}function pn(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function dn(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,fn(n.key),n)}}function fn(t){var e=function(t,e){if("object"!=ln(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=ln(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==ln(e)?e:e+""}r(8431),r(7945),r(1278);var yn=function(){return t=function t(e,r,n,i){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.jsoneditor=e,this.schema=r||this.jsoneditor.schema,this.options=n||{},this.translate=this.jsoneditor.translate||i.translate,this.translateProperty=this.jsoneditor.translateProperty||i.translateProperty,this.defaults=i,this._validateSubSchema={dependentRequired:function(t,e,r){var n=[];if(void 0!==t.dependentRequired){var i=[];Object.keys(t.dependentRequired).forEach((function(r){if(void 0!==e[r]){var n=t.dependentRequired[r];i=n.filter((function(t){return!h(e,t)}))}})),i.length>0&&n.push({message:"Must have the required properties: "+i.join(", "),path:r})}return n},dependentSchemas:function(t,e,r){var n=this,i=[];return Object.keys(t.dependentSchemas).forEach((function(o){if(void 0!==e[o]){var a=t.dependentSchemas[o],s=n._validateSchema(a,e,r);i=[].concat(un(i),un(s))}})),i},contains:function(t,e,r){var n=this,i=[],o=0;e.forEach((function(e){0===n._validateSchema(t.contains,e,r).length&&o++}));var a=0===o;return void 0!==t.minContains?o<t.minContains&&i.push({message:this.translate("error_minContains",[o,t.minContains],t),path:r}):a&&i.push({message:this.translate("error_contains",null,t),path:r}),void 0!==t.maxContains&&o>t.maxContains&&i.push({message:this.translate("error_maxContains",[o,t.maxContains],t),path:r}),i},if:function(t,e,r){if(void 0===t.then&&void 0===t.else)return[];var n=this._validateSchema(t.if,e,r),i=[],o=[];return void 0!==t.then&&(i=this._validateSchema(t.then,e,r)),void 0!==t.else&&(o=this._validateSchema(t.else,e,r)),!0===t.if?i:!1===t.if?o:0===n.length?i:n.length>0?o:[]},const:function(t,e,r){return JSON.stringify(t.const)===JSON.stringify(e)?[]:[{path:r,property:"const",message:this.translate("error_const",null,t)}]},enum:function(t,e,r){var n=JSON.stringify(e);return t.enum.some((function(t){return n===JSON.stringify(t)}))?[]:[{path:r,property:"enum",message:this.translate("error_enum",null,t)}]},extends:function(t,e,r){var n=this;return t.extends.reduce((function(t,i){return t.push.apply(t,un(n._validateSchema(i,e,r))),t}),[])},allOf:function(t,e,r){var n=this;return t.allOf.reduce((function(t,i){return t.push.apply(t,un(n._validateSchema(i,e,r))),t}),[])},anyOf:function(t,e,r){var n=this;return t.anyOf.some((function(t){return!n._validateSchema(t,e,r).length}))?[]:[{path:r,property:"anyOf",message:this.translate("error_anyOf",null,t)}]},oneOf:function(t,e,r){var n=this,i=0,o=[];t.oneOf.forEach((function(t,a){var s=n._validateSchema(t,e,r);s.length||i++,s.forEach((function(t){t.path="".concat(r,".oneOf[").concat(a,"]").concat(t.path.substr(r.length))})),o.push.apply(o,un(s))}));var a=[];return 1!==i&&(a.push({path:r,property:"oneOf",message:this.translate("error_oneOf",[i],t)}),a.push.apply(a,o)),a},not:function(t,e,r){return this._validateSchema(t.not,e,r).length?[]:[{path:r,property:"not",message:this.translate("error_not",null,t)}]},type:function(t,e,r){var n=this;if(Array.isArray(t.type)){if(!t.type.some((function(t){return n._checkType(t,e)})))return[{path:r,property:"type",message:this.translate("error_type_union",null,t)}]}else if(["date","time","datetime-local"].includes(t.format)&&"integer"===t.type){if(!this._checkType("string","".concat(e)))return[{path:r,property:"type",message:this.translate("error_type",[t.format],t)}]}else if(!this._checkType(t.type,e))return[{path:r,property:"type",message:this.translate("error_type",[t.type],t)}];return[]},disallow:function(t,e,r){var n=this;if(Array.isArray(t.disallow)){if(t.disallow.some((function(t){return n._checkType(t,e)})))return[{path:r,property:"disallow",message:this.translate("error_disallow_union",null,t)}]}else if(this._checkType(t.disallow,e))return[{path:r,property:"disallow",message:this.translate("error_disallow",[t.disallow],t)}];return[]}},this._validateNumberSubSchema={multipleOf:function(t,e,r){return this._validateNumberSubSchemaMultipleDivisible(t,e,r)},divisibleBy:function(t,e,r){return this._validateNumberSubSchemaMultipleDivisible(t,e,r)},maximum:function(t,e,r){var n=t.exclusiveMaximum?e<t.maximum:e<=t.maximum;return window.math?n=window.math[t.exclusiveMaximum?"smaller":"smallerEq"](window.math.bignumber(e),window.math.bignumber(t.maximum)):window.Decimal&&(n=new window.Decimal(e)[t.exclusiveMaximum?"lt":"lte"](new window.Decimal(t.maximum))),n?[]:[{path:r,property:"maximum",message:this.translate(t.exclusiveMaximum?"error_maximum_excl":"error_maximum_incl",[t.maximum],t)}]},minimum:function(t,e,r){var n=t.exclusiveMinimum?e>t.minimum:e>=t.minimum;return window.math?n=window.math[t.exclusiveMinimum?"larger":"largerEq"](window.math.bignumber(e),window.math.bignumber(t.minimum)):window.Decimal&&(n=new window.Decimal(e)[t.exclusiveMinimum?"gt":"gte"](new window.Decimal(t.minimum))),n?[]:[{path:r,property:"minimum",message:this.translate(t.exclusiveMinimum?"error_minimum_excl":"error_minimum_incl",[t.minimum],t)}]}},this._validateStringSubSchema={maxLength:function(t,e,r){var n=[];return"".concat(e).length>t.maxLength&&n.push({path:r,property:"maxLength",message:this.translate("error_maxLength",[t.maxLength],t)}),n},minLength:function(t,e,r){return"".concat(e).length<t.minLength?[{path:r,property:"minLength",message:this.translate(1===t.minLength?"error_notempty":"error_minLength",[t.minLength],t)}]:[]},pattern:function(t,e,r){return new RegExp(t.pattern).test(e)?[]:[{path:r,property:"pattern",message:t.options&&t.options.patternmessage?t.options.patternmessage:this.translate("error_pattern",[t.pattern],t)}]}},this._validateArraySubSchema={items:function(t,e,r){var n=this,i=[];if(Array.isArray(t.items))for(var o=0;o<e.length;o++)if(t.items[o])i.push.apply(i,un(this._validateSchema(t.items[o],e[o],"".concat(r,".").concat(o))));else{if(!0===t.additionalItems)break;if(!t.additionalItems){if(!1===t.additionalItems){i.push({path:r,property:"additionalItems",message:this.translate("error_additionalItems",null,t)});break}break}i.push.apply(i,un(this._validateSchema(t.additionalItems,e[o],"".concat(r,".").concat(o))))}else e.forEach((function(e,o){i.push.apply(i,un(n._validateSchema(t.items,e,"".concat(r,".").concat(o))))}));return i},maxItems:function(t,e,r){return e.length>t.maxItems?[{path:r,property:"maxItems",message:this.translate("error_maxItems",[t.maxItems],t)}]:[]},minItems:function(t,e,r){return e.length<t.minItems?[{path:r,property:"minItems",message:this.translate("error_minItems",[t.minItems],t)}]:[]},uniqueItems:function(t,e,r){for(var n={},i=0;i<e.length;i++){var o=JSON.stringify(e[i]);if(n[o])return[{path:r,property:"uniqueItems",message:this.translate("error_uniqueItems",null,t)}];n[o]=!0}return[]}},this._validateObjectSubSchema={maxProperties:function(t,e,r){return Object.keys(e).length>t.maxProperties?[{path:r,property:"maxProperties",message:this.translate("error_maxProperties",[t.maxProperties],t)}]:[]},minProperties:function(t,e,r){return Object.keys(e).length<t.minProperties?[{path:r,property:"minProperties",message:this.translate("error_minProperties",[t.minProperties],t)}]:[]},required:function(t,e,r){var n=this,i=[];return Array.isArray(t.required)&&t.required.forEach((function(o){if(void 0===e[o]){var a=n.jsoneditor.getEditor("".concat(r,".").concat(o));a&&!1===a.dependenciesFulfilled||a&&["button","info"].includes(a.schema.format||a.schema.type)||i.push({path:r,property:"required",message:n.translate("error_required",[t&&t.properties&&t.properties[o]&&t.properties[o].title?t.properties[o].title:o],t)})}})),i},properties:function(t,e,r,n){var i=this,o=[];return Object.entries(t.properties).forEach((function(t){var a=cn(t,2),s=a[0],l=a[1];n[s]=!0,o.push.apply(o,un(i._validateSchema(l,e[s],"".concat(r,".").concat(s))))})),o},patternProperties:function(t,e,r,n){var i=this,o=[];return Object.entries(t.patternProperties).forEach((function(t){var a=cn(t,2),s=a[0],l=a[1],c=new RegExp(s);Object.entries(e).forEach((function(t){var e=cn(t,2),a=e[0],s=e[1];c.test(a)&&(n[a]=!0,o.push.apply(o,un(i._validateSchema(l,s,"".concat(r,".").concat(a)))))}))})),o}},this._validateObjectSubSchema2={propertyNames:function(t,e,r,n){for(var i,o=this,a=[],s=Object.keys(e),l=null,c=function(){var e="";return l=s[u],"boolean"==typeof t.propertyNames?!0===t.propertyNames?0:(a.push({path:r,property:"propertyNames",message:o.translate("error_property_names_false",[l],t)}),1):Object.entries(t.propertyNames).every((function(n){var i=cn(n,2),s=i[0],c=i[1],u=!1;switch(s){case"maxLength":if("number"!=typeof c){e="error_property_names_maxlength";break}if(l.length>c){e="error_property_names_exceeds_maxlength";break}return!0;case"const":if(c!==l){e="error_property_names_const_mismatch";break}return!0;case"enum":if(!Array.isArray(c)){e="error_property_names_enum";break}if(c.forEach((function(t){t===l&&(u=!0)})),!u){e="error_property_names_enum_mismatch";break}return!0;case"pattern":if("string"!=typeof c){e="error_property_names_pattern";break}if(!new RegExp(c).test(l)){e="error_property_names_pattern_mismatch";break}return!0;default:return a.push({path:r,property:"propertyNames",message:o.translate("error_property_names_unsupported",[s],t)}),!1}return a.push({path:r,property:"propertyNames",message:o.translate(e,[l],t)}),!1}))?void 0:1},u=0;u<s.length&&(0===(i=c())||1!==i);u++);return a},additionalProperties:function(t,e,r,n){for(var i=[],o=Object.keys(e),a=0;a<o.length;a++){var s=o[a];if(!n[s]){if(!t.additionalProperties){i.push({path:r,property:"additionalProperties",message:this.translate("error_additional_properties",[s],t)});break}if(!0===t.additionalProperties)break;i.push.apply(i,un(this._validateSchema(t.additionalProperties,e[s],"".concat(r,".").concat(s))))}}return i},dependencies:function(t,e,r){var n=this,i=[];return Object.entries(t.dependencies).forEach((function(o){var a=cn(o,2),s=a[0],l=a[1];void 0!==e[s]&&(Array.isArray(l)?l.forEach((function(o){void 0===e[o]&&i.push({path:r,property:"dependencies",message:n.translate("error_dependency",[o],t)})})):i.push.apply(i,un(n._validateSchema(l,e,r))))})),i}}},e=[{key:"fitTest",value:function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e7,n={match:0,extra:0};if("object"===ln(t)&&null!==t){var i=this._getSchema(e);if(i.anyOf){var o,a=function(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?an(Object(r),!0).forEach((function(e){sn(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):an(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}({},n),s=function(t,e){var r="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!r){if(Array.isArray(t)||(r=hn(t))){r&&(t=r);var n=0,i=function(){};return{s:i,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,s=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){s=!0,o=t},f:function(){try{a||null==r.return||r.return()}finally{if(s)throw o}}}}(i.anyOf);try{for(s.s();!(o=s.n()).done;){var l=o.value,c=this.fitTest(t,l,r);(c.match>a.match||c.match===a.match&&c.extra<a.extra)&&(a=c)}}catch(t){s.e(t)}finally{s.f()}return a}var u=this._getSchema(e).properties;for(var p in u)if(h(u,p)){if("object"===ln(t[p])&&"object"===ln(u[p])&&"object"===ln(u[p].properties)){var d=this.fitTest(t[p],u[p],r/100);n.match+=d.match,n.extra+=d.extra}void 0!==t[p]&&(n.match+=r)}else n.extra+=r}return n}},{key:"_getSchema",value:function(t){return void 0===t?l({},this.jsoneditor.expandRefs(this.schema)):t}},{key:"validate",value:function(t){return this._validateSchema(this.schema,t)}},{key:"_validateSchema",value:function(t,e,r){var n=this,i=[];return r=r||this.jsoneditor.root.formname,t=l({},this.jsoneditor.expandRefs(t)),void 0===e?this._validateV3Required(t,e,r):(Object.keys(t).forEach((function(o){n._validateSubSchema[o]&&i.push.apply(i,un(n._validateSubSchema[o].call(n,t,e,r)))})),i.push.apply(i,un(this._validateByValueType(t,e,r))),t.links&&t.links.forEach((function(o,a){o.rel&&"describedby"===o.rel.toLowerCase()&&(t=n._expandSchemaLink(t,a),i.push.apply(i,un(n._validateSchema(t,e,r,n.translate))))})),["date","time","datetime-local"].includes(t.format)&&i.push.apply(i,un(this._validateDateTimeSubSchema(t,e,r))),["uuid"].includes(t.format)&&i.push.apply(i,un(this._validateUUIDSchema(t,e,r))),i.push.apply(i,un(this._validateCustomValidator(t,e,r))),this._removeDuplicateErrors(i))}},{key:"_expandSchemaLink",value:function(t,e){var r=t.links[e].href,n=this.jsoneditor.root.getValue(),i=this.jsoneditor.compileTemplate(r,this.jsoneditor.template),o=document.location.origin+document.location.pathname+i(n);return t.links=t.links.slice(0,e).concat(t.links.slice(e+1)),l({},t,this.jsoneditor.refs[o])}},{key:"_validateV3Required",value:function(t,e,r){return(void 0!==t.required&&!0===t.required||void 0===t.required&&!0===this.jsoneditor.options.required_by_default)&&"info"!==t.type?[{path:r,property:"required",message:this.translate("error_notset",null,t)}]:[]}},{key:"_validateByValueType",value:function(t,e,r){var n=this,i=[];if(null===e)return i;if("number"==typeof e)Object.keys(t).forEach((function(o){n._validateNumberSubSchema[o]&&i.push.apply(i,un(n._validateNumberSubSchema[o].call(n,t,e,r)))}));else if("string"==typeof e)Object.keys(t).forEach((function(o){n._validateStringSubSchema[o]&&i.push.apply(i,un(n._validateStringSubSchema[o].call(n,t,e,r)))}));else if(Array.isArray(e))Object.keys(t).forEach((function(o){n._validateArraySubSchema[o]&&i.push.apply(i,un(n._validateArraySubSchema[o].call(n,t,e,r)))}));else if("object"===ln(e)){var o={};Object.keys(t).forEach((function(a){n._validateObjectSubSchema[a]&&i.push.apply(i,un(n._validateObjectSubSchema[a].call(n,t,e,r,o)))})),void 0!==t.additionalProperties||!this.jsoneditor.options.no_additional_properties||t.oneOf||t.anyOf||t.allOf||(t.additionalProperties=!1),Object.keys(t).forEach((function(a){void 0!==n._validateObjectSubSchema2[a]&&i.push.apply(i,un(n._validateObjectSubSchema2[a].call(n,t,e,r,o)))}))}return i}},{key:"_validateUUIDSchema",value:function(t,e,r){return/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e)?[]:[{path:r,property:"format",message:this.translate("error_pattern",["^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$"],t)}]}},{key:"_validateNumberSubSchemaMultipleDivisible",value:function(t,e,r){var n=t.multipleOf||t.divisibleBy,i=e/n===Math.floor(e/n);return window.math?i=window.math.mod(window.math.bignumber(e),window.math.bignumber(n)).equals(0):window.Decimal&&(i=new window.Decimal(e).mod(new window.Decimal(n)).equals(0)),i?[]:[{path:r,property:t.multipleOf?"multipleOf":"divisibleBy",message:this.translate("error_multipleOf",[n],t)}]}},{key:"_validateDateTimeSubSchema",value:function(t,e,r){var n=this,i=this.jsoneditor.getEditor(r),o=i&&i.flatpickr?i.flatpickr.config.dateFormat:{date:'"YYYY-MM-DD"',time:'"HH:MM"',"datetime-local":'"YYYY-MM-DD HH:MM"'}[t.format];if("integer"===t.type)return function(t,e,r){return 1*e<1?[{path:r,property:"format",message:n.translate("error_invalid_epoch",null,t)}]:e!==Math.abs(parseInt(e))?[{path:r,property:"format",message:n.translate("error_".concat(t.format.replace(/-/g,"_")),[o],t)}]:[]}(t,e,r);if(i&&i.flatpickr){if(i)return function(t,e,r,i){if(""!==e){var o;if("single"!==i.flatpickr.config.mode){var a="range"===i.flatpickr.config.mode?i.flatpickr.l10n.rangeSeparator:", ";o=i.flatpickr.selectedDates.map((function(t){return i.flatpickr.formatDate(t,i.flatpickr.config.dateFormat)})).join(a)}try{if(o){if(o!==e)throw new Error("".concat(i.flatpickr.config.mode," mismatch"))}else if(i.flatpickr.formatDate(i.flatpickr.parseDate(e,i.flatpickr.config.dateFormat),i.flatpickr.config.dateFormat)!==e)throw new Error("mismatch")}catch(e){var s=void 0!==i.flatpickr.config.errorDateFormat?i.flatpickr.config.errorDateFormat:i.flatpickr.config.dateFormat;return[{path:r,property:"format",message:n.translate("error_".concat(i.format.replace(/-/g,"_")),[s],t)}]}}return[]}(t,e,r,i)}else if(!{date:/^(\d{4}\D\d{2}\D\d{2})$/,time:/^(\d{2}:\d{2}(?::\d{2})?)$/,"datetime-local":/^(\d{4}\D\d{2}\D\d{2}[ T]\d{2}:\d{2}(?::\d{2})?)$/}[t.format].test(e))return[{path:r,property:"format",message:this.translate("error_".concat(t.format.replace(/-/g,"_")),[o],t)}];return[]}},{key:"_validateCustomValidator",value:function(t,e,r){var n=this,i=[];i.push.apply(i,un(on.call(this,t,e,r,this.translate)));var o=function(o){i.push.apply(i,un(o.call(n,t,e,r)))};return this.defaults.custom_validators.forEach(o),this.options.custom_validators&&this.options.custom_validators.forEach(o),i}},{key:"_removeDuplicateErrors",value:function(t){return t.reduce((function(t,e){var r=!0;return t||(t=[]),t.forEach((function(t){t.message===e.message&&t.path===e.path&&t.property===e.property&&(t.errorcount++,r=!1)})),r&&(e.errorcount=1,t.push(e)),t}),[])}},{key:"_checkType",value:function(t,e){var r={string:function(t){return"string"==typeof t},number:function(t){return"number"==typeof t},integer:function(t){return"number"==typeof t&&t===Math.floor(t)},boolean:function(t){return"boolean"==typeof t},array:function(t){return Array.isArray(t)},object:function(t){return null!==t&&!Array.isArray(t)&&"object"===ln(t)},null:function(t){return null===t}};return"string"==typeof t?!r[t]||r[t](e):!this._validateSchema(t,e).length}}],e&&dn(t.prototype,e),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,e}();function mn(t){return mn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},mn(t)}function vn(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,bn(n.key),n)}}function bn(t){var e=function(t,e){if("object"!=mn(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=mn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==mn(e)?e:e+""}function gn(t,e,r){return e=kn(e),function(t,e){if(e&&("object"===mn(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,wn()?Reflect.construct(e,r||[],kn(t).constructor):e.apply(t,r))}function wn(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(wn=function(){return!!t})()}function _n(){return _n="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=kn(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},_n.apply(this,arguments)}function kn(t){return kn=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},kn(t)}function jn(t,e){return jn=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},jn(t,e)}var On=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),gn(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&jn(t,e)}(e,t),r=e,(n=[{key:"register",value:function(){if(this.editors){for(var t=0;t<this.editors.length;t++)this.editors[t]&&this.editors[t].unregister();this.editors[this.type]&&this.editors[this.type].register()}_n(kn(e.prototype),"register",this).call(this)}},{key:"unregister",value:function(){if(_n(kn(e.prototype),"unregister",this).call(this),this.editors)for(var t=0;t<this.editors.length;t++)this.editors[t]&&this.editors[t].unregister()}},{key:"getNumColumns",value:function(){return this.editors[this.type]?Math.max(this.editors[this.type].getNumColumns(),4):4}},{key:"enable",value:function(){if(!this.always_disabled){if(this.editors)for(var t=0;t<this.editors.length;t++)this.editors[t]&&this.editors[t].enable();this.switcher.disabled=!1,_n(kn(e.prototype),"enable",this).call(this)}}},{key:"disable",value:function(t){if(t&&(this.always_disabled=!0),this.editors)for(var r=0;r<this.editors.length;r++)this.editors[r]&&this.editors[r].disable(t);this.switcher.disabled=!0,_n(kn(e.prototype),"disable",this).call(this)}},{key:"switchEditor",value:function(t){var e=this;this.lastType=this.type,this.editors[t]||this.buildChildEditor(t);var r=this.getValue();this.type=t,this.register(),this.editors.forEach((function(t,n){var i,o;t&&(e.type===n?(e.keep_only_existing_values&&(i=t.getValue(),o=r,Object.keys(o).forEach((function(t){t in i&&(i[t]=o[t])})),r=i),(e.keep_values||e.if)&&t.setValue(r,!0),t.container.style.display=""):t.container.style.display="none")})),this.onChange(!0,!1,{event:"switch",data:{type:this.lastType,path:this.editors[t].path}}),this.refreshValue(),this.refreshHeaderText()}},{key:"buildChildEditor",value:function(t){var e,r,n=this,i=this.types[t],o=this.theme.getChildEditorHolder();this.editor_holder.appendChild(o),"string"==typeof i?(r=l({},this.schema)).type=i:(r=l({},this.schema,i),r=this.jsoneditor.expandRefs(r),i&&i.required&&Array.isArray(i.required)&&this.schema.required&&Array.isArray(this.schema.required)&&(r.required=this.schema.required.concat(i.required))),null!==(e=r)&&void 0!==e&&null!==(e=e.options)&&void 0!==e&&e.dependencies&&delete r.options.dependencies;var a=this.jsoneditor.getEditorClass(r);this.editors[t]=this.jsoneditor.createEditor(a,{jsoneditor:this.jsoneditor,schema:r,container:o,path:this.path,parent:this,required:!0}),this.editors[t].preBuild(),this.editors[t].build(),this.editors[t].postBuild(),this.editors[t].header&&this.theme.visuallyHidden(this.editors[t].header),this.editors[t].option=this.switcher_options[t],o.addEventListener("change_header_text",(function(){n.refreshHeaderText()})),t!==this.type&&(o.style.display="none")}},{key:"preBuild",value:function(){if(this.types=[],this.type=0,this.editors=[],this.validators=[],this.keep_values=!0,void 0!==this.jsoneditor.options.keep_oneof_values&&(this.keep_values=this.jsoneditor.options.keep_oneof_values),void 0!==this.options.keep_oneof_values&&(this.keep_values=this.options.keep_oneof_values),this.keep_only_existing_values=!1,void 0!==this.jsoneditor.options.keep_only_existing_values&&(this.keep_only_existing_values=this.jsoneditor.options.keep_only_existing_values),void 0!==this.options.keep_only_existing_values&&(this.keep_only_existing_values=this.options.keep_only_existing_values),this.schema.oneOf)this.oneOf=!0,this.types=this.schema.oneOf,delete this.schema.oneOf;else if(this.schema.anyOf)this.anyOf=!0,this.types=this.schema.anyOf,delete this.schema.anyOf;else if(this.schema.if)this.if=!0,this.ifSchema=JSON.parse(JSON.stringify(this.schema.if)),this.thenSchema={title:"then"},this.elseSchema={title:"else"},this.types=[],this.schema.then&&m(this.thenSchema,this.schema,this.schema.then),this.schema.else&&m(this.elseSchema,this.schema,this.schema.else),this.types.push(this.thenSchema),this.types.push(this.elseSchema),this.types.forEach((function(t){delete t.if,delete t.then,delete t.else})),delete this.schema.if;else{if(this.schema.type&&"any"!==this.schema.type)Array.isArray(this.schema.type)?this.types=this.schema.type:this.types=[this.schema.type];else if(this.types=["string","number","integer","boolean","object","array","null"],this.schema.disallow){var t=this.schema.disallow;"object"===mn(t)&&Array.isArray(t)||(t=[t]);var e=[];this.types.forEach((function(r){t.includes(r)||e.push(r)})),this.types=e}delete this.schema.type}this.display_text=this.getDisplayText(this.types)}},{key:"build",value:function(){var t=this,e=this.container;this.header=this.label=this.theme.getLabelLike(this.getTitle(),this.isRequired()),this.switcher=this.theme.getSwitcher(this.display_text),this.switcher.setAttribute("id",this.formname+"switcher"),this.switcherLabel=this.theme.getHiddenLabel(this.formname+" switcher"),this.switcherLabel.setAttribute("for",this.formname+"switcher"),this.if||(this.container.appendChild(this.header),e.appendChild(this.switcherLabel),e.appendChild(this.switcher)),this.switcher.addEventListener("change",(function(e){e.preventDefault(),e.stopPropagation(),t.switchEditor(t.display_text.indexOf(e.currentTarget.value)),t.onChange(!0)})),this.editor_holder=document.createElement("div"),e.appendChild(this.editor_holder);var r={};this.jsoneditor.options.custom_validators&&(r.custom_validators=this.jsoneditor.options.custom_validators),this.switcher_options=this.theme.getSwitcherOptions(this.switcher),this.types.forEach((function(e,n){var i;t.editors[n]=!1,"string"==typeof e?(i=l({},t.schema)).type=e:(i=l({},t.schema,e),e.required&&Array.isArray(e.required)&&t.schema.required&&Array.isArray(t.schema.required)&&(i.required=t.schema.required.concat(e.required))),t.validators[n]=new yn(t.jsoneditor,i,r,t.defaults)})),this.jsoneditor.on("change",(function(){t.switchIf()})),this.switchEditor(0)}},{key:"onChildEditorChange",value:function(t,r){this.editors[this.type]&&(this.refreshValue(),this.refreshHeaderText()),_n(kn(e.prototype),"onChildEditorChange",this).call(this,t,r)}},{key:"refreshHeaderText",value:function(){var t=this.getDisplayText(this.types);Array.from(this.switcher_options).forEach((function(e,r){e.textContent=t[r]}))}},{key:"refreshValue",value:function(){this.editors[this.type]&&(this.value=this.editors[this.type].getValue())}},{key:"switchIf",value:function(){if(this.ifSchema&&this.value){var t=this.getIfType(this.value);this.lastType!==t&&(this.switchEditor(t),this.editors[this.type].setValue(this.value,!0)),this.switcher.value=this.display_text[this.type]}}},{key:"getIfType",value:function(t){return 0===this.jsoneditor.validator._validateSchema(this.ifSchema,t).length?0:1}},{key:"setValue",value:function(t,e){var r=this;t=this.applyConstFilter(t);var n=this.type,i={match:0,extra:0,i:this.type},o={match:0,i:null};this.validators.forEach((function(e,n){var a=null;void 0!==r.anyOf&&r.anyOf&&(a=e.fitTest(t),(i.match<a.match||i.match===a.match&&i.extra>a.extra)&&((i=a).i=n)),e.validate(t).length||null!==o.i?i=o:(o.i=n,null!==a&&(o.match=a.match))}));var a=o.i;void 0!==this.anyOf&&this.anyOf&&o.match<i.match&&(a=i.i),this.if&&(a=this.getIfType(t)),null===a&&(a=this.type),this.type=a,this.switcher.value=this.display_text[a];var s=this.type!==n;s&&(this.switchEditor(this.type),this.editors[this.type].setValue(t,e)),void 0!==t&&this.editors[this.type].setValue(t,e),this.refreshValue(),this.onChange(s)}},{key:"destroy",value:function(){this.editors.forEach((function(t){t&&t.destroy()})),this.editor_holder&&this.editor_holder.parentNode&&this.editor_holder.parentNode.removeChild(this.editor_holder),this.switcher&&this.switcher.parentNode&&this.switcher.parentNode.removeChild(this.switcher),_n(kn(e.prototype),"destroy",this).call(this)}},{key:"showValidationErrors",value:function(t){var e=this;if(this.oneOf||this.anyOf){var r=this.oneOf?"oneOf":"anyOf";this.editors.forEach((function(n,i){if(n){var o="".concat(e.path,".").concat(r,"[").concat(i,"]");n.showValidationErrors(t.reduce((function(t,r){if(r.path.startsWith(o)||r.path===o.substr(0,r.path.length)){var n=l({},r);r.path.startsWith(o)&&(n.path=e.path+n.path.substr(o.length)),t.push(n)}return t}),[]))}}))}else this.editors.forEach((function(e){e&&e.showValidationErrors(t)}))}},{key:"addLinks",value:function(){}}])&&vn(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function xn(t){return xn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},xn(t)}function Cn(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,En(n.key),n)}}function En(t){var e=function(t,e){if("object"!=xn(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=xn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==xn(e)?e:e+""}function Sn(t,e,r){return e=Ln(e),function(t,e){if(e&&("object"===xn(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Pn()?Reflect.construct(e,r||[],Ln(t).constructor):e.apply(t,r))}function Pn(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Pn=function(){return!!t})()}function Ln(t){return Ln=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Ln(t)}function Tn(t,e){return Tn=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Tn(t,e)}var An=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Sn(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Tn(t,e)}(e,t),r=e,(n=[{key:"getValue",value:function(){if(this.dependenciesFulfilled)return null}},{key:"setValue",value:function(){this.onChange()}},{key:"getNumColumns",value:function(){return 2}}])&&Cn(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function Rn(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function In(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?Rn(Object(r),!0).forEach((function(e){Bn(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):Rn(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function Bn(t,e,r){return(e=Hn(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function Nn(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,i,o,a,s=[],l=!0,c=!1;try{if(o=(r=r.call(t)).next,0===e){if(Object(r)!==r)return;l=!1}else for(;!(l=(n=o.call(r)).done)&&(s.push(n.value),s.length!==e);l=!0);}catch(t){c=!0,i=t}finally{try{if(!l&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw i}}return s}}(t,e)||function(t,e){if(t){if("string"==typeof t)return Dn(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Dn(t,e):void 0}}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Dn(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Fn(t){return Fn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Fn(t)}function Vn(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Hn(n.key),n)}}function Hn(t){var e=function(t,e){if("object"!=Fn(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Fn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Fn(e)?e:e+""}function zn(t,e,r){return e=Un(e),function(t,e){if(e&&("object"===Fn(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Mn()?Reflect.construct(e,r||[],Un(t).constructor):e.apply(t,r))}function Mn(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Mn=function(){return!!t})()}function qn(){return qn="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Un(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},qn.apply(this,arguments)}function Un(t){return Un=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Un(t)}function Gn(t,e){return Gn=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Gn(t,e)}var $n=function(t){function e(t,r,n){var i;return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),(i=zn(this,e,[t,r])).currentDepth=n,i}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Gn(t,e)}(e,t),r=e,(n=[{key:"getChildEditors",value:function(){return this.editors}},{key:"register",value:function(){qn(Un(e.prototype),"register",this).call(this),this.editors&&Object.values(this.editors).forEach((function(t){return t.register()}))}},{key:"unregister",value:function(){qn(Un(e.prototype),"unregister",this).call(this),this.editors&&Object.values(this.editors).forEach((function(t){return t.unregister()}))}},{key:"getNumColumns",value:function(){return Math.max(Math.min(12,this.maxwidth),3)}},{key:"enable",value:function(){this.always_disabled||(this.editjson_control&&(this.editjson_control.disabled=!1),this.addproperty_button&&(this.addproperty_button.disabled=!1),qn(Un(e.prototype),"enable",this).call(this),this.editors&&Object.values(this.editors).forEach((function(t){(t.isActive()||t.isUiOnly)&&t.enable(),t.optInCheckbox&&(t.optInCheckbox.disabled=!1)})))}},{key:"disable",value:function(t){t&&(this.always_disabled=!0),this.editjson_control&&(this.editjson_control.disabled=!0),this.addproperty_button&&(this.addproperty_button.disabled=!0),this.hideEditJSON(),qn(Un(e.prototype),"disable",this).call(this),this.editors&&Object.values(this.editors).forEach((function(e){(e.isActive()||e.isUiOnly)&&e.disable(t),e.optInCheckbox.disabled=!0}))}},{key:"layoutEditors",value:function(){var t,e,r=this;if(this.row_container){var n;this.property_order=Object.keys(this.editors),this.property_order=this.property_order.sort((function(t,e){var n=r.editors[t].schema.propertyOrder,i=r.editors[e].schema.propertyOrder;return"number"!=typeof n&&(n=1e3),"number"!=typeof i&&(i=1e3),n-i}));var i,o="categories"===this.format,a=[],s=null,l=null;if("grid-strict"===this.format){var u=0;if(i=[],this.property_order.forEach((function(t){var e=r.editors[t];if(!e.property_removed){var n=e.options.hidden?0:e.options.grid_columns||e.getNumColumns(),o=e.options.hidden?0:e.options.grid_offset||0,s=!e.options.hidden&&(e.options.grid_break||!1),l={key:t,width:n,offset:o,height:e.options.hidden?0:e.container.offsetHeight};i.push(l),a[u]=i,s&&(u++,i=[])}})),this.layout===JSON.stringify(a))return!1;for(this.layout=JSON.stringify(a),n=document.createElement("div"),t=0;t<a.length;t++)for(i=this.theme.getGridRow(),n.appendChild(i),e=0;e<a[t].length;e++)s=a[t][e].key,(l=this.editors[s]).options.hidden?l.container.style.display="none":this.theme.setGridColumnSize(l.container,a[t][e].width,a[t][e].offset),i.appendChild(l.container)}else if("grid"===this.format){for(this.property_order.forEach((function(t){var e=r.editors[t];if(!e.property_removed){for(var n=!1,i=e.options.hidden?0:e.options.grid_columns||e.getNumColumns(),o=e.options.hidden?0:e.container.offsetHeight,s=0;s<a.length;s++)a[s].width+i<=12&&(!o||.5*a[s].minh<o&&2*a[s].maxh>o)&&(n=s);!1===n&&(a.push({width:0,minh:999999,maxh:0,editors:[]}),n=a.length-1),a[n].editors.push({key:t,width:i,height:o}),a[n].width+=i,a[n].minh=Math.min(a[n].minh,o),a[n].maxh=Math.max(a[n].maxh,o)}})),t=0;t<a.length;t++)if(a[t].width<12){var h=!1,p=0;for(e=0;e<a[t].editors.length;e++)(!1===h||a[t].editors[e].width>a[t].editors[h].width)&&(h=e),a[t].editors[e].width*=12/a[t].width,a[t].editors[e].width=Math.floor(a[t].editors[e].width),p+=a[t].editors[e].width;p<12&&(a[t].editors[h].width+=12-p),a[t].width=12}if(this.layout===JSON.stringify(a))return!1;for(this.layout=JSON.stringify(a),n=document.createElement("div"),t=0;t<a.length;t++)for(i=this.theme.getGridRow(),n.appendChild(i),e=0;e<a[t].editors.length;e++)s=a[t].editors[e].key,(l=this.editors[s]).options.hidden?l.container.style.display="none":this.theme.setGridColumnSize(l.container,a[t].editors[e].width),i.appendChild(l.container)}else{if(n=document.createElement("div"),o){var d=document.createElement("div"),f=this.theme.getTopTabHolder(this.translateProperty(this.schema.title)),y=this.theme.getTopTabContentHolder(f);for(this.property_order.forEach((function(t){var e=r.editors[t];if(!e.property_removed){var n=r.theme.getTabContent(),i=e.schema&&("object"===e.schema.type||"array"===e.schema.type);n.isObjOrArray=i;var o=r.theme.getGridRow();e.tab||(void 0===r.basicPane?r.addRow(e,f,n):r.addRow(e,f,r.basicPane)),n.id=r.getValidId(e.tab_text.textContent),i?(n.appendChild(o),y.appendChild(n),r.theme.addTopTab(f,e.tab)):(d.appendChild(o),y.childElementCount>0?y.firstChild.isObjOrArray&&(n.appendChild(d),y.insertBefore(n,y.firstChild),r.theme.insertBasicTopTab(e.tab,f),e.basicPane=n):(n.appendChild(d),y.appendChild(n),r.theme.addTopTab(f,e.tab),e.basicPane=n)),e.options.hidden?e.container.style.display="none":r.theme.setGridColumnSize(e.container,12),o.appendChild(e.container),e.rowPane=n}}));this.tabPanesContainer.firstChild;)this.tabPanesContainer.removeChild(this.tabPanesContainer.firstChild);var m=this.tabs_holder.parentNode;m.removeChild(m.firstChild),m.appendChild(f),this.tabPanesContainer=y,this.tabs_holder=f;var v=this.theme.getFirstTab(this.tabs_holder);return void(v&&c(v,"click"))}this.property_order.forEach((function(t){var e=r.editors[t];e.property_removed||(i=r.theme.getGridRow(),n.appendChild(i),e.options.hidden?e.container.style.display="none":r.theme.setGridColumnSize(e.container,12),i.appendChild(e.container))}))}for(;this.row_container.firstChild;)this.row_container.removeChild(this.row_container.firstChild);this.row_container.appendChild(n)}}},{key:"getPropertySchema",value:function(t){var e=this,r=this.schema.properties[t]||{};r=l({},r);var n=!!this.schema.properties[t];return this.schema.patternProperties&&Object.keys(this.schema.patternProperties).forEach((function(i){new RegExp(i).test(t)&&(r.allOf=r.allOf||[],r.allOf.push(e.schema.patternProperties[i]),n=!0)})),!n&&this.schema.additionalProperties&&"object"===Fn(this.schema.additionalProperties)&&(r=l({},this.schema.additionalProperties)),r}},{key:"preBuild",value:function(){var t=this;if(qn(Un(e.prototype),"preBuild",this).call(this),this.editors={},this.cached_editors={},this.format=this.options.layout||this.options.object_layout||this.schema.format||this.jsoneditor.options.object_layout||"normal",this.schema.properties=this.schema.properties||{},this.minwidth=0,this.maxwidth=0,this.options.table_row)Object.entries(this.schema.properties).forEach((function(e){var r=Nn(e,2),n=r[0],i=r[1],o=t.jsoneditor.getEditorClass(i);t.editors[n]=t.jsoneditor.createEditor(o,{jsoneditor:t.jsoneditor,schema:i,path:"".concat(t.path,".").concat(n),parent:t,compact:!0,required:!0},t.currentDepth+1),t.editors[n].preBuild();var a=t.editors[n].options.hidden?0:t.editors[n].options.grid_columns||t.editors[n].getNumColumns();t.minwidth+=a,t.maxwidth+=a})),this.no_link_holder=!0;else{if(this.options.table)throw new Error("Not supported yet");this.schema.defaultProperties||(this.jsoneditor.options.display_required_only||this.options.display_required_only?this.schema.defaultProperties=Object.keys(this.schema.properties).filter((function(e){return t.isRequiredObject({key:e,schema:t.schema.properties[e]})})):this.schema.defaultProperties=Object.keys(this.schema.properties)),this.maxwidth+=1,Array.isArray(this.schema.defaultProperties)&&this.schema.defaultProperties.forEach((function(e){t.addObjectProperty(e,!0),t.editors[e]&&(t.minwidth=Math.max(t.minwidth,t.editors[e].options.grid_columns||t.editors[e].getNumColumns()),t.maxwidth+=t.editors[e].options.grid_columns||t.editors[e].getNumColumns())}))}this.property_order=Object.keys(this.editors),this.property_order=this.property_order.sort((function(e,r){var n=t.editors[e].schema.propertyOrder,i=t.editors[r].schema.propertyOrder;return"number"!=typeof n&&(n=1e3),"number"!=typeof i&&(i=1e3),n-i}))}},{key:"addTab",value:function(t){var e=this,r=this.rows[t].schema&&("object"===this.rows[t].schema.type||"array"===this.rows[t].schema.type);this.tabs_holder&&(this.rows[t].tab_text=document.createElement("span"),this.rows[t].tab_text.textContent=r?this.rows[t].getHeaderText():void 0===this.schema.basicCategoryTitle?"Basic":this.schema.basicCategoryTitle,this.rows[t].tab=this.theme.getTopTab(this.rows[t].tab_text,this.getValidId(this.rows[t].tab_text.textContent)),this.rows[t].tab.addEventListener("click",(function(r){e.active_tab=e.rows[t].tab,e.refreshTabs(),r.preventDefault(),r.stopPropagation()})))}},{key:"addRow",value:function(t,e,r){var n=this.rows.length,i="object"===t.schema.type||"array"===t.schema.type;this.rows[n]=t,this.rows[n].rowPane=r,i?(this.addTab(n),this.theme.addTopTab(e,this.rows[n].tab)):void 0===this.basicTab?(this.addTab(n),this.basicTab=n,this.basicPane=r,this.theme.addTopTab(e,this.rows[n].tab)):(this.rows[n].tab=this.rows[this.basicTab].tab,this.rows[n].tab_text=this.rows[this.basicTab].tab_text,this.rows[n].rowPane=this.rows[this.basicTab].rowPane)}},{key:"refreshTabs",value:function(t){var e=this,r=void 0!==this.basicTab,n=!1;this.rows.forEach((function(i){i.tab&&i.rowPane&&i.rowPane.parentNode&&(r&&i.tab===e.rows[e.basicTab].tab&&n||(t?i.tab_text.textContent=i.getHeaderText():(r&&i.tab===e.rows[e.basicTab].tab&&(n=!0),i.tab===e.active_tab?e.theme.markTabActive(i):e.theme.markTabInactive(i))))}))}},{key:"build",value:function(){var t=this,e="categories"===this.format;if(this.rows=[],this.active_tab=null,this.options.table_row)this.editor_holder=this.container,Object.entries(this.editors).forEach((function(e){var r=Nn(e,2),n=r[0],i=r[1],o=t.theme.getTableCell();t.editor_holder.appendChild(o),i.setContainer(o),i.build(),i.postBuild(),i.setOptInCheckbox(i.header),i.setValue(i.getDefault(),!0),t.editors[n].options.hidden&&(o.style.display="none"),t.editors[n].options.input_width&&(o.style.width=t.editors[n].options.input_width)}));else{if(this.options.table)throw new Error("Not supported yet");this.header="",this.options.compact||(this.header=document.createElement("span"),this.header.textContent=this.getTitle()),this.title=this.theme.getHeader(this.header,this.getPathDepth()),this.title.classList.add("je-object__title"),this.controls=this.theme.getButtonHolder(),this.controls.classList.add("je-object__controls"),this.container.appendChild(this.title),this.container.appendChild(this.controls),this.container.classList.add("je-object__container"),this.editjson_holder=this.theme.getModal(),this.editjson_textarea_label=this.theme.getHiddenLabel(this.translate("button_edit_json")),this.editjson_textarea_label.setAttribute("for",this.path+"-edit-json-textarea"),this.editjson_textarea=this.theme.getTextareaInput(),this.editjson_textarea.setAttribute("id",this.path+"-edit-json-textarea"),this.editjson_textarea.setAttribute("aria-labelledby",this.path+"-edit-json-textarea"),this.editjson_textarea.classList.add("je-edit-json--textarea"),this.editjson_save=this.getButton("button_save","save","button_save"),this.editjson_save.classList.add("json-editor-btntype-save"),this.editjson_save.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.saveJSON()})),this.editjson_copy=this.getButton("button_copy","copy","button_copy"),this.editjson_copy.classList.add("json-editor-btntype-copy"),this.editjson_copy.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.copyJSON()})),this.editjson_cancel=this.getButton("button_cancel","cancel","button_cancel"),this.editjson_cancel.classList.add("json-editor-btntype-cancel"),this.editjson_cancel.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.hideEditJSON()})),this.editjson_holder.appendChild(this.editjson_textarea_label),this.editjson_holder.appendChild(this.editjson_textarea),this.editjson_holder.appendChild(this.editjson_save),this.editjson_holder.appendChild(this.editjson_copy),this.editjson_holder.appendChild(this.editjson_cancel),this.addproperty_holder=this.theme.getModal(),this.addproperty_list=document.createElement("div"),this.addproperty_list.classList.add("property-selector"),this.addproperty_add=this.getButton("button_add","add","button_add"),this.addproperty_add.classList.add("json-editor-btntype-add"),this.addproperty_input=this.theme.getFormInputField("text"),this.addproperty_input.setAttribute("placeholder","Property name..."),this.addproperty_input_label=this.theme.getHiddenLabel(this.translate("button_properties")),this.addproperty_input_label.setAttribute("for",this.path+"-property-selector"),this.addproperty_input.classList.add("property-selector-input"),this.addproperty_input.setAttribute("id",this.path+"-property-selector"),this.addproperty_input.setAttribute("aria-labelledby",this.path+"-property-selector"),this.addproperty_add.addEventListener("click",(function(e){if(e.preventDefault(),e.stopPropagation(),t.addproperty_input.value){if(t.editors[t.addproperty_input.value])return void window.alert("there is already a property with that name");t.addObjectProperty(t.addproperty_input.value),t.editors[t.addproperty_input.value]&&t.editors[t.addproperty_input.value].disable();var r=t.editors[t.addproperty_input.value].key,n=t.editors[t.addproperty_input.value].type,i=t.editors[t.addproperty_input.value].path;t.onChange(!0,!1,{event:"add",data:{key:r,type:n,path:i}})}})),this.addproperty_input.addEventListener("input",(function(e){e.target.previousSibling.previousSibling.childNodes.forEach((function(r){var n=r.innerText,i=e.target.value;t.options.case_sensitive_property_search||t.jsoneditor.options.case_sensitive_property_search||(n=n.toLowerCase(),i=i.toLowerCase()),n.includes(i)?r.style.display="":r.style.display="none"}))})),this.addproperty_holder.appendChild(this.addproperty_list),this.addproperty_holder.appendChild(this.addproperty_input_label),this.addproperty_holder.appendChild(this.addproperty_input),this.addproperty_holder.appendChild(this.addproperty_add);var r=document.createElement("div");r.style.clear="both",this.addproperty_holder.appendChild(r),this.onOutsideModalClickListener=this.onOutsideModalClick.bind(this),document.addEventListener("click",this.onOutsideModalClickListener,!0),this.schema.description&&(this.description=this.theme.getDescription(this.translateProperty(this.schema.description)),this.container.appendChild(this.description)),this.error_holder=document.createElement("div"),this.container.appendChild(this.error_holder),this.editor_holder=this.theme.getIndentedPanel(),this.container.appendChild(this.editor_holder),this.row_container=this.theme.getGridContainer(),e?(this.tabs_holder=this.theme.getTopTabHolder(this.getValidId(this.translateProperty(this.schema.title))),this.tabPanesContainer=this.theme.getTopTabContentHolder(this.tabs_holder),this.editor_holder.appendChild(this.tabs_holder)):(this.tabs_holder=this.theme.getTabHolder(this.getValidId(this.translateProperty(this.schema.title))),this.tabPanesContainer=this.theme.getTabContentHolder(this.tabs_holder),this.editor_holder.appendChild(this.row_container)),Object.values(this.editors).forEach((function(r){var n=t.theme.getTabContent(),i=t.theme.getGridColumn(),o=!(!r.schema||"object"!==r.schema.type&&"array"!==r.schema.type);if(n.isObjOrArray=o,e){if(o){var a=t.theme.getGridContainer();a.appendChild(i),n.appendChild(a),t.tabPanesContainer.appendChild(n),t.row_container=a}else void 0===t.row_container_basic&&(t.row_container_basic=t.theme.getGridContainer(),n.appendChild(t.row_container_basic),0===t.tabPanesContainer.childElementCount?t.tabPanesContainer.appendChild(n):t.tabPanesContainer.insertBefore(n,t.tabPanesContainer.childNodes[1])),t.row_container_basic.appendChild(i);t.addRow(r,t.tabs_holder,n),n.id=t.getValidId(r.schema.title)}else t.row_container.appendChild(i);r.setContainer(i),r.build(),r.postBuild(),r.setOptInCheckbox(r.header)})),this.rows[0]&&c(this.rows[0].tab,"click"),this.collapsed=!1,this.collapse_control=this.getButton("","collapse","button_collapse"),this.collapse_control.classList.add("json-editor-btntype-toggle"),this.title.insertBefore(this.collapse_control,this.title.childNodes[0]),this.collapse_control.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.collapsed?(t.editor_holder.style.display="",t.collapsed=!1,t.setButtonText(t.collapse_control,"","collapse","button_collapse")):(t.editor_holder.style.display="none",t.collapsed=!0,t.setButtonText(t.collapse_control,"","expand","button_expand"))})),this.options.collapsed&&c(this.collapse_control,"click"),this.schema.options&&void 0!==this.schema.options.disable_collapse?this.schema.options.disable_collapse&&(this.collapse_control.style.display="none"):this.jsoneditor.options.disable_collapse&&(this.collapse_control.style.display="none"),this.editjson_control=this.getButton("JSON","edit","button_edit_json"),this.editjson_control.classList.add("json-editor-btntype-editjson"),this.editjson_control.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.toggleEditJSON()})),this.controls.appendChild(this.editjson_control),this.controls.insertBefore(this.editjson_holder,this.controls.childNodes[0]),this.schema.options&&void 0!==this.schema.options.disable_edit_json?this.schema.options.disable_edit_json&&(this.editjson_control.style.display="none"):this.jsoneditor.options.disable_edit_json&&(this.editjson_control.style.display="none"),this.addproperty_button=this.getButton("properties","edit_properties","button_object_properties"),this.addproperty_button.classList.add("json-editor-btntype-properties"),this.addproperty_button.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.toggleAddProperty()})),this.controls.appendChild(this.addproperty_button),this.controls.insertBefore(this.addproperty_holder,this.controls.childNodes[1]),this.refreshAddProperties(),this.deactivateNonRequiredProperties(!1)}this.options.table_row?(this.editor_holder=this.container,this.property_order.forEach((function(e){t.editor_holder.appendChild(t.editors[e].container)}))):(this.layoutEditors(),this.layoutEditors()),(this.schema.readOnly||this.schema.readonly)&&this.disable()}},{key:"deactivateNonRequiredProperties",value:function(t){var e=this,r=this.jsoneditor.options.show_opt_in,n=void 0!==this.options.show_opt_in,i=n&&!0===this.options.show_opt_in,o=n&&!1===this.options.show_opt_in;(i||!o&&r||!n&&r)&&Object.entries(this.editors).forEach((function(r){var n=Nn(r,2),i=n[0],o=n[1];e.isRequiredObject(o)||e.editors[i].deactivate(),t&&"function"==typeof e.editors[i].deactivateNonRequiredProperties&&e.editors[i].deactivateNonRequiredProperties(t)}))}},{key:"showEditJSON",value:function(){this.editjson_holder&&(this.hideAddProperty(),this.editjson_holder.style.left="".concat(this.editjson_control.offsetLeft,"px"),this.editjson_holder.style.top="".concat(this.editjson_control.offsetTop+this.editjson_control.offsetHeight,"px"),this.editjson_textarea.value=JSON.stringify(this.getValue(),null,2),this.disable(),this.editjson_holder.style.display="",this.editjson_control.disabled=!1,this.editing_json=!0)}},{key:"hideEditJSON",value:function(){this.editjson_holder&&this.editing_json&&(this.editjson_holder.style.display="none",this.enable(),this.editing_json=!1)}},{key:"copyJSON",value:function(){this.editjson_holder&&navigator.clipboard.writeText(this.editjson_textarea.value).catch((function(t){return window.alert(t)}))}},{key:"saveJSON",value:function(){if(this.editjson_holder)try{var t=JSON.parse(this.editjson_textarea.value);this.setValue(t),this.hideEditJSON(),this.onChange(!0)}catch(t){throw window.alert("invalid JSON"),t}}},{key:"toggleEditJSON",value:function(){this.editing_json?this.hideEditJSON():this.showEditJSON()}},{key:"insertPropertyControlUsingPropertyOrder",value:function(t,e,r){var n;this.schema.properties[t]&&(n=this.schema.properties[t].propertyOrder),"number"!=typeof n&&(n=1e3),e.propertyOrder=n;for(var i=0;i<r.childNodes.length;i++){var o=r.childNodes[i];if(e.propertyOrder<o.propertyOrder){this.addproperty_list.insertBefore(e,o),e=null;break}}e&&this.addproperty_list.appendChild(e)}},{key:"addPropertyCheckbox",value:function(t){var e,r=this,n=this.theme.getCheckbox();e=this.schema.properties[t]&&this.schema.properties[t].title?this.schema.properties[t].title:t;var i=this.theme.getCheckboxLabel(e),o=this.theme.getFormControl(i,n,null,null,this.path+"-"+t);return o.style.paddingBottom=o.style.marginBottom=o.style.paddingTop=o.style.marginTop=0,o.style.height="auto",this.insertPropertyControlUsingPropertyOrder(t,o,this.addproperty_list),n.checked=t in this.editors,n.addEventListener("change",(function(){n.checked?r.addObjectProperty(t):r.removeObjectProperty(t),r.onChange(!0)})),this.addproperty_checkboxes[t]=n,n}},{key:"showAddProperty",value:function(){this.addproperty_holder&&(this.hideEditJSON(),this.addproperty_holder.style.left="".concat(this.addproperty_button.offsetLeft,"px"),this.addproperty_holder.style.top="".concat(this.addproperty_button.offsetTop+this.addproperty_button.offsetHeight,"px"),this.disable(),this.adding_property=!0,this.addproperty_button.disabled=!1,this.addproperty_holder.style.display="",this.refreshAddProperties())}},{key:"hideAddProperty",value:function(){this.addproperty_holder&&this.adding_property&&(this.addproperty_holder.style.display="none",this.enable(),this.adding_property=!1)}},{key:"toggleAddProperty",value:function(){this.adding_property?this.hideAddProperty():this.showAddProperty()}},{key:"removeObjectProperty",value:function(t){if(this.editors[t]){var e;if(null!==(e=this.editors[t].schema)&&void 0!==e&&null!==(e=e.options)&&void 0!==e&&e.dependencies)return;this.editors[t].unregister(),delete this.editors[t],this.refreshValue(),this.layoutEditors()}}},{key:"getSchemaOnMaxDepth",value:function(t){return Object.keys(t).reduce((function(e,r){switch(r){case"$ref":return e;case"properties":case"items":return In(In({},e),{},Bn({},r,{}));case"additionalProperties":case"propertyNames":return In(In({},e),{},Bn({},r,!0));default:return In(In({},e),{},Bn({},r,t[r]))}}),{})}},{key:"addObjectProperty",value:function(t,e){if(!this.editors[t]){if(this.cached_editors[t]){if(this.editors[t]=this.cached_editors[t],e)return;this.editors[t].register()}else{if(!(this.canHaveAdditionalProperties()||this.schema.properties&&this.schema.properties[t]||this.schema.patternProperties&&Object.keys(this.schema.patternProperties).find((function(e){return new RegExp(e).test(t)}))))return;var r=this.getPropertySchema(t);"number"!=typeof r.propertyOrder&&(r.propertyOrder=Object.keys(this.editors).length+1e3);var n=this.jsoneditor.getEditorClass(r),i=this.jsoneditor.options.max_depth;if(this.editors[t]=this.jsoneditor.createEditor(n,{jsoneditor:this.jsoneditor,schema:i&&this.currentDepth>=i?this.getSchemaOnMaxDepth(r):r,path:"".concat(this.path,".").concat(t),parent:this},this.currentDepth+1),this.editors[t].preBuild(),!e){var o=this.theme.getChildEditorHolder();this.editor_holder.appendChild(o),this.editors[t].setContainer(o),this.editors[t].build(),this.editors[t].postBuild(),this.editors[t].setOptInCheckbox(n.header),this.editors[t].activate()}this.cached_editors[t]=this.editors[t]}e||(this.refreshValue(),this.layoutEditors())}}},{key:"onOutsideModalClick",value:function(t){var e=t.path||t.composedPath&&t.composedPath();this.addproperty_holder&&!this.addproperty_holder.contains(e[0])&&this.adding_property&&(t.preventDefault(),t.stopPropagation(),this.toggleAddProperty())}},{key:"onChildEditorChange",value:function(t,r){this.refreshValue(),qn(Un(e.prototype),"onChildEditorChange",this).call(this,t,r)}},{key:"canHaveAdditionalProperties",value:function(){return"boolean"==typeof this.schema.additionalProperties?this.schema.additionalProperties:"object"===Fn(this.schema.additionalProperties)&&null!==this.schema.additionalProperties||("boolean"==typeof this.options.no_additional_properties?!this.options.no_additional_properties:"boolean"!=typeof this.jsoneditor.options.no_additional_properties||!this.jsoneditor.options.no_additional_properties)}},{key:"destroy",value:function(){Object.values(this.cached_editors).forEach((function(t){return t.destroy()})),this.editor_holder&&(this.editor_holder.innerHTML=""),this.title&&this.title.parentNode&&this.title.parentNode.removeChild(this.title),this.error_holder&&this.error_holder.parentNode&&this.error_holder.parentNode.removeChild(this.error_holder),this.editors=null,this.cached_editors=null,this.editor_holder&&this.editor_holder.parentNode&&this.editor_holder.parentNode.removeChild(this.editor_holder),this.editor_holder=null,document.removeEventListener("click",this.onOutsideModalClickListener,!0),qn(Un(e.prototype),"destroy",this).call(this)}},{key:"getValue",value:function(){if(this.dependenciesFulfilled){var t=qn(Un(e.prototype),"getValue",this).call(this);return t&&(this.jsoneditor.options.remove_empty_properties||this.options.remove_empty_properties)&&Object.keys(t).forEach((function(e){var r;(void 0===(r=t[e])||""===r||r===Object(r)&&0===Object.keys(r).length&&r.constructor===Object)&&delete t[e]})),t&&(this.jsoneditor.options.remove_false_properties||this.options.remove_false_properties)&&Object.keys(t).forEach((function(e){!1===t[e]&&delete t[e]})),t}}},{key:"refreshValue",value:function(){var t=this;this.value={},this.editors&&(Object.keys(this.editors).forEach((function(e){t.editors[e].isActive()&&(t.editors[e].refreshValue(),t.value[e]=t.editors[e].getValue())})),Object.keys(this.editors).forEach((function(e){t.editors[e].isActive()&&t.activateDependentRequired(t.editors[e].key)})),this.adding_property&&this.refreshAddProperties())}},{key:"activateDependentRequired",value:function(t){var e=this;this.getDependentRequired(t).forEach((function(t){var r;Object.entries(e.cached_editors).forEach((function(e){var n=Nn(e,2),i=(n[0],n[1]);i.key===t&&(r=i)})),r&&!r.isActive()&&r.activate()}))}},{key:"getDependentRequired",value:function(t){return this.schema.dependentRequired&&h(this.schema.dependentRequired,t)?this.schema.dependentRequired[t]:[]}},{key:"refreshAddProperties",value:function(){var t=this;if(this.options.disable_properties||!1!==this.options.disable_properties&&this.jsoneditor.options.disable_properties)this.addproperty_button.style.display="none";else{var e,r=0,n=!1;Object.keys(this.editors).forEach((function(t){return r++})),e=this.canHaveAdditionalProperties()&&!(void 0!==this.schema.maxProperties&&r>=this.schema.maxProperties),this.addproperty_checkboxes&&(this.addproperty_list.innerHTML=""),this.addproperty_checkboxes={},Object.keys(this.cached_editors).forEach((function(i){t.addPropertyCheckbox(i),t.isRequiredObject(t.cached_editors[i])&&i in t.editors&&(t.addproperty_checkboxes[i].disabled=!0),void 0!==t.schema.minProperties&&r<=t.schema.minProperties?(t.addproperty_checkboxes[i].disabled=t.addproperty_checkboxes[i].checked,t.addproperty_checkboxes[i].checked||(n=!0)):i in t.editors?n=!0:e||h(t.schema.properties,i)?(t.addproperty_checkboxes[i].disabled=!1,n=!0):t.addproperty_checkboxes[i].disabled=!0})),this.canHaveAdditionalProperties()&&(n=!0),Object.keys(this.schema.properties).forEach((function(e){t.cached_editors[e]||(n=!0,t.addPropertyCheckbox(e))})),n?this.canHaveAdditionalProperties()?this.addproperty_add.disabled=!e:(this.addproperty_add.style.display="none",this.addproperty_input.style.display="none"):(this.hideAddProperty(),this.addproperty_button.style.display="none")}}},{key:"isRequiredObject",value:function(t){if(t)return"boolean"==typeof t.schema.required?t.schema.required:Array.isArray(this.schema.required)?this.schema.required.includes(t.key):!!this.jsoneditor.options.required_by_default}},{key:"setValue",value:function(t,e){var r=this;("object"!==Fn(t=(t=this.applyConstFilter(t))||{})||Array.isArray(t))&&(t={}),Object.entries(this.cached_editors).forEach((function(n){var i=Nn(n,2),o=i[0],a=i[1];void 0!==t[o]?(r.addObjectProperty(o),a.setValue(t[o],e),a.activate(),r.disabled&&a.disable()):e||r.isRequiredObject(a)?a.setValue(a.getDefault(),e):r.jsoneditor.options.show_opt_in||r.options.show_opt_in?a.deactivate():r.removeObjectProperty(o)})),Object.entries(t).forEach((function(t){var n=Nn(t,2),i=n[0],o=n[1];r.cached_editors[i]||(r.addObjectProperty(i),r.editors[i]&&r.editors[i].setValue(o,e,!!r.editors[i].template))})),this.refreshValue(),this.layoutEditors(),this.onChange()}},{key:"showValidationErrors",value:function(t){var e=this,r=[],n=[];t.forEach((function(t){t.path===e.path?r.push(t):n.push(t)})),this.error_holder&&(r.length?(this.error_holder.innerHTML="",this.error_holder.style.display="",r.forEach((function(t){t.errorcount&&t.errorcount>1&&(t.message+=" (".concat(t.errorcount," errors)")),e.error_holder.appendChild(e.theme.getErrorMessage(t.message))}))):this.error_holder.style.display="none"),this.options.table_row&&(r.length?this.theme.addTableRowError(this.container):this.theme.removeTableRowError(this.container)),Object.values(this.editors).forEach((function(t){t.showValidationErrors(n)}))}}])&&Vn(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_);function Jn(t){return Jn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Jn(t)}function Wn(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Zn(n.key),n)}}function Zn(t){var e=function(t,e){if("object"!=Jn(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Jn(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Jn(e)?e:e+""}function Yn(t,e,r){return e=Xn(e),function(t,e){if(e&&("object"===Jn(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Qn()?Reflect.construct(e,r||[],Xn(t).constructor):e.apply(t,r))}function Qn(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Qn=function(){return!!t})()}function Kn(){return Kn="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Xn(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Kn.apply(this,arguments)}function Xn(t){return Xn=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Xn(t)}function ti(t,e){return ti=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},ti(t,e)}$n.rules={".je-object__title":"display:inline-block",".je-object__controls":"margin:0%200%200%2010px",".je-object__container":"position:relative",".je-object__property-checkbox":"margin:0;height:auto",".property-selector":"width:295px;max-height:160px;padding:5px%200;overflow-y:auto;overflow-x:hidden;padding-left:5px",".property-selector-input":"width:220px;margin-bottom:0;display:inline-block",".json-editor-btntype-toggle":"margin:0%2010px%200%200",".je-edit-json--textarea":"height:170px;width:300px;display:block"};var ei=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Yn(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ti(t,e)}(e,t),r=e,(n=[{key:"preBuild",value:function(){Kn(Xn(e.prototype),"preBuild",this).call(this)}},{key:"build",value:function(){var t=this;this.label="",this.options.compact||(this.header=this.label=this.theme.getFormInputLabel(this.getTitle(),this.isRequired())),this.schema.description&&(this.description=this.theme.getFormInputDescription(this.translateProperty(this.schema.description))),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText))),this.options.compact&&this.container.classList.add("compact"),this.radioContainer=document.createElement("div"),this.radioGroup=[];for(var e=function(e){t.setValue(e.currentTarget.value),t.onChange(!0),t.radioGroup.forEach((function(e){e.checked=e.value===t.getValue()}))},r=0;r<this.enum_values.length;r++){var n={id:"".concat(this.formname,"[").concat(r,"]"),value:this.enum_values[r]};this.jsoneditor.options.use_name_attributes&&(n.name=this.formname),this.input=this.theme.getFormRadio(n),this.setInputAttributes(["id","value","name"]),this.input.addEventListener("change",e,!1),this.radioGroup.push(this.input);var i=this.theme.getFormRadioLabel(this.enum_display[r]);i.htmlFor=this.input.id;var o=this.theme.getFormRadioControl(i,this.input,!("horizontal"!==this.options.layout&&!this.options.compact));this.radioContainer.appendChild(o)}if(this.schema.readOnly||this.schema.readonly){this.disable(!0);for(var a=0;a<this.radioGroup.length;a++)this.radioGroup[a].disabled=!0;this.radioContainer.classList.add("readonly")}var s=this.theme.getContainer();s.appendChild(this.radioContainer),s.dataset.containerFor="radio",this.input=s,this.control=this.theme.getFormControl(this.label,s,this.description,this.infoButton),this.container.appendChild(this.control),window.requestAnimationFrame((function(){t.input.parentNode&&t.afterInputReady()}))}},{key:"enable",value:function(){if(!this.always_disabled){for(var t=0;t<this.radioGroup.length;t++)this.radioGroup[t].disabled=!1;this.radioContainer.classList.remove("readonly"),Kn(Xn(e.prototype),"enable",this).call(this)}}},{key:"disable",value:function(t){t&&(this.always_disabled=!0);for(var r=0;r<this.radioGroup.length;r++)this.radioGroup[r].disabled=!0;this.radioContainer.classList.add("readonly"),Kn(Xn(e.prototype),"disable",this).call(this)}},{key:"destroy",value:function(){this.radioContainer.parentNode&&this.radioContainer.parentNode.parentNode&&this.radioContainer.parentNode.parentNode.removeChild(this.radioContainer.parentNode),this.label&&this.label.parentNode&&this.label.parentNode.removeChild(this.label),this.description&&this.description.parentNode&&this.description.parentNode.removeChild(this.description),Kn(Xn(e.prototype),"destroy",this).call(this)}},{key:"getNumColumns",value:function(){return 2}},{key:"setValue",value:function(t){"string"!=typeof(t=this.applyConstFilter(t))&&(t=String(t));for(var e=0;e<this.radioGroup.length;e++){if(this.radioGroup[e].value===t){this.radioGroup[e].checked=!0;break}this.radioGroup[e].checked=!1}this.value=t,this.onChange()}}])&&Wn(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(ke);function ri(t){return ri="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ri(t)}function ni(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,ii(n.key),n)}}function ii(t){var e=function(t,e){if("object"!=ri(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=ri(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==ri(e)?e:e+""}function oi(t,e,r){return e=li(e),function(t,e){if(e&&("object"===ri(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,ai()?Reflect.construct(e,r||[],li(t).constructor):e.apply(t,r))}function ai(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(ai=function(){return!!t})()}function si(){return si="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=li(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},si.apply(this,arguments)}function li(t){return li=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},li(t)}function ci(t,e){return ci=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},ci(t,e)}var ui=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),oi(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ci(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r,n){t=this.applyConstFilter(t);var i=si(li(e.prototype),"setValue",this).call(this,t,r,n);void 0!==i&&i.changed&&this.sceditor_instance&&this.sceditor_instance.val(i.value)}},{key:"build",value:function(){this.options.format="textarea",si(li(e.prototype),"build",this).call(this),this.input_type=this.schema.format,this.input.setAttribute("data-schemaformat",this.input_type)}},{key:"afterInputReady",value:function(){var t=this;if(window.sceditor){var r=this.expandCallbacks("sceditor",l({},{format:this.input_type,emoticonsEnabled:!1,width:"100%",height:300,readOnly:this.schema.readOnly||this.schema.readonly||this.schema.template},this.defaults.options.sceditor||{},this.options.sceditor||{},{element:this.input})),n=window.sceditor.instance(this.input);void 0===n&&window.sceditor.create(this.input,r),this.sceditor_instance=n||window.sceditor.instance(this.input),this.sceditor_instance.blur((function(){t.value=t.sceditor_instance.val(),t.sceditor_instance.updateOriginal(),t.is_dirty=!0,t.onChange(!0)})),this.theme.afterInputReady(this.input)}else si(li(e.prototype),"afterInputReady",this).call(this)}},{key:"getNumColumns",value:function(){return 6}},{key:"enable",value:function(){!this.always_disabled&&this.sceditor_instance&&this.sceditor_instance.readOnly(!1),si(li(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.sceditor_instance&&this.sceditor_instance.readOnly(!0),si(li(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.sceditor_instance&&(this.sceditor_instance.destroy(),this.sceditor_instance=null),si(li(e.prototype),"destroy",this).call(this)}}])&&ni(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function hi(t){return hi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},hi(t)}function pi(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,di(n.key),n)}}function di(t){var e=function(t,e){if("object"!=hi(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=hi(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==hi(e)?e:e+""}function fi(t,e,r){return e=vi(e),function(t,e){if(e&&("object"===hi(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,yi()?Reflect.construct(e,r||[],vi(t).constructor):e.apply(t,r))}function yi(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(yi=function(){return!!t})()}function mi(){return mi="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=vi(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},mi.apply(this,arguments)}function vi(t){return vi=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},vi(t)}function bi(t,e){return bi=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},bi(t,e)}var gi=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),fi(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&bi(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r){if(t=this.applyConstFilter(t),this.select2_instance){r?this.is_dirty=!1:"change"===this.jsoneditor.options.show_errors&&(this.is_dirty=!0);var n=this.updateValue(t);this.input.value=n,this.select2v4?this.select2_instance.val(n).trigger("change"):this.select2_instance.select2("val",n),this.onChange(!0)}else mi(vi(e.prototype),"setValue",this).call(this,t,r)}},{key:"afterInputReady",value:function(){var t=this;if(window.jQuery&&window.jQuery.fn&&window.jQuery.fn.select2&&!this.select2_instance){var r=this.expandCallbacks("select2",l({},this.defaults.options.select2||{},this.options.select2||{}));this.newEnumAllowed=r.tags=!!r.tags&&"string"===this.schema.type,this.select2_instance=window.jQuery(this.input).select2(r),this.select2v4=h(this.select2_instance.select2,"amd"),this.selectChangeHandler=function(){var e=t.select2v4?t.select2_instance.val():t.select2_instance.select2("val");t.updateValue(e),t.onChange(!0)},this.select2_instance.on("change",this.selectChangeHandler),this.select2_instance.on("select2-blur",this.selectChangeHandler)}mi(vi(e.prototype),"afterInputReady",this).call(this)}},{key:"updateValue",value:function(t){var e=this.enum_values[0];return t=this.typecast(t||""),this.enum_values.includes(t)?e=t:this.newEnumAllowed&&(e=this.addNewOption(t)?t:e),this.value=e,e}},{key:"addNewOption",value:function(t){var e,r=this.typecast(t),n=!1;return this.enum_values.includes(r)||""===r||(this.enum_options.push("".concat(r)),this.enum_display.push("".concat(r)),this.enum_values.push(r),this.schema.enum.push(r),(e=this.input.querySelector('option[value="'.concat(r,'"]')))?e.removeAttribute("data-select2-tag"):this.select2_instance.append(new Option(r,r,!1,!1)).trigger("change"),n=!0),n}},{key:"enable",value:function(){this.always_disabled||this.select2_instance&&(this.select2v4?this.select2_instance.prop("disabled",!1):this.select2_instance.select2("enable",!0)),mi(vi(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.select2_instance&&(this.select2v4?this.select2_instance.prop("disabled",!0):this.select2_instance.select2("enable",!1)),mi(vi(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.select2_instance&&(this.select2_instance.select2("destroy"),this.select2_instance=null),mi(vi(e.prototype),"destroy",this).call(this)}}])&&pi(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(ke);function wi(t){return wi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},wi(t)}function _i(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,ki(n.key),n)}}function ki(t){var e=function(t,e){if("object"!=wi(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=wi(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==wi(e)?e:e+""}function ji(t,e,r){return e=Ci(e),function(t,e){if(e&&("object"===wi(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Oi()?Reflect.construct(e,r||[],Ci(t).constructor):e.apply(t,r))}function Oi(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Oi=function(){return!!t})()}function xi(){return xi="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Ci(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},xi.apply(this,arguments)}function Ci(t){return Ci=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Ci(t)}function Ei(t,e){return Ei=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Ei(t,e)}var Si=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),ji(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Ei(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r){if(t=this.applyConstFilter(t),this.selectize_instance){r?this.is_dirty=!1:"change"===this.jsoneditor.options.show_errors&&(this.is_dirty=!0);var n=this.updateValue(t);this.input.value=n,this.selectize_instance.clear(!0),this.selectize_instance.setValue(n),this.onChange(!0)}else xi(Ci(e.prototype),"setValue",this).call(this,t,r)}},{key:"afterInputReady",value:function(){var t=this;if(window.jQuery&&window.jQuery.fn&&window.jQuery.fn.selectize&&!this.selectize_instance){var r=this.expandCallbacks("selectize",l({},this.defaults.options.selectize||{},this.options.selectize||{}));this.newEnumAllowed=r.create=!!r.create&&"string"===this.schema.type,this.selectize_instance=window.jQuery(this.input).selectize(r)[0].selectize,this.control.removeEventListener("change",this.multiselectChangeHandler),this.multiselectChangeHandler=function(e){t.updateValue(e),t.onChange(!0)},this.selectize_instance.on("change",this.multiselectChangeHandler)}xi(Ci(e.prototype),"afterInputReady",this).call(this)}},{key:"updateValue",value:function(t){var e=this.enum_values[0];return t=this.typecast(t||""),this.enum_values.includes(t)?e=t:this.newEnumAllowed&&(e=this.addNewOption(t)?t:e),this.value=e,e}},{key:"addNewOption",value:function(t){var e=this.typecast(t),r=!1;return this.enum_values.includes(e)||""===e||(this.enum_options.push("".concat(e)),this.enum_display.push("".concat(e)),this.enum_values.push(e),this.schema.enum.push(e),this.selectize_instance.addItem(e),this.selectize_instance.refreshOptions(!1),r=!0),r}},{key:"onWatchedFieldChange",value:function(){var t=this;xi(Ci(e.prototype),"onWatchedFieldChange",this).call(this),this.selectize_instance&&(this.selectize_instance.clear(!0),this.selectize_instance.clearOptions(!0),this.enum_options.forEach((function(e,r){t.selectize_instance.addOption({value:e,text:t.enum_display[r]})})),this.selectize_instance.addItem("".concat(this.value),!0))}},{key:"enable",value:function(){!this.always_disabled&&this.selectize_instance&&this.selectize_instance.unlock(),xi(Ci(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.selectize_instance&&this.selectize_instance.lock(),xi(Ci(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.selectize_instance&&(this.selectize_instance.destroy(),this.selectize_instance=null),xi(Ci(e.prototype),"destroy",this).call(this)}}])&&_i(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(ke);function Pi(t){return Pi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Pi(t)}function Li(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Ti(n.key),n)}}function Ti(t){var e=function(t,e){if("object"!=Pi(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Pi(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Pi(e)?e:e+""}function Ai(t,e,r){return e=Ii(e),function(t,e){if(e&&("object"===Pi(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ri()?Reflect.construct(e,r||[],Ii(t).constructor):e.apply(t,r))}function Ri(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ri=function(){return!!t})()}function Ii(t){return Ii=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Ii(t)}function Bi(t,e){return Bi=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Bi(t,e)}var Ni=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ai(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Bi(t,e)}(e,t),r=e,(n=[{key:"build",value:function(){var t=this;this.options.compact||(this.header=this.label=this.theme.getFormInputLabel(this.getTitle(),this.isRequired())),this.schema.description&&(this.description=this.theme.getFormInputDescription(this.translateProperty(this.schema.description)));var e=this.formname.replace(/\W/g,"");if("function"==typeof SignaturePad){this.input=this.theme.getFormInputField("hidden"),this.container.appendChild(this.input);var r=document.createElement("div");r.classList.add("signature-container");var n=document.createElement("canvas");this.jsoneditor.options.use_name_attributes&&n.setAttribute("name",e),n.classList.add("signature"),r.appendChild(n),this.signaturePad=new window.SignaturePad(n),this.signaturePad.onEnd=function(){t.signaturePad.isEmpty()?t.input.value="":t.input.value=t.signaturePad.toDataURL(),t.is_dirty=!0,t.refreshValue(),t.watch_listener(),t.jsoneditor.notifyWatchers(t.path),t.parent?t.parent.onChildEditorChange(t):t.jsoneditor.onChange()};var i=document.createElement("div"),o=document.createElement("button");o.classList.add("tiny","button"),o.innerHTML="Clear signature",i.appendChild(o),r.appendChild(i),this.options.compact&&this.container.setAttribute("class","".concat(this.container.getAttribute("class")," compact")),(this.schema.readOnly||this.schema.readonly)&&(this.disable(!0),Array.from(this.inputs).forEach((function(t){n.setAttribute("readOnly","readOnly"),t.disabled=!0}))),o.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.signaturePad.clear(),t.signaturePad.strokeEnd()})),this.control=this.theme.getFormControl(this.label,r,this.description),this.container.appendChild(this.control),this.refreshValue(),n.width=r.offsetWidth,this.options&&this.options.canvas_height?n.height=this.options.canvas_height:n.height="300"}else{var a=document.createElement("p");a.innerHTML="Signature pad is not available, please include SignaturePad from https://github.com/szimek/signature_pad",this.container.appendChild(a)}}},{key:"setValue",value:function(t){if(t=this.applyConstFilter(t),"function"==typeof SignaturePad){var e=this.sanitize(t);if(this.value===e)return;return this.value=e,this.input.value=this.value,this.signaturePad.clear(),t&&""!==t&&this.signaturePad.fromDataURL(t),this.watch_listener(),this.jsoneditor.notifyWatchers(this.path),!1}}},{key:"destroy",value:function(){this.signaturePad.off(),delete this.signaturePad}}])&&Li(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function Di(t){return Di="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Di(t)}function Fi(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Vi(n.key),n)}}function Vi(t){var e=function(t,e){if("object"!=Di(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Di(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Di(e)?e:e+""}function Hi(t,e,r){return e=qi(e),function(t,e){if(e&&("object"===Di(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,zi()?Reflect.construct(e,r||[],qi(t).constructor):e.apply(t,r))}function zi(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(zi=function(){return!!t})()}function Mi(){return Mi="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=qi(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Mi.apply(this,arguments)}function qi(t){return qi=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},qi(t)}function Ui(t,e){return Ui=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Ui(t,e)}r(6031);var Gi=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Hi(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Ui(t,e)}(e,t),r=e,(n=[{key:"setValue",value:function(t,r,n){t=this.applyConstFilter(t);var i=Mi(qi(e.prototype),"setValue",this).call(this,t,r,n);void 0!==i&&i.changed&&this.simplemde_instance&&this.simplemde_instance.value(i.value)}},{key:"build",value:function(){this.options.format="textarea",Mi(qi(e.prototype),"build",this).call(this),this.input_type=this.schema.format,this.input.setAttribute("data-schemaformat",this.input_type)}},{key:"afterInputReady",value:function(){var t,r=this;window.SimpleMDE?(t=this.expandCallbacks("simplemde",l({},{height:300},this.defaults.options.simplemde||{},this.options.simplemde||{},{element:this.input,forceSync:!0})),this.simplemde_instance=new window.SimpleMDE(t),(this.schema.readOnly||this.schema.readonly||this.schema.template)&&(this.simplemde_instance.codemirror.options.readOnly=!0),this.simplemde_instance.codemirror.on("change",(function(){r.value=r.simplemde_instance.value(),r.is_dirty=!0,r.onChange(!0)})),t.autorefresh&&this.startListening(this.simplemde_instance.codemirror,this.simplemde_instance.codemirror.state.autoRefresh={delay:250}),this.theme.afterInputReady(this.input)):Mi(qi(e.prototype),"afterInputReady",this).call(this)}},{key:"getNumColumns",value:function(){return 6}},{key:"enable",value:function(){!this.always_disabled&&this.simplemde_instance&&(this.simplemde_instance.codemirror.options.readOnly=!1),Mi(qi(e.prototype),"enable",this).call(this)}},{key:"disable",value:function(t){this.simplemde_instance&&(this.simplemde_instance.codemirror.options.readOnly=!0),Mi(qi(e.prototype),"disable",this).call(this,t)}},{key:"destroy",value:function(){this.simplemde_instance&&(this.simplemde_instance.toTextArea(),this.simplemde_instance=null),Mi(qi(e.prototype),"destroy",this).call(this)}},{key:"startListening",value:function(t,e){var r=this,n=function n(){t.display.wrapper.offsetHeight?(r.stopListening(t,e),t.display.lastWrapHeight!==t.display.wrapper.clientHeight&&t.refresh()):e.timeout=window.setTimeout(n,e.delay)};e.timeout=window.setTimeout(n,e.delay),e.hurry=function(){window.clearTimeout(e.timeout),e.timeout=window.setTimeout(n,50)},t.on(window,"mouseup",e.hurry),t.on(window,"keyup",e.hurry)}},{key:"stopListening",value:function(t,e){window.clearTimeout(e.timeout),t.off(window,"mouseup",e.hurry),t.off(window,"keyup",e.hurry)}}])&&Fi(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function $i(t){return $i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},$i(t)}function Ji(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Wi(n.key),n)}}function Wi(t){var e=function(t,e){if("object"!=$i(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=$i(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==$i(e)?e:e+""}function Zi(t,e,r){return e=Ki(e),function(t,e){if(e&&("object"===$i(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Yi()?Reflect.construct(e,r||[],Ki(t).constructor):e.apply(t,r))}function Yi(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Yi=function(){return!!t})()}function Qi(){return Qi="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Ki(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Qi.apply(this,arguments)}function Ki(t){return Ki=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Ki(t)}function Xi(t,e){return Xi=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Xi(t,e)}var to=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Zi(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Xi(t,e)}(e,t),r=e,(n=[{key:"build",value:function(){var t=this;if(this.options.compact||(this.header=this.label=this.theme.getLabelLike(this.getTitle(),this.isRequired())),this.schema.description&&(this.description=this.theme.getFormInputDescription(this.translateProperty(this.schema.description))),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText))),this.options.compact&&this.container.classList.add("compact"),this.ratingContainer=document.createElement("div"),this.ratingContainer.classList.add("starrating"),void 0===this.schema.enum){var e=this.schema.maximum?this.schema.maximum:5;this.schema.exclusiveMaximum&&e--,this.enum_values=[];for(var r=0;r<e;r++)this.enum_values.push(r+1)}else this.enum_values=this.schema.enum;this.radioGroup=[];for(var n=function(e){e.preventDefault(),e.stopPropagation(),t.setValue(e.currentTarget.value),t.onChange(!0)},i=this.enum_values.length-1;i>-1;i--){var o=this.formname+(i+1),a=this.theme.getFormInputField("radio");a.name="".concat(this.formname,"[starrating]"),a.value=this.enum_values[i],a.id=o,a.addEventListener("change",n,!1),this.radioGroup.push(a);var s=document.createElement("label");s.htmlFor=o,s.title=this.enum_values[i],this.options.displayValue&&s.classList.add("starrating-display-enabled");var l=this.theme.getHiddenText("label");l.textContent=i,s.appendChild(l),this.ratingContainer.appendChild(a),this.ratingContainer.appendChild(s)}if(this.options.displayValue&&(this.displayRating=document.createElement("div"),this.displayRating.classList.add("starrating-display"),this.displayRating.innerText=this.enum_values[0],this.ratingContainer.appendChild(this.displayRating)),this.schema.readOnly||this.schema.readonly){this.disable(!0);for(var c=0;c<this.radioGroup.length;c++)this.radioGroup[c].disabled=!0;this.ratingContainer.classList.add("readonly")}var u=this.theme.getContainer();u.appendChild(this.ratingContainer),this.input=u,this.control=this.theme.getFormControl(this.label,u,this.description,this.infoButton),this.container.appendChild(this.control),this.refreshValue()}},{key:"enable",value:function(){if(!this.always_disabled){for(var t=0;t<this.radioGroup.length;t++)this.radioGroup[t].disabled=!1;this.ratingContainer.classList.remove("readonly"),this.disabled=!1}}},{key:"disable",value:function(t){t&&(this.always_disabled=!0);for(var e=0;e<this.radioGroup.length;e++)this.radioGroup[e].disabled=!0;this.ratingContainer.classList.add("readonly"),this.disabled=!0}},{key:"destroy",value:function(){this.ratingContainer.parentNode&&this.ratingContainer.parentNode.parentNode&&this.ratingContainer.parentNode.parentNode.removeChild(this.ratingContainer.parentNode),this.label&&this.label.parentNode&&this.label.parentNode.removeChild(this.label),this.description&&this.description.parentNode&&this.description.parentNode.removeChild(this.description),Qi(Ki(e.prototype),"destroy",this).call(this)}},{key:"getNumColumns",value:function(){return 2}},{key:"getValue",value:function(){if(this.dependenciesFulfilled)return"integer"===this.schema.type?""===this.value?0:parseInt(this.value):this.value}},{key:"setValue",value:function(t){t=this.applyConstFilter(t),this.value=t;for(var r=0;r<this.radioGroup.length;r++)if(this.radioGroup[r].value==="".concat(t)){this.radioGroup[r].checked=!0,this.value=t,this.options.displayValue&&(this.displayRating.innerHTML=this.value);break}Qi(Ki(e.prototype),"setValue",this).call(this,this.value)}}])&&Ji(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L);function eo(t){return eo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},eo(t)}function ro(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,no(n.key),n)}}function no(t){var e=function(t,e){if("object"!=eo(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=eo(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==eo(e)?e:e+""}function io(t,e,r){return e=so(e),function(t,e){if(e&&("object"===eo(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,oo()?Reflect.construct(e,r||[],so(t).constructor):e.apply(t,r))}function oo(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(oo=function(){return!!t})()}function ao(){return ao="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=so(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},ao.apply(this,arguments)}function so(t){return so=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},so(t)}function lo(t,e){return lo=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},lo(t,e)}to.rules={".starrating":"direction:rtl;display:inline-block;white-space:nowrap",".starrating > input":"display:none",".starrating > label:before":"content:'%5C2606';margin:1px;font-size:18px;font-style:normal;font-weight:400;line-height:1;font-family:'Arial';display:inline-block",".starrating > label":"color:%23888;cursor:pointer;margin:8px%200%202px%200",".starrating > label.starrating-display-enabled":"margin:1px%200%200%200",".starrating > input:checked ~ label":"color:%23ffca08",".starrating:not(.readonly) > input:hover ~ label":"color:%23ffca08",".starrating > input:checked ~ label:before":"content:'%5C2605';text-shadow:0%200%201px%20rgba(0%2C20%2C20%2C1)",".starrating:not(.readonly) > input:hover ~ label:before":"content:'%5C2605';text-shadow:0%200%201px%20rgba(0%2C20%2C20%2C1)",".starrating .starrating-display":"position:relative;direction:rtl;text-align:center;font-size:10px;line-height:0px"};var co=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),io(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&lo(t,e)}(e,t),r=e,(n=[{key:"build",value:function(){ao(so(e.prototype),"build",this).call(this),this.input.setAttribute("type","number"),this.input.getAttribute("step")||this.input.setAttribute("step","1");var t=this.theme.getStepperButtons(this.input);this.control.appendChild(t),this.stepperDown=this.control.querySelector(".stepper-down"),this.stepperUp=this.control.querySelector(".stepper-up")}},{key:"enable",value:function(){ao(so(e.prototype),"enable",this).call(this),this.stepperDown.removeAttribute("disabled"),this.stepperUp.removeAttribute("disabled")}},{key:"disable",value:function(){ao(so(e.prototype),"disable",this).call(this),this.stepperDown.setAttribute("disabled",!0),this.stepperUp.setAttribute("disabled",!0)}}])&&ro(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(Vr);function uo(t){return uo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},uo(t)}function ho(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,po(n.key),n)}}function po(t){var e=function(t,e){if("object"!=uo(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=uo(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==uo(e)?e:e+""}function fo(t,e,r){return e=vo(e),function(t,e){if(e&&("object"===uo(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,yo()?Reflect.construct(e,r||[],vo(t).constructor):e.apply(t,r))}function yo(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(yo=function(){return!!t})()}function mo(){return mo="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=vo(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},mo.apply(this,arguments)}function vo(t){return vo=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},vo(t)}function bo(t,e){return bo=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},bo(t,e)}var go=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),fo(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&bo(t,e)}(e,t),r=e,n=[{key:"register",value:function(){if(mo(vo(e.prototype),"register",this).call(this),this.rows)for(var t=0;t<this.rows.length;t++)this.rows[t].register()}},{key:"unregister",value:function(){if(mo(vo(e.prototype),"unregister",this).call(this),this.rows)for(var t=0;t<this.rows.length;t++)this.rows[t].unregister()}},{key:"getNumColumns",value:function(){return Math.max(Math.min(12,this.width),3)}},{key:"preBuild",value:function(){var t=this.jsoneditor.expandRefs(this.schema.items||{});this.item_title=t.title||"row",this.item_default=t.default||null,this.item_has_child_editors=t.properties||t.items,this.width=12,this.array_controls_top=this.options.array_controls_top||this.jsoneditor.options.array_controls_top,mo(vo(e.prototype),"preBuild",this).call(this)}},{key:"build",value:function(){this.tableContainer=this.theme.getTableContainer(),this.table=this.theme.getTable(),this.tableContainer.appendChild(this.table),this.container.appendChild(this.tableContainer),this.thead=this.theme.getTableHead(),this.table.appendChild(this.thead),this.header_row=this.theme.getTableRow(),this.thead.appendChild(this.header_row),this.row_holder=this.theme.getTableBody(),this.table.appendChild(this.row_holder);var t=this.getElementEditor(0,!0);if(this.item_default=t.getDefault(),this.width=t.getNumColumns()+2,this.options.compact?(this.panel=document.createElement("div"),this.container.appendChild(this.panel)):(this.header=document.createElement("span"),this.header.textContent=this.getTitle(),this.title=this.theme.getHeader(this.header,this.getPathDepth()),this.container.appendChild(this.title),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText)),this.container.appendChild(this.infoButton)),this.title_controls=this.theme.getHeaderButtonHolder(),this.title.appendChild(this.title_controls),this.schema.description&&(this.description=this.theme.getDescription(this.translateProperty(this.schema.description)),this.container.appendChild(this.description)),this.panel=this.theme.getIndentedPanel(),this.container.appendChild(this.panel),this.error_holder=document.createElement("div"),this.panel.appendChild(this.error_holder)),this.panel.appendChild(this.tableContainer),this.controls=this.theme.getButtonHolder(),this.array_controls_top?this.title.appendChild(this.controls):this.panel.appendChild(this.controls),this.item_has_child_editors)for(var e=t.getChildEditors(),r=t.property_order||Object.keys(e),n=0;n<r.length;n++){var i=this.theme.getTableHeaderCell(e[r[n]].getTitle());e[r[n]].options.hidden&&(i.style.display="none"),this.header_row.appendChild(i)}else this.header_row.appendChild(this.theme.getTableHeaderCell(this.item_title));t.destroy(),this.row_holder.innerHTML="",this.controls_header_cell=this.theme.getTableHeaderCell(this.translate("table_controls")),this.controls_header_cell.setAttribute("aria-hidden","true"),this.controls_header_cell.style.visibility="hidden",this.header_row.appendChild(this.controls_header_cell),this.addControls()}},{key:"onChildEditorChange",value:function(t,r){this.refreshValue(),mo(vo(e.prototype),"onChildEditorChange",this).call(this,t,r)}},{key:"getItemDefault",value:function(){return l({},{default:this.item_default}).default}},{key:"getItemTitle",value:function(){return this.item_title}},{key:"getElementEditor",value:function(t,e){var r=l({},this.schema.items),n=this.jsoneditor.getEditorClass(r,this.jsoneditor),i=this.row_holder.appendChild(this.theme.getTableRow()),o=i;this.item_has_child_editors||(o=this.theme.getTableCell(),i.appendChild(o));var a=this.jsoneditor.createEditor(n,{jsoneditor:this.jsoneditor,schema:r,container:o,path:"".concat(this.path,".").concat(t),parent:this,compact:!0,table_row:!0});return a.preBuild(),e||(a.build(),a.postBuild(),a.controls_cell=i.appendChild(this.theme.getTableCell()),a.row=i,a.table_controls=this.theme.getButtonHolder(),a.controls_cell.appendChild(a.table_controls),a.table_controls.style.margin=0,a.table_controls.style.padding=0),a}},{key:"destroy",value:function(){this.innerHTML="",this.checkParent(this.title)&&this.title.parentNode.removeChild(this.title),this.checkParent(this.description)&&this.description.parentNode.removeChild(this.description),this.checkParent(this.row_holder)&&this.row_holder.parentNode.removeChild(this.row_holder),this.checkParent(this.table)&&this.table.parentNode.removeChild(this.table),this.checkParent(this.panel)&&this.panel.parentNode.removeChild(this.panel),this.rows=this.title=this.description=this.row_holder=this.table=this.panel=null,mo(vo(e.prototype),"destroy",this).call(this)}},{key:"ensureArraySize",value:function(t){if(Array.isArray(t)||(t=[t]),this.schema.minItems)for(;t.length<this.schema.minItems;)t.push(this.getItemDefault());return this.schema.maxItems&&t.length>this.schema.maxItems&&(t=t.slice(0,this.schema.maxItems)),t}},{key:"setValue",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],r=arguments.length>1?arguments[1]:void 0;if(e=this.applyConstFilter(e),e=this.ensureArraySize(e),JSON.stringify(e)!==this.serialized){var n=!1;e.forEach((function(e,r){t.rows[r]?t.rows[r].setValue(e):(t.addRow(e),n=!0)}));for(var i=e.length;i<this.rows.length;i++){var o=this.rows[i].container;this.item_has_child_editors||this.rows[i].row.parentNode.removeChild(this.rows[i].row),this.rows[i].destroy(),o.parentNode&&o.parentNode.removeChild(o),this.rows[i]=null,n=!0}this.rows=this.rows.slice(0,e.length),this.refreshValue(),(n||r)&&this.refreshRowButtons(),this.onChange()}}},{key:"refreshRowButtons",value:function(){var t=this,e=this.schema.minItems&&this.schema.minItems>=this.rows.length,r=this.schema.maxItems&&this.schema.maxItems<=this.rows.length,n=[];this.rows.forEach((function(i,o){if(i.delete_button){var a=!e;t.setButtonState(i.delete_button,a),n.push(a)}if(i.copy_button){var s=!r;t.setButtonState(i.copy_button,s),n.push(s)}if(i.moveup_button){var l=0!==o;t.setButtonState(i.moveup_button,l),n.push(l)}if(i.movedown_button){var c=o!==t.rows.length-1;t.setButtonState(i.movedown_button,c),n.push(c)}}));var i=n.some((function(t){return t}));this.rows.forEach((function(e){return t.setButtonState(e.controls_cell,i)})),this.setButtonState(this.controls_header_cell,i),this.setButtonState(this.table,this.value.length);var o=!(r||this.hide_add_button);this.setButtonState(this.add_row_button,o);var a=!(!this.value.length||e||this.hide_delete_last_row_buttons);this.setButtonState(this.delete_last_row_button,a);var s=!(this.value.length<=1||e||this.hide_delete_all_rows_buttons);this.setButtonState(this.remove_all_rows_button,s);var l=o||a||s;this.setButtonState(this.controls,l)}},{key:"refreshValue",value:function(){var t=this;this.value=[],this.rows.forEach((function(e,r){t.value[r]=e.getValue()})),this.serialized=JSON.stringify(this.value)}},{key:"addRow",value:function(t){var e=this.rows.length;this.rows[e]=this.getElementEditor(e);var r=this.rows[e].table_controls;return this.hide_delete_buttons||(this.rows[e].delete_button=this._createDeleteButton(e,r)),this.show_copy_button&&(this.rows[e].copy_button=this._createCopyButton(e,r)),this.hide_move_buttons||(this.rows[e].moveup_button=this._createMoveUpButton(e,r)),this.hide_move_buttons||(this.rows[e].movedown_button=this._createMoveDownButton(e,r)),this._supportDragDrop(this.rows[e].row),void 0!==t&&this.rows[e].setValue(t),this.rows[e]}},{key:"_createDeleteButton",value:function(t,e){var r=this,n=this.getButton("","delete","button_delete_row_title_short");return n.classList.add("delete","json-editor-btntype-delete"),n.setAttribute("data-i",t),n.addEventListener("click",(function(t){if(t.preventDefault(),t.stopPropagation(),!r.askConfirmation())return!1;var e=1*t.currentTarget.getAttribute("data-i"),n=r.getValue(),i=r.getValue()[e];n.splice(e,1),r.setValue(n),r.onChange(!0),r.jsoneditor.trigger("deleteRow",i)})),e.appendChild(n),n}},{key:"_createCopyButton",value:function(t,e){var r=this,n=this.getButton("","copy","button_copy_row_title_short"),i=this.schema;return n.classList.add("copy","json-editor-btntype-copy"),n.setAttribute("data-i",t),n.addEventListener("click",(function(t){t.preventDefault(),t.stopPropagation();var e=1*t.currentTarget.getAttribute("data-i"),n=r.getValue(),o=n[e];"string"===i.items.type&&"uuid"===i.items.format?o=f():"object"===i.items.type&&i.items.properties&&n.forEach((function(t,r){if(e===r)for(var a=0,s=Object.keys(t);a<s.length;a++){var l=s[a];i.items.properties&&i.items.properties[l]&&"uuid"===i.items.properties[l].format&&((o=Object.assign({},n[e]))[l]=f())}})),n.splice(e+1,0,o),r.setValue(n),r.onChange(!0),r.jsoneditor.trigger("copyRow",r.rows[e+1])})),e.appendChild(n),n}},{key:"_createMoveUpButton",value:function(t,e){var r=this,n=this.getButton("","moveup","button_move_up_title");return n.classList.add("moveup","json-editor-btntype-move"),n.setAttribute("data-i",t),n.addEventListener("click",(function(t){t.preventDefault(),t.stopPropagation();var e=1*t.currentTarget.getAttribute("data-i"),n=r.getValue();n.splice(e-1,0,n.splice(e,1)[0]),r.setValue(n),r.onChange(!0),r.jsoneditor.trigger("moveRow",r.rows[e-1])})),e.appendChild(n),n}},{key:"_createMoveDownButton",value:function(t,e){var r=this,n=this.getButton("","movedown","button_move_down_title");return n.classList.add("movedown","json-editor-btntype-move"),n.setAttribute("data-i",t),n.addEventListener("click",(function(t){t.preventDefault(),t.stopPropagation();var e=1*t.currentTarget.getAttribute("data-i"),n=r.getValue();n.splice(e+1,0,n.splice(e,1)[0]),r.setValue(n),r.onChange(!0),r.jsoneditor.trigger("moveRow",r.rows[e+1])})),e.appendChild(n),n}},{key:"_supportDragDrop",value:function(t){var e=this;Z(t,(function(t,r){var n=e.getValue(),i=n[t];n.splice(t,1),n.splice(r,0,i),e.setValue(n),e.onChange(!0),e.jsoneditor.trigger("moveRow",e.rows[r])}),{useTrigger:!0})}},{key:"addControls",value:function(){var t=this;this.collapsed=!1,this.toggle_button=this._createToggleButton(),this.title_controls&&(this.title.insertBefore(this.toggle_button,this.title.childNodes[0]),this.toggle_button.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation(),t.setButtonState(t.panel,t.collapsed),t.collapsed?(t.collapsed=!1,t.setButtonText(e.currentTarget,"","collapse","button_collapse")):(t.collapsed=!0,t.setButtonText(e.currentTarget,"","expand","button_expand"))})),this.options.collapsed&&c(this.toggle_button,"click"),this.schema.options&&void 0!==this.schema.options.disable_collapse?this.schema.options.disable_collapse&&(this.toggle_button.style.display="none"):this.jsoneditor.options.disable_collapse&&(this.toggle_button.style.display="none")),this.add_row_button=this._createAddRowButton(),this.delete_last_row_button=this._createDeleteLastRowButton(),this.remove_all_rows_button=this._createRemoveAllRowsButton()}},{key:"_createToggleButton",value:function(){var t=this.getButton("","collapse","button_collapse");return t.classList.add("json-editor-btntype-toggle"),t}},{key:"_createAddRowButton",value:function(){var t=this,e=this.getButton(this.getItemTitle(),"add","button_add_row_title",[this.getItemTitle()]);return e.classList.add("json-editor-btntype-add"),e.addEventListener("click",(function(e){e.preventDefault(),e.stopPropagation();var r=t.addRow();t.refreshValue(),t.refreshRowButtons(),t.onChange(!0),t.jsoneditor.trigger("addRow",r)})),this.controls.appendChild(e),e}},{key:"_createDeleteLastRowButton",value:function(){var t=this,e=this.getButton("button_delete_last","subtract","button_delete_last_title",[this.getItemTitle()]);return e.classList.add("json-editor-btntype-deletelast"),e.addEventListener("click",(function(e){if(e.preventDefault(),e.stopPropagation(),!t.askConfirmation())return!1;var r=t.getValue(),n=r.pop();t.setValue(r),t.onChange(!0),t.jsoneditor.trigger("deleteRow",n)})),this.controls.appendChild(e),e}},{key:"_createRemoveAllRowsButton",value:function(){var t=this,e=this.getButton("button_delete_all","delete","button_delete_all_title");return e.classList.add("json-editor-btntype-deleteall"),e.addEventListener("click",(function(e){if(e.preventDefault(),e.stopPropagation(),!t.askConfirmation())return!1;var r=t.getValue();t.setValue([]),t.onChange(!0),t.jsoneditor.trigger("deleteAllRows",r)})),this.controls.appendChild(e),e}}],n&&ho(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(W);function wo(t){return wo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},wo(t)}function _o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,ko(n.key),n)}}function ko(t){var e=function(t,e){if("object"!=wo(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=wo(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==wo(e)?e:e+""}function jo(t,e,r){return e=Co(e),function(t,e){if(e&&("object"===wo(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Oo()?Reflect.construct(e,r||[],Co(t).constructor):e.apply(t,r))}function Oo(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Oo=function(){return!!t})()}function xo(){return xo="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Co(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},xo.apply(this,arguments)}function Co(t){return Co=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Co(t)}function Eo(t,e){return Eo=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Eo(t,e)}function So(t){return So="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},So(t)}function Po(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Lo(n.key),n)}}function Lo(t){var e=function(t,e){if("object"!=So(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=So(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==So(e)?e:e+""}function To(t,e,r){return e=Io(e),function(t,e){if(e&&("object"===So(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ao()?Reflect.construct(e,r||[],Io(t).constructor):e.apply(t,r))}function Ao(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ao=function(){return!!t})()}function Ro(){return Ro="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Io(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Ro.apply(this,arguments)}function Io(t){return Io=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Io(t)}function Bo(t,e){return Bo=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Bo(t,e)}function No(t){return No="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},No(t)}function Do(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Fo(n.key),n)}}function Fo(t){var e=function(t,e){if("object"!=No(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=No(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==No(e)?e:e+""}function Vo(t,e,r){return e=Mo(e),function(t,e){if(e&&("object"===No(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ho()?Reflect.construct(e,r||[],Mo(t).constructor):e.apply(t,r))}function Ho(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ho=function(){return!!t})()}function zo(){return zo="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Mo(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},zo.apply(this,arguments)}function Mo(t){return Mo=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Mo(t)}function qo(t,e){return qo=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},qo(t,e)}r(9868);var Uo={ace:V,array:W,arrayChoices:dt,arraySelect2:kt,arraySelectize:Tt,autocomplete:Ht,base64:Zt,button:ie,checkbox:de,choices:Te,datetime:He,describedBy:Ze,enum:or,hidden:fr,info:kr,integer:Vr,ip:Wr,jodit:nn,multiple:On,multiselect:it,null:An,number:Tr,object:$n,radio:ei,sceditor:ui,select:ke,select2:gi,selectize:Si,signature:Ni,simplemde:Gi,starrating:to,stepper:co,string:L,table:go,upload:function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),jo(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Eo(t,e)}(e,t),r=e,(n=[{key:"getNumColumns",value:function(){return 4}},{key:"build",value:function(){var t=this;if(this.options.compact||(this.header=this.label=this.theme.getFormInputLabel(this.getTitle(),this.isRequired())),this.schema.description&&(this.description=this.theme.getFormInputDescription(this.translateProperty(this.schema.description))),this.options.infoText&&(this.infoButton=this.theme.getInfoButton(this.translateProperty(this.options.infoText))),this.options.hidden&&(this.container.style.display="none"),this.options=this.expandCallbacks("upload",l({},{title:"Browse",icon:"",auto_upload:!1,hide_input:!1,enable_drag_drop:!1,drop_zone_text:"Drag & Drop file here",drop_zone_top:!1,alt_drop_zone:"",mime_type:"",max_upload_size:0,upload_handler:function(t,e,r,n){window.alert('No upload_handler defined for "'.concat(t.path,'". You must create your own handler to enable upload to server'))}},this.defaults.options.upload||{},this.options.upload||{})),this.options.mime_type=this.options.mime_type?[].concat(this.options.mime_type):[],this.input=this.theme.getFormInputField("hidden"),this.container.appendChild(this.input),!this.schema.readOnly&&!this.schema.readonly){if("function"!=typeof this.options.upload_handler)throw new Error("Upload handler required for upload editor");if(this.uploader=this.theme.getFormInputField("file"),this.uploader.style.display="none",this.options.mime_type.length&&this.uploader.setAttribute("accept",this.options.mime_type),!0===this.options.enable_drag_drop&&!0===this.options.hide_input||(this.clickHandler=function(e){t.uploader.dispatchEvent(new window.MouseEvent("click",{view:window,bubbles:!0,cancelable:!1}))},this.browseButton=this.getButton(this.options.title,this.options.icon,this.options.title),this.browseButton.addEventListener("click",this.clickHandler),this.fileDisplay=this.theme.getFormInputField("input"),this.fileDisplay.setAttribute("readonly",!0),this.fileDisplay.value="No file selected.",this.fileDisplay.addEventListener("dblclick",this.clickHandler),this.fileUploadGroup=this.theme.getInputGroup(this.fileDisplay,[this.browseButton]),this.fileUploadGroup||(this.fileUploadGroup=document.createElement("div"),this.fileUploadGroup.appendChild(this.fileDisplay),this.fileUploadGroup.appendChild(this.browseButton))),!0===this.options.enable_drag_drop){if(""!==this.options.alt_drop_zone){if(this.altDropZone=document.querySelector(this.options.alt_drop_zone),!this.altDropZone)throw new Error('Error: alt_drop_zone selector "'.concat(this.options.alt_drop_zone,'" not found!'));this.dropZone=this.altDropZone}else this.dropZone=this.theme.getDropZone(this.options.drop_zone_text);this.dropZone&&(this.dropZone.classList.add("upload-dropzone"),this.dropZone.addEventListener("dblclick",this.clickHandler))}this.uploadHandler=function(e){e.preventDefault(),e.stopPropagation();var r=e.target.files||e.dataTransfer.files;if(r&&r.length)if(0!==t.options.max_upload_size&&r[0].size>t.options.max_upload_size)t.theme.addInputError(t.uploader,"".concat(t.translate("upload_max_size")," ").concat(t.options.max_upload_size));else if(0===t.options.mime_type.length||t.isValidMimeType(r[0].type,t.options.mime_type)){t.fileDisplay&&(t.fileDisplay.value=r[0].name);var n=new window.FileReader;n.onload=function(e){t.preview_value=e.target.result,t.refreshPreview(r),t.onChange(!0),n=null},n.readAsDataURL(r[0])}else t.theme.addInputError(t.uploader,"".concat(t.translate("upload_wrong_file_format")," ").concat(t.options.mime_type.toString()))},this.uploader.addEventListener("change",this.uploadHandler),this.dragHandler=function(e){var r=e.dataTransfer.items||e.dataTransfer.files,n=r&&r.length&&(0===t.options.mime_type.length||t.isValidMimeType(r[0].type,t.options.mime_type)),i=e.currentTarget.classList&&e.currentTarget.classList.contains("upload-dropzone")&&n;switch((e.currentTarget===window?"w_":"e_")+e.type){case"w_drop":case"w_dragover":i||(e.dataTransfer.dropEffect="none");break;case"e_dragenter":i?(t.dropZone.classList.add("valid-dropzone"),e.dataTransfer.dropEffect="copy"):t.dropZone.classList.add("invalid-dropzone");break;case"e_dragover":i&&(e.dataTransfer.dropEffect="copy");break;case"e_dragleave":t.dropZone.classList.remove("valid-dropzone","invalid-dropzone");break;case"e_drop":t.dropZone.classList.remove("valid-dropzone","invalid-dropzone"),i&&t.uploadHandler(e)}i||e.preventDefault()},!0===this.options.enable_drag_drop&&(["dragover","drop"].forEach((function(e){window.addEventListener(e,t.dragHandler,!0)})),["dragenter","dragover","dragleave","drop"].forEach((function(e){t.dropZone.addEventListener(e,t.dragHandler,!0)})))}this.preview=document.createElement("div"),this.control=this.input.controlgroup=this.theme.getFormControl(this.label,this.uploader||this.input,this.description,this.infoButton),this.uploader&&(this.uploader.controlgroup=this.control);var e=this.uploader||this.input,r=document.createElement("div");this.dropZone&&!this.altDropZone&&!0===this.options.drop_zone_top&&r.appendChild(this.dropZone),this.fileUploadGroup&&r.appendChild(this.fileUploadGroup),this.dropZone&&!this.altDropZone&&!0!==this.options.drop_zone_top&&r.appendChild(this.dropZone),r.appendChild(this.preview),e.parentNode.insertBefore(r,e.nextSibling),this.container.appendChild(this.control),window.requestAnimationFrame((function(){t.afterInputReady()}))}},{key:"afterInputReady",value:function(){var t=this;if(this.value){var e=document.createElement("img");e.style.maxWidth="100%",e.style.maxHeight="100px",e.onload=function(r){t.preview.appendChild(e)},e.onerror=function(t){console.error("upload error",t,t.currentTarget)},e.src=this.container.querySelector("a").href}this.theme.afterInputReady(this.input)}},{key:"refreshPreview",value:function(t){var e=this;if(this.last_preview!==this.preview_value&&(this.last_preview=this.preview_value,this.preview.innerHTML="",this.preview_value)){var r=t[0],n=this.preview_value.match(/^data:([^;,]+)[;,]/);if(r.mimeType=n?n[1]:"unknown",r.size>0){var i=Math.floor(Math.log(r.size)/Math.log(1024));r.formattedSize="".concat(parseFloat((r.size/Math.pow(1024,i)).toFixed(2))," ").concat(["Bytes","KB","MB","GB","TB","PB","EB","ZB","YB"][i])}else r.formattedSize="0 Bytes";var o=this.getButton("button_upload","upload","button_upload");o.addEventListener("click",(function(t){t.preventDefault(),o.setAttribute("disabled","disabled"),e.theme.removeInputError(e.uploader),e.theme.getProgressBar&&(e.progressBar=e.theme.getProgressBar(),e.preview.appendChild(e.progressBar)),e.options.upload_handler(e.path,r,{success:function(t){e.setValue(t),e.parent?e.parent.onChildEditorChange(e):e.jsoneditor.onChange(),e.progressBar&&e.preview.removeChild(e.progressBar),o.removeAttribute("disabled")},failure:function(t){e.theme.addInputError(e.uploader,t),e.progressBar&&e.preview.removeChild(e.progressBar),o.removeAttribute("disabled")},updateProgress:function(t){e.progressBar&&(t?e.theme.updateProgressBar(e.progressBar,t):e.theme.updateProgressBarUnknown(e.progressBar))}})})),this.preview.appendChild(this.theme.getUploadPreview(r,o,this.preview_value)),this.options.auto_upload&&(o.dispatchEvent(new window.MouseEvent("click")),o.parentNode.removeChild(o))}}},{key:"enable",value:function(){this.always_disabled||(this.uploader&&(this.uploader.disabled=!1),xo(Co(e.prototype),"enable",this).call(this))}},{key:"disable",value:function(t){t&&(this.always_disabled=!0),this.uploader&&(this.uploader.disabled=!0),xo(Co(e.prototype),"disable",this).call(this)}},{key:"setValue",value:function(t){t=this.applyConstFilter(t),this.value!==t&&(this.value=t,this.input.value=this.value,this.onChange())}},{key:"destroy",value:function(){var t=this;!0===this.options.enable_drag_drop&&(["dragover","drop"].forEach((function(e){window.removeEventListener(e,t.dragHandler,!0)})),["dragenter","dragover","dragleave","drop"].forEach((function(e){t.dropZone.removeEventListener(e,t.dragHandler,!0)})),this.dropZone.removeEventListener("dblclick",this.clickHandler),this.dropZone&&this.dropZone.parentNode&&this.dropZone.parentNode.removeChild(this.dropZone)),this.uploader&&this.uploader.parentNode&&(this.uploader.removeEventListener("change",this.uploadHandler),this.uploader.parentNode.removeChild(this.uploader)),this.browseButton&&this.browseButton.parentNode&&(this.browseButton.removeEventListener("click",this.clickHandler),this.browseButton.parentNode.removeChild(this.browseButton)),this.fileDisplay&&this.fileDisplay.parentNode&&(this.fileDisplay.removeEventListener("dblclick",this.clickHandler),this.fileDisplay.parentNode.removeChild(this.fileDisplay)),this.fileUploadGroup&&this.fileUploadGroup.parentNode&&this.fileUploadGroup.parentNode.removeChild(this.fileUploadGroup),this.preview&&this.preview.parentNode&&this.preview.parentNode.removeChild(this.preview),this.header&&this.header.parentNode&&this.header.parentNode.removeChild(this.header),this.input&&this.input.parentNode&&this.input.parentNode.removeChild(this.input),xo(Co(e.prototype),"destroy",this).call(this)}},{key:"isValidMimeType",value:function(t,e){return e.reduce((function(e,r){return e||new RegExp(r.replace(/\*/g,".*"),"gi").test(t)}),!1)}}])&&_o(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(_),uuid:function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),To(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Bo(t,e)}(e,t),r=e,(n=[{key:"preBuild",value:function(){Ro(Io(e.prototype),"preBuild",this).call(this),this.schema.default=this.uuid=this.getUuid(),this.schema.options||(this.schema.options={}),this.schema.options.cleave||(this.schema.options.cleave={delimiters:["-"],blocks:[8,4,4,4,12]})}},{key:"build",value:function(){Ro(Io(e.prototype),"build",this).call(this),this.disable(!0),this.input.setAttribute("readonly","true")}},{key:"sanitize",value:function(t){return this.testUuid(t)||(t=this.uuid),t}},{key:"setValue",value:function(t,r,n){t=this.applyConstFilter(t),this.testUuid(t)||(t=this.uuid),this.uuid=t,Ro(Io(e.prototype),"setValue",this).call(this,t,r,n)}},{key:"getUuid",value:function(){return f()}},{key:"testUuid",value:function(t){return/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t)}}])&&Po(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L),colorpicker:function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Vo(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&qo(t,e)}(e,t),r=e,(n=[{key:"postBuild",value:function(){window.Picker&&(this.input.type="text"),this.input.style.padding="3px"}},{key:"setValue",value:function(t,r,n){t=this.applyConstFilter(t);var i=zo(Mo(e.prototype),"setValue",this).call(this,t,r,n);return this.picker_instance&&this.picker_instance.domElement&&i&&i.changed&&this.picker_instance.setColor(i.value,!0),i}},{key:"getNumColumns",value:function(){return 2}},{key:"afterInputReady",value:function(){zo(Mo(e.prototype),"afterInputReady",this).call(this),this.createPicker(!0)}},{key:"disable",value:function(){if(zo(Mo(e.prototype),"disable",this).call(this),this.picker_instance&&this.picker_instance.domElement){this.picker_instance.domElement.style.pointerEvents="none";for(var t=this.picker_instance.domElement.querySelectorAll("button"),r=0;r<t.length;r++)t[r].disabled=!0}}},{key:"enable",value:function(){if(zo(Mo(e.prototype),"enable",this).call(this),this.picker_instance&&this.picker_instance.domElement){this.picker_instance.domElement.style.pointerEvents="auto";for(var t=this.picker_instance.domElement.querySelectorAll("button"),r=0;r<t.length;r++)t[r].disabled=!1}}},{key:"destroy",value:function(){this.createPicker(!1),zo(Mo(e.prototype),"destroy",this).call(this)}},{key:"createPicker",value:function(t){var e=this;if(t){if(window.Picker&&!this.picker_instance){var r=this.expandCallbacks("colorpicker",l({},{editor:!1,alpha:!1,color:this.value,popup:"bottom"},this.defaults.options.colorpicker||{},this.options.colorpicker||{},{parent:this.container})),n=function(t){var r=e.picker_instance.settings.editorFormat,n=e.picker_instance.settings.alpha;e.setValue("hex"===r?n?t.hex:t.hex.slice(0,7):t["".concat(r+(n?"a":""),"String")])};r.popup||"function"==typeof r.onChange?r.popup&&"function"!=typeof r.onDone&&(r.onDone=n):r.onChange=n,this.picker_instance=new window.Picker(r),r.popup||(this.input.style.display="none",this.theme.afterInputReady(this.picker_instance.domElement))}}else this.picker_instance&&(this.picker_instance.destroy(),this.picker_instance=null,this.input.style.display="")}}])&&Do(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(L)};function Go(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var $o={},Jo="en",Wo=Jo;$o.en={error_notset:"Property must be set",error_notempty:"Value required",error_enum:"Value must be one of the enumerated values",error_const:"Value must be the constant value",error_anyOf:"Value must validate against at least one of the provided schemas",error_oneOf:"Value must validate against exactly one of the provided schemas. It currently validates against {{0}} of the schemas.",error_not:"Value must not validate against the provided schema",error_type_union:"Value must be one of the provided types",error_type:"Value must be of type {{0}}",error_disallow_union:"Value must not be one of the provided disallowed types",error_disallow:"Value must not be of type {{0}}",error_multipleOf:"Value must be a multiple of {{0}}",error_maximum_excl:"Value must be less than {{0}}",error_maximum_incl:"Value must be at most {{0}}",error_minimum_excl:"Value must be greater than {{0}}",error_minimum_incl:"Value must be at least {{0}}",error_maxLength:"Value must be at most {{0}} characters long",error_contains:"No items match contains",error_minContains:"Contains match count {{0}} is less than minimum contains count of {{1}}",error_maxContains:"Contains match count {{0}} exceeds maximum contains count of {{1}}",error_minLength:"Value must be at least {{0}} characters long",error_pattern:"Value must match the pattern {{0}}",error_additionalItems:"No additional items allowed in this array",error_maxItems:"Value must have at most {{0}} items",error_minItems:"Value must have at least {{0}} items",error_uniqueItems:"Array must have unique items",error_maxProperties:"Object must have at most {{0}} properties",error_minProperties:"Object must have at least {{0}} properties",error_required:"Object is missing the required property '{{0}}'",error_additional_properties:"No additional properties allowed, but property {{0}} is set",error_property_names_exceeds_maxlength:"Property name {{0}} exceeds maxLength",error_property_names_enum_mismatch:"Property name {{0}} does not match any enum values",error_property_names_const_mismatch:"Property name {{0}} does not match the const value",error_property_names_pattern_mismatch:"Property name {{0}} does not match pattern",error_property_names_false:"Property name {{0}} fails when propertyName is false",error_property_names_maxlength:"Property name {{0}} cannot match invalid maxLength",error_property_names_enum:"Property name {{0}} cannot match invalid enum",error_property_names_pattern:"Property name {{0}} cannot match invalid pattern",error_property_names_unsupported:"Unsupported propertyName {{0}}",error_dependency:"Must have property {{0}}",error_date:"Date must be in the format {{0}}",error_time:"Time must be in the format {{0}}",error_datetime_local:"Datetime must be in the format {{0}}",error_invalid_epoch:"Date must be greater than 1 January 1970",error_ipv4:"Value must be a valid IPv4 address in the form of 4 numbers between 0 and 255, separated by dots",error_ipv6:"Value must be a valid IPv6 address",error_hostname:"The hostname has the wrong format",upload_max_size:"Filesize too large. Max size is ",upload_wrong_file_format:"Wrong file format. Allowed format(s): ",button_save:"Save",button_copy:"Copy",button_cancel:"Cancel",button_add:"Add",button_delete_all:"All",button_delete_all_title:"Delete All",button_delete_last:"Last {{0}}",button_delete_last_title:"Delete Last {{0}}",button_add_row_title:"Add {{0}}",button_move_down_title:"Move down",button_move_up_title:"Move up",button_properties:"Properties",button_object_properties:"Object Properties",button_copy_row_title:"Copy {{0}}",button_delete_row_title:"Delete {{0}}",button_delete_row_title_short:"Delete",button_copy_row_title_short:"Copy",button_collapse:"Collapse",button_expand:"Expand",button_edit_json:"Edit JSON",button_upload:"Upload",flatpickr_toggle_button:"Toggle",flatpickr_clear_button:"Clear",choices_placeholder_text:"Start typing to add value",default_array_item_title:"item",button_delete_node_warning:"Are you sure you want to remove this item?",table_controls:"Controls",paste_max_length_reached:"Pasted text exceeded maximum length of {{0}} and will be clipped."},Object.entries(Uo).forEach((function(t){var e=function(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,i,o,a,s=[],l=!0,c=!1;try{if(o=(r=r.call(t)).next,0===e){if(Object(r)!==r)return;l=!1}else for(;!(l=(n=o.call(r)).done)&&(s.push(n.value),s.length!==e);l=!0);}catch(t){c=!0,i=t}finally{try{if(!l&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw i}}return s}}(t,e)||function(t,e){if(t){if("string"==typeof t)return Go(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Go(t,e):void 0}}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}(t,2),r=e[0],n=e[1];Uo[r].options=n.options||{}}));var Zo={options:{upload:function(t,e,r){console.log("Upload handler required for upload editor")},use_name_attributes:!0,prompt_before_delete:!0,use_default_values:!0,max_depth:0,button_state_mode:1,case_sensitive_property_search:!0,show_errors:"interaction",prompt_paste_max_length_reached:!1,remove_false_properties:!1,enforce_const:!1,opt_in_widget:"checkbox"},theme:"html",template:"default",themes:{},callbacks:{},templates:{},iconlibs:{},editors:Uo,languages:$o,resolvers:e,custom_validators:[],default_language:Jo,language:Wo,translate:function(t,e,r){var n={};r&&r.options&&r.options.error_messages&&r.options.error_messages[Zo.language]&&(n=r.options.error_messages[Zo.language]);var i=Zo.languages[Zo.language];if(!i)throw new Error("Unknown language ".concat(Zo.language));var o=n[t]||i[t]||Zo.languages[Jo][t]||t;if(e)for(var a=0;a<e.length;a++)o=o.replace(new RegExp("\\{\\{".concat(a,"}}"),"g"),e[a]);return o},translateProperty:function(t,e){return t}};function Yo(){Yo=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,i=Object.defineProperty||function(t,e,r){t[e]=r.value},o="function"==typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",s=o.asyncIterator||"@@asyncIterator",l=o.toStringTag||"@@toStringTag";function c(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{c({},"")}catch(t){c=function(t,e,r){return t[e]=r}}function u(t,e,r,n){var o=e&&e.prototype instanceof v?e:v,a=Object.create(o.prototype),s=new L(n||[]);return i(a,"_invoke",{value:C(t,r,s)}),a}function h(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=u;var p="suspendedStart",d="suspendedYield",f="executing",y="completed",m={};function v(){}function b(){}function g(){}var w={};c(w,a,(function(){return this}));var _=Object.getPrototypeOf,k=_&&_(_(T([])));k&&k!==r&&n.call(k,a)&&(w=k);var j=g.prototype=v.prototype=Object.create(w);function O(t){["next","throw","return"].forEach((function(e){c(t,e,(function(t){return this._invoke(e,t)}))}))}function x(t,e){function r(i,o,a,s){var l=h(t[i],t,o);if("throw"!==l.type){var c=l.arg,u=c.value;return u&&"object"==ea(u)&&n.call(u,"__await")?e.resolve(u.__await).then((function(t){r("next",t,a,s)}),(function(t){r("throw",t,a,s)})):e.resolve(u).then((function(t){c.value=t,a(c)}),(function(t){return r("throw",t,a,s)}))}s(l.arg)}var o;i(this,"_invoke",{value:function(t,n){function i(){return new e((function(e,i){r(t,n,e,i)}))}return o=o?o.then(i,i):i()}})}function C(e,r,n){var i=p;return function(o,a){if(i===f)throw Error("Generator is already running");if(i===y){if("throw"===o)throw a;return{value:t,done:!0}}for(n.method=o,n.arg=a;;){var s=n.delegate;if(s){var l=E(s,n);if(l){if(l===m)continue;return l}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(i===p)throw i=y,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);i=f;var c=h(e,r,n);if("normal"===c.type){if(i=n.done?y:d,c.arg===m)continue;return{value:c.arg,done:n.done}}"throw"===c.type&&(i=y,n.method="throw",n.arg=c.arg)}}}function E(e,r){var n=r.method,i=e.iterator[n];if(i===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,E(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),m;var o=h(i,e.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,m;var a=o.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,m):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,m)}function S(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function P(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function L(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(S,this),this.reset(!0)}function T(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var i=-1,o=function r(){for(;++i<e.length;)if(n.call(e,i))return r.value=e[i],r.done=!1,r;return r.value=t,r.done=!0,r};return o.next=o}}throw new TypeError(ea(e)+" is not iterable")}return b.prototype=g,i(j,"constructor",{value:g,configurable:!0}),i(g,"constructor",{value:b,configurable:!0}),b.displayName=c(g,l,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===b||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,g):(t.__proto__=g,c(t,l,"GeneratorFunction")),t.prototype=Object.create(j),t},e.awrap=function(t){return{__await:t}},O(x.prototype),c(x.prototype,s,(function(){return this})),e.AsyncIterator=x,e.async=function(t,r,n,i,o){void 0===o&&(o=Promise);var a=new x(u(t,r,n,i),o);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},O(j),c(j,l,"Generator"),c(j,a,(function(){return this})),c(j,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function t(){for(;r.length;){var n=r.pop();if(n in e)return t.value=n,t.done=!1,t}return t.done=!0,t}},e.values=T,L.prototype={constructor:L,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(P),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function i(n,i){return s.type="throw",s.arg=e,r.next=n,i&&(r.method="next",r.arg=t),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],s=a.completion;if("root"===a.tryLoc)return i("end");if(a.tryLoc<=this.prev){var l=n.call(a,"catchLoc"),c=n.call(a,"finallyLoc");if(l&&c){if(this.prev<a.catchLoc)return i(a.catchLoc,!0);if(this.prev<a.finallyLoc)return i(a.finallyLoc)}else if(l){if(this.prev<a.catchLoc)return i(a.catchLoc,!0)}else{if(!c)throw Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return i(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&n.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,m):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),m},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),P(r),m}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;P(r)}return i}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:T(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),m}},e}function Qo(t,e,r,n,i,o,a){try{var s=t[o](a),l=s.value}catch(t){return void r(t)}s.done?e(l):Promise.resolve(l).then(n,i)}function Ko(t){return function(){var e=this,r=arguments;return new Promise((function(n,i){var o=t.apply(e,r);function a(t){Qo(o,n,i,a,s,"next",t)}function s(t){Qo(o,n,i,a,s,"throw",t)}a(void 0)}))}}function Xo(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,i,o,a,s=[],l=!0,c=!1;try{if(o=(r=r.call(t)).next,0===e){if(Object(r)!==r)return;l=!1}else for(;!(l=(n=o.call(r)).done)&&(s.push(n.value),s.length!==e);l=!0);}catch(t){c=!0,i=t}finally{try{if(!l&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw i}}return s}}(t,e)||function(t,e){if(t){if("string"==typeof t)return ta(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?ta(t,e):void 0}}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function ta(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function ea(t){return ea="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ea(t)}function ra(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,na(n.key),n)}}function na(t){var e=function(t,e){if("object"!=ea(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=ea(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==ea(e)?e:e+""}r(1688);var ia=function(){return t=function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=e||{},this.schema={},this.refs=this.options.refs||{},this.refs_with_info={},this.refs_prefix="#/counter/",this.refs_counter=1,this._subSchema1={type:function(t){"object"===ea(t.type)&&(t.type=this._expandSubSchema(t.type))},disallow:function(t){"object"===ea(t.disallow)&&(t.disallow=this._expandSubSchema(t.disallow))},anyOf:function(t){var e=this;Object.entries(t.anyOf).forEach((function(r){var n=Xo(r,2),i=n[0],o=n[1];t.anyOf[i]=e.expandSchema(o)}))},dependencies:function(t){var e=this;Object.entries(t.dependencies).forEach((function(r){var n=Xo(r,2),i=n[0],o=n[1];"object"!==ea(o)||Array.isArray(o)||(t.dependencies[i]=e.expandSchema(o))}))},not:function(t){t.not=this.expandSchema(t.not)}},this._subSchema2={allOf:function(t,e){var r=this,n=l({},e);return Object.entries(t.allOf).forEach((function(e){var i=Xo(e,2),o=i[0],a=i[1];t.allOf[o]=r.expandRefs(a,!0),n=r.extendSchemas(n,r.expandSchema(a))})),delete n.allOf,n},extends:function(t,e){var r,n=this;return delete(r=Array.isArray(t.extends)?t.extends.reduce((function(t,e,r){return n.extendSchemas(t,n.expandSchema(e))}),e):this.extendSchemas(e,this.expandSchema(t.extends))).extends,r},oneOf:function(t,e){var r=this,n=l({},e);return delete n.oneOf,t.oneOf.reduce((function(t,e,i){return t.oneOf[i]=r.extendSchemas(r.expandSchema(e),n),t}),e),e}}},e=[{key:"load",value:(n=Ko(Yo().mark((function t(e,r,n){return Yo().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return this.schema=e,t.next=3,this._asyncloadExternalRefs(e,r,this._getFileBase(n),!0);case 3:return t.abrupt("return",this.expandRefs(e));case 4:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return n.apply(this,arguments)})},{key:"expandRefs",value:function(t,e){var r=this,n=l({},t);if(!n.$ref)return n;var i=n.$ref.split("#");if(2===i.length&&!this.refs_with_info[n.$ref]){var o=this.expandRecursivePointer(this.schema,i[1]),a=this.extendSchemas(n,this.expandSchema(o));return delete a.$ref,a}var s=i.length>2?this.refs_with_info["#"+i[1]]:this.refs_with_info[n.$ref];delete n.$ref;var c=s.$ref.startsWith("#")?s.fetchUrl:"",u=this._getRef(c,s);if(this.refs[u]){if(e&&h(this.refs[u],"allOf")){var p=this.refs[u].allOf;Object.keys(p).forEach((function(t){p[t]=r.expandRefs(p[t],!0)}))}}else console.warn("reference:'".concat(u,"' not found!"));return i.length>2?this.extendSchemas(n,this.expandSchema(this.expandRecursivePointer(this.refs[u],i[2]))):this.extendSchemas(n,this.expandSchema(this.refs[u]))}},{key:"expandRecursivePointer",value:function(t,e){var r=t;return e.split("/").slice(1).forEach((function(t){r[t]&&(r=r[t])})),r.$refs&&r.$refs.startsWith("#")?this.expandRecursivePointer(t,r.$refs):r}},{key:"expandSchema",value:function(t){var e=this;Object.entries(this._subSchema1).forEach((function(r){var n=Xo(r,2),i=n[0],o=n[1];t[i]&&o.call(e,t)}));var r=l({},t);return Object.entries(this._subSchema2).forEach((function(n){var i=Xo(n,2),o=i[0],a=i[1];t[o]&&(r=a.call(e,t,r))})),this.expandRefs(r)}},{key:"_getRef",value:function(t,e){var r=t+e;return this.refs[r]?r:t+decodeURIComponent(e.$ref)}},{key:"_expandSubSchema",value:function(t){var e=this;return Array.isArray(t)?t.map((function(t){return"object"===ea(t)?e.expandSchema(t):t})):this.expandSchema(t)}},{key:"_manageRecursivePointer",value:function(t,e){Object.keys(t).forEach((function(r){null!==t[r]&&t[r].$ref&&0===t[r].$ref.indexOf("#")&&(t[r].$ref=e+t[r].$ref)}))}},{key:"_getExternalRefs",value:function(t,e){var r=this,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n||this._manageRecursivePointer(t,e);var i={},o=function(t){return Object.keys(t).forEach((function(t){i[t]=!0}))};if(t.$ref&&"object"!==ea(t.$ref)&&(0!==t.$ref.indexOf("#")||!n)){var a=t.$ref,s="";a.indexOf("#")>0&&(a=a.substr(0,a.indexOf("#"))),a!==t.$ref&&(s=t.$ref.substr(t.$ref.indexOf("#")));var l=this.refs_prefix+this.refs_counter++,c=l+s;"#"===t.$ref.substr(0,1)||this.refs[t.$ref]||(i[a]=!0),this.refs_with_info[l]={fetchUrl:e,$ref:a},t.$ref=c}return Object.values(t).forEach((function(t){t&&"object"===ea(t)&&(Array.isArray(t)?Object.values(t).forEach((function(t){t&&"object"===ea(t)&&o(r._getExternalRefs(t,e,n))})):t.$ref&&"string"==typeof t.$ref&&t.$ref.startsWith("#")||o(r._getExternalRefs(t,e,n)))})),t.id&&"string"==typeof t.id&&"urn:"===t.id.substr(0,4)?this.refs[t.id]=t:t.$id&&"string"==typeof t.$id&&"urn:"===t.$id.substr(0,4)&&(this.refs[t.$id]=t),i}},{key:"_getFileBase",value:function(t){if(!t)return"/";var e=this.options.ajaxBase;return void 0===e?this._getFileBaseFromFileLocation(t):e}},{key:"_getFileBaseFromFileLocation",value:function(t){var e=t.split("/");return e.pop(),"".concat(e.join("/"),"/")}},{key:"_joinUrl",value:function(t,e){var r=t;return"http://"!==t.substr(0,7)&&"https://"!==t.substr(0,8)&&"blob:"!==t.substr(0,5)&&"data:"!==t.substr(0,5)&&"#"!==t.substr(0,1)&&"/"!==t.substr(0,1)&&(r=e+t),r.indexOf("#")>0&&(r=r.substr(0,r.indexOf("#"))),r}},{key:"_isUniformResourceName",value:function(t){return"urn:"===t.substr(0,4)}},{key:"_asyncloadExternalRefs",value:(r=Ko(Yo().mark((function t(e,r,n){var i,o,a,s,l,c,u=this,h=arguments;return Yo().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:i=h.length>3&&void 0!==h[3]&&h[3],o=this._getExternalRefs(e,r,i),a=0,s=Yo().mark((function t(){var e,r,i,o,s,h,p,d,f,y,m;return Yo().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(void 0!==(e=c[l])){t.next=3;break}return t.abrupt("return",0);case 3:if(!u.refs[e]){t.next=5;break}return t.abrupt("return",0);case 5:if(!u._isUniformResourceName(e)){t.next=40;break}if(u.refs[e]="loading",a++,r=u.options.urn_resolver,i=e,"function"==typeof r){t.next=13;break}throw console.log('No "urn_resolver" callback defined to resolve "'.concat(i,'"')),new Error("Must set urn_resolver option to a callback to resolve ".concat(i));case 13:return i.indexOf("#")>0&&(i=i.substr(0,i.indexOf("#"))),t.prev=14,t.next=17,r(i);case 17:o=t.sent,t.prev=18,s=JSON.parse(o),t.next=26;break;case 22:throw t.prev=22,t.t0=t.catch(18),console.log(t.t0),new Error("Failed to parse external ref ".concat(i));case 26:if(!("boolean"!=typeof s&&"object"!==ea(s)||null===s||Array.isArray(s))){t.next=28;break}throw new Error("External ref does not contain a valid schema - ".concat(i));case 28:return u.refs[e]=s,t.next=31,u._asyncloadExternalRefs(s,e,n);case 31:t.next=37;break;case 33:throw t.prev=33,t.t1=t.catch(14),console.log(t.t1),new Error("Failed to parse external ref ".concat(i));case 37:if("boolean"!=typeof o){t.next=39;break}throw new Error("External ref does not contain a valid schema - ".concat(i));case 39:return t.abrupt("return",0);case 40:if(u.options.ajax){t.next=42;break}throw new Error("Must set ajax option to true to load external ref ".concat(e));case 42:if(a++,h=u._joinUrl(e,n),u.options.ajax_cache_responses&&(d=u.cacheGet(h))&&(p=d),p){t.next=61;break}return t.next=48,new Promise((function(t){var e=new XMLHttpRequest;u.options.ajaxCredentials&&(e.withCredentials=u.options.ajaxCredentials),e.overrideMimeType("application/json"),e.open("GET",h,!0),e.onload=function(){t(e)},e.onerror=function(e){t(void 0)},e.send()}));case 48:if(void 0!==(f=t.sent)){t.next=51;break}throw new Error("Failed to fetch ref via ajax - ".concat(e));case 51:t.prev=51,p=JSON.parse(f.responseText),u.onSchemaLoaded({schema:p,schemaUrl:h}),u.options.ajax_cache_responses&&u.cacheSet(h,p),t.next=61;break;case 57:throw t.prev=57,t.t2=t.catch(51),console.log(t.t2),new Error("Failed to parse external ref ".concat(h));case 61:if(!("boolean"!=typeof p&&"object"!==ea(p)||null===p||Array.isArray(p))){t.next=63;break}throw new Error("External ref does not contain a valid schema - ".concat(h));case 63:return u.refs[e]=p,y=u._getFileBaseFromFileLocation(h),h!==e&&(m=h.split("/"),h=("/"===e.substr(0,1)?"/":"")+m.pop()),t.next=68,u._asyncloadExternalRefs(p,h,y);case 68:case"end":return t.stop()}}),t,null,[[14,33],[18,22],[51,57]])})),l=0,c=Object.keys(o);case 5:if(!(l<c.length)){t.next=13;break}return t.delegateYield(s(),"t0",7);case 7:if(0!==t.t0){t.next=10;break}return t.abrupt("continue",10);case 10:l++,t.next=5;break;case 13:if(a){t.next=15;break}return t.abrupt("return",!0);case 15:this.onAllSchemasLoaded();case 16:case"end":return t.stop()}}),t,this)}))),function(t,e,n){return r.apply(this,arguments)})},{key:"onSchemaLoaded",value:function(t){}},{key:"onAllSchemasLoaded",value:function(){}},{key:"extendSchemas",value:function(t,e){var r=this;t=l({},t),e=l({},e);var n={},i=function(t){"string"==typeof t&&(t=[t]),"string"==typeof e.type&&(e.type=[e.type]),e.type&&e.type.length?n.type=t.filter((function(t){return e.type.includes(t)})):n.type=t,1===n.type.length&&"string"==typeof n.type[0]?n.type=n.type[0]:0===n.type.length&&delete n.type};return Object.entries(t).forEach((function(t){var o=Xo(t,2),a=o[0],s=o[1];void 0!==e[a]?function(t,o){!function(t,e){return("required"===t||"defaultProperties"===t)&&"object"===ea(e)&&Array.isArray(e)}(t,o)?"type"!==t||"string"!=typeof o&&!Array.isArray(o)?"object"!==ea(o)||Array.isArray(o)||null===o?n[t]=o:n[t]=r.extendSchemas(o,e[t]):i(o):n[t]=o.concat(e[t]).reduce((function(t,e){return t.includes(e)||t.push(e),t}),[])}(a,s):n[a]=s})),Object.entries(e).forEach((function(e){var r=Xo(e,2),i=r[0],o=r[1];void 0===t[i]&&(n[i]=o)})),n}},{key:"getCacheKey",value:function(t){return["je-cache",t].join("::")}},{key:"getCacheBuster",value:function(){return this.options.ajax_cache_buster||(new Date).toISOString().slice(0,10)}},{key:"cacheSet",value:function(t,e){try{window.localStorage.setItem(this.getCacheKey(t),JSON.stringify({cacheBuster:this.getCacheBuster(),schema:e}))}catch(t){console.error(t)}}},{key:"cacheGet",value:function(t){try{var e=window.localStorage.getItem(this.getCacheKey(t));if(e){var r=JSON.parse(e);if(r.cacheBuster&&r.schema&&r.cacheBuster===this.getCacheBuster())return r.schema;this.cacheDelete(t)}}catch(t){console.error(t)}}},{key:"cacheDelete",value:function(t){window.localStorage.removeItem(this.getCacheKey(t))}}],e&&ra(t.prototype,e),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,e,r,n}(),oa=(r(2762),{default:function(){return{compile:function(t){var e=t.match(/{{\s*([a-zA-Z0-9\-_ .]+)\s*}}/g),r=e&&e.length;if(!r)return function(){return t};for(var n=[],i=function(t){var r,i,o=e[t].replace(/[{}]+/g,"").trim().split("."),a=o.length;a>1?r=function(e){for(i=e,t=0;t<a&&(i=i[o[t]]);t++);return i}:(o=o[0],r=function(t){return t[o]}),n.push({s:e[t],r})},o=0;o<r;o++)i(o);return function(e){for(var i,o="".concat(t),a=0;a<r;a++)i=n[a],o=o.replace(i.s,i.r(e));return o}}}},ejs:function(){return!!window.EJS&&{compile:function(t){var e=new window.EJS({text:t});return function(t){return e.render(t)}}}},handlebars:function(){return window.Handlebars},hogan:function(){return!!window.Hogan&&{compile:function(t){var e=window.Hogan.compile(t);return function(t){return e.render(t)}}}},lodash:function(){return!!window._&&{compile:function(t){return function(e){return window._.template(t)(e)}}}},markup:function(){return!(!window.Mark||!window.Mark.up)&&{compile:function(t){return function(e){return window.Mark.up(t,e)}}}},mustache:function(){return!!window.Mustache&&{compile:function(t){return function(e){return window.Mustache.render(t,e)}}}},swig:function(){return window.swig},underscore:function(){return!!window._&&{compile:function(t){return function(e){return window._.template(t)(e)}}}}});function aa(t){return aa="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},aa(t)}function sa(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function la(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,ca(n.key),n)}}function ca(t){var e=function(t,e){if("object"!=aa(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=aa(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==aa(e)?e:e+""}var ua={collapse:"",expand:"",delete:"",edit:"",add:"",cancel:"",save:"",moveup:"",movedown:""},ha=function(){return t=function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ua;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.mapping=r,this.icon_prefix=e},(e=[{key:"getIconClass",value:function(t){return this.mapping[t]?this.icon_prefix+this.mapping[t]:this.icon_prefix+t}},{key:"getIcon",value:function(t){var e,r=this.getIconClass(t);if(!r)return null;var n,i=document.createElement("i");return(e=i.classList).add.apply(e,function(t){if(Array.isArray(t))return sa(t)}(n=r.split(" "))||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(n)||function(t,e){if(t){if("string"==typeof t)return sa(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?sa(t,e):void 0}}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),i}}])&&la(t.prototype,e),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,e}();function pa(t){return pa="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},pa(t)}function da(t,e,r){return e=ya(e),function(t,e){if(e&&("object"===pa(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,fa()?Reflect.construct(e,r||[],ya(t).constructor):e.apply(t,r))}function fa(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(fa=function(){return!!t})()}function ya(t){return ya=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},ya(t)}function ma(t,e){return ma=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},ma(t,e)}var va={collapse:"chevron-down",expand:"chevron-right",delete:"trash",edit:"pencil",add:"plus",subtract:"minus",cancel:"floppy-remove",save:"floppy-saved",moveup:"arrow-up",moveright:"arrow-right",movedown:"arrow-down",moveleft:"arrow-left",copy:"copy",clear:"remove-circle",time:"time",calendar:"calendar",edit_properties:"list"},ba=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),da(this,e,["glyphicon glyphicon-",va])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ma(t,e)}(e,t),r=e,Object.defineProperty(r,"prototype",{writable:!1}),r;var r}(ha);function ga(t){return ga="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ga(t)}function wa(t,e,r){return e=ka(e),function(t,e){if(e&&("object"===ga(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,_a()?Reflect.construct(e,r||[],ka(t).constructor):e.apply(t,r))}function _a(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_a=function(){return!!t})()}function ka(t){return ka=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},ka(t)}function ja(t,e){return ja=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},ja(t,e)}var Oa={collapse:"chevron-down",expand:"chevron-right",delete:"trash",edit:"pencil",add:"plus",subtract:"minus",cancel:"ban-circle",save:"save",moveup:"arrow-up",moveright:"arrow-right",movedown:"arrow-down",moveleft:"arrow-left",copy:"copy",clear:"remove-circle",time:"time",calendar:"calendar",edit_properties:"list"},xa=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),wa(this,e,["icon-",Oa])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ja(t,e)}(e,t),r=e,Object.defineProperty(r,"prototype",{writable:!1}),r;var r}(ha);function Ca(t){return Ca="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ca(t)}function Ea(t,e,r){return e=Pa(e),function(t,e){if(e&&("object"===Ca(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Sa()?Reflect.construct(e,r||[],Pa(t).constructor):e.apply(t,r))}function Sa(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Sa=function(){return!!t})()}function Pa(t){return Pa=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Pa(t)}function La(t,e){return La=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},La(t,e)}var Ta={collapse:"caret-square-o-down",expand:"caret-square-o-right",delete:"times",edit:"pencil",add:"plus",subtract:"minus",cancel:"ban",save:"save",moveup:"arrow-up",moveright:"arrow-right",movedown:"arrow-down",moveleft:"arrow-left",copy:"files-o",clear:"times-circle-o",time:"clock-o",calendar:"calendar",edit_properties:"list"},Aa=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ea(this,e,["fa fa-",Ta])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&La(t,e)}(e,t),r=e,Object.defineProperty(r,"prototype",{writable:!1}),r;var r}(ha);function Ra(t){return Ra="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ra(t)}function Ia(t,e,r){return e=Na(e),function(t,e){if(e&&("object"===Ra(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ba()?Reflect.construct(e,r||[],Na(t).constructor):e.apply(t,r))}function Ba(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ba=function(){return!!t})()}function Na(t){return Na=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Na(t)}function Da(t,e){return Da=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Da(t,e)}var Fa={collapse:"caret-down",expand:"caret-right",delete:"trash",edit:"pen",add:"plus",subtract:"minus",cancel:"ban",save:"save",moveup:"arrow-up",moveright:"arrow-right",movedown:"arrow-down",moveleft:"arrow-left",copy:"copy",clear:"times-circle",time:"clock",calendar:"calendar",edit_properties:"list"},Va=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ia(this,e,["fas fa-",Fa])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Da(t,e)}(e,t),r=e,Object.defineProperty(r,"prototype",{writable:!1}),r;var r}(ha);function Ha(t){return Ha="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ha(t)}function za(t,e,r){return e=qa(e),function(t,e){if(e&&("object"===Ha(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ma()?Reflect.construct(e,r||[],qa(t).constructor):e.apply(t,r))}function Ma(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ma=function(){return!!t})()}function qa(t){return qa=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},qa(t)}function Ua(t,e){return Ua=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Ua(t,e)}var Ga={collapse:"triangle-1-s",expand:"triangle-1-e",delete:"trash",edit:"pencil",add:"plusthick",subtract:"minusthick",cancel:"closethick",save:"disk",moveup:"arrowthick-1-n",moveright:"arrowthick-1-e",movedown:"arrowthick-1-s",moveleft:"arrowthick-1-w",copy:"copy",clear:"circle-close",time:"time",calendar:"calendar",edit_properties:"note"},$a=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),za(this,e,["ui-icon ui-icon-",Ga])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Ua(t,e)}(e,t),r=e,Object.defineProperty(r,"prototype",{writable:!1}),r;var r}(ha);function Ja(t){return Ja="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ja(t)}function Wa(t,e,r){return e=Ya(e),function(t,e){if(e&&("object"===Ja(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Za()?Reflect.construct(e,r||[],Ya(t).constructor):e.apply(t,r))}function Za(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Za=function(){return!!t})()}function Ya(t){return Ya=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Ya(t)}function Qa(t,e){return Qa=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Qa(t,e)}var Ka={collapse:"collapse-down",expand:"expand-right",delete:"trash",edit:"pencil",add:"plus",subtract:"minus",cancel:"ban",save:"file",moveup:"arrow-thick-top",moveright:"arrow-thick-right",movedown:"arrow-thick-bottom",moveleft:"arrow-thick-left",copy:"clipboard",clear:"circle-x",time:"clock",calendar:"calendar",edit_properties:"list"},Xa=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Wa(this,e,["oi oi-",Ka])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Qa(t,e)}(e,t),r=e,Object.defineProperty(r,"prototype",{writable:!1}),r;var r}(ha);function ts(t){return ts="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ts(t)}function es(t,e,r){return e=ns(e),function(t,e){if(e&&("object"===ts(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,rs()?Reflect.construct(e,r||[],ns(t).constructor):e.apply(t,r))}function rs(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(rs=function(){return!!t})()}function ns(t){return ns=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},ns(t)}function is(t,e){return is=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},is(t,e)}var os={collapse:"arrow-down",expand:"arrow-right",delete:"delete",edit:"edit",add:"plus",subtract:"minus",cancel:"cross",save:"check",moveup:"upward",moveright:"forward",movedown:"downward",moveleft:"back",copy:"copy",clear:"close",time:"time",calendar:"bookmark",edit_properties:"menu"},as=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),es(this,e,["icon icon-",os])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&is(t,e)}(e,t),r=e,Object.defineProperty(r,"prototype",{writable:!1}),r;var r}(ha);function ss(t){return ss="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},ss(t)}function ls(t,e,r){return e=us(e),function(t,e){if(e&&("object"===ss(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,cs()?Reflect.construct(e,r||[],us(t).constructor):e.apply(t,r))}function cs(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(cs=function(){return!!t})()}function us(t){return us=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},us(t)}function hs(t,e){return hs=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},hs(t,e)}var ps={collapse:"chevron-down",expand:"chevron-right",delete:"trash",edit:"pencil",add:"plus",subtract:"dash",cancel:"x-circle",save:"save",moveup:"arrow-up",moveright:"arrow-right",movedown:"arrow-down",moveleft:"arrow-left",copy:"clipboard",clear:"x-circle",time:"clock",calendar:"calendar",edit_properties:"list-ul"},ds={bootstrap:function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),ls(this,e,["bi bi-",ps])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&hs(t,e)}(e,t),r=e,Object.defineProperty(r,"prototype",{writable:!1}),r;var r}(ha),bootstrap3:ba,fontawesome3:xa,fontawesome4:Aa,fontawesome5:Va,jqueryui:$a,openiconic:Xa,spectre:as};function fs(t){return fs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},fs(t)}function ys(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,ms(n.key),n)}}function ms(t){var e=function(t,e){if("object"!=fs(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=fs(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==fs(e)?e:e+""}var vs=["matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector"].find((function(t){return t in document.documentElement})),bs=function(){return t=function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{disable_theme_rules:!1};!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.jsoneditor=e,Object.keys(r).forEach((function(t){void 0!==e.options[t]&&(r[t]=e.options[t])})),this.options=r},e=[{key:"getContainer",value:function(){return document.createElement("div")}},{key:"getOptInCheckbox",value:function(t){var e=document.createElement("span"),r=this.getHiddenLabel(t+" opt-in");r.setAttribute("for",t+"-opt-in"),r.textContent=t+"-opt-in";var n=document.createElement("input");return n.setAttribute("type","checkbox"),n.setAttribute("style","margin: 0 10px 0 0;"),n.setAttribute("id",t+"-opt-in"),n.classList.add("json-editor-opt-in"),e.appendChild(n),e.appendChild(r),{label:r,checkbox:n,container:e}}},{key:"getOptInSwitch",value:function(t){return this.getOptInCheckbox()}},{key:"getFloatRightLinkHolder",value:function(){var t=document.createElement("div");return t.classList.add("je-float-right-linkholder"),t}},{key:"getModal",value:function(){var t=document.createElement("div");return t.style.display="none",t.classList.add("je-modal"),t}},{key:"getGridContainer",value:function(){return document.createElement("div")}},{key:"getGridRow",value:function(){var t=document.createElement("div");return t.classList.add("row"),t}},{key:"getGridColumn",value:function(){return document.createElement("div")}},{key:"setGridColumnSize",value:function(t,e){}},{key:"getLink",value:function(t){var e=document.createElement("a");return e.setAttribute("href","#"),e.appendChild(document.createTextNode(t)),e}},{key:"disableHeader",value:function(t){t.style.color="#ccc"}},{key:"disableLabel",value:function(t){t.style.color="#ccc"}},{key:"enableHeader",value:function(t){t.style.color=""}},{key:"enableLabel",value:function(t){t.style.color=""}},{key:"getInfoButton",value:function(t){var e=document.createElement("span");e.innerText="â",e.classList.add("je-infobutton-icon");var r=document.createElement("span");return r.classList.add("je-infobutton-tooltip"),r.innerText=t,e.onmouseover=function(){r.style.visibility="visible"},e.onmouseleave=function(){r.style.visibility="hidden"},e.appendChild(r),e}},{key:"getFormInputLabel",value:function(t,e){var r=document.createElement("label");return r.appendChild(document.createTextNode(t)),e&&r.classList.add("required"),r}},{key:"getLabelLike",value:function(t,e){var r=document.createElement("b");return r.appendChild(document.createTextNode(t)),e&&r.classList.add("required"),r}},{key:"getHeader",value:function(t,e){var r=document.createElement("span");return"string"==typeof t?r.textContent=t:r.appendChild(t),r.classList.add("je-header"),r}},{key:"getCheckbox",value:function(){var t=this.getFormInputField("checkbox");return t.classList.add("je-checkbox"),t}},{key:"getCheckboxLabel",value:function(t,e){var r=document.createElement("label");return r.appendChild(document.createTextNode("Â ".concat(t))),e&&r.classList.add("required"),r}},{key:"getMultiCheckboxHolder",value:function(t,e,r,n){var i=document.createElement("div");return i.classList.add("control-group"),e&&(e.style.display="block",i.appendChild(e),n&&e.appendChild(n)),Object.values(t).forEach((function(t){t.style.display="inline-block",t.style.marginRight="20px",i.appendChild(t)})),r&&i.appendChild(r),i}},{key:"getFormCheckboxControl",value:function(t,e,r){var n=document.createElement("div");return n.appendChild(t),e.style.width="auto",t.insertBefore(e,t.firstChild),r&&n.classList.add("je-checkbox-control--compact"),n}},{key:"getFormRadio",value:function(t){var e=this.getFormInputField("radio");return Object.keys(t).forEach((function(r){return e.setAttribute(r,t[r])})),e.classList.add("je-radio"),e}},{key:"getFormRadioLabel",value:function(t,e){var r=document.createElement("label");return r.appendChild(document.createTextNode("Â ".concat(t))),e&&r.classList.add("required"),r}},{key:"getFormRadioControl",value:function(t,e,r,n){var i=document.createElement("div");return i.appendChild(t),e.style.width="auto",t.insertBefore(e,t.firstChild),r&&i.classList.add("je-radio-control--compact"),"div"!==e.tagName.toLowerCase()&&n&&t&&e&&(e.setAttribute("id",n),e.setAttribute("aria-labelledby",n),t.setAttribute("for",n)),i}},{key:"getSelectInput",value:function(t,e){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=document.createElement("select");return t&&this.setSelectOptions(n,t,[],r),n}},{key:"getSwitcher",value:function(t){var e=this.getSelectInput(t,!1);return e.classList.add("je-switcher"),e}},{key:"getSwitcherOptions",value:function(t){return t.getElementsByTagName("option")}},{key:"setSwitcherOptions",value:function(t,e,r){this.setSelectOptions(t,e,r)}},{key:"setSelectOptions",value:function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:" ";if(t.innerHTML="",n){var o=document.createElement("option");o.setAttribute("value","_placeholder_"),o.textContent=i,o.setAttribute("disabled",""),o.setAttribute("hidden",""),t.appendChild(o)}for(var a=0;a<e.length;a++){var s=document.createElement("option");s.setAttribute("value",e[a]),s.textContent=r[a]||e[a],t.appendChild(s)}}},{key:"getTextareaInput",value:function(){var t=document.createElement("textarea");return t.classList.add("je-textarea"),t}},{key:"getHiddenLabel",value:function(t){var e=document.createElement("label");return e.textContent=t,e.setAttribute("style","position: absolute;width: 1px;height: 1px;padding: 0;margin: -1px;overflow: hidden;clip: rect(0,0,0,0);border: 0;"),e}},{key:"visuallyHidden",value:function(t){t&&t.setAttribute("style","position: absolute;width: 1px;height: 1px;padding: 0;margin: -1px;overflow: hidden;clip: rect(0,0,0,0);border: 0;")}},{key:"getHiddenText",value:function(t){var e=document.createElement("span");return e.textContent=t,e.setAttribute("style","position: absolute;width: 1px;height: 1px;padding: 0;margin: -1px;overflow: hidden;clip: rect(0,0,0,0);border: 0;"),e}},{key:"getRangeInput",value:function(t,e,r,n,i){var o=this.getFormInputField("range");return o.setAttribute("min",t),o.setAttribute("max",e),o.setAttribute("step",r),n&&(n.setAttribute("id",i+"-description"),o.setAttribute("aria-describedby",i+"-description")),o}},{key:"getStepperButtons",value:function(t){var e=document.createElement("div"),r=document.createElement("button");r.setAttribute("type","button"),r.classList.add("stepper-down");var n=document.createElement("button");n.setAttribute("type","button"),n.classList.add("stepper-up"),t.getAttribute("readonly")&&(r.setAttribute("disabled",!0),n.setAttribute("disabled",!0)),r.textContent="-",n.textContent="+";var i=function(t,e){t.value=Number(e||t.value),t.setAttribute("initialized","1")},o=t.getAttribute("min"),a=t.getAttribute("max");return r.addEventListener("click",(function(){t.getAttribute("initialized")?o?Number(t.value)>Number(o)&&t.stepDown():t.stepDown():i(t,o),c(t,"change")})),n.addEventListener("click",(function(){t.getAttribute("initialized")?a?Number(t.value)<Number(a)&&t.stepUp():t.stepUp():i(t,o),c(t,"change")})),e.appendChild(r),e.appendChild(n),e}},{key:"getRangeOutput",value:function(t){var e=document.createElement("output"),r=function(t){e.value=t.currentTarget.value};return t.addEventListener("change",r,!1),t.addEventListener("input",r,!1),e}},{key:"getRangeControl",value:function(t,e){var r=document.createElement("div");return r.classList.add("je-range-control"),e&&r.appendChild(e),r.appendChild(t),r}},{key:"getFormInputField",value:function(t){var e=document.createElement("input");return e.setAttribute("type",t),e}},{key:"afterInputReady",value:function(t){}},{key:"getFormControl",value:function(t,e,r,n,i){var o=document.createElement("div");return o.classList.add("form-control"),t&&(o.appendChild(t),i&&t.setAttribute("for",i)),"checkbox"!==e.type&&"radio"!==e.type||!t?(n&&t&&t.appendChild(n),o.appendChild(e)):(e.style.width="auto",t.insertBefore(e,t.firstChild),n&&t.appendChild(n)),"div"!==e.tagName.toLowerCase()&&e&&t&&i&&(t.setAttribute("for",i),e.setAttribute("id",i)),"div"!==e.tagName.toLowerCase()&&e&&r&&(r.setAttribute("id",i+"-description"),e.setAttribute("aria-describedby",i+"-description")),r&&o.appendChild(r),o}},{key:"getIndentedPanel",value:function(){var t=document.createElement("div");return t.classList.add("je-indented-panel"),t}},{key:"getTopIndentedPanel",value:function(){var t=document.createElement("div");return t.classList.add("je-indented-panel--top"),t}},{key:"getChildEditorHolder",value:function(){return document.createElement("div")}},{key:"getDescription",value:function(t){var e=document.createElement("p");return window.DOMPurify?e.innerHTML=window.DOMPurify.sanitize(t):e.textContent=this.cleanText(t),e}},{key:"getCheckboxDescription",value:function(t){return this.getDescription(t)}},{key:"getFormInputDescription",value:function(t){return this.getDescription(t)}},{key:"getButtonHolder",value:function(){return document.createElement("span")}},{key:"getHeaderButtonHolder",value:function(){return this.getButtonHolder()}},{key:"getFormButtonHolder",value:function(t){return this.getButtonHolder()}},{key:"getButton",value:function(t,e,r){var n=document.createElement("button");return n.type="button",this.setButtonText(n,t,e,r),n}},{key:"getFormButton",value:function(t,e,r){return this.getButton(t,e,r)}},{key:"setButtonText",value:function(t,e,r,n){for(;t.firstChild;)t.removeChild(t.firstChild);if(r&&(t.appendChild(r),e=" ".concat(e)),!this.jsoneditor.options.iconlib||!this.jsoneditor.options.remove_button_labels||!r){var i=document.createElement("span");i.appendChild(document.createTextNode(e)),t.appendChild(i)}n&&t.setAttribute("title",n)}},{key:"getTableContainer",value:function(){return document.createElement("div")}},{key:"getTable",value:function(){return document.createElement("table")}},{key:"getTableRow",value:function(){return document.createElement("tr")}},{key:"getTableHead",value:function(){return document.createElement("thead")}},{key:"getTableBody",value:function(){return document.createElement("tbody")}},{key:"getTableHeaderCell",value:function(t){var e=document.createElement("th");return e.textContent=t,e}},{key:"getTableCell",value:function(){return document.createElement("td")}},{key:"getErrorMessage",value:function(t){var e=document.createElement("p");return e.style=e.style||{},e.style.color="red",e.appendChild(document.createTextNode(t)),e}},{key:"addInputError",value:function(t,e){t.errmsg.setAttribute("role","alert")}},{key:"removeInputError",value:function(t){}},{key:"addTableRowError",value:function(t){}},{key:"removeTableRowError",value:function(t){}},{key:"getTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.innerHTML="<div class='je-tabholder tabs'></div><div class='content' id='".concat(e,"'></div><div class='je-tabholder--clear'></div>"),r}},{key:"getTopTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.innerHTML="<div class='tabs je-tabholder--top'></div><div class='je-tabholder--clear'></div><div class='content' id='".concat(e,"'></div>"),r}},{key:"applyStyles",value:function(t,e){Object.keys(e).forEach((function(r){return t.style[r]=e[r]}))}},{key:"closest",value:function(t,e){for(;t&&t!==document;){if(!t[vs])return!1;if(t[vs](e))return t;t=t.parentNode}return!1}},{key:"insertBasicTopTab",value:function(t,e){e.firstChild.insertBefore(t,e.firstChild.firstChild)}},{key:"getTab",value:function(t,e){var r=document.createElement("div");return r.appendChild(t),r.id=e,r.classList.add("je-tab"),r}},{key:"getTopTab",value:function(t,e){var r=document.createElement("div");return r.appendChild(t),r.id=e,r.classList.add("je-tab--top"),r}},{key:"getTabContentHolder",value:function(t){return t.children[1]}},{key:"getTopTabContentHolder",value:function(t){return t.children[1]}},{key:"getTabContent",value:function(){return this.getIndentedPanel()}},{key:"getTopTabContent",value:function(){return this.getTopIndentedPanel()}},{key:"markTabActive",value:function(t){this.applyStyles(t.tab,{opacity:1,background:"white"}),void 0!==t.rowPane?t.rowPane.style.display="":t.container.style.display=""}},{key:"markTabInactive",value:function(t){this.applyStyles(t.tab,{opacity:.5,background:""}),void 0!==t.rowPane?t.rowPane.style.display="none":t.container.style.display="none"}},{key:"addTab",value:function(t,e){t.children[0].appendChild(e)}},{key:"addTopTab",value:function(t,e){t.children[0].appendChild(e)}},{key:"getBlockLink",value:function(){var t=document.createElement("a");return t.classList.add("je-block-link"),t}},{key:"getBlockLinkHolder",value:function(){return document.createElement("div")}},{key:"getLinksHolder",value:function(){return document.createElement("div")}},{key:"createMediaLink",value:function(t,e,r){t.appendChild(e),r.classList.add("je-media"),t.appendChild(r)}},{key:"createImageLink",value:function(t,e,r){t.appendChild(e),e.appendChild(r)}},{key:"getFirstTab",value:function(t){return t.firstChild.firstChild}},{key:"getInputGroup",value:function(t,e){}},{key:"cleanText",value:function(t){var e=document.createElement("div");return e.innerHTML=t,e.textContent||e.innerText}},{key:"getDropZone",value:function(t){var e=document.createElement("div");return e.setAttribute("data-text",t),e.classList.add("je-dropzone"),e}},{key:"getUploadPreview",value:function(t,e,r){var n=document.createElement("div");if(n.classList.add("je-upload-preview"),"image"===t.mimeType.substr(0,5)){var i=document.createElement("img");i.src=r,n.appendChild(i)}var o=document.createElement("div");o.innerHTML+="<strong>Name:</strong> ".concat(t.name,"<br><strong>Type:</strong> ").concat(t.type,"<br><strong>Size:</strong> ").concat(t.formattedSize),n.appendChild(o),n.appendChild(e);var a=document.createElement("div");return a.style.clear="left",n.appendChild(a),n}},{key:"getProgressBar",value:function(){var t=document.createElement("progress");return t.setAttribute("max",100),t.setAttribute("value",0),t}},{key:"updateProgressBar",value:function(t,e){t&&t.setAttribute("value",e)}},{key:"updateProgressBarUnknown",value:function(t){t&&t.removeAttribute("value")}}],e&&ys(t.prototype,e),Object.defineProperty(t,"prototype",{writable:!1}),t;var t,e}();function gs(t){return gs="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},gs(t)}function ws(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,_s(n.key),n)}}function _s(t){var e=function(t,e){if("object"!=gs(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=gs(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==gs(e)?e:e+""}function ks(t,e,r){return e=xs(e),function(t,e){if(e&&("object"===gs(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,js()?Reflect.construct(e,r||[],xs(t).constructor):e.apply(t,r))}function js(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(js=function(){return!!t})()}function Os(){return Os="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=xs(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Os.apply(this,arguments)}function xs(t){return xs=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},xs(t)}function Cs(t,e){return Cs=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Cs(t,e)}var Es=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),ks(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Cs(t,e)}(e,t),r=e,(n=[{key:"getFormInputLabel",value:function(t,r){var n=Os(xs(e.prototype),"getFormInputLabel",this).call(this,t,r);return n.classList.add("je-form-input-label"),n}},{key:"getFormInputDescription",value:function(t){var r=Os(xs(e.prototype),"getFormInputDescription",this).call(this,t);return r.classList.add("je-form-input-label"),r}},{key:"getIndentedPanel",value:function(){var t=Os(xs(e.prototype),"getIndentedPanel",this).call(this);return t.classList.add("je-indented-panel"),t}},{key:"getTopIndentedPanel",value:function(){return this.getIndentedPanel()}},{key:"getChildEditorHolder",value:function(){var t=Os(xs(e.prototype),"getChildEditorHolder",this).call(this);return t.classList.add("je-child-editor-holder"),t}},{key:"getHeaderButtonHolder",value:function(){var t=this.getButtonHolder();return t.classList.add("je-header-button-holder"),t}},{key:"getTable",value:function(){var t=Os(xs(e.prototype),"getTable",this).call(this);return t.classList.add("je-table"),t}},{key:"addInputError",value:function(t,e){var r=this.closest(t,".form-control")||t.controlgroup;t.errmsg?t.errmsg.style.display="block":(t.errmsg=document.createElement("div"),t.errmsg.setAttribute("class","errmsg"),t.errmsg.style=t.errmsg.style||{},t.errmsg.style.color="red",r.appendChild(t.errmsg)),t.errmsg.innerHTML="",t.errmsg.appendChild(document.createTextNode(e)),t.errmsg.setAttribute("role","alert")}},{key:"removeInputError",value:function(t){t.style&&(t.style.borderColor=""),t.errmsg&&(t.errmsg.style.display="none")}}])&&ws(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(bs);function Ss(t){return Ss="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ss(t)}function Ps(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Ls(n.key),n)}}function Ls(t){var e=function(t,e){if("object"!=Ss(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Ss(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Ss(e)?e:e+""}function Ts(t,e,r){return e=Is(e),function(t,e){if(e&&("object"===Ss(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,As()?Reflect.construct(e,r||[],Is(t).constructor):e.apply(t,r))}function As(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(As=function(){return!!t})()}function Rs(){return Rs="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Is(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Rs.apply(this,arguments)}function Is(t){return Is=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Is(t)}function Bs(t,e){return Bs=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Bs(t,e)}Es.rules={".je-form-input-label":"display:block;margin-bottom:3px;font-weight:bold",".je-form-input-description":"display:inline-block;margin:0;font-size:0.8em;font-style:italic",".je-indented-panel":"padding:5px;margin:10px;border-radius:3px;border:1px%20solid%20%23ddd",".je-child-editor-holder":"margin-bottom:8px",".je-header-button-holder":"display:inline-block;margin-left:10px;font-size:0.8em;vertical-align:middle",".je-table":"margin-bottom:5px;border-bottom:1px%20solid%20%23ccc",".je-upload-preview img":"float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem",".je-dropzone":"position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s",".je-dropzone:before":"position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)",".je-dropzone.valid-dropzone":"background:green",".je-dropzone.invalid-dropzone":"background:red"};var Ns=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ts(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Bs(t,e)}(e,t),r=e,(n=[{key:"getOptInSwitch",value:function(t){var e=this.getHiddenLabel(t+" opt-in");e.setAttribute("for",t+"-opt-in");var r=document.createElement("label");r.classList.add("switch");var n=document.createElement("input");n.setAttribute("type","checkbox"),n.setAttribute("id",t+"-opt-in"),n.classList.add("json-editor-opt-in");var i=document.createElement("span");i.classList.add("switch-slider");var o=document.createElement("span");return o.classList.add("sr-only"),o.textContent=t+"-opt-in",r.appendChild(o),r.appendChild(n),r.appendChild(i),{label:e,checkbox:n,container:r}}},{key:"getSelectInput",value:function(t,r){var n=Rs(Is(e.prototype),"getSelectInput",this).call(this,t);return n.classList.add("form-control"),n}},{key:"setGridColumnSize",value:function(t,e,r){t.classList.add("col-md-".concat(e)),r&&t.classList.add("col-md-offset-".concat(r))}},{key:"afterInputReady",value:function(t){t.controlgroup||(t.controlgroup=this.closest(t,".form-group"),this.closest(t,".compact")&&(t.controlgroup.style.marginBottom=0))}},{key:"getTextareaInput",value:function(){var t=document.createElement("textarea");return t.classList.add("form-control"),t}},{key:"getRangeInput",value:function(t,r,n,i,o){return Rs(Is(e.prototype),"getRangeInput",this).call(this,t,r,n,i,o)}},{key:"getFormInputField",value:function(t){var r=Rs(Is(e.prototype),"getFormInputField",this).call(this,t);return"checkbox"!==t&&"radio"!==t&&r.classList.add("form-control"),r}},{key:"getHiddenLabel",value:function(t){var e=document.createElement("label");return e.textContent=t,e.classList.add("sr-only"),e}},{key:"visuallyHidden",value:function(t){t&&t.classList.add("sr-only")}},{key:"getHiddenText",value:function(t){var e=document.createElement("span");return e.textContent=t,e.classList.add("sr-only"),e}},{key:"getFormControl",value:function(t,e,r,n,i){var o=document.createElement("div");return!t||"checkbox"!==e.type&&"radio"!==e.type?(o.classList.add("form-group"),t&&(t.classList.add("control-label"),o.appendChild(t),n&&t.appendChild(n)),o.appendChild(e)):(o.classList.add(e.type),n&&t.appendChild(n),t.insertBefore(e,t.firstChild),o.appendChild(t)),r&&o.appendChild(r),"div"!==e.tagName.toLowerCase()&&e&&t&&i&&(t.setAttribute("for",i),e.setAttribute("id",i)),"div"!==e.tagName.toLowerCase()&&e&&r&&(r.setAttribute("id",i+"-description"),e.setAttribute("aria-describedby",i+"-description")),o}},{key:"getIndentedPanel",value:function(){var t=document.createElement("div");return t.classList.add("well","well-sm"),t.style.paddingBottom=0,t}},{key:"getInfoButton",value:function(t){var e=document.createElement("span");e.classList.add("glyphicon","glyphicon-info-sign","pull-right"),e.style.padding=".25rem",e.style.position="relative",e.style.display="inline-block";var r=document.createElement("span");return r.style["font-family"]="sans-serif",r.style.visibility="hidden",r.style["background-color"]="rgba(50, 50, 50, .75)",r.style.margin="0 .25rem",r.style.color="#FAFAFA",r.style.padding=".5rem 1rem",r.style["border-radius"]=".25rem",r.style.width="25rem",r.style.position="absolute",r.innerText=t,e.onmouseover=function(){r.style.visibility="visible"},e.onmouseleave=function(){r.style.visibility="hidden"},e.appendChild(r),e}},{key:"getFormInputDescription",value:function(t){var e=document.createElement("p");return e.classList.add("help-block"),window.DOMPurify?e.innerHTML=window.DOMPurify.sanitize(t):e.textContent=this.cleanText(t),e}},{key:"getHeaderContainer",value:function(){return document.createElement("div")}},{key:"getHeader",value:function(t,e){var r=document.createElement("span");return r.classList.add("h3"),"string"==typeof t?r.textContent=t:r.appendChild(t),r}},{key:"getHeaderButtonHolder",value:function(){var t=this.getButtonHolder();return t.style.marginLeft="10px",t}},{key:"getButtonHolder",value:function(){var t=document.createElement("span");return t.classList.add("btn-group"),t}},{key:"getButton",value:function(t,r,n){var i=Rs(Is(e.prototype),"getButton",this).call(this,t,r,n);return i.classList.add("btn","btn-default"),i}},{key:"getTableContainer",value:function(){var t=Rs(Is(e.prototype),"getTableContainer",this).call(this);return t.classList.add("table-responsive"),t}},{key:"getTable",value:function(){var t=document.createElement("table");return t.classList.add("table","table-bordered"),t.style.width="auto",t.style.maxWidth="none",t}},{key:"addInputError",value:function(t,e){t.controlgroup&&(t.controlgroup.classList.add("has-error"),t.errmsg?t.errmsg.style.display="":(t.errmsg=document.createElement("p"),t.errmsg.classList.add("help-block","errormsg"),t.controlgroup.appendChild(t.errmsg)),t.errmsg.textContent=e,t.errmsg.setAttribute("role","alert"))}},{key:"removeInputError",value:function(t){t.errmsg&&(t.errmsg.style.display="none",t.controlgroup.classList.remove("has-error"))}},{key:"getTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.innerHTML="<ul class='col-md-2 nav nav-pills nav-stacked' id='".concat(e,"' role='tablist'></ul><div class='col-md-10 tab-content active well well-small'  id='").concat(e,"'></div>"),r}},{key:"getTopTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.innerHTML="<ul class='nav nav-tabs' id='".concat(e,"' role='tablist'></ul><div class='tab-content active well well-small'  id='").concat(e,"'></div>"),r}},{key:"getTab",value:function(t,e){var r=document.createElement("li");r.setAttribute("role","presentation");var n=document.createElement("a");return n.setAttribute("href","#".concat(e)),n.appendChild(t),n.setAttribute("aria-controls",e),n.setAttribute("role","tab"),n.setAttribute("data-toggle","tab"),r.appendChild(n),r}},{key:"getTopTab",value:function(t,e){var r=document.createElement("li");r.setAttribute("role","presentation");var n=document.createElement("a");return n.setAttribute("href","#".concat(e)),n.appendChild(t),n.setAttribute("aria-controls",e),n.setAttribute("role","tab"),n.setAttribute("data-toggle","tab"),r.appendChild(n),r}},{key:"getTabContent",value:function(){var t=document.createElement("div");return t.classList.add("tab-pane"),t.setAttribute("role","tabpanel"),t}},{key:"getTopTabContent",value:function(){var t=document.createElement("div");return t.classList.add("tab-pane"),t.setAttribute("role","tabpanel"),t}},{key:"markTabActive",value:function(t){t.tab.classList.add("active"),void 0!==t.rowPane?t.rowPane.classList.add("active"):t.container.classList.add("active")}},{key:"markTabInactive",value:function(t){t.tab.classList.remove("active"),void 0!==t.rowPane?t.rowPane.classList.remove("active"):t.container.classList.remove("active")}},{key:"getProgressBar",value:function(){var t=document.createElement("div");t.classList.add("progress");var e=document.createElement("div");return e.classList.add("progress-bar"),e.setAttribute("role","progressbar"),e.setAttribute("aria-valuenow",0),e.setAttribute("aria-valuemin",0),e.setAttribute("aria-valuenax",100),e.innerHTML="".concat(0,"%"),t.appendChild(e),t}},{key:"updateProgressBar",value:function(t,e){if(t){var r=t.firstChild,n="".concat(e,"%");r.setAttribute("aria-valuenow",e),r.style.width=n,r.innerHTML=n}}},{key:"updateProgressBarUnknown",value:function(t){if(t){var e=t.firstChild;t.classList.add("progress","progress-striped","active"),e.removeAttribute("aria-valuenow"),e.style.width="100%",e.innerHTML=""}}},{key:"getInputGroup",value:function(t,e){if(t){var r=document.createElement("div");r.classList.add("input-group"),r.appendChild(t);var n=document.createElement("div");n.classList.add("input-group-btn"),r.appendChild(n);for(var i=0;i<e.length;i++)n.appendChild(e[i]);return r}}}])&&Ps(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(bs);function Ds(t){return Ds="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ds(t)}function Fs(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Vs(n.key),n)}}function Vs(t){var e=function(t,e){if("object"!=Ds(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Ds(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Ds(e)?e:e+""}function Hs(t,e,r){return e=qs(e),function(t,e){if(e&&("object"===Ds(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,zs()?Reflect.construct(e,r||[],qs(t).constructor):e.apply(t,r))}function zs(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(zs=function(){return!!t})()}function Ms(){return Ms="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=qs(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Ms.apply(this,arguments)}function qs(t){return qs=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},qs(t)}function Us(t,e){return Us=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Us(t,e)}Ns.rules={".switch":"position:relative;display:inline-block;width:28px;height:16px;margin-right:10px",".switch input":"opacity:0;width:0;height:0",".switch-slider":"position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:%23ccc;transition:.1s;border-radius:34px",".switch-slider:before":"position:absolute;content:%22%22;height:12px;width:12px;left:1px;top:2px;background-color:white;transition:.1s;border-radius:50%25","input:checked + .switch-slider":"background-color:%232196F3","input:focus + .switch-slider":"box-shadow:0%200%201px%20%232196F3","input:checked + .switch-slider:before":"transform:translateX(12px)","input:disabled + .switch-slider":"opacity:0.5"};var Gs={disable_theme_rules:!1,input_size:"normal",custom_forms:!1,object_indent:!0,object_background:"bg-light",object_text:"",table_border:!1,table_zebrastyle:!1,tooltip:"bootstrap"},$s=function(t){function e(t){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Hs(this,e,[t,Gs])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Us(t,e)}(e,t),r=e,(n=[{key:"getSelectInput",value:function(t,r){var n=Ms(qs(e.prototype),"getSelectInput",this).call(this,t);return n.classList.add("form-control"),!1===this.options.custom_forms?("small"===this.options.input_size&&n.classList.add("form-control-sm"),"large"===this.options.input_size&&n.classList.add("form-control-lg")):(n.classList.remove("form-control"),n.classList.add("custom-select"),"small"===this.options.input_size&&n.classList.add("custom-select-sm"),"large"===this.options.input_size&&n.classList.add("custom-select-lg")),n}},{key:"getContainer",value:function(){var t=document.createElement("div");return this.options.object_indent||t.classList.add("je-noindent"),t}},{key:"getOptInSwitch",value:function(t){var e=this.getHiddenLabel(t+" opt-in");e.setAttribute("for",t+"-opt-in");var r=document.createElement("div");r.classList.add("custom-control","custom-switch","d-inline-block","fs-6");var n=document.createElement("input");n.setAttribute("type","checkbox"),n.setAttribute("id",t+"-opt-in"),n.classList.add("custom-control-input","json-editor-opt-in");var i=document.createElement("label");i.setAttribute("for",t+"-opt-in"),i.classList.add("custom-control-label");var o=document.createElement("span");return o.classList.add("sr-only"),o.textContent=t+"-opt-in",i.appendChild(o),r.appendChild(n),r.appendChild(i),{label:e,checkbox:n,container:r}}},{key:"setGridColumnSize",value:function(t,e,r){t.classList.add("col-md-".concat(e)),r&&t.classList.add("offset-md-".concat(r))}},{key:"afterInputReady",value:function(t){if(!t.controlgroup){var e=t.name;t.id=e;var r=t.parentNode.parentNode.getElementsByTagName("label")[0];r&&(r.htmlFor=e),t.controlgroup=this.closest(t,".form-group")}}},{key:"getTextareaInput",value:function(){var t=document.createElement("textarea");return t.classList.add("form-control"),"small"===this.options.input_size&&t.classList.add("form-control-sm"),"large"===this.options.input_size&&t.classList.add("form-control-lg"),t}},{key:"getRangeInput",value:function(t,r,n,i,o){var a=Ms(qs(e.prototype),"getRangeInput",this).call(this,t,r,n,i,o);return!0===this.options.custom_forms&&(a.classList.remove("form-control"),a.classList.add("custom-range")),a}},{key:"getStepperButtons",value:function(t){var e=document.createElement("div"),r=document.createElement("div"),n=document.createElement("div"),i=document.createElement("button");i.setAttribute("type","button");var o=document.createElement("button");o.setAttribute("type","button"),e.appendChild(r),e.appendChild(t),e.appendChild(n),r.appendChild(i),n.appendChild(o),e.classList.add("input-group"),r.classList.add("input-group-prepend"),n.classList.add("input-group-append"),i.classList.add("btn"),i.classList.add("btn-secondary"),i.classList.add("stepper-down"),o.classList.add("btn"),o.classList.add("btn-secondary"),o.classList.add("stepper-up"),t.getAttribute("readonly")&&(i.setAttribute("disabled",!0),o.setAttribute("disabled",!0)),i.textContent="-",o.textContent="+";var a=function(t,e){t.value=Number(e||t.value),t.setAttribute("initialized","1")},s=t.getAttribute("min"),l=t.getAttribute("max");return t.addEventListener("change",(function(){t.getAttribute("initialized")||t.setAttribute("initialized","1")})),i.addEventListener("click",(function(){t.getAttribute("initialized")?s?Number(t.value)>Number(s)&&t.stepDown():t.stepDown():a(t,s),c(t,"change")})),o.addEventListener("click",(function(){t.getAttribute("initialized")?l?Number(t.value)<Number(l)&&t.stepUp():t.stepUp():a(t,s),c(t,"change")})),e}},{key:"getFormInputField",value:function(t){var r=Ms(qs(e.prototype),"getFormInputField",this).call(this,t);return"checkbox"!==t&&"radio"!==t&&"file"!==t&&(r.classList.add("form-control"),"small"===this.options.input_size&&r.classList.add("form-control-sm"),"large"===this.options.input_size&&r.classList.add("form-control-lg")),"file"===t&&r.classList.add("form-control-file"),r}},{key:"getHiddenLabel",value:function(t){var e=document.createElement("label");return e.textContent=t,e.classList.add("sr-only"),e}},{key:"visuallyHidden",value:function(t){t&&t.classList.add("sr-only")}},{key:"getHiddenText",value:function(t){var e=document.createElement("span");return e.textContent=t,e.classList.add("sr-only"),e}},{key:"getFormControl",value:function(t,e,r,n,i){var o=document.createElement("div");if(o.classList.add("form-group"),!t||"checkbox"!==e.type&&"radio"!==e.type)t&&(o.appendChild(t),n&&o.appendChild(n)),o.appendChild(e);else{var a=document.createElement("div");!1===this.options.custom_forms?(a.classList.add("form-check"),e.classList.add("form-check-input"),t.classList.add("form-check-label")):(a.classList.add("custom-control"),e.classList.add("custom-control-input"),t.classList.add("custom-control-label"),"checkbox"===e.type?a.classList.add("custom-checkbox"):a.classList.add("custom-radio")),a.appendChild(e),a.appendChild(t),n&&a.appendChild(n),o.appendChild(a)}return r&&o.appendChild(r),"div"!==e.tagName.toLowerCase()&&e&&t&&i&&(t.setAttribute("for",i),e.setAttribute("id",i)),"div"!==e.tagName.toLowerCase()&&e&&r&&(r.setAttribute("id",i+"-description"),e.setAttribute("aria-describedby",i+"-description")),o}},{key:"getInfoButton",value:function(t){var e=document.createElement("button");e.type="button",e.classList.add("ml-3","jsoneditor-twbs4-text-button"),e.setAttribute("data-toggle","tooltip"),e.setAttribute("data-placement","auto"),e.title=t;var r=document.createTextNode("â");return e.appendChild(r),"bootstrap"===this.options.tooltip?window.jQuery&&window.jQuery().tooltip?window.jQuery(e).tooltip():console.warn("Could not find popper jQuery plugin of Bootstrap."):"css"===this.options.tooltip&&e.classList.add("je-tooltip"),e}},{key:"getCheckbox",value:function(){return this.getFormInputField("checkbox")}},{key:"getMultiCheckboxHolder",value:function(t,e,r,n){var i=document.createElement("div");i.classList.add("form-group"),e&&(i.appendChild(e),n&&e.appendChild(n));var o=document.createElement("div");return Object.values(t).forEach((function(t){var e=t.firstChild;o.appendChild(e)})),i.appendChild(o),r&&i.appendChild(r),i}},{key:"getFormRadio",value:function(t){var e=this.getFormInputField("radio");for(var r in t)e.setAttribute(r,t[r]);return!1===this.options.custom_forms?e.classList.add("form-check-input"):e.classList.add("custom-control-input"),e}},{key:"getFormRadioLabel",value:function(t,e){var r=document.createElement("label");return!1===this.options.custom_forms?r.classList.add("form-check-label"):r.classList.add("custom-control-label"),r.appendChild(document.createTextNode(t)),r}},{key:"getFormRadioControl",value:function(t,e,r){var n=document.createElement("div");return!1===this.options.custom_forms?n.classList.add("form-check"):n.classList.add("custom-control","custom-radio"),n.appendChild(e),n.appendChild(t),r&&(!1===this.options.custom_forms?n.classList.add("form-check-inline"):n.classList.add("custom-control-inline")),n}},{key:"getIndentedPanel",value:function(){var t=document.createElement("div");return t.classList.add("card","card-body","mb-3"),this.options.object_background&&t.classList.add(this.options.object_background),this.options.object_text&&t.classList.add(this.options.object_text),t}},{key:"getFormInputDescription",value:function(t){var e=document.createElement("small");return e.classList.add("form-text"),window.DOMPurify?e.innerHTML=window.DOMPurify.sanitize(t):e.textContent=this.cleanText(t),e}},{key:"getHeader",value:function(t,e){var r=document.createElement("span");return r.classList.add("h3"),r.classList.add("card-title"),r.classList.add("level-"+e),"string"==typeof t?r.textContent=t:r.appendChild(t),r.style.display="inline-block",r}},{key:"getHeaderButtonHolder",value:function(){return this.getButtonHolder()}},{key:"getButtonHolder",value:function(){var t=document.createElement("span");return t.classList.add("btn-group"),t}},{key:"getFormButtonHolder",value:function(t){var e=this.getButtonHolder();return e.classList.add("d-block"),"center"===t?e.classList.add("text-center"):"right"===t&&e.classList.add("text-right"),e}},{key:"getButton",value:function(t,r,n){var i=Ms(qs(e.prototype),"getButton",this).call(this,t,r,n);return i.classList.add("btn","btn-secondary","btn-sm"),i}},{key:"getTableContainer",value:function(){var t=Ms(qs(e.prototype),"getTableContainer",this).call(this);return t.classList.add("table-responsive"),t}},{key:"getTable",value:function(){var t=document.createElement("table");return t.classList.add("table","table-sm"),this.options.table_border&&t.classList.add("table-bordered"),this.options.table_zebrastyle&&t.classList.add("table-striped"),t}},{key:"getErrorMessage",value:function(t){var e=document.createElement("div");return e.classList.add("alert","alert-danger"),e.setAttribute("role","alert"),e.appendChild(document.createTextNode(t)),e}},{key:"addInputError",value:function(t,e){t.controlgroup&&(t.controlgroup.classList.add("is-invalid"),t.errmsg||(t.errmsg=document.createElement("p"),t.errmsg.classList.add("invalid-feedback"),t.controlgroup.appendChild(t.errmsg),t.errmsg.style.display="block"),t.errmsg.style.display="block",t.errmsg.textContent=e,t.errmsg.setAttribute("role","alert"))}},{key:"removeInputError",value:function(t){t.errmsg&&(t.errmsg.style.display="none",t.controlgroup.classList.remove("is-invalid"))}},{key:"getTabHolder",value:function(t){var e=document.createElement("div"),r=void 0===t?"":t;return e.innerHTML="<div class='col-md-2' id='".concat(r,"'><ul class='nav flex-column nav-pills'></ul></div><div class='col-md-10'><div class='tab-content' id='").concat(r,"'></div></div>"),e.classList.add("row"),e}},{key:"addTab",value:function(t,e){t.children[0].children[0].appendChild(e)}},{key:"getTabContentHolder",value:function(t){return t.children[1].children[0]}},{key:"getTopTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.classList.add("card"),r.innerHTML="<div class='card-header'><ul class='nav nav-tabs card-header-tabs' id='".concat(e,"'></ul></div><div class='card-body'><div class='tab-content' id='").concat(e,"'></div></div>"),r}},{key:"getTab",value:function(t,e){var r=document.createElement("li");r.classList.add("nav-item");var n=document.createElement("a");return n.classList.add("nav-link"),n.setAttribute("href","#".concat(e)),n.setAttribute("data-toggle","tab"),n.appendChild(t),r.appendChild(n),r}},{key:"getTopTab",value:function(t,e){var r=document.createElement("li");r.classList.add("nav-item");var n=document.createElement("a");return n.classList.add("nav-link"),n.setAttribute("href","#".concat(e)),n.setAttribute("data-toggle","tab"),n.appendChild(t),r.appendChild(n),r}},{key:"getTabContent",value:function(){var t=document.createElement("div");return t.classList.add("tab-pane"),t.setAttribute("role","tabpanel"),t}},{key:"getTopTabContent",value:function(){var t=document.createElement("div");return t.classList.add("tab-pane"),t.setAttribute("role","tabpanel"),t}},{key:"markTabActive",value:function(t){t.tab.firstChild.classList.add("active"),void 0!==t.rowPane?t.rowPane.classList.add("active"):t.container.classList.add("active")}},{key:"markTabInactive",value:function(t){t.tab.firstChild.classList.remove("active"),void 0!==t.rowPane?t.rowPane.classList.remove("active"):t.container.classList.remove("active")}},{key:"insertBasicTopTab",value:function(t,e){e.children[0].children[0].insertBefore(t,e.children[0].children[0].firstChild)}},{key:"addTopTab",value:function(t,e){t.children[0].children[0].appendChild(e)}},{key:"getTopTabContentHolder",value:function(t){return t.children[1].children[0]}},{key:"getFirstTab",value:function(t){return t.firstChild.firstChild.firstChild}},{key:"getProgressBar",value:function(){var t=document.createElement("div");t.classList.add("progress");var e=document.createElement("div");return e.classList.add("progress-bar"),e.setAttribute("role","progressbar"),e.setAttribute("aria-valuenow",0),e.setAttribute("aria-valuemin",0),e.setAttribute("aria-valuenax",100),e.innerHTML="".concat(0,"%"),t.appendChild(e),t}},{key:"updateProgressBar",value:function(t,e){if(t){var r=t.firstChild,n="".concat(e,"%");r.setAttribute("aria-valuenow",e),r.style.width=n,r.innerHTML=n}}},{key:"updateProgressBarUnknown",value:function(t){if(t){var e=t.firstChild;t.classList.add("progress","progress-striped","active"),e.removeAttribute("aria-valuenow"),e.style.width="100%",e.innerHTML=""}}},{key:"getBlockLink",value:function(){var t=document.createElement("a");return t.classList.add("mb-3","d-inline-block"),t}},{key:"getLinksHolder",value:function(){return document.createElement("div")}},{key:"getInputGroup",value:function(t,e){if(t){var r=document.createElement("div");r.classList.add("input-group"),r.appendChild(t);var n=document.createElement("div");n.classList.add("input-group-append"),r.appendChild(n);for(var i=0;i<e.length;i++)e[i].classList.remove("mr-2","btn-secondary"),e[i].classList.add("btn-outline-secondary"),n.appendChild(e[i]);return r}}}])&&Fs(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(bs);function Js(t){return Js="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Js(t)}function Ws(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Zs(n.key),n)}}function Zs(t){var e=function(t,e){if("object"!=Js(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Js(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Js(e)?e:e+""}function Ys(t,e,r){return e=Xs(e),function(t,e){if(e&&("object"===Js(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Qs()?Reflect.construct(e,r||[],Xs(t).constructor):e.apply(t,r))}function Qs(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Qs=function(){return!!t})()}function Ks(){return Ks="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Xs(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Ks.apply(this,arguments)}function Xs(t){return Xs=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Xs(t)}function tl(t,e){return tl=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},tl(t,e)}$s.rules={".jsoneditor-twbs4-text-button":"background:none;padding:0;border:0;color:currentColor","td > .form-group":"margin-bottom:0",".json-editor-btn-upload":"margin-top:1rem",".je-noindent .card":"padding:0;border:0",".je-tooltip:hover::before":"display:block;position:absolute;font-size:0.8em;color:%23fff;border-radius:0.2em;content:attr(title);background-color:%23000;margin-top:-2.5em;padding:0.3em",".je-tooltip:hover::after":"display:block;position:absolute;font-size:0.8em;color:%23fff",".select2-container--default .select2-selection--single":"height:calc(1.5em%20%2B%200.75rem%20%2B%202px)",".select2-container--default   .select2-selection--single   .select2-selection__arrow":"height:calc(1.5em%20%2B%200.75rem%20%2B%202px)",".select2-container--default   .select2-selection--single   .select2-selection__rendered":"line-height:calc(1.5em%20%2B%200.75rem%20%2B%202px)",".selectize-control.form-control":"padding:0",".selectize-dropdown.form-control":"padding:0;height:auto",".je-upload-preview img":"float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem",".je-dropzone":"position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s",".je-dropzone:before":"position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)",".je-dropzone.valid-dropzone":"background:green",".je-dropzone.invalid-dropzone":"background:red"};var el={disable_theme_rules:!1,input_size:"normal",object_indent:!0,object_background:"bg-light",object_text:"",table_border:!1,table_zebrastyle:!1,tooltip:"bootstrap"},rl=function(t){function e(t){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Ys(this,e,[t,el])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&tl(t,e)}(e,t),r=e,(n=[{key:"getSelectInput",value:function(t,r){var n=Ks(Xs(e.prototype),"getSelectInput",this).call(this,t);return n.classList.add("form-control"),n.classList.add("form-select"),"small"===this.options.input_size&&n.classList.add("form-control-sm"),"large"===this.options.input_size&&n.classList.add("form-control-lg"),n}},{key:"getContainer",value:function(){var t=document.createElement("div");return this.options.object_indent||t.classList.add("je-noindent"),t}},{key:"getOptInSwitch",value:function(t){var e=this.getHiddenLabel(t+" opt-in");e.setAttribute("for",t+"-opt-in");var r=document.createElement("div");r.classList.add("form-check","form-switch","d-inline-block","fs-6");var n=document.createElement("input");n.setAttribute("type","checkbox"),n.setAttribute("role","switch"),n.setAttribute("id",t+"-opt-in"),n.classList.add("form-check-input","json-editor-opt-in");var i=document.createElement("label");i.setAttribute("for",t+"-opt-in"),i.classList.add("form-check-label");var o=document.createElement("span");return o.classList.add("visually-hidden"),o.textContent=t+"-opt-in",i.appendChild(o),r.appendChild(n),r.appendChild(i),{label:e,checkbox:n,container:r}}},{key:"setGridColumnSize",value:function(t,e,r){t.classList.add("col-md-".concat(e)),r&&t.classList.add("offset-md-".concat(r))}},{key:"afterInputReady",value:function(t){if(!t.controlgroup){var e=t.name;t.id=e;var r=t.parentNode.parentNode.getElementsByTagName("label")[0];r&&(r.classList.add("form-label"),r.htmlFor=e),t.controlgroup=this.closest(t,".form-group")}}},{key:"getTextareaInput",value:function(){var t=document.createElement("textarea");return t.classList.add("form-control"),"small"===this.options.input_size&&t.classList.add("form-control-sm"),"large"===this.options.input_size&&t.classList.add("form-control-lg"),t}},{key:"getRangeInput",value:function(t,r,n,i,o){var a=Ks(Xs(e.prototype),"getRangeInput",this).call(this,t,r,n,i,o);return a.classList.remove("form-control"),a.classList.add("form-range"),a}},{key:"getStepperButtons",value:function(t){var e=document.createElement("div"),r=document.createElement("button");r.setAttribute("type","button");var n=document.createElement("button");n.setAttribute("type","button"),e.appendChild(r),e.appendChild(t),e.appendChild(n),e.classList.add("input-group"),r.classList.add("btn"),r.classList.add("btn-secondary"),r.classList.add("stepper-down"),n.classList.add("btn"),n.classList.add("btn-secondary"),n.classList.add("stepper-up"),t.getAttribute("readonly")&&(r.setAttribute("disabled",!0),n.setAttribute("disabled",!0)),r.textContent="-",n.textContent="+";var i=function(t,e){t.value=Number(e||t.value),t.setAttribute("initialized","1")},o=t.getAttribute("min"),a=t.getAttribute("max");return t.addEventListener("change",(function(){t.getAttribute("initialized")||t.setAttribute("initialized","1")})),r.addEventListener("click",(function(){t.getAttribute("initialized")?o?Number(t.value)>Number(o)&&t.stepDown():t.stepDown():i(t,o),c(t,"change")})),n.addEventListener("click",(function(){t.getAttribute("initialized")?a?Number(t.value)<Number(a)&&t.stepUp():t.stepUp():i(t,o),c(t,"change")})),e}},{key:"getFormInputField",value:function(t){var r=Ks(Xs(e.prototype),"getFormInputField",this).call(this,t);return"checkbox"!==t&&"radio"!==t&&(r.classList.add("form-control"),"small"===this.options.input_size&&r.classList.add("form-control-sm"),"large"===this.options.input_size&&r.classList.add("form-control-lg")),r}},{key:"getFormControl",value:function(t,e,r,n,i){var o=document.createElement("div");if(o.classList.add("form-group"),!t||"checkbox"!==e.type&&"radio"!==e.type)t&&(t.classList.add("form-label"),o.appendChild(t),n&&o.appendChild(n)),o.appendChild(e);else{var a=document.createElement("div");a.classList.add("form-check"),e.classList.add("form-check-input"),t.classList.add("form-check-label"),"div"!==e.tagName.toLowerCase()&&e&&t&&i&&(t.setAttribute("for",i),e.setAttribute("id",i)),"div"!==e.tagName.toLowerCase()&&e&&r&&(r.setAttribute("id",i+"-description"),e.setAttribute("aria-describedby",i+"-description")),a.appendChild(e),a.appendChild(t),n&&a.appendChild(n),o.appendChild(a)}return r&&o.appendChild(r),o}},{key:"getHiddenLabel",value:function(t){var e=document.createElement("label");return e.textContent=t,e.classList.add("visually-hidden"),e}},{key:"visuallyHidden",value:function(t){t&&t.classList.add("visually-hidden")}},{key:"getHiddenText",value:function(t){var e=document.createElement("span");return e.textContent=t,e.classList.add("sr-only"),e}},{key:"getInfoButton",value:function(t){var e=document.createElement("button");e.type="button",e.classList.add("ms-3","jsoneditor-twbs5-text-button"),e.setAttribute("data-toggle","tooltip"),e.setAttribute("data-placement","auto"),e.title=t;var r=document.createTextNode("â");return e.appendChild(r),"bootstrap"===this.options.tooltip?window.jQuery&&window.jQuery().tooltip?window.jQuery(e).tooltip():console.warn("Could not find popper jQuery plugin of Bootstrap."):"css"===this.options.tooltip&&e.classList.add("je-tooltip"),e}},{key:"getCheckbox",value:function(){return this.getFormInputField("checkbox")}},{key:"getMultiCheckboxHolder",value:function(t,e,r,n){var i=document.createElement("div");i.classList.add("form-group"),e&&(i.appendChild(e),n&&e.appendChild(n));var o=document.createElement("div");return Object.values(t).forEach((function(t){var e=t.firstChild;o.appendChild(e)})),i.appendChild(o),r&&i.appendChild(r),i}},{key:"getFormRadio",value:function(t){var e=this.getFormInputField("radio");for(var r in t)e.setAttribute(r,t[r]);return e.classList.add("form-check-input"),e}},{key:"getFormRadioLabel",value:function(t,e){var r=document.createElement("label");return r.classList.add("form-check-label"),r.appendChild(document.createTextNode(t)),r}},{key:"getFormRadioControl",value:function(t,e,r){var n=document.createElement("div");return n.classList.add("form-check"),n.appendChild(e),n.appendChild(t),r&&n.classList.add("form-check-inline"),n}},{key:"getIndentedPanel",value:function(){var t=document.createElement("div");return t.classList.add("card","card-body","my-3"),this.options.object_background&&t.classList.add(this.options.object_background),this.options.object_text&&t.classList.add(this.options.object_text),t}},{key:"getFormInputDescription",value:function(t){var e=document.createElement("small");return e.classList.add("form-text"),e.classList.add("d-block"),window.DOMPurify?e.innerHTML=window.DOMPurify.sanitize(t):e.textContent=this.cleanText(t),e}},{key:"getHeader",value:function(t,e){var r=document.createElement("span");return r.classList.add("h3"),r.classList.add("card-title"),r.classList.add("level-"+e),"string"==typeof t?r.textContent=t:r.appendChild(t),r.style.display="inline-block",r}},{key:"getHeaderButtonHolder",value:function(){return this.getButtonHolder()}},{key:"getButtonHolder",value:function(){var t=document.createElement("span");return t.classList.add("btn-group"),t}},{key:"getFormButtonHolder",value:function(t){var e=this.getButtonHolder();return e.classList.add("d-block"),"center"===t?e.classList.add("text-center"):"right"===t&&e.classList.add("text-end"),e}},{key:"getButton",value:function(t,r,n){var i=Ks(Xs(e.prototype),"getButton",this).call(this,t,r,n);return i.classList.add("btn","btn-secondary","btn-sm"),i}},{key:"getTableContainer",value:function(){var t=Ks(Xs(e.prototype),"getTableContainer",this).call(this);return t.classList.add("table-responsive"),t}},{key:"getTable",value:function(){var t=document.createElement("table");return t.classList.add("table","table-sm"),this.options.table_border&&t.classList.add("table-bordered"),this.options.table_zebrastyle&&t.classList.add("table-striped"),t}},{key:"getErrorMessage",value:function(t){var e=document.createElement("div");return e.classList.add("alert","alert-danger"),e.setAttribute("role","alert"),e.appendChild(document.createTextNode(t)),e}},{key:"addInputError",value:function(t,e){t.controlgroup&&(t.controlgroup.classList.add("is-invalid"),t.errmsg||(t.errmsg=document.createElement("p"),t.errmsg.classList.add("invalid-feedback"),t.controlgroup.appendChild(t.errmsg),t.errmsg.style.display="block"),t.errmsg.style.display="block",t.errmsg.textContent=e,t.errmsg.setAttribute("role","alert"))}},{key:"removeInputError",value:function(t){t.errmsg&&(t.errmsg.style.display="none",t.controlgroup.classList.remove("is-invalid"))}},{key:"getTabHolder",value:function(t){var e=document.createElement("div"),r=void 0===t?"":t;return e.innerHTML="<div class='col-md-2' id='".concat(r,"'><ul class='nav flex-column nav-pills'></ul></div><div class='col-md-10'><div class='tab-content' id='").concat(r,"'></div></div>"),e.classList.add("row"),e}},{key:"addTab",value:function(t,e){t.children[0].children[0].appendChild(e)}},{key:"getTabContentHolder",value:function(t){return t.children[1].children[0]}},{key:"getTopTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.classList.add("card"),r.innerHTML="<div class='card-header'><ul class='nav nav-tabs card-header-tabs' id='".concat(e,"'></ul></div><div class='card-body'><div class='tab-content' id='").concat(e,"'></div></div>"),r}},{key:"getTab",value:function(t,e){var r=document.createElement("li");r.classList.add("nav-item");var n=document.createElement("a");return n.classList.add("nav-link"),n.setAttribute("href","#".concat(e)),n.setAttribute("data-toggle","tab"),n.appendChild(t),r.appendChild(n),r}},{key:"getTopTab",value:function(t,e){var r=document.createElement("li");r.classList.add("nav-item");var n=document.createElement("a");return n.classList.add("nav-link"),n.setAttribute("href","#".concat(e)),n.setAttribute("data-toggle","tab"),n.appendChild(t),r.appendChild(n),r}},{key:"getTabContent",value:function(){var t=document.createElement("div");return t.classList.add("tab-pane"),t.setAttribute("role","tabpanel"),t}},{key:"getTopTabContent",value:function(){var t=document.createElement("div");return t.classList.add("tab-pane"),t.setAttribute("role","tabpanel"),t}},{key:"markTabActive",value:function(t){t.tab.firstChild.classList.add("active"),void 0!==t.rowPane?t.rowPane.classList.add("active"):t.container.classList.add("active")}},{key:"markTabInactive",value:function(t){t.tab.firstChild.classList.remove("active"),void 0!==t.rowPane?t.rowPane.classList.remove("active"):t.container.classList.remove("active")}},{key:"insertBasicTopTab",value:function(t,e){e.children[0].children[0].insertBefore(t,e.children[0].children[0].firstChild)}},{key:"addTopTab",value:function(t,e){t.children[0].children[0].appendChild(e)}},{key:"getTopTabContentHolder",value:function(t){return t.children[1].children[0]}},{key:"getFirstTab",value:function(t){return t.firstChild.firstChild.firstChild}},{key:"getProgressBar",value:function(){var t=document.createElement("div");t.classList.add("progress");var e=document.createElement("div");return e.classList.add("progress-bar"),e.setAttribute("role","progressbar"),e.setAttribute("aria-valuenow",0),e.setAttribute("aria-valuemin",0),e.setAttribute("aria-valuenax",100),e.innerHTML="".concat(0,"%"),t.appendChild(e),t}},{key:"updateProgressBar",value:function(t,e){if(t){var r=t.firstChild,n="".concat(e,"%");r.setAttribute("aria-valuenow",e),r.style.width=n,r.innerHTML=n}}},{key:"updateProgressBarUnknown",value:function(t){if(t){var e=t.firstChild;t.classList.add("progress","progress-striped","active"),e.removeAttribute("aria-valuenow"),e.style.width="100%",e.innerHTML=""}}},{key:"getBlockLink",value:function(){var t=document.createElement("a");return t.classList.add("mb-3","d-inline-block"),t}},{key:"getLinksHolder",value:function(){return document.createElement("div")}},{key:"getInputGroup",value:function(t,e){if(t){var r=document.createElement("div");r.classList.add("input-group"),r.appendChild(t);for(var n=0;n<e.length;n++)e[n].classList.remove("me-2","btn-secondary"),e[n].classList.add("btn-outline-secondary"),r.appendChild(e[n]);return r}}}])&&Ws(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(bs);function nl(t){return nl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},nl(t)}function il(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,ol(n.key),n)}}function ol(t){var e=function(t,e){if("object"!=nl(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=nl(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==nl(e)?e:e+""}function al(t,e,r){return e=cl(e),function(t,e){if(e&&("object"===nl(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,sl()?Reflect.construct(e,r||[],cl(t).constructor):e.apply(t,r))}function sl(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(sl=function(){return!!t})()}function ll(){return ll="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=cl(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},ll.apply(this,arguments)}function cl(t){return cl=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},cl(t)}function ul(t,e){return ul=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},ul(t,e)}rl.rules={".form-group":"margin-bottom:1rem",".form-text":"display:block",".jsoneditor-twbs5-text-button":"background:none;padding:0;border:0;color:currentColor","td > .form-group":"margin-bottom:0",".json-editor-btn-upload":"margin-top:1rem",".je-noindent .card":"padding:0;border:0",".je-tooltip:hover::before":"display:block;position:absolute;font-size:0.8em;color:%23fff;border-radius:0.2em;content:attr(title);background-color:%23000;margin-top:-2.5em;padding:0.3em",".je-tooltip:hover::after":"display:block;position:absolute;font-size:0.8em;color:%23fff",".select2-container--default .select2-selection--single":"height:calc(1.5em%20%2B%200.75rem%20%2B%202px)",".select2-container--default   .select2-selection--single   .select2-selection__arrow":"height:calc(1.5em%20%2B%200.75rem%20%2B%202px)",".select2-container--default   .select2-selection--single   .select2-selection__rendered":"line-height:calc(1.5em%20%2B%200.75rem%20%2B%202px)",".selectize-control.form-control":"padding:0",".selectize-dropdown.form-control":"padding:0;height:auto",".je-upload-preview img":"float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem",".je-dropzone":"position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s",".je-dropzone:before":"position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)",".je-dropzone.valid-dropzone":"background:green",".je-dropzone.invalid-dropzone":"background:red"};var hl=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),al(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&ul(t,e)}(e,t),r=e,(n=[{key:"getTable",value:function(){var t=ll(cl(e.prototype),"getTable",this).call(this);return t.setAttribute("cellpadding",5),t.setAttribute("cellspacing",0),t}},{key:"getTableHeaderCell",value:function(t){var r=ll(cl(e.prototype),"getTableHeaderCell",this).call(this,t);return r.classList.add("ui-state-active"),r.style.fontWeight="bold",r}},{key:"getTableCell",value:function(){var t=ll(cl(e.prototype),"getTableCell",this).call(this);return t.classList.add("ui-widget-content"),t}},{key:"getHeaderButtonHolder",value:function(){var t=this.getButtonHolder();return t.style.marginLeft="10px",t.style.fontSize=".6em",t.style.display="inline-block",t}},{key:"getFormInputDescription",value:function(t){var e=this.getDescription(t);return e.style.marginLeft="10px",e.style.display="inline-block",e}},{key:"getFormControl",value:function(t,r,n,i){var o=ll(cl(e.prototype),"getFormControl",this).call(this,t,r,n,i);return"checkbox"===r.type?(o.style.lineHeight="25px",o.style.padding="3px 0"):o.style.padding="4px 0 8px 0",o}},{key:"getDescription",value:function(t){var e=document.createElement("span");return e.style.fontSize=".8em",e.style.fontStyle="italic",window.DOMPurify?e.innerHTML=window.DOMPurify.sanitize(t):e.textContent=this.cleanText(t),e}},{key:"getButtonHolder",value:function(){var t=document.createElement("div");return t.classList.add("ui-buttonset"),t.style.fontSize=".7em",t}},{key:"getFormInputLabel",value:function(t,e){var r=document.createElement("label");return r.style.fontWeight="bold",r.style.display="block",r.textContent=t,e&&r.classList.add("required"),r}},{key:"getButton",value:function(t,e,r){var n=document.createElement("button");n.classList.add("ui-button","ui-widget","ui-state-default","ui-corner-all"),e&&!t?(n.classList.add("ui-button-icon-only"),e.classList.add("ui-button-icon-primary","ui-icon-primary"),n.appendChild(e)):e?(n.classList.add("ui-button-text-icon-primary"),e.classList.add("ui-button-icon-primary","ui-icon-primary"),n.appendChild(e)):n.classList.add("ui-button-text-only");var i=document.createElement("span");return i.classList.add("ui-button-text"),i.textContent=t||r||".",n.appendChild(i),n.setAttribute("title",r),n}},{key:"setButtonText",value:function(t,e,r,n){t.innerHTML="",t.classList.add("ui-button","ui-widget","ui-state-default","ui-corner-all"),r&&!e?(t.classList.add("ui-button-icon-only"),r.classList.add("ui-button-icon-primary","ui-icon-primary"),t.appendChild(r)):r?(t.classList.add("ui-button-text-icon-primary"),r.classList.add("ui-button-icon-primary","ui-icon-primary"),t.appendChild(r)):t.classList.add("ui-button-text-only");var i=document.createElement("span");i.classList.add("ui-button-text"),i.textContent=e||n||".",t.appendChild(i),t.setAttribute("title",n)}},{key:"getIndentedPanel",value:function(){var t=document.createElement("div");return t.classList.add("ui-widget-content","ui-corner-all"),t.style.padding="1em 1.4em",t.style.marginBottom="20px",t}},{key:"afterInputReady",value:function(t){if(!t.controls&&(t.controls=this.closest(t,".form-control"),this.queuedInputErrorText)){var e=this.queuedInputErrorText;delete this.queuedInputErrorText,this.addInputError(t,e)}}},{key:"addInputError",value:function(t,e){t.controls?(t.errmsg?t.errmsg.style.display="":(t.errmsg=document.createElement("div"),t.errmsg.classList.add("ui-state-error"),t.controls.appendChild(t.errmsg)),t.errmsg.textContent=e):this.queuedInputErrorText=e}},{key:"removeInputError",value:function(t){t.controls||delete this.queuedInputErrorText,t.errmsg&&(t.errmsg.style.display="none")}},{key:"markTabActive",value:function(t){t.tab.classList.remove("ui-widget-header"),t.tab.classList.add("ui-state-active"),void 0!==t.rowPane?t.rowPane.style.display="":t.container.style.display=""}},{key:"markTabInactive",value:function(t){t.tab.classList.add("ui-widget-header"),t.tab.classList.remove("ui-state-active"),void 0!==t.rowPane?t.rowPane.style.display="none":t.container.style.display="none"}}])&&il(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(bs);function pl(t){return pl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},pl(t)}function dl(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,fl(n.key),n)}}function fl(t){var e=function(t,e){if("object"!=pl(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=pl(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==pl(e)?e:e+""}function yl(t,e,r){return e=vl(e),function(t,e){if(e&&("object"===pl(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,ml()?Reflect.construct(e,r||[],vl(t).constructor):e.apply(t,r))}function ml(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(ml=function(){return!!t})()}function vl(t){return vl=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},vl(t)}function bl(t,e){return bl=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},bl(t,e)}hl.rules={'div[data-schemaid="root"]:after':'position:relative;color:red;margin:10px 0;font-weight:600;display:block;width:100%;text-align:center;content:"This is an old JSON-Editor 1.x Theme and might not display elements correctly when used with the 2.x version"'};var gl=function(t){function e(){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),yl(this,e,arguments)}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&bl(t,e)}(e,t),r=e,(n=[{key:"addInputError",value:function(t,e){if(t.errmsg)t.errmsg.style.display="block";else{var r=this.closest(t,".form-control");t.errmsg=document.createElement("div"),t.errmsg.setAttribute("class","errmsg"),r.nodeName&&r.appendChild(t.errmsg)}t.errmsg.innerHTML="",t.errmsg.appendChild(document.createTextNode(e)),t.errmsg.setAttribute("role","alert")}},{key:"removeInputError",value:function(t){t.style&&(t.style.borderColor=""),t.errmsg&&(t.errmsg.style.display="none")}}])&&dl(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(bs);function wl(t){return wl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},wl(t)}function _l(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,kl(n.key),n)}}function kl(t){var e=function(t,e){if("object"!=wl(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=wl(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==wl(e)?e:e+""}function jl(t,e,r){return e=Cl(e),function(t,e){if(e&&("object"===wl(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Ol()?Reflect.construct(e,r||[],Cl(t).constructor):e.apply(t,r))}function Ol(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Ol=function(){return!!t})()}function xl(){return xl="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Cl(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},xl.apply(this,arguments)}function Cl(t){return Cl=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Cl(t)}function El(t,e){return El=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},El(t,e)}gl.rules={".je-upload-preview img":"float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem",".je-dropzone":"position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s",".je-dropzone:before":"position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)",".je-dropzone.valid-dropzone":"background:green",".je-dropzone.invalid-dropzone":"background:red"};var Sl={disable_theme_rules:!1,label_bold:!0,align_bottom:!1,object_indent:!1,object_border:!1,table_border:!1,table_zebrastyle:!1,input_size:"normal"},Pl=function(t){function e(t){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),jl(this,e,[t,Sl])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&El(t,e)}(e,t),r=e,(n=[{key:"getOptInSwitch",value:function(t){var e=document.createElement("span");e.classList.add("form-group");var r=document.createElement("label");r.classList.add("form-switch","d-inline-block");var n=document.createElement("input");n.setAttribute("type","checkbox"),n.setAttribute("id",t+"-opt-in"),n.classList.add("json-editor-opt-in");var i=document.createElement("i");i.classList.add("form-icon");var o=document.createElement("span");return o.classList.add("sr-only"),o.textContent=t+"-opt-in",r.appendChild(o),r.appendChild(n),r.appendChild(i),e.appendChild(r),{label:r,checkbox:n,container:e}}},{key:"setGridColumnSize",value:function(t,e,r){t.classList.add("col-".concat(e)),r&&t.classList.add("col-mx-auto")}},{key:"getGridContainer",value:function(){var t=document.createElement("div");return t.classList.add("container"),this.options.object_indent||t.classList.add("je-noindent"),t}},{key:"getGridRow",value:function(){var t=document.createElement("div");return t.classList.add("columns"),t}},{key:"getGridColumn",value:function(){var t=document.createElement("div");return t.classList.add("column"),this.options.align_bottom&&t.classList.add("je-align-bottom"),t}},{key:"getIndentedPanel",value:function(){var t=document.createElement("div");return t.classList.add("je-panel"),this.options.object_border&&t.classList.add("je-border"),t}},{key:"getTopIndentedPanel",value:function(){var t=document.createElement("div");return t.classList.add("je-panel-top"),this.options.object_border&&t.classList.add("je-border"),t}},{key:"getHeaderButtonHolder",value:function(){return this.getButtonHolder()}},{key:"getButtonHolder",value:function(){var t=xl(Cl(e.prototype),"getButtonHolder",this).call(this);return t.classList.add("btn-group"),t}},{key:"getFormButtonHolder",value:function(t){var r=xl(Cl(e.prototype),"getFormButtonHolder",this).call(this);return r.classList.remove("btn-group"),r.classList.add("d-block"),"center"===t?r.classList.add("text-center"):"right"===t?r.classList.add("text-right"):r.classList.add("text-left"),r}},{key:"getFormButton",value:function(t,r,n){var i=xl(Cl(e.prototype),"getFormButton",this).call(this,t,r,n);return i.classList.add("btn","btn-primary","mx-2","my-1"),"small"!==this.options.input_size&&i.classList.remove("btn-sm"),"large"===this.options.input_size&&i.classList.add("btn-lg"),i}},{key:"getButton",value:function(t,r,n){var i=xl(Cl(e.prototype),"getButton",this).call(this,t,r,n);return i.classList.add("btn","btn-sm","btn-primary","mr-2","my-1"),i}},{key:"getHeader",value:function(t,e){var r=document.createElement("span");return"string"==typeof t?r.textContent=t:r.appendChild(t),r.style.display="inline-block",r}},{key:"getFormInputDescription",value:function(t){var r=xl(Cl(e.prototype),"getFormInputDescription",this).call(this,t);return r.classList.add("je-desc","hide-sm"),r}},{key:"getFormInputLabel",value:function(t,r){var n=xl(Cl(e.prototype),"getFormInputLabel",this).call(this,t,r);return this.options.label_bold&&n.classList.add("je-label"),n}},{key:"getCheckbox",value:function(){return this.getFormInputField("checkbox")}},{key:"getCheckboxLabel",value:function(t,r){var n=xl(Cl(e.prototype),"getCheckboxLabel",this).call(this,t,r),i=document.createElement("i");return i.classList.add("form-icon"),n.classList.add("form-checkbox","pr-0"),n.insertBefore(i,n.firstChild),n}},{key:"getFormCheckboxControl",value:function(t,e,r){return t.insertBefore(e,t.firstChild),r&&t.classList.add("form-inline"),t}},{key:"getMultiCheckboxHolder",value:function(t,r,n,i){return xl(Cl(e.prototype),"getMultiCheckboxHolder",this).call(this,t,r,n,i)}},{key:"getFormRadio",value:function(t){var e=this.getFormInputField("radio");for(var r in t)e.setAttribute(r,t[r]);return e}},{key:"getFormRadioLabel",value:function(t,r){var n=xl(Cl(e.prototype),"getFormRadioLabel",this).call(this,t,r),i=document.createElement("i");return i.classList.add("form-icon"),n.classList.add("form-radio"),n.insertBefore(i,n.firstChild),n}},{key:"getFormRadioControl",value:function(t,e,r){return t.insertBefore(e,t.firstChild),r&&t.classList.add("form-inline"),t}},{key:"getFormInputField",value:function(t){var r=xl(Cl(e.prototype),"getFormInputField",this).call(this,t);return["checkbox","radio"].includes(t)||r.classList.add("form-input"),r}},{key:"getRangeInput",value:function(t,r,n,i,o){var a=xl(Cl(e.prototype),"getRangeInput",this).call(this,t,r,n,i,o);return a.classList.add("slider"),a.classList.remove("form-input"),a.setAttribute("oninput",'this.setAttribute("value", this.value)'),a}},{key:"getRangeControl",value:function(t,r){var n=xl(Cl(e.prototype),"getRangeControl",this).call(this,t,r);return n.classList.add("text-center"),n}},{key:"getSelectInput",value:function(t,r){var n=xl(Cl(e.prototype),"getSelectInput",this).call(this,t);return n.classList.add("form-select"),n}},{key:"getTextareaInput",value:function(){var t=document.createElement("textarea");return t.classList.add("form-input"),t}},{key:"getFormControl",value:function(t,e,r,n,i){var o=document.createElement("div");return o.classList.add("form-group"),!t||"checkbox"!==e.type&&"radio"!==e.type?(t&&(t.classList.add("form-label"),o.appendChild(t),n&&t.appendChild(n)),o.appendChild(e)):(o.classList.add(e.type),n&&t.appendChild(n),t.insertBefore(e,t.firstChild),o.appendChild(t)),"small"===this.options.input_size?e.classList.add("input-sm","select-sm"):"large"===this.options.input_size&&e.classList.add("input-lg","select-lg"),"checkbox"!==e.type&&o.appendChild(e),r&&o.appendChild(r),"div"!==e.tagName.toLowerCase()&&e&&t&&i&&(t.setAttribute("for",i),e.setAttribute("id",i)),"div"!==e.tagName.toLowerCase()&&e&&r&&(r.setAttribute("id",i+"-description"),e.setAttribute("aria-describedby",i+"-description")),o}},{key:"getInputGroup",value:function(t,e){if(t){var r=document.createElement("div");r.classList.add("input-group"),r.appendChild(t);for(var n=0;n<e.length;n++)e[n].classList.add("input-group-btn"),e[n].classList.remove("btn-sm","mr-2","my-1"),r.appendChild(e[n]);return r}}},{key:"getInfoButton",value:function(t){var e=document.createElement("div");e.classList.add("popover","popover-left","float-right");var r=document.createElement("button");r.classList.add("btn","btn-secondary","btn-info","btn-action","s-circle"),r.setAttribute("tabindex","-1"),e.appendChild(r);var n=document.createTextNode("I");r.appendChild(n);var i=document.createElement("div");i.classList.add("popover-container"),e.appendChild(i);var o=document.createElement("div");o.classList.add("card"),i.appendChild(o);var a=document.createElement("div");return a.classList.add("card-body"),a.innerHTML=t,o.appendChild(a),e}},{key:"getTable",value:function(){var t=xl(Cl(e.prototype),"getTable",this).call(this);return t.classList.add("table","table-scroll"),this.options.table_border&&t.classList.add("je-table-border"),this.options.table_zebrastyle&&t.classList.add("table-striped"),t}},{key:"getProgressBar",value:function(){var t=xl(Cl(e.prototype),"getProgressBar",this).call(this);return t.classList.add("progress"),t}},{key:"getTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.classList.add("columns"),r.innerHTML='<div class="column col-2"></div><div class="column col-10 content" id="'.concat(e,'"></div>'),r}},{key:"getTopTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.innerHTML='<ul class="tab"></ul><div class="content" id="'.concat(e,'"></div>'),r}},{key:"getTab",value:function(t,e){var r=document.createElement("a");return r.classList.add("btn","btn-secondary","btn-block"),r.setAttribute("href","#".concat(e)),r.appendChild(t),r}},{key:"getTopTab",value:function(t,e){var r=document.createElement("li");r.id=e,r.classList.add("tab-item");var n=document.createElement("a");return n.setAttribute("href","#".concat(e)),n.appendChild(t),r.appendChild(n),r}},{key:"markTabActive",value:function(t){t.tab.classList.add("active"),void 0!==t.rowPane?t.rowPane.style.display="":t.container.style.display=""}},{key:"markTabInactive",value:function(t){t.tab.classList.remove("active"),void 0!==t.rowPane?t.rowPane.style.display="none":t.container.style.display="none"}},{key:"afterInputReady",value:function(t){if("select"===t.localName)if(t.classList.contains("selectized")){var e=t.nextSibling;e&&(e.classList.remove("form-select"),Array.from(e.querySelectorAll(".form-select")).forEach((function(t){t.classList.remove("form-select")})))}else if(t.classList.contains("select2-hidden-accessible")){var r=t.nextSibling;r&&r.querySelector(".select2-selection--single")&&r.classList.add("form-select")}t.controlgroup||(t.controlgroup=this.closest(t,".form-group"),this.closest(t,".compact")&&(t.controlgroup.style.marginBottom=0))}},{key:"addInputError",value:function(t,e){t.controlgroup&&(t.controlgroup.classList.add("has-error"),t.errmsg||(t.errmsg=document.createElement("p"),t.errmsg.classList.add("form-input-hint"),t.controlgroup.appendChild(t.errmsg)),t.errmsg.classList.remove("d-hide"),t.errmsg.textContent=e,t.errmsg.setAttribute("role","alert"))}},{key:"removeInputError",value:function(t){t.errmsg&&(t.errmsg.classList.add("d-hide"),t.controlgroup.classList.remove("has-error"))}}])&&_l(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(bs);function Ll(t){return Ll="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ll(t)}function Tl(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Al(n.key),n)}}function Al(t){var e=function(t,e){if("object"!=Ll(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Ll(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Ll(e)?e:e+""}function Rl(t,e,r){return e=Nl(e),function(t,e){if(e&&("object"===Ll(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,Il()?Reflect.construct(e,r||[],Nl(t).constructor):e.apply(t,r))}function Il(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(Il=function(){return!!t})()}function Bl(){return Bl="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,r){var n=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Nl(t)););return t}(t,e);if(n){var i=Object.getOwnPropertyDescriptor(n,e);return i.get?i.get.call(arguments.length<3?t:r):i.value}},Bl.apply(this,arguments)}function Nl(t){return Nl=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Nl(t)}function Dl(t,e){return Dl=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},Dl(t,e)}Pl.rules={"*":"--primary-color:%235755d9;--gray-color:%23bcc3ce;--light-color:%23fff",".slider:focus":"box-shadow:none","h4 > label + .btn-group":"margin-left:1rem",".text-right > button":"margin-right:0%20!important",".text-left > button":"margin-left:0%20!important",".property-selector":"font-size:0.7rem;font-weight:normal;max-height:260px%20!important;width:395px%20!important",".property-selector .form-checkbox":"margin:0",textarea:"width:100%25;min-height:2rem;resize:vertical",table:"border-collapse:collapse",".table td":"padding:0.4rem%200.4rem",".mr-5":"margin-right:1rem%20!important","div[data-schematype]:not([data-schematype='object'])":"transition:0.5s","div[data-schematype]:not([data-schematype='object']):hover":"background-color:%23eee",".je-table-border td":"border:0.05rem%20solid%20%23dadee4%20!important",".btn-info":"font-size:0.5rem;font-weight:bold;height:0.8rem;padding:0.15rem%200;line-height:0.8;margin:0.3rem%200%200.3rem%200.1rem",".je-label + select":"min-width:5rem",".je-label":"font-weight:600",".btn-action.btn-info":"width:0.8rem",".je-border":"border:0.05rem%20solid%20%23dadee4",".je-panel":"padding:0.2rem;margin:0.2rem;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)",".je-panel-top":"padding:0.2rem;margin:0.2rem;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)",".required:after":"content:%22%20*%22;color:red;font:inherit",".je-align-bottom":"margin-top:auto",".je-desc":"font-size:smaller;margin:0.2rem%200",".je-upload-preview img":"float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem;border:3px%20solid%20white;box-shadow:0px%200px%208px%20rgba(0%2C%200%2C%200%2C%200.3);box-sizing:border-box",".je-dropzone":"position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s",".je-dropzone:before":"position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)",".je-dropzone.valid-dropzone":"background:green",".je-dropzone.invalid-dropzone":"background:red",".columns .container.je-noindent":"padding-left:0;padding-right:0",".selectize-control.multi .item":"background:var(--primary-color)%20!important",".select2-container--default   .select2-selection--single   .select2-selection__arrow":"display:none",".select2-container--default .select2-selection--single":"border:none",".select2-container .select2-selection--single .select2-selection__rendered":"padding:0",".select2-container .select2-search--inline .select2-search__field":"margin-top:0",".select2-container--default.select2-container--focus   .select2-selection--multiple":"border:0.05rem%20solid%20var(--gray-color)",".select2-container--default   .select2-selection--multiple   .select2-selection__choice":"margin:0.4rem%200.2rem%200.2rem%200;padding:2px%205px;background-color:var(--primary-color);color:var(--light-color)",".select2-container--default .select2-search--inline .select2-search__field":"line-height:normal",".choices":"margin-bottom:auto",".choices__list--multiple .choices__item":"border:none;background-color:var(--primary-color);color:var(--light-color)",".choices[data-type*='select-multiple'] .choices__button":"border-left:0.05rem%20solid%20%232826a6",".choices__inner":"font-size:inherit;min-height:20px;padding:4px%207.5px%204px%203.75px",".choices[data-type*='select-one'] .choices__inner":"padding-bottom:4px",".choices__list--dropdown .choices__item":"font-size:inherit"};var Fl={disable_theme_rules:!1,label_bold:!1,object_panel_default:!0,object_indent:!0,object_border:!1,table_border:!1,table_hdiv:!1,table_zebrastyle:!1,input_size:"small",enable_compact:!1},Vl=function(t){function e(t){return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),Rl(this,e,[t,Fl])}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&Dl(t,e)}(e,t),r=e,(n=[{key:"getOptInSwitch",value:function(t){var e=this.getHiddenLabel(t+" opt-in");e.setAttribute("for",t+"-opt-in");var r=document.createElement("label");r.classList.add("switch");var n=document.createElement("input");n.setAttribute("type","checkbox"),n.setAttribute("id",t+"-opt-in"),n.classList.add("json-editor-opt-in");var i=document.createElement("span");i.classList.add("switch-slider","round");var o=document.createElement("span");return o.classList.add("sr-only"),o.textContent=t+"-opt-in",r.appendChild(o),r.appendChild(n),r.appendChild(i),{label:e,checkbox:n,container:r}}},{key:"getGridContainer",value:function(){var t=document.createElement("div");return t.classList.add("flex","flex-col","w-full"),this.options.object_indent||t.classList.add("je-noindent"),t}},{key:"getGridRow",value:function(){var t=document.createElement("div");return t.classList.add("flex","flex-wrap","w-full"),t}},{key:"getGridColumn",value:function(){var t=document.createElement("div");return t.classList.add("flex","flex-col"),t}},{key:"setGridColumnSize",value:function(t,e,r){e>0&&e<12?t.classList.add("w-".concat(e,"/12"),"px-1"):t.classList.add("w-full","px-1"),r&&(t.style.marginLeft="".concat(100/12*r,"%"))}},{key:"getIndentedPanel",value:function(){var t=document.createElement("div");return this.options.object_panel_default?t.classList.add("w-full","p-1"):t.classList.add("relative","flex","flex-col","rounded","break-words","border","bg-white","border-0","border-blue-400","p-1","shadow-md"),this.options.object_border&&t.classList.add("je-border"),t}},{key:"getTopIndentedPanel",value:function(){var t=document.createElement("div");return this.options.object_panel_default?t.classList.add("w-full","m-2"):t.classList.add("relative","flex","flex-col","rounded","break-words","border","bg-white","border-0","border-blue-400","p-1","shadow-md"),this.options.object_border&&t.classList.add("je-border"),t}},{key:"getTitle",value:function(){return this.translateProperty(this.schema.title)}},{key:"getSelectInput",value:function(t,r){var n=Bl(Nl(e.prototype),"getSelectInput",this).call(this,t);return r?n.classList.add("form-multiselect","block","py-0","h-auto","w-full","px-1","text-sm","text-black","leading-normal","bg-white","border","border-grey","rounded"):n.classList.add("form-select","block","py-0","h-6","w-full","px-1","text-sm","text-black","leading-normal","bg-white","border","border-grey","rounded"),this.options.enable_compact&&n.classList.add("compact"),n}},{key:"afterInputReady",value:function(t){t.controlgroup||(t.controlgroup=this.closest(t,".form-group"),this.closest(t,".compact")&&(t.controlgroup.style.marginBottom=0))}},{key:"getTextareaInput",value:function(){var t=Bl(Nl(e.prototype),"getTextareaInput",this).call(this);return t.classList.add("block","w-full","px-1","text-sm","leading-normal","bg-white","text-black","border","border-grey","rounded"),this.options.enable_compact&&t.classList.add("compact"),t.style.height=0,t}},{key:"getRangeInput",value:function(t,e,r){var n=this.getFormInputField("range");return n.classList.add("slider"),this.options.enable_compact&&n.classList.add("compact"),n.setAttribute("oninput",'this.setAttribute("value", this.value)'),n.setAttribute("min",t),n.setAttribute("max",e),n.setAttribute("step",r),n}},{key:"getRangeControl",value:function(t,r){var n=Bl(Nl(e.prototype),"getRangeControl",this).call(this,t,r);return n.classList.add("text-center","text-black"),n}},{key:"getCheckbox",value:function(){var t=this.getFormInputField("checkbox");return t.classList.add("form-checkbox","text-red-600"),t}},{key:"getCheckboxLabel",value:function(t,r){var n=Bl(Nl(e.prototype),"getCheckboxLabel",this).call(this,t,r);return n.classList.add("inline-flex","items-center"),n}},{key:"getFormCheckboxControl",value:function(t,e,r){return t.insertBefore(e,t.firstChild),r&&t.classList.add("inline-flex flex-row"),t}},{key:"getMultiCheckboxHolder",value:function(t,r,n,i){var o=Bl(Nl(e.prototype),"getMultiCheckboxHolder",this).call(this,t,r,n,i);return o.classList.add("inline-flex","flex-col"),o}},{key:"getFormRadio",value:function(t){var e=this.getFormInputField("radio");for(var r in e.classList.add("form-radio","text-red-600"),t)e.setAttribute(r,t[r]);return e}},{key:"getFormRadioLabel",value:function(t,r){var n=Bl(Nl(e.prototype),"getFormRadioLabel",this).call(this,t,r);return n.classList.add("inline-flex","items-center","mr-2"),n}},{key:"getFormRadioControl",value:function(t,e,r){return t.insertBefore(e,t.firstChild),r&&t.classList.add("form-radio"),t}},{key:"getRadioHolder",value:function(t,r,n,i,o){var a=Bl(Nl(e.prototype),"getRadioHolder",this).call(this,r,n,i,o);return"h"===t.options.layout?a.classList.add("inline-flex","flex-row"):a.classList.add("inline-flex","flex-col"),a}},{key:"getFormInputLabel",value:function(t,r){var n=Bl(Nl(e.prototype),"getFormInputLabel",this).call(this,t,r);return this.options.label_bold?n.classList.add("font-bold"):n.classList.add("required"),n}},{key:"getFormInputField",value:function(t){var r=Bl(Nl(e.prototype),"getFormInputField",this).call(this,t);return["checkbox","radio"].includes(t)||r.classList.add("block","w-full","px-1","text-black","text-sm","leading-normal","bg-white","border","border-grey","rounded"),this.options.enable_compact&&r.classList.add("compact"),r}},{key:"getFormInputDescription",value:function(t){var e=document.createElement("p");return e.classList.add("block","mt-1","text-xs"),window.DOMPurify?e.innerHTML=window.DOMPurify.sanitize(t):e.textContent=this.cleanText(t),e}},{key:"getFormControl",value:function(t,e,r,n){var i=document.createElement("div");return i.classList.add("form-group","mb-1","w-full"),t&&(t.classList.add("text-xs"),"checkbox"===e.type&&(e.classList.add("form-checkbox","text-xs","text-red-600","mr-1"),t.classList.add("items-center","flex"),t=this.getFormCheckboxControl(t,e,!1,n)),"radio"===e.type&&(e.classList.add("form-radio","text-red-600","mr-1"),t.classList.add("items-center","flex"),t=this.getFormRadioControl(t,e,!1,n)),i.appendChild(t),!["checkbox","radio"].includes(e.type)&&n&&i.appendChild(n)),["checkbox","radio"].includes(e.type)||("small"===this.options.input_size?e.classList.add("text-xs"):"normal"===this.options.input_size?e.classList.add("text-base"):"large"===this.options.input_size&&e.classList.add("text-xl"),i.appendChild(e)),r&&i.appendChild(r),i}},{key:"getHeaderButtonHolder",value:function(){var t=this.getButtonHolder();return t.classList.add("text-sm"),t}},{key:"getButtonHolder",value:function(){var t=document.createElement("div");return t.classList.add("flex","relative","inline-flex","align-middle"),t}},{key:"getButton",value:function(t,r,n){var i=Bl(Nl(e.prototype),"getButton",this).call(this,t,r,n);return i.classList.add("inline-block","align-middle","text-center","text-sm","bg-blue-700","text-white","py-1","pr-1","m-2","shadow","select-none","whitespace-no-wrap","rounded"),i}},{key:"getInfoButton",value:function(t){var e=document.createElement("a");e.classList.add("tooltips","float-right"),e.innerHTML="â";var r=document.createElement("span");return r.innerHTML=t,e.appendChild(r),e}},{key:"getTable",value:function(){var t=Bl(Nl(e.prototype),"getTable",this).call(this);return this.options.table_border?t.classList.add("je-table-border"):t.classList.add("table","border","p-0"),t}},{key:"getTableRow",value:function(){var t=Bl(Nl(e.prototype),"getTableRow",this).call(this);return this.options.table_border&&t.classList.add("je-table-border"),this.options.table_zebrastyle&&t.classList.add("je-table-zebra"),t}},{key:"getTableHeaderCell",value:function(t){var r=Bl(Nl(e.prototype),"getTableHeaderCell",this).call(this,t);return this.options.table_border?r.classList.add("je-table-border"):this.options.table_hdiv?r.classList.add("je-table-hdiv"):r.classList.add("text-xs","border","p-0","m-0"),r}},{key:"getTableCell",value:function(){var t=Bl(Nl(e.prototype),"getTableCell",this).call(this);return this.options.table_border?t.classList.add("je-table-border"):this.options.table_hdiv?t.classList.add("je-table-hdiv"):t.classList.add("border-0","p-0","m-0"),t}},{key:"addInputError",value:function(t,e){t.controlgroup&&(t.controlgroup.classList.add("has-error"),t.controlgroup.classList.add("text-red-600"),t.errmsg?t.errmsg.style.display="":(t.errmsg=document.createElement("p"),t.errmsg.classList.add("block","mt-1","text-xs","text-red"),t.controlgroup.appendChild(t.errmsg)),t.errmsg.textContent=e)}},{key:"removeInputError",value:function(t){t.errmsg&&(t.errmsg.style.display="none",t.controlgroup.classList.remove("text-red-600"),t.controlgroup.classList.remove("has-error"))}},{key:"getTabHolder",value:function(t){var e=document.createElement("div"),r=void 0===t?"":t;return e.innerHTML="<div class='w-2/12' id='".concat(r,"'><ul class='list-reset pl-0 mb-0'></ul></div><div class='w-10/12' id='").concat(r,"'></div>"),e.classList.add("flex"),e}},{key:"addTab",value:function(t,e){t.children[0].children[0].appendChild(e)}},{key:"getTopTabHolder",value:function(t){var e=void 0===t?"":t,r=document.createElement("div");return r.innerHTML="<ul class='nav-tabs flex list-reset pl-0 mb-0 border-b border-grey-light' id='".concat(e,"'></ul><div class='p-6 block' id='").concat(e,"'></div>"),r}},{key:"getTab",value:function(t,e){var r=document.createElement("li");r.classList.add("nav-item","flex-col","text-center","text-white","bg-blue-500","shadow-md","border","p-2","mb-2","mr-2","hover:bg-blue-400","rounded");var n=document.createElement("a");return n.classList.add("nav-link","text-center"),n.setAttribute("href","#".concat(e)),n.setAttribute("data-toggle","tab"),n.appendChild(t),r.appendChild(n),r}},{key:"getTopTab",value:function(t,e){var r=document.createElement("li");r.classList.add("nav-item","flex","border-l","border-t","border-r");var n=document.createElement("a");return n.classList.add("nav-link","-mb-px","flex-row","text-center","bg-white","p-2","hover:bg-blue-400","rounded-t"),n.setAttribute("href","#".concat(e)),n.setAttribute("data-toggle","tab"),n.appendChild(t),r.appendChild(n),r}},{key:"getTabContent",value:function(){var t=document.createElement("div");return t.setAttribute("role","tabpanel"),t}},{key:"getTopTabContent",value:function(){var t=document.createElement("div");return t.setAttribute("role","tabpanel"),t}},{key:"markTabActive",value:function(t){t.tab.firstChild.classList.add("block"),!0===t.tab.firstChild.classList.contains("border-b")?(t.tab.firstChild.classList.add("border-b-0"),t.tab.firstChild.classList.remove("border-b")):t.tab.firstChild.classList.add("border-b-0"),!0===t.container.classList.contains("hidden")?(t.container.classList.remove("hidden"),t.container.classList.add("block")):t.container.classList.add("block")}},{key:"markTabInactive",value:function(t){!0===t.tab.firstChild.classList.contains("border-b-0")?(t.tab.firstChild.classList.add("border-b"),t.tab.firstChild.classList.remove("border-b-0")):t.tab.firstChild.classList.add("border-b"),!0===t.container.classList.contains("block")&&(t.container.classList.remove("block"),t.container.classList.add("hidden"))}},{key:"getProgressBar",value:function(){var t=document.createElement("div");t.classList.add("progress");var e=document.createElement("div");return e.classList.add("bg-blue","leading-none","py-1","text-xs","text-center","text-white"),e.setAttribute("role","progressbar"),e.setAttribute("aria-valuenow",0),e.setAttribute("aria-valuemin",0),e.setAttribute("aria-valuenax",100),e.innerHTML="".concat(0,"%"),t.appendChild(e),t}},{key:"updateProgressBar",value:function(t,e){if(t){var r=t.firstChild,n="".concat(e,"%");r.setAttribute("aria-valuenow",e),r.style.width=n,r.innerHTML=n}}},{key:"updateProgressBarUnknown",value:function(t){if(t){var e=t.firstChild;t.classList.add("progress","bg-blue","leading-none","py-1","text-xs","text-center","text-white","block"),e.removeAttribute("aria-valuenow"),e.classList.add("w-full"),e.innerHTML=""}}},{key:"getInputGroup",value:function(t,e){if(t){var r=document.createElement("div");r.classList.add("relative","items-stretch","w-full"),r.appendChild(t);var n=document.createElement("div");n.classList.add("-mr-1"),r.appendChild(n);for(var i=0;i<e.length;i++)n.appendChild(e[i]);return r}}}])&&Tl(r.prototype,n),Object.defineProperty(r,"prototype",{writable:!1}),r;var r,n}(bs);Vl.rules={".slider":"-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;display:block;border:none;height:1.2rem;width:100%25",".slider:focus":"box-shadow:0%200%200%200%20rgba(87%2C%2085%2C%20217%2C%200.2);outline:none",".slider.tooltip:not([data-tooltip])::after":"content:attr(value)",".slider::-webkit-slider-thumb":"-webkit-appearance:none;background:%23f17405;border-radius:100%25;height:0.6rem;margin-top:-0.25rem;transition:transform%200.2s;width:0.6rem",".slider:active::-webkit-slider-thumb":"transform:scale(1.25);outline:none",".slider::-webkit-slider-runnable-track":"background:%23b2b4b6;border-radius:0.1rem;height:0.1rem;width:100%25","a.tooltips":"position:relative;display:inline","a.tooltips span":"position:absolute;white-space:nowrap;width:auto;padding-left:1rem;padding-right:1rem;color:%23ffffff;background:rgba(56%2C%2056%2C%2056%2C%200.85);height:1.5rem;line-height:1.5rem;text-align:center;visibility:hidden;border-radius:3px","a.tooltips span:after":"content:%22%22;position:absolute;top:50%25;left:100%25;margin-top:-5px;width:0;height:0;border-left:5px%20solid%20rgba(56%2C%2056%2C%2056%2C%200.85);border-top:5px%20solid%20transparent;border-bottom:5px%20solid%20transparent","a:hover.tooltips span":"visibility:visible;opacity:0.9;font-size:0.8rem;right:100%25;top:50%25;margin-top:-12px;margin-right:10px;z-index:999",".json-editor-btntype-properties + div":"font-size:0.8rem;font-weight:normal",textarea:"width:100%25;min-height:2rem;resize:vertical",table:"width:100%25;border-collapse:collapse",".table td":"padding:0rem%200rem","div[data-schematype]:not([data-schematype='object'])":"transition:0.5s","div[data-schematype]:not([data-schematype='object']):hover":"background-color:%23e6f4fe","div[data-schemaid='root']":"position:relative;width:inherit;display:inherit;overflow-x:hidden;z-index:10","select[multiple]":"height:auto","select[multiple].from-select":"height:auto",".je-table-zebra:nth-child(even)":"background-color:%23f2f2f2",".je-table-border":"border:0.5px%20solid%20black",".je-table-hdiv":"border-bottom:1px%20solid%20black",".je-border":"border:0.05rem%20solid%20%233182ce",".je-panel":"width:inherit;padding:0.2rem;margin:0.2rem;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)",".je-panel-top":"width:100%25;padding:0.2rem;margin:0.2rem;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)",".required:after":"content:%22%20*%22;color:red;font:inherit;font-weight:bold",".je-desc":"font-size:smaller;margin:0.2rem%200",".container-xl.je-noindent":"padding-left:0;padding-right:0",".json-editor-btntype-add":"color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%234299e1;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)",".json-editor-btntype-deletelast":"color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%23e53e3e;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)",".json-editor-btntype-deleteall":"color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%23000000;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)",".json-editor-btn-save":"float:right;color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%232b6cb0;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)",".json-editor-btn-back":"color:white;margin:0.3rem;padding:0.3rem%200.8rem;background-color:%232b6cb0;box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-webkit-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2);-moz-box-shadow:3px%203px%205px%201px%20rgba(4%2C%204%2C%204%2C%200.2)",".json-editor-btntype-delete":"color:%23e53e3e;background-color:rgba(218%2C%20222%2C%20228%2C%200.1);margin:0.03rem;padding:0.1rem",".json-editor-btntype-move":"color:%23000000;background-color:rgba(218%2C%20222%2C%20228%2C%200.1);margin:0.03rem;padding:0.1rem",".json-editor-btn-collapse":"padding:0em%200.8rem;font-size:1.3rem;color:%23e53e3e;background-color:rgba(218%2C%20222%2C%20228%2C%200.1)",".je-upload-preview img":"float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem",".je-dropzone":"position:relative;margin:0.5rem%200;border:2px%20dashed%20black;width:100%25;height:60px;background:teal;transition:all%200.5s",".je-dropzone:before":"position:absolute;content:attr(data-text);color:rgba(0%2C%200%2C%200%2C%200.6);left:50%25;top:50%25;transform:translate(-50%25%2C%20-50%25)",".je-dropzone.valid-dropzone":"background:green",".je-dropzone.invalid-dropzone":"background:red",".switch":"position:relative;display:inline-block;width:28px;height:16px;margin-right:10px",".switch input":"opacity:0;width:0;height:0",".switch-slider":"position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:%23ccc;transition:.1s;border-radius:34px",".switch-slider:before":"position:absolute;content:%22%22;height:12px;width:12px;left:1px;top:2px;background-color:white;transition:.1s;border-radius:50%25","input:checked + .switch-slider":"background-color:%232196F3","input:focus + .switch-slider":"box-shadow:0%200%201px%20%232196F3","input:checked + .switch-slider:before":"transform:translateX(12px)","input:disabled + .switch-slider":"opacity:0.5"};var Hl={html:Es,bootstrap3:Ns,bootstrap4:$s,bootstrap5:rl,jqueryui:hl,barebones:gl,spectre:Pl,tailwind:Vl};const zl={".table-responsive .autocomplete-result-list":"position:relative%20!important",".je-float-right-linkholder":"float:right;margin-left:10px",".je-modal":"background-color:white;border:1px%20solid%20black;box-shadow:3px%203px%20black;position:absolute;z-index:10",".je-infobutton-icon":"font-size:16px;font-weight:bold;padding:0.25rem;position:relative;display:inline-block",".je-infobutton-tooltip":"font-size:12px;font-weight:normal;font-family:sans-serif;visibility:hidden;background-color:rgba(50%2C%2050%2C%2050%2C%200.75);margin:0%200.25rem;color:%23fafafa;padding:0.5rem%201rem;border-radius:0.25rem;width:20rem;position:absolute",".je-not-loaded":"pointer-events:none",".je-header":"display:inline-block",".je-upload-preview img":"float:left;margin:0%200.5rem%200.5rem%200;max-width:100%25;max-height:5rem",".je-checkbox":"display:inline-block;width:auto",".je-checkbox-control--compact":"display:inline-block;margin-right:1rem",".je-radio":"display:inline-block;width:auto",".je-radio-control--compact":"display:inline-block;margin-right:1rem",".je-switcher":"background-color:transparent;display:inline-block;font-style:italic;font-weight:normal;height:auto;width:auto;margin-bottom:0;margin-left:5px;padding:0%200%200%203px",".je-textarea":"width:100%25;height:300px;box-sizing:border-box",".je-range-control":"text-align:center",".je-indented-panel":"padding-left:10px;margin-left:10px;border-left:1px%20solid%20%23ccc",".je-indented-panel--top":"padding-left:10px;margin-left:10px",".je-tabholder":"float:left;width:130px",".je-tabholder .content":"margin-left:120px",".je-tabholder--top":"margin-left:10px",".je-tabholder--clear":"clear:both",".je-tab":"border:1px%20solid%20%23ccc;border-width:1px%200%201px%201px;text-align:center;line-height:30px;border-radius:5px;border-bottom-right-radius:0;border-top-right-radius:0;font-weight:bold;cursor:pointer",".je-tab--top":"float:left;border:1px%20solid%20%23ccc;border-width:1px%201px%200px%201px;text-align:center;line-height:30px;border-radius:5px;padding-left:5px;padding-right:5px;border-bottom-right-radius:0;border-bottom-left-radius:0;font-weight:bold;cursor:pointer",".je-block-link":"display:block",".je-media":"width:100%25"};function Ml(t){return Ml="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ml(t)}function ql(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Ul(){Ul=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,i=Object.defineProperty||function(t,e,r){t[e]=r.value},o="function"==typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",s=o.asyncIterator||"@@asyncIterator",l=o.toStringTag||"@@toStringTag";function c(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{c({},"")}catch(t){c=function(t,e,r){return t[e]=r}}function u(t,e,r,n){var o=e&&e.prototype instanceof v?e:v,a=Object.create(o.prototype),s=new L(n||[]);return i(a,"_invoke",{value:C(t,r,s)}),a}function h(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=u;var p="suspendedStart",d="suspendedYield",f="executing",y="completed",m={};function v(){}function b(){}function g(){}var w={};c(w,a,(function(){return this}));var _=Object.getPrototypeOf,k=_&&_(_(T([])));k&&k!==r&&n.call(k,a)&&(w=k);var j=g.prototype=v.prototype=Object.create(w);function O(t){["next","throw","return"].forEach((function(e){c(t,e,(function(t){return this._invoke(e,t)}))}))}function x(t,e){function r(i,o,a,s){var l=h(t[i],t,o);if("throw"!==l.type){var c=l.arg,u=c.value;return u&&"object"==Ml(u)&&n.call(u,"__await")?e.resolve(u.__await).then((function(t){r("next",t,a,s)}),(function(t){r("throw",t,a,s)})):e.resolve(u).then((function(t){c.value=t,a(c)}),(function(t){return r("throw",t,a,s)}))}s(l.arg)}var o;i(this,"_invoke",{value:function(t,n){function i(){return new e((function(e,i){r(t,n,e,i)}))}return o=o?o.then(i,i):i()}})}function C(e,r,n){var i=p;return function(o,a){if(i===f)throw Error("Generator is already running");if(i===y){if("throw"===o)throw a;return{value:t,done:!0}}for(n.method=o,n.arg=a;;){var s=n.delegate;if(s){var l=E(s,n);if(l){if(l===m)continue;return l}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(i===p)throw i=y,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);i=f;var c=h(e,r,n);if("normal"===c.type){if(i=n.done?y:d,c.arg===m)continue;return{value:c.arg,done:n.done}}"throw"===c.type&&(i=y,n.method="throw",n.arg=c.arg)}}}function E(e,r){var n=r.method,i=e.iterator[n];if(i===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,E(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),m;var o=h(i,e.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,m;var a=o.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,m):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,m)}function S(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function P(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function L(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(S,this),this.reset(!0)}function T(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var i=-1,o=function r(){for(;++i<e.length;)if(n.call(e,i))return r.value=e[i],r.done=!1,r;return r.value=t,r.done=!0,r};return o.next=o}}throw new TypeError(Ml(e)+" is not iterable")}return b.prototype=g,i(j,"constructor",{value:g,configurable:!0}),i(g,"constructor",{value:b,configurable:!0}),b.displayName=c(g,l,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===b||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,g):(t.__proto__=g,c(t,l,"GeneratorFunction")),t.prototype=Object.create(j),t},e.awrap=function(t){return{__await:t}},O(x.prototype),c(x.prototype,s,(function(){return this})),e.AsyncIterator=x,e.async=function(t,r,n,i,o){void 0===o&&(o=Promise);var a=new x(u(t,r,n,i),o);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},O(j),c(j,l,"Generator"),c(j,a,(function(){return this})),c(j,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function t(){for(;r.length;){var n=r.pop();if(n in e)return t.value=n,t.done=!1,t}return t.done=!0,t}},e.values=T,L.prototype={constructor:L,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(P),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function i(n,i){return s.type="throw",s.arg=e,r.next=n,i&&(r.method="next",r.arg=t),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],s=a.completion;if("root"===a.tryLoc)return i("end");if(a.tryLoc<=this.prev){var l=n.call(a,"catchLoc"),c=n.call(a,"finallyLoc");if(l&&c){if(this.prev<a.catchLoc)return i(a.catchLoc,!0);if(this.prev<a.finallyLoc)return i(a.finallyLoc)}else if(l){if(this.prev<a.catchLoc)return i(a.catchLoc,!0)}else{if(!c)throw Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return i(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&n.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,m):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),m},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),P(r),m}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;P(r)}return i}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:T(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),m}},e}function Gl(t,e,r,n,i,o,a){try{var s=t[o](a),l=s.value}catch(t){return void r(t)}s.done?e(l):Promise.resolve(l).then(n,i)}function $l(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,Jl(n.key),n)}}function Jl(t){var e=function(t,e){if("object"!=Ml(t)||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,"string");if("object"!=Ml(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==Ml(e)?e:e+""}var Wl=function(){function t(e){var r=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),!(e instanceof Element))throw new Error("element should be an instance of Element");this.element=e,this.options=l({},t.defaults.options,n),this.ready=!1,this.copyClipboard=null,this.schema=this.options.schema,this.template=this.options.template,this.translate=this.options.translate||t.defaults.translate,this.translateProperty=this.options.translateProperty||t.defaults.translateProperty,this.uuid=0,this.__data={};var i=this.options.theme||t.defaults.theme,o=t.defaults.themes[i];if(!o)throw new Error("Unknown theme ".concat(i));this.element.setAttribute("data-theme",i),this.element.classList.add("je-not-loaded"),this.element.classList.remove("je-ready"),this.theme=new o(this);var a=l(zl,this.getEditorsRules()),s=function(t,e,n){return n?r.addNewStyleRulesToShadowRoot(t,e,n):r.addNewStyleRules(t,e)};if(!this.theme.options.disable_theme_rules){var c=u(this.element);s("default",a,c),void 0!==o.rules&&s(i,o.rules,c)}var h=t.defaults.iconlibs[this.options.iconlib||t.defaults.iconlib];h&&(this.iconlib=new h),this.root_container=this.theme.getContainer(),this.element.appendChild(this.root_container),this.promise=this.load()}return e=t,r=[{key:"load",value:(n=Ul().mark((function e(){var r,n,i,o,a,s,l=this;return Ul().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return r=document.location.origin+document.location.pathname.toString(),(n=new ia(this.options)).onSchemaLoaded=function(t){l.trigger("schemaLoaded",t)},n.onAllSchemasLoaded=function(){l.trigger("allSchemasLoaded")},this.expandSchema=function(t){return n.expandSchema(t)},this.expandRefs=function(t,e){return n.expandRefs(t,e)},i=document.location.toString(),e.next=9,n.load(this.schema,r,i);case 9:o=e.sent,a=this.options.custom_validators?{custom_validators:this.options.custom_validators}:{},this.validator=new yn(this,null,a,t.defaults),s=this.getEditorClass(o),this.root=this.createEditor(s,{jsoneditor:this,schema:o,required:!0,container:this.root_container}),this.root.preBuild(),this.root.build(),this.root.postBuild(),h(this.options,"startval")&&this.root.setValue(this.options.startval),this.validation_results=this.validator.validate(this.root.getValue()),this.root.showValidationErrors(this.validation_results),this.ready=!0,this.element.classList.remove("je-not-loaded"),this.element.classList.add("je-ready"),window.requestAnimationFrame((function(){l.ready&&(l.validation_results=l.validator.validate(l.root.getValue()),l.root.showValidationErrors(l.validation_results),l.trigger("ready"),l.trigger("change"))}));case 24:case"end":return e.stop()}}),e,this)})),i=function(){var t=this,e=arguments;return new Promise((function(r,i){var o=n.apply(t,e);function a(t){Gl(o,r,i,a,s,"next",t)}function s(t){Gl(o,r,i,a,s,"throw",t)}a(void 0)}))},function(){return i.apply(this,arguments)})},{key:"getValue",value:function(){if(!this.ready)throw new Error("JSON Editor not ready yet. Make sure the load method is complete");return this.root.getValue()}},{key:"setValue",value:function(t){if(!this.ready)throw new Error("JSON Editor not ready yet. Make sure the load method is complete");return this.root.setValue(t),this}},{key:"validate",value:function(t){if(!this.ready)throw new Error("JSON Editor not ready yet. Make sure the load method is complete");return 1===arguments.length?this.validator.validate(t):this.validation_results}},{key:"destroy",value:function(){this.destroyed||this.ready&&(this.schema=null,this.options=null,this.root.destroy(),this.root=null,this.root_container=null,this.validator=null,this.validation_results=null,this.theme=null,this.iconlib=null,this.template=null,this.__data=null,this.ready=!1,this.element.innerHTML="",this.element.removeAttribute("data-theme"),this.destroyed=!0)}},{key:"on",value:function(t,e){return this.callbacks=this.callbacks||{},this.callbacks[t]=this.callbacks[t]||[],this.callbacks[t].push(e),this}},{key:"off",value:function(t,e){if(t&&e){this.callbacks=this.callbacks||{},this.callbacks[t]=this.callbacks[t]||[];for(var r=[],n=0;n<this.callbacks[t].length;n++)this.callbacks[t][n]!==e&&r.push(this.callbacks[t][n]);this.callbacks[t]=r}else t?(this.callbacks=this.callbacks||{},this.callbacks[t]=[]):this.callbacks={};return this}},{key:"trigger",value:function(t,e){if(this.callbacks&&this.callbacks[t]&&this.callbacks[t].length)for(var r=0;r<this.callbacks[t].length;r++)this.callbacks[t][r].apply(this,[e]);return this}},{key:"setOption",value:function(t,e){if("show_errors"!==t)throw new Error("Option ".concat(t," must be set during instantiation and cannot be changed later"));return this.options.show_errors=e,this.onChange(),this}},{key:"getEditorsRules",value:function(){return Object.values(t.defaults.editors).reduce((function(t,e){return e.rules?l(t,e.rules):t}),{})}},{key:"getEditorClass",value:function(e){var r,n=this;if(e=this.expandSchema(e),t.defaults.resolvers.find((function(i){return(r=i(e,n))&&t.defaults.editors[r]})),!r)throw new Error("Unknown editor for schema ".concat(JSON.stringify(e)));if(!t.defaults.editors[r])throw new Error("Unknown editor ".concat(r));return t.defaults.editors[r]}},{key:"createEditor",value:function(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return new e(r=l({},e.options||{},r),t.defaults,n)}},{key:"onChange",value:function(t){var e=this;if(this.ready&&(t&&this.trigger(t.event,t.data),!this.firing_change))return this.firing_change=!0,window.requestAnimationFrame((function(){e.firing_change=!1,e.ready&&(e.validation_results=e.validator.validate(e.root.getValue()),"never"!==e.options.show_errors?e.root.showValidationErrors(e.validation_results):e.root.showValidationErrors([]),e.trigger("change"))})),this}},{key:"compileTemplate",value:function(e){var r,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.defaults.template;if("string"==typeof n){if(!t.defaults.templates[n])throw new Error("Unknown template engine ".concat(n));if(!(r=t.defaults.templates[n]()))throw new Error("Template engine ".concat(n," missing required library."))}else r=n;if(!r)throw new Error("No template engine set");if(!r.compile)throw new Error("Invalid template engine set");return r.compile(e)}},{key:"_data",value:function(t,e,r){if(3!==arguments.length)return t.hasAttribute("data-jsoneditor-".concat(e))?this.__data[t.getAttribute("data-jsoneditor-".concat(e))]:null;var n;t.hasAttribute("data-jsoneditor-".concat(e))?n=t.getAttribute("data-jsoneditor-".concat(e)):(n=this.uuid++,t.setAttribute("data-jsoneditor-".concat(e),n)),this.__data[n]=r}},{key:"registerEditor",value:function(t){return this.editors=this.editors||{},this.editors[t.path]=t,this}},{key:"unregisterEditor",value:function(t){return this.editors=this.editors||{},this.editors[t.path]=null,this}},{key:"getEditor",value:function(t){if(this.editors)return this.editors[t]}},{key:"watch",value:function(t,e){return this.watchlist=this.watchlist||{},this.watchlist[t]=this.watchlist[t]||[],this.watchlist[t].push(e),this}},{key:"unwatch",value:function(t,e){if(!this.watchlist||!this.watchlist[t])return this;if(!e)return this.watchlist[t]=null,this;for(var r=[],n=0;n<this.watchlist[t].length;n++)this.watchlist[t][n]!==e&&r.push(this.watchlist[t][n]);return this.watchlist[t]=r.length?r:null,this}},{key:"notifyWatchers",value:function(t){if(!this.watchlist||!this.watchlist[t])return this;for(var e=0;e<this.watchlist[t].length;e++)this.watchlist[t][e]()}},{key:"isEnabled",value:function(){return!this.root||this.root.isEnabled()}},{key:"enable",value:function(){this.root.enable()}},{key:"disable",value:function(){this.root.disable()}},{key:"setCopyClipboardContents",value:function(t){this.copyClipboard=t}},{key:"getCopyClipboardContents",value:function(){return this.copyClipboard}},{key:"addNewStyleRules",value:function(t,e){var r=document.querySelector("#theme-".concat(t));r||((r=document.createElement("style")).setAttribute("id","theme-".concat(t)),r.appendChild(document.createTextNode("")),document.head.appendChild(r));for(var n=r.sheet?r.sheet:r.styleSheet,i=this.element.nodeName.toLowerCase();n.cssRules.length>0;)n.deleteRule(0);Object.keys(e).forEach((function(r){var o="default"===t?r:"".concat(i,'[data-theme="').concat(t,'"] ').concat(r);n.insertRule?n.insertRule(o+" {"+decodeURIComponent(e[r])+"}",0):n.addRule&&n.addRule(o,decodeURIComponent(e[r]),0)}))}},{key:"addNewStyleRulesToShadowRoot",value:function(t,e,r){var n=this.element.nodeName.toLowerCase(),i="";Object.keys(e).forEach((function(r){var o="default"===t?r:"".concat(n,'[data-theme="').concat(t,'"] ').concat(r);i+=o+" {"+decodeURIComponent(e[r])+"}\n"}));var o,a=new CSSStyleSheet;a.replaceSync(i),r.adoptedStyleSheets=[].concat(function(t){if(Array.isArray(t))return ql(t)}(o=r.adoptedStyleSheets)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(o)||function(t,e){if(t){if("string"==typeof t)return ql(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?ql(t,e):void 0}}(o)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),[a])}},{key:"showValidationErrors",value:function(t){var e=null!=t?t:this.validate();Object.values(this.editors).forEach((function(t){t&&(t.is_dirty=!0,t.showValidationErrors(e))}))}}],r&&$l(e.prototype,r),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,r,n,i}();Wl.defaults=Zo,Wl.AbstractEditor=_,Wl.AbstractTheme=bs,Wl.AbstractIconLib=ha,Object.assign(Wl.defaults.themes,Hl),Object.assign(Wl.defaults.editors,Uo),Object.assign(Wl.defaults.templates,oa),Object.assign(Wl.defaults.iconlibs,ds)})(),n})()));
},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPopper = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function get() {
    return _detectOverflow["default"];
  }
});
exports.popperGenerator = popperGenerator;
var _getCompositeRect = _interopRequireDefault(require("./dom-utils/getCompositeRect.js"));
var _getLayoutRect = _interopRequireDefault(require("./dom-utils/getLayoutRect.js"));
var _listScrollParents = _interopRequireDefault(require("./dom-utils/listScrollParents.js"));
var _getOffsetParent = _interopRequireDefault(require("./dom-utils/getOffsetParent.js"));
var _orderModifiers = _interopRequireDefault(require("./utils/orderModifiers.js"));
var _debounce = _interopRequireDefault(require("./utils/debounce.js"));
var _mergeByName = _interopRequireDefault(require("./utils/mergeByName.js"));
var _detectOverflow = _interopRequireDefault(require("./utils/detectOverflow.js"));
var _instanceOf = require("./dom-utils/instanceOf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
    _generatorOptions$def = _generatorOptions.defaultModifiers,
    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
    _generatorOptions$def2 = _generatorOptions.defaultOptions,
    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0, _instanceOf.isElement)(reference) ? (0, _listScrollParents["default"])(reference) : reference.contextElement ? (0, _listScrollParents["default"])(reference.contextElement) : [],
          popper: (0, _listScrollParents["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0, _orderModifiers["default"])((0, _mergeByName["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update â it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
          reference = _state$elements.reference,
          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers

        state.rects = {
          reference: (0, _getCompositeRect["default"])(reference, (0, _getOffsetParent["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0, _getLayoutRect["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
            fn = _state$orderedModifie.fn,
            _state$orderedModifie2 = _state$orderedModifie.options,
            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
            name = _state$orderedModifie.name;
          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update â it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0, _debounce["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      return instance;
    }
    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options,
          effect = _ref.effect;
        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
          var noopFn = function noopFn() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = exports.createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules

},{"./dom-utils/getCompositeRect.js":10,"./dom-utils/getLayoutRect.js":15,"./dom-utils/getOffsetParent.js":18,"./dom-utils/instanceOf.js":25,"./dom-utils/listScrollParents.js":29,"./utils/debounce.js":46,"./utils/detectOverflow.js":47,"./utils/mergeByName.js":57,"./utils/orderModifiers.js":59}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = contains;
var _instanceOf = require("./instanceOf.js");
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0, _instanceOf.isShadowRoot)(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...

      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false

  return false;
}

},{"./instanceOf.js":25}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getBoundingClientRect;
var _instanceOf = require("./instanceOf.js");
var _math = require("../utils/math.js");
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _isLayoutViewport = _interopRequireDefault(require("./isLayoutViewport.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && (0, _instanceOf.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0, _math.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0, _math.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = (0, _instanceOf.isElement)(element) ? (0, _getWindow["default"])(element) : window,
    visualViewport = _ref.visualViewport;
  var addVisualOffsets = !(0, _isLayoutViewport["default"])() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

},{"../utils/math.js":56,"./getWindow.js":22,"./instanceOf.js":25,"./isLayoutViewport.js":26}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getClippingRect;
var _enums = require("../enums.js");
var _getViewportRect = _interopRequireDefault(require("./getViewportRect.js"));
var _getDocumentRect = _interopRequireDefault(require("./getDocumentRect.js"));
var _listScrollParents = _interopRequireDefault(require("./listScrollParents.js"));
var _getOffsetParent = _interopRequireDefault(require("./getOffsetParent.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _instanceOf = require("./instanceOf.js");
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _contains = _interopRequireDefault(require("./contains.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _rectToClientRect = _interopRequireDefault(require("../utils/rectToClientRect.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getInnerBoundingClientRect(element, strategy) {
  var rect = (0, _getBoundingClientRect["default"])(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums.viewport ? (0, _rectToClientRect["default"])((0, _getViewportRect["default"])(element, strategy)) : (0, _instanceOf.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0, _rectToClientRect["default"])((0, _getDocumentRect["default"])((0, _getDocumentElement["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`

function getClippingParents(element) {
  var clippingParents = (0, _listScrollParents["default"])((0, _getParentNode["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0, _getComputedStyle["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0, _instanceOf.isHTMLElement)(element) ? (0, _getOffsetParent["default"])(element) : element;
  if (!(0, _instanceOf.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

  return clippingParents.filter(function (clippingParent) {
    return (0, _instanceOf.isElement)(clippingParent) && (0, _contains["default"])(clippingParent, clipperElement) && (0, _getNodeName["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents

function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0, _math.max)(rect.top, accRect.top);
    accRect.right = (0, _math.min)(rect.right, accRect.right);
    accRect.bottom = (0, _math.min)(rect.bottom, accRect.bottom);
    accRect.left = (0, _math.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

},{"../enums.js":30,"../utils/math.js":56,"../utils/rectToClientRect.js":60,"./contains.js":7,"./getBoundingClientRect.js":8,"./getComputedStyle.js":11,"./getDocumentElement.js":12,"./getDocumentRect.js":13,"./getNodeName.js":16,"./getOffsetParent.js":18,"./getParentNode.js":19,"./getViewportRect.js":21,"./instanceOf.js":25,"./listScrollParents.js":29}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getCompositeRect;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getNodeScroll = _interopRequireDefault(require("./getNodeScroll.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _instanceOf = require("./instanceOf.js");
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0, _math.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0, _math.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = (0, _instanceOf.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0, _instanceOf.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0, _getDocumentElement["default"])(offsetParent);
  var rect = (0, _getBoundingClientRect["default"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0, _getNodeName["default"])(offsetParent) !== 'body' ||
    // https://github.com/popperjs/popper-core/issues/1078
    (0, _isScrollParent["default"])(documentElement)) {
      scroll = (0, _getNodeScroll["default"])(offsetParent);
    }
    if ((0, _instanceOf.isHTMLElement)(offsetParent)) {
      offsets = (0, _getBoundingClientRect["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0, _getWindowScrollBarX["default"])(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

},{"../utils/math.js":56,"./getBoundingClientRect.js":8,"./getDocumentElement.js":12,"./getNodeName.js":16,"./getNodeScroll.js":17,"./getWindowScrollBarX.js":24,"./instanceOf.js":25,"./isScrollParent.js":27}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getComputedStyle;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getComputedStyle(element) {
  return (0, _getWindow["default"])(element).getComputedStyle(element);
}

},{"./getWindow.js":22}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getDocumentElement;
var _instanceOf = require("./instanceOf.js");
function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0, _instanceOf.isElement)(element) ? element.ownerDocument :
  // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

},{"./instanceOf.js":25}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getDocumentRect;
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = (0, _getDocumentElement["default"])(element);
  var winScroll = (0, _getWindowScroll["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0, _math.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0, _math.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0, _getWindowScrollBarX["default"])(element);
  var y = -winScroll.scrollTop;
  if ((0, _getComputedStyle["default"])(body || html).direction === 'rtl') {
    x += (0, _math.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

},{"../utils/math.js":56,"./getComputedStyle.js":11,"./getDocumentElement.js":12,"./getWindowScroll.js":23,"./getWindowScrollBarX.js":24}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getHTMLElementScroll;
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getLayoutRect;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0, _getBoundingClientRect["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

},{"./getBoundingClientRect.js":8}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getNodeName;
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getNodeScroll;
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _instanceOf = require("./instanceOf.js");
var _getHTMLElementScroll = _interopRequireDefault(require("./getHTMLElementScroll.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getNodeScroll(node) {
  if (node === (0, _getWindow["default"])(node) || !(0, _instanceOf.isHTMLElement)(node)) {
    return (0, _getWindowScroll["default"])(node);
  } else {
    return (0, _getHTMLElementScroll["default"])(node);
  }
}

},{"./getHTMLElementScroll.js":14,"./getWindow.js":22,"./getWindowScroll.js":23,"./instanceOf.js":25}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getOffsetParent;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _instanceOf = require("./instanceOf.js");
var _isTableElement = _interopRequireDefault(require("./isTableElement.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _userAgent = _interopRequireDefault(require("../utils/userAgent.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getTrueOffsetParent(element) {
  if (!(0, _instanceOf.isHTMLElement)(element) ||
  // https://github.com/popperjs/popper-core/issues/837
  (0, _getComputedStyle["default"])(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block

function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0, _userAgent["default"])());
  var isIE = /Trident/i.test((0, _userAgent["default"])());
  if (isIE && (0, _instanceOf.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0, _getComputedStyle["default"])(element);
    if (elementCss.position === 'fixed') {
      return null;
    }
  }
  var currentNode = (0, _getParentNode["default"])(element);
  if ((0, _instanceOf.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }
  while ((0, _instanceOf.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0, _getNodeName["default"])(currentNode)) < 0) {
    var css = (0, _getComputedStyle["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.

function getOffsetParent(element) {
  var window = (0, _getWindow["default"])(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && (0, _isTableElement["default"])(offsetParent) && (0, _getComputedStyle["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && ((0, _getNodeName["default"])(offsetParent) === 'html' || (0, _getNodeName["default"])(offsetParent) === 'body' && (0, _getComputedStyle["default"])(offsetParent).position === 'static')) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

},{"../utils/userAgent.js":61,"./getComputedStyle.js":11,"./getNodeName.js":16,"./getParentNode.js":19,"./getWindow.js":22,"./instanceOf.js":25,"./isTableElement.js":28}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getParentNode;
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _instanceOf = require("./instanceOf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getParentNode(element) {
  if ((0, _getNodeName["default"])(element) === 'html') {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot ||
    // step into the shadow DOM of the parent of a slotted node
    element.parentNode || (
    // DOM Element detected
    (0, _instanceOf.isShadowRoot)(element) ? element.host : null) ||
    // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0, _getDocumentElement["default"])(element) // fallback
  );
}

},{"./getDocumentElement.js":12,"./getNodeName.js":16,"./instanceOf.js":25}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getScrollParent;
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _instanceOf = require("./instanceOf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0, _getNodeName["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }
  if ((0, _instanceOf.isHTMLElement)(node) && (0, _isScrollParent["default"])(node)) {
    return node;
  }
  return getScrollParent((0, _getParentNode["default"])(node));
}

},{"./getNodeName.js":16,"./getParentNode.js":19,"./instanceOf.js":25,"./isScrollParent.js":27}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getViewportRect;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _isLayoutViewport = _interopRequireDefault(require("./isLayoutViewport.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getViewportRect(element, strategy) {
  var win = (0, _getWindow["default"])(element);
  var html = (0, _getDocumentElement["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0, _isLayoutViewport["default"])();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width,
    height: height,
    x: x + (0, _getWindowScrollBarX["default"])(element),
    y: y
  };
}

},{"./getDocumentElement.js":12,"./getWindow.js":22,"./getWindowScrollBarX.js":24,"./isLayoutViewport.js":26}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getWindow;
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

},{}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getWindowScroll;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getWindowScroll(node) {
  var win = (0, _getWindow["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

},{"./getWindow.js":22}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getWindowScrollBarX;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0, _getBoundingClientRect["default"])((0, _getDocumentElement["default"])(element)).left + (0, _getWindowScroll["default"])(element).scrollLeft;
}

},{"./getBoundingClientRect.js":8,"./getDocumentElement.js":12,"./getWindowScroll.js":23}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isElement = isElement;
exports.isHTMLElement = isHTMLElement;
exports.isShadowRoot = isShadowRoot;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isElement(node) {
  var OwnElement = (0, _getWindow["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = (0, _getWindow["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  var OwnElement = (0, _getWindow["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

},{"./getWindow.js":22}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isLayoutViewport;
var _userAgent = _interopRequireDefault(require("../utils/userAgent.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0, _userAgent["default"])());
}

},{"../utils/userAgent.js":61}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isScrollParent;
var _getComputedStyle2 = _interopRequireDefault(require("./getComputedStyle.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0, _getComputedStyle2["default"])(element),
    overflow = _getComputedStyle.overflow,
    overflowX = _getComputedStyle.overflowX,
    overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

},{"./getComputedStyle.js":11}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isTableElement;
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0, _getNodeName["default"])(element)) >= 0;
}

},{"./getNodeName.js":16}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = listScrollParents;
var _getScrollParent = _interopRequireDefault(require("./getScrollParent.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = (0, _getScrollParent["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0, _getWindow["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0, _isScrollParent["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList :
  // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0, _getParentNode["default"])(target)));
}

},{"./getParentNode.js":19,"./getScrollParent.js":20,"./getWindow.js":22,"./isScrollParent.js":27}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.write = exports.viewport = exports.variationPlacements = exports.top = exports.start = exports.right = exports.reference = exports.read = exports.popper = exports.placements = exports.modifierPhases = exports.main = exports.left = exports.end = exports.clippingParents = exports.bottom = exports.beforeWrite = exports.beforeRead = exports.beforeMain = exports.basePlacements = exports.auto = exports.afterWrite = exports.afterRead = exports.afterMain = void 0;
var top = exports.top = 'top';
var bottom = exports.bottom = 'bottom';
var right = exports.right = 'right';
var left = exports.left = 'left';
var auto = exports.auto = 'auto';
var basePlacements = exports.basePlacements = [top, bottom, right, left];
var start = exports.start = 'start';
var end = exports.end = 'end';
var clippingParents = exports.clippingParents = 'clippingParents';
var viewport = exports.viewport = 'viewport';
var popper = exports.popper = 'popper';
var reference = exports.reference = 'reference';
var variationPlacements = exports.variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = exports.placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = exports.beforeRead = 'beforeRead';
var read = exports.read = 'read';
var afterRead = exports.afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = exports.beforeMain = 'beforeMain';
var main = exports.main = 'main';
var afterMain = exports.afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = exports.beforeWrite = 'beforeWrite';
var write = exports.write = 'write';
var afterWrite = exports.afterWrite = 'afterWrite';
var modifierPhases = exports.modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  popperGenerator: true,
  detectOverflow: true,
  createPopperBase: true,
  createPopper: true,
  createPopperLite: true
};
Object.defineProperty(exports, "createPopper", {
  enumerable: true,
  get: function get() {
    return _popper.createPopper;
  }
});
Object.defineProperty(exports, "createPopperBase", {
  enumerable: true,
  get: function get() {
    return _createPopper.createPopper;
  }
});
Object.defineProperty(exports, "createPopperLite", {
  enumerable: true,
  get: function get() {
    return _popperLite.createPopper;
  }
});
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function get() {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function get() {
    return _createPopper.popperGenerator;
  }
});
var _enums = require("./enums.js");
Object.keys(_enums).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _enums[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _enums[key];
    }
  });
});
var _index = require("./modifiers/index.js");
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});
var _createPopper = require("./createPopper.js");
var _popper = require("./popper.js");
var _popperLite = require("./popper-lite.js");

},{"./createPopper.js":6,"./enums.js":30,"./modifiers/index.js":38,"./popper-lite.js":42,"./popper.js":43}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _getNodeName = _interopRequireDefault(require("../dom-utils/getNodeName.js"));
var _instanceOf = require("../dom-utils/instanceOf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0, _instanceOf.isHTMLElement)(element) || !(0, _getNodeName["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]

    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0, _instanceOf.isHTMLElement)(element) || !(0, _getNodeName["default"])(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
};

},{"../dom-utils/getNodeName.js":16,"../dom-utils/instanceOf.js":25}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getLayoutRect = _interopRequireDefault(require("../dom-utils/getLayoutRect.js"));
var _contains = _interopRequireDefault(require("../dom-utils/contains.js"));
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("../utils/getMainAxisFromPlacement.js"));
var _within = require("../utils/within.js");
var _mergePaddingObject = _interopRequireDefault(require("../utils/mergePaddingObject.js"));
var _expandToHashMap = _interopRequireDefault(require("../utils/expandToHashMap.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0, _mergePaddingObject["default"])(typeof padding !== 'number' ? padding : (0, _expandToHashMap["default"])(padding, _enums.basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
    name = _ref.name,
    options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0, _getBasePlacement["default"])(state.placement);
  var axis = (0, _getMainAxisFromPlacement["default"])(basePlacement);
  var isVertical = [_enums.left, _enums.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0, _getLayoutRect["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums.top : _enums.left;
  var maxProp = axis === 'y' ? _enums.bottom : _enums.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0, _getOffsetParent["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0, _within.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
  var state = _ref2.state,
    options = _ref2.options;
  var _options$element = options.element,
    arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
  if (arrowElement == null) {
    return;
  } // CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!(0, _contains["default"])(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

},{"../dom-utils/contains.js":7,"../dom-utils/getLayoutRect.js":15,"../dom-utils/getOffsetParent.js":18,"../enums.js":30,"../utils/expandToHashMap.js":48,"../utils/getBasePlacement.js":50,"../utils/getMainAxisFromPlacement.js":52,"../utils/mergePaddingObject.js":58,"../utils/within.js":62}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.mapToStyles = mapToStyles;
var _enums = require("../enums.js");
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _getWindow = _interopRequireDefault(require("../dom-utils/getWindow.js"));
var _getDocumentElement = _interopRequireDefault(require("../dom-utils/getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("../dom-utils/getComputedStyle.js"));
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
    y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0, _math.round)(x * dpr) / dpr || 0,
    y: (0, _math.round)(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper,
    popperRect = _ref2.popperRect,
    placement = _ref2.placement,
    variation = _ref2.variation,
    offsets = _ref2.offsets,
    position = _ref2.position,
    gpuAcceleration = _ref2.gpuAcceleration,
    adaptive = _ref2.adaptive,
    roundOffsets = _ref2.roundOffsets,
    isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
    x = _offsets$x === void 0 ? 0 : _offsets$x,
    _offsets$y = offsets.y,
    y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums.left;
  var sideY = _enums.top;
  var win = window;
  if (adaptive) {
    var offsetParent = (0, _getOffsetParent["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';
    if (offsetParent === (0, _getWindow["default"])(popper)) {
      offsetParent = (0, _getDocumentElement["default"])(popper);
      if ((0, _getComputedStyle["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    offsetParent = offsetParent;
    if (placement === _enums.top || (placement === _enums.left || placement === _enums.right) && variation === _enums.end) {
      sideY = _enums.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
      // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === _enums.left || (placement === _enums.top || placement === _enums.bottom) && variation === _enums.end) {
      sideX = _enums.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
      // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, (0, _getWindow["default"])(popper)) : {
    x: x,
    y: y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state,
    options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
    gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
    _options$adaptive = options.adaptive,
    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
    _options$roundOffsets = options.roundOffsets,
    roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: (0, _getBasePlacement["default"])(state.placement),
    variation: (0, _getVariation["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

},{"../dom-utils/getComputedStyle.js":11,"../dom-utils/getDocumentElement.js":12,"../dom-utils/getOffsetParent.js":18,"../dom-utils/getWindow.js":22,"../enums.js":30,"../utils/getBasePlacement.js":50,"../utils/getVariation.js":55,"../utils/math.js":56}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _getWindow = _interopRequireDefault(require("../dom-utils/getWindow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state,
    instance = _ref.instance,
    options = _ref.options;
  var _options$scroll = options.scroll,
    scroll = _options$scroll === void 0 ? true : _options$scroll,
    _options$resize = options.resize,
    resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0, _getWindow["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

},{"../dom-utils/getWindow.js":22}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _getOppositePlacement = _interopRequireDefault(require("../utils/getOppositePlacement.js"));
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getOppositeVariationPlacement = _interopRequireDefault(require("../utils/getOppositeVariationPlacement.js"));
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
var _computeAutoPlacement = _interopRequireDefault(require("../utils/computeAutoPlacement.js"));
var _enums = require("../enums.js");
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0, _getBasePlacement["default"])(placement) === _enums.auto) {
    return [];
  }
  var oppositePlacement = (0, _getOppositePlacement["default"])(placement);
  return [(0, _getOppositeVariationPlacement["default"])(placement), oppositePlacement, (0, _getOppositeVariationPlacement["default"])(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
    specifiedFallbackPlacements = options.fallbackPlacements,
    padding = options.padding,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    _options$flipVariatio = options.flipVariations,
    flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
    allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0, _getBasePlacement["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0, _getOppositePlacement["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0, _getBasePlacement["default"])(placement) === _enums.auto ? (0, _computeAutoPlacement["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];
  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = (0, _getBasePlacement["default"])(placement);
    var isStartVariation = (0, _getVariation["default"])(placement) === _enums.start;
    var isVertical = [_enums.top, _enums.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0, _detectOverflow["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums.right : _enums.left : isStartVariation ? _enums.bottom : _enums.top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0, _getOppositePlacement["default"])(mainVariationSide);
    }
    var altVariationSide = (0, _getOppositePlacement["default"])(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    // `2` may be desired in some cases â research later
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

},{"../enums.js":30,"../utils/computeAutoPlacement.js":44,"../utils/detectOverflow.js":47,"../utils/getBasePlacement.js":50,"../utils/getOppositePlacement.js":53,"../utils/getOppositeVariationPlacement.js":54,"../utils/getVariation.js":55}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _enums = require("../enums.js");
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [_enums.top, _enums.right, _enums.bottom, _enums.left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
    name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0, _detectOverflow["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0, _detectOverflow["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

},{"../enums.js":30,"../utils/detectOverflow.js":47}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "applyStyles", {
  enumerable: true,
  get: function get() {
    return _applyStyles["default"];
  }
});
Object.defineProperty(exports, "arrow", {
  enumerable: true,
  get: function get() {
    return _arrow["default"];
  }
});
Object.defineProperty(exports, "computeStyles", {
  enumerable: true,
  get: function get() {
    return _computeStyles["default"];
  }
});
Object.defineProperty(exports, "eventListeners", {
  enumerable: true,
  get: function get() {
    return _eventListeners["default"];
  }
});
Object.defineProperty(exports, "flip", {
  enumerable: true,
  get: function get() {
    return _flip["default"];
  }
});
Object.defineProperty(exports, "hide", {
  enumerable: true,
  get: function get() {
    return _hide["default"];
  }
});
Object.defineProperty(exports, "offset", {
  enumerable: true,
  get: function get() {
    return _offset["default"];
  }
});
Object.defineProperty(exports, "popperOffsets", {
  enumerable: true,
  get: function get() {
    return _popperOffsets["default"];
  }
});
Object.defineProperty(exports, "preventOverflow", {
  enumerable: true,
  get: function get() {
    return _preventOverflow["default"];
  }
});
var _applyStyles = _interopRequireDefault(require("./applyStyles.js"));
var _arrow = _interopRequireDefault(require("./arrow.js"));
var _computeStyles = _interopRequireDefault(require("./computeStyles.js"));
var _eventListeners = _interopRequireDefault(require("./eventListeners.js"));
var _flip = _interopRequireDefault(require("./flip.js"));
var _hide = _interopRequireDefault(require("./hide.js"));
var _offset = _interopRequireDefault(require("./offset.js"));
var _popperOffsets = _interopRequireDefault(require("./popperOffsets.js"));
var _preventOverflow = _interopRequireDefault(require("./preventOverflow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"./applyStyles.js":32,"./arrow.js":33,"./computeStyles.js":34,"./eventListeners.js":35,"./flip.js":36,"./hide.js":37,"./offset.js":39,"./popperOffsets.js":40,"./preventOverflow.js":41}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.distanceAndSkiddingToXY = distanceAndSkiddingToXY;
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0, _getBasePlacement["default"])(placement);
  var invertDistance = [_enums.left, _enums.top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
    skidding = _ref[0],
    distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums.left, _enums.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state,
    options = _ref2.options,
    name = _ref2.name;
  var _options$offset = options.offset,
    offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
    x = _data$state$placement.x,
    y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

},{"../enums.js":30,"../utils/getBasePlacement.js":50}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _computeOffsets = _interopRequireDefault(require("../utils/computeOffsets.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function popperOffsets(_ref) {
  var state = _ref.state,
    name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0, _computeOffsets["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

},{"../utils/computeOffsets.js":45}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _enums = require("../enums.js");
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("../utils/getMainAxisFromPlacement.js"));
var _getAltAxis = _interopRequireDefault(require("../utils/getAltAxis.js"));
var _within = require("../utils/within.js");
var _getLayoutRect = _interopRequireDefault(require("../dom-utils/getLayoutRect.js"));
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
var _getFreshSideObject = _interopRequireDefault(require("../utils/getFreshSideObject.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function preventOverflow(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    padding = options.padding,
    _options$tether = options.tether,
    tether = _options$tether === void 0 ? true : _options$tether,
    _options$tetherOffset = options.tetherOffset,
    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0, _detectOverflow["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0, _getBasePlacement["default"])(state.placement);
  var variation = (0, _getVariation["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0, _getMainAxisFromPlacement["default"])(basePlacement);
  var altAxis = (0, _getAltAxis["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === 'y' ? _enums.top : _enums.left;
    var altSide = mainAxis === 'y' ? _enums.bottom : _enums.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0, _getLayoutRect["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0, _getFreshSideObject["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0, _within.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0, _getOffsetParent["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0, _within.within)(tether ? (0, _math.min)(min, tetherMin) : min, offset, tether ? (0, _math.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === 'x' ? _enums.top : _enums.left;
    var _altSide = mainAxis === 'x' ? _enums.bottom : _enums.right;
    var _offset = popperOffsets[altAxis];
    var _len = altAxis === 'y' ? 'height' : 'width';
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [_enums.top, _enums.left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? (0, _within.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0, _within.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

},{"../dom-utils/getLayoutRect.js":15,"../dom-utils/getOffsetParent.js":18,"../enums.js":30,"../utils/detectOverflow.js":47,"../utils/getAltAxis.js":49,"../utils/getBasePlacement.js":50,"../utils/getFreshSideObject.js":51,"../utils/getMainAxisFromPlacement.js":52,"../utils/getVariation.js":55,"../utils/math.js":56,"../utils/within.js":62}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultModifiers = exports.createPopper = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function get() {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function get() {
    return _createPopper.popperGenerator;
  }
});
var _createPopper = require("./createPopper.js");
var _eventListeners = _interopRequireDefault(require("./modifiers/eventListeners.js"));
var _popperOffsets = _interopRequireDefault(require("./modifiers/popperOffsets.js"));
var _computeStyles = _interopRequireDefault(require("./modifiers/computeStyles.js"));
var _applyStyles = _interopRequireDefault(require("./modifiers/applyStyles.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var defaultModifiers = exports.defaultModifiers = [_eventListeners["default"], _popperOffsets["default"], _computeStyles["default"], _applyStyles["default"]];
var createPopper = exports.createPopper = /*#__PURE__*/(0, _createPopper.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":6,"./modifiers/applyStyles.js":32,"./modifiers/computeStyles.js":34,"./modifiers/eventListeners.js":35,"./modifiers/popperOffsets.js":40}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createPopper: true,
  defaultModifiers: true,
  popperGenerator: true,
  detectOverflow: true,
  createPopperLite: true
};
exports.createPopper = void 0;
Object.defineProperty(exports, "createPopperLite", {
  enumerable: true,
  get: function get() {
    return _popperLite.createPopper;
  }
});
exports.defaultModifiers = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function get() {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function get() {
    return _createPopper.popperGenerator;
  }
});
var _createPopper = require("./createPopper.js");
var _eventListeners = _interopRequireDefault(require("./modifiers/eventListeners.js"));
var _popperOffsets = _interopRequireDefault(require("./modifiers/popperOffsets.js"));
var _computeStyles = _interopRequireDefault(require("./modifiers/computeStyles.js"));
var _applyStyles = _interopRequireDefault(require("./modifiers/applyStyles.js"));
var _offset = _interopRequireDefault(require("./modifiers/offset.js"));
var _flip = _interopRequireDefault(require("./modifiers/flip.js"));
var _preventOverflow = _interopRequireDefault(require("./modifiers/preventOverflow.js"));
var _arrow = _interopRequireDefault(require("./modifiers/arrow.js"));
var _hide = _interopRequireDefault(require("./modifiers/hide.js"));
var _popperLite = require("./popper-lite.js");
var _index = require("./modifiers/index.js");
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var defaultModifiers = exports.defaultModifiers = [_eventListeners["default"], _popperOffsets["default"], _computeStyles["default"], _applyStyles["default"], _offset["default"], _flip["default"], _preventOverflow["default"], _arrow["default"], _hide["default"]];
var createPopper = exports.createPopper = /*#__PURE__*/(0, _createPopper.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

// eslint-disable-next-line import/no-unused-modules

// eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":6,"./modifiers/applyStyles.js":32,"./modifiers/arrow.js":33,"./modifiers/computeStyles.js":34,"./modifiers/eventListeners.js":35,"./modifiers/flip.js":36,"./modifiers/hide.js":37,"./modifiers/index.js":38,"./modifiers/offset.js":39,"./modifiers/popperOffsets.js":40,"./modifiers/preventOverflow.js":41,"./popper-lite.js":42}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = computeAutoPlacement;
var _getVariation = _interopRequireDefault(require("./getVariation.js"));
var _enums = require("../enums.js");
var _detectOverflow = _interopRequireDefault(require("./detectOverflow.js"));
var _getBasePlacement = _interopRequireDefault(require("./getBasePlacement.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    placement = _options.placement,
    boundary = _options.boundary,
    rootBoundary = _options.rootBoundary,
    padding = _options.padding,
    flipVariations = _options.flipVariations,
    _options$allowedAutoP = _options.allowedAutoPlacements,
    allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums.placements : _options$allowedAutoP;
  var variation = (0, _getVariation["default"])(placement);
  var placements = variation ? flipVariations ? _enums.variationPlacements : _enums.variationPlacements.filter(function (placement) {
    return (0, _getVariation["default"])(placement) === variation;
  }) : _enums.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0, _detectOverflow["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0, _getBasePlacement["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

},{"../enums.js":30,"./detectOverflow.js":47,"./getBasePlacement.js":50,"./getVariation.js":55}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = computeOffsets;
var _getBasePlacement = _interopRequireDefault(require("./getBasePlacement.js"));
var _getVariation = _interopRequireDefault(require("./getVariation.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("./getMainAxisFromPlacement.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function computeOffsets(_ref) {
  var reference = _ref.reference,
    element = _ref.element,
    placement = _ref.placement;
  var basePlacement = placement ? (0, _getBasePlacement["default"])(placement) : null;
  var variation = placement ? (0, _getVariation["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case _enums.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case _enums.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case _enums.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case _enums.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? (0, _getMainAxisFromPlacement["default"])(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case _enums.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case _enums.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

},{"../enums.js":30,"./getBasePlacement.js":50,"./getMainAxisFromPlacement.js":52,"./getVariation.js":55}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = debounce;
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

},{}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = detectOverflow;
var _getClippingRect = _interopRequireDefault(require("../dom-utils/getClippingRect.js"));
var _getDocumentElement = _interopRequireDefault(require("../dom-utils/getDocumentElement.js"));
var _getBoundingClientRect = _interopRequireDefault(require("../dom-utils/getBoundingClientRect.js"));
var _computeOffsets = _interopRequireDefault(require("./computeOffsets.js"));
var _rectToClientRect = _interopRequireDefault(require("./rectToClientRect.js"));
var _enums = require("../enums.js");
var _instanceOf = require("../dom-utils/instanceOf.js");
var _mergePaddingObject = _interopRequireDefault(require("./mergePaddingObject.js"));
var _expandToHashMap = _interopRequireDefault(require("./expandToHashMap.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$placement = _options.placement,
    placement = _options$placement === void 0 ? state.placement : _options$placement,
    _options$strategy = _options.strategy,
    strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
    _options$boundary = _options.boundary,
    boundary = _options$boundary === void 0 ? _enums.clippingParents : _options$boundary,
    _options$rootBoundary = _options.rootBoundary,
    rootBoundary = _options$rootBoundary === void 0 ? _enums.viewport : _options$rootBoundary,
    _options$elementConte = _options.elementContext,
    elementContext = _options$elementConte === void 0 ? _enums.popper : _options$elementConte,
    _options$altBoundary = _options.altBoundary,
    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
    _options$padding = _options.padding,
    padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0, _mergePaddingObject["default"])(typeof padding !== 'number' ? padding : (0, _expandToHashMap["default"])(padding, _enums.basePlacements));
  var altContext = elementContext === _enums.popper ? _enums.reference : _enums.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0, _getClippingRect["default"])((0, _instanceOf.isElement)(element) ? element : element.contextElement || (0, _getDocumentElement["default"])(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0, _getBoundingClientRect["default"])(state.elements.reference);
  var popperOffsets = (0, _computeOffsets["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0, _rectToClientRect["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums.right, _enums.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums.top, _enums.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}

},{"../dom-utils/getBoundingClientRect.js":8,"../dom-utils/getClippingRect.js":9,"../dom-utils/getDocumentElement.js":12,"../dom-utils/instanceOf.js":25,"../enums.js":30,"./computeOffsets.js":45,"./expandToHashMap.js":48,"./mergePaddingObject.js":58,"./rectToClientRect.js":60}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = expandToHashMap;
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getAltAxis;
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

},{}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getBasePlacement;
var _enums = require("../enums.js");
function getBasePlacement(placement) {
  return placement.split('-')[0];
}

},{"../enums.js":30}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getFreshSideObject;
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getMainAxisFromPlacement;
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getOppositePlacement;
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

},{}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getOppositeVariationPlacement;
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getVariation;
function getVariation(placement) {
  return placement.split('-')[1];
}

},{}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.round = exports.min = exports.max = void 0;
var max = exports.max = Math.max;
var min = exports.min = Math.min;
var round = exports.round = Math.round;

},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = mergeByName;
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = mergePaddingObject;
var _getFreshSideObject = _interopRequireDefault(require("./getFreshSideObject.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0, _getFreshSideObject["default"])(), paddingObject);
}

},{"./getFreshSideObject.js":51}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = orderModifiers;
var _enums = require("../enums.js");
// source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

},{"../enums.js":30}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = rectToClientRect;
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getUAString;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }
  return navigator.userAgent;
}

},{}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.within = within;
exports.withinMaxClamp = withinMaxClamp;
var _math = require("./math.js");
function within(min, value, max) {
  return (0, _math.max)(min, (0, _math.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

},{"./math.js":56}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emitter = Emitter;
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }
  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
    callbacks = this._callbacks['$' + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],64:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tooltip = exports.Toast = exports.Tab = exports.ScrollSpy = exports.Popover = exports.Offcanvas = exports.Modal = exports.Dropdown = exports.Collapse = exports.Carousel = exports.Button = exports.Alert = void 0;
var Popper = _interopRequireWildcard(require("@popperjs/core"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } /*!
  * Bootstrap v5.3.7 (https://getbootstrap.com/)
  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var elementMap = new Map();
var Data = {
  set: function set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, new Map());
    }
    var instanceMap = elementMap.get(element);

    // make it clear we only want one instance per element
    // can be removed later when multiple key/instances are fine to be used
    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      // eslint-disable-next-line no-console
      console.error("Bootstrap doesn't allow more than one instance per element. Bound instance: ".concat(Array.from(instanceMap.keys())[0], "."));
      return;
    }
    instanceMap.set(key, instance);
  },
  get: function get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }
    return null;
  },
  remove: function remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }
    var instanceMap = elementMap.get(element);
    instanceMap["delete"](key);

    // free up element references if there are no instances left for an element
    if (instanceMap.size === 0) {
      elementMap["delete"](element);
    }
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

var MAX_UID = 1000000;
var MILLISECONDS_MULTIPLIER = 1000;
var TRANSITION_END = 'transitionend';

/**
 * Properly escape IDs selectors to handle weird IDs
 * @param {string} selector
 * @returns {string}
 */
var parseSelector = function parseSelector(selector) {
  if (selector && window.CSS && window.CSS.escape) {
    // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
    selector = selector.replace(/#([^\s"#']+)/g, function (match, id) {
      return "#".concat(CSS.escape(id));
    });
  }
  return selector;
};

// Shout-out Angus Croll (https://goo.gl/pxwQGp)
var toType = function toType(object) {
  if (object === null || object === undefined) {
    return "".concat(object);
  }
  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};

/**
 * Public Util API
 */

var getUID = function getUID(prefix) {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {
  if (!element) {
    return 0;
  }

  // Get transition-duration of the element
  var _window$getComputedSt = window.getComputedStyle(element),
    transitionDuration = _window$getComputedSt.transitionDuration,
    transitionDelay = _window$getComputedSt.transitionDelay;
  var floatTransitionDuration = Number.parseFloat(transitionDuration);
  var floatTransitionDelay = Number.parseFloat(transitionDelay);

  // Return 0 if element or transition duration is not found
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }

  // If multiple durations are defined, take the first
  transitionDuration = transitionDuration.split(',')[0];
  transitionDelay = transitionDelay.split(',')[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
var triggerTransitionEnd = function triggerTransitionEnd(element) {
  element.dispatchEvent(new Event(TRANSITION_END));
};
var isElement = function isElement(object) {
  if (!object || _typeof(object) !== 'object') {
    return false;
  }
  if (typeof object.jquery !== 'undefined') {
    object = object[0];
  }
  return typeof object.nodeType !== 'undefined';
};
var getElement = function getElement(object) {
  // it's a jQuery object or a node element
  if (isElement(object)) {
    return object.jquery ? object[0] : object;
  }
  if (typeof object === 'string' && object.length > 0) {
    return document.querySelector(parseSelector(object));
  }
  return null;
};
var isVisible = function isVisible(element) {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }
  var elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  // Handle `details` element as its content may falsie appear visible when it is closed
  var closedDetails = element.closest('details:not([open])');
  if (!closedDetails) {
    return elementIsVisible;
  }
  if (closedDetails !== element) {
    var summary = element.closest('summary');
    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }
    if (summary === null) {
      return false;
    }
  }
  return elementIsVisible;
};
var isDisabled = function isDisabled(element) {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element.classList.contains('disabled')) {
    return true;
  }
  if (typeof element.disabled !== 'undefined') {
    return element.disabled;
  }
  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
};
var _findShadowRoot = function findShadowRoot(element) {
  if (!document.documentElement.attachShadow) {
    return null;
  }

  // Can find the shadow root otherwise it'll return the document
  if (typeof element.getRootNode === 'function') {
    var root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }
  if (element instanceof ShadowRoot) {
    return element;
  }

  // when we don't find a shadow root
  if (!element.parentNode) {
    return null;
  }
  return _findShadowRoot(element.parentNode);
};
var noop = function noop() {};

/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.harrytheo.com/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */
var reflow = function reflow(element) {
  element.offsetHeight; // eslint-disable-line no-unused-expressions
};
var getjQuery = function getjQuery() {
  if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
    return window.jQuery;
  }
  return null;
};
var DOMContentLoadedCallbacks = [];
var onDOMContentLoaded = function onDOMContentLoaded(callback) {
  if (document.readyState === 'loading') {
    // add listener on the first call when the document is in loading state
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener('DOMContentLoaded', function () {
        for (var _i = 0, _DOMContentLoadedCall = DOMContentLoadedCallbacks; _i < _DOMContentLoadedCall.length; _i++) {
          var _callback = _DOMContentLoadedCall[_i];
          _callback();
        }
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
var isRTL = function isRTL() {
  return document.documentElement.dir === 'rtl';
};
var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
  onDOMContentLoaded(function () {
    var $ = getjQuery();
    /* istanbul ignore if */
    if ($) {
      var name = plugin.NAME;
      var JQUERY_NO_CONFLICT = $.fn[name];
      $.fn[name] = plugin.jQueryInterface;
      $.fn[name].Constructor = plugin;
      $.fn[name].noConflict = function () {
        $.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};
var execute = function execute(possibleCallback) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : possibleCallback;
  return typeof possibleCallback === 'function' ? possibleCallback.call.apply(possibleCallback, _toConsumableArray(args)) : defaultValue;
};
var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {
  var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  var durationPadding = 5;
  var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  var called = false;
  var _handler = function handler(_ref) {
    var target = _ref.target;
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, _handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, _handler);
  setTimeout(function () {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};

/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */
var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {
  var listLength = list.length;
  var index = list.indexOf(activeElement);

  // if the element does not exist in the list return an element
  // depending on the direction and if cycle is allowed
  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
  }
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list[Math.max(0, Math.min(index, listLength - 1))];
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/event-handler.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
var stripNameRegex = /\..*/;
var stripUidRegex = /::\d+$/;
var eventRegistry = {}; // Events storage
var uidEvent = 1;
var customEvents = {
  mouseenter: 'mouseover',
  mouseleave: 'mouseout'
};
var nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);

/**
 * Private methods
 */

function makeEventUid(element, uid) {
  return uid && "".concat(uid, "::").concat(uidEvent++) || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
  var uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}
function bootstrapHandler(element, fn) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });
    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn);
    }
    return fn.apply(element, [event]);
  };
}
function bootstrapDelegationHandler(element, selector, fn) {
  return function handler(event) {
    var domElements = element.querySelectorAll(selector);
    for (var target = event.target; target && target !== this; target = target.parentNode) {
      var _iterator = _createForOfIteratorHelper(domElements),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var domElement = _step.value;
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, {
            delegateTarget: target
          });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn);
          }
          return fn.apply(target, [event]);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };
}
function findHandler(events, callable) {
  var delegationSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return Object.values(events).find(function (event) {
    return event.callable === callable && event.delegationSelector === delegationSelector;
  });
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  var isDelegated = typeof handler === 'string';
  // TODO: tooltip passes `false` instead of selector, so we need to check
  var callable = isDelegated ? delegationFunction : handler || delegationFunction;
  var typeEvent = getTypeEvent(originalTypeEvent);
  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }
  return [isDelegated, callable, typeEvent];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== 'string' || !element) {
    return;
  }
  var _normalizeParameters = normalizeParameters(originalTypeEvent, handler, delegationFunction),
    _normalizeParameters2 = _slicedToArray(_normalizeParameters, 3),
    isDelegated = _normalizeParameters2[0],
    callable = _normalizeParameters2[1],
    typeEvent = _normalizeParameters2[2];

  // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
  // this prevents the handler from being dispatched the same way as mouseover or mouseout does
  if (originalTypeEvent in customEvents) {
    var wrapFunction = function wrapFunction(fn) {
      return function (event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn.call(this, event);
        }
      };
    };
    callable = wrapFunction(callable);
  }
  var events = getElementEvents(element);
  var handlers = events[typeEvent] || (events[typeEvent] = {});
  var previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }
  var uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
  var fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn.delegationSelector = isDelegated ? handler : null;
  fn.callable = callable;
  fn.oneOff = oneOff;
  fn.uidEvent = uid;
  handlers[uid] = fn;
  element.addEventListener(typeEvent, fn, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  var fn = findHandler(events[typeEvent], handler, delegationSelector);
  if (!fn) {
    return;
  }
  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
  delete events[typeEvent][fn.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  var storeElementEvent = events[typeEvent] || {};
  for (var _i2 = 0, _Object$entries = Object.entries(storeElementEvent); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
      handlerKey = _Object$entries$_i[0],
      event = _Object$entries$_i[1];
    if (handlerKey.includes(namespace)) {
      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
    }
  }
}
function getTypeEvent(event) {
  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
  event = event.replace(stripNameRegex, '');
  return customEvents[event] || event;
}
var EventHandler = {
  on: function on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },
  one: function one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },
  off: function off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }
    var _normalizeParameters3 = normalizeParameters(originalTypeEvent, handler, delegationFunction),
      _normalizeParameters4 = _slicedToArray(_normalizeParameters3, 3),
      isDelegated = _normalizeParameters4[0],
      callable = _normalizeParameters4[1],
      typeEvent = _normalizeParameters4[2];
    var inNamespace = typeEvent !== originalTypeEvent;
    var events = getElementEvents(element);
    var storeElementEvent = events[typeEvent] || {};
    var isNamespace = originalTypeEvent.startsWith('.');
    if (typeof callable !== 'undefined') {
      // Simplest case: handler is passed, remove that listener ONLY.
      if (!Object.keys(storeElementEvent).length) {
        return;
      }
      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
      return;
    }
    if (isNamespace) {
      for (var _i3 = 0, _Object$keys = Object.keys(events); _i3 < _Object$keys.length; _i3++) {
        var elementEvent = _Object$keys[_i3];
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      }
    }
    for (var _i4 = 0, _Object$entries2 = Object.entries(storeElementEvent); _i4 < _Object$entries2.length; _i4++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
        keyHandlers = _Object$entries2$_i[0],
        event = _Object$entries2$_i[1];
      var handlerKey = keyHandlers.replace(stripUidRegex, '');
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },
  trigger: function trigger(element, event, args) {
    if (typeof event !== 'string' || !element) {
      return null;
    }
    var $ = getjQuery();
    var typeEvent = getTypeEvent(event);
    var inNamespace = event !== typeEvent;
    var jQueryEvent = null;
    var bubbles = true;
    var nativeDispatch = true;
    var defaultPrevented = false;
    if (inNamespace && $) {
      jQueryEvent = $.Event(event, args);
      $(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    var evt = hydrateObj(new Event(event, {
      bubbles: bubbles,
      cancelable: true
    }), args);
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
function hydrateObj(obj) {
  var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _loop = function _loop() {
    var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i5], 2),
      key = _Object$entries3$_i[0],
      value = _Object$entries3$_i[1];
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,
        get: function get() {
          return value;
        }
      });
    }
  };
  for (var _i5 = 0, _Object$entries3 = Object.entries(meta); _i5 < _Object$entries3.length; _i5++) {
    _loop();
  }
  return obj;
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

function normalizeData(value) {
  if (value === 'true') {
    return true;
  }
  if (value === 'false') {
    return false;
  }
  if (value === Number(value).toString()) {
    return Number(value);
  }
  if (value === '' || value === 'null') {
    return null;
  }
  if (typeof value !== 'string') {
    return value;
  }
  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
}
function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, function (chr) {
    return "-".concat(chr.toLowerCase());
  });
}
var Manipulator = {
  setDataAttribute: function setDataAttribute(element, key, value) {
    element.setAttribute("data-bs-".concat(normalizeDataKey(key)), value);
  },
  removeDataAttribute: function removeDataAttribute(element, key) {
    element.removeAttribute("data-bs-".concat(normalizeDataKey(key)));
  },
  getDataAttributes: function getDataAttributes(element) {
    if (!element) {
      return {};
    }
    var attributes = {};
    var bsKeys = Object.keys(element.dataset).filter(function (key) {
      return key.startsWith('bs') && !key.startsWith('bsConfig');
    });
    var _iterator2 = _createForOfIteratorHelper(bsKeys),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var key = _step2.value;
        var pureKey = key.replace(/^bs/, '');
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return attributes;
  },
  getDataAttribute: function getDataAttribute(element, key) {
    return normalizeData(element.getAttribute("data-bs-".concat(normalizeDataKey(key))));
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/config.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Class definition
 */
var Config = /*#__PURE__*/function () {
  function Config() {
    _classCallCheck(this, Config);
  }
  return _createClass(Config, [{
    key: "_getConfig",
    value: function _getConfig(config) {
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
  }, {
    key: "_configAfterMerge",
    value: function _configAfterMerge(config) {
      return config;
    }
  }, {
    key: "_mergeConfigObj",
    value: function _mergeConfigObj(config, element) {
      var jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse

      return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), _typeof(jsonConfig) === 'object' ? jsonConfig : {}), isElement(element) ? Manipulator.getDataAttributes(element) : {}), _typeof(config) === 'object' ? config : {});
    }
  }, {
    key: "_typeCheckConfig",
    value: function _typeCheckConfig(config) {
      var configTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.DefaultType;
      for (var _i6 = 0, _Object$entries4 = Object.entries(configTypes); _i6 < _Object$entries4.length; _i6++) {
        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i6], 2),
          property = _Object$entries4$_i[0],
          expectedTypes = _Object$entries4$_i[1];
        var value = config[property];
        var valueType = isElement(value) ? 'element' : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError("".concat(this.constructor.NAME.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
        }
      }
    }
  }], [{
    key: "Default",
    get:
    // Getters
    function get() {
      return {};
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return {};
    }
  }, {
    key: "NAME",
    get: function get() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
  }]);
}();
/**
 * --------------------------------------------------------------------------
 * Bootstrap base-component.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * Constants
 */
var VERSION = '5.3.7';

/**
 * Class definition
 */
var BaseComponent = /*#__PURE__*/function (_Config) {
  function BaseComponent(element, config) {
    var _this;
    _classCallCheck(this, BaseComponent);
    _this = _callSuper(this, BaseComponent);
    element = getElement(element);
    if (!element) {
      return _possibleConstructorReturn(_this);
    }
    _this._element = element;
    _this._config = _this._getConfig(config);
    Data.set(_this._element, _this.constructor.DATA_KEY, _this);
    return _this;
  }

  // Public
  _inherits(BaseComponent, _Config);
  return _createClass(BaseComponent, [{
    key: "dispose",
    value: function dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      var _iterator3 = _createForOfIteratorHelper(Object.getOwnPropertyNames(this)),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var propertyName = _step3.value;
          this[propertyName] = null;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }

    // Private
  }, {
    key: "_queueCallback",
    value: function _queueCallback(callback, element) {
      var isAnimated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      executeAfterTransition(callback, element, isAnimated);
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = this._mergeConfigObj(config, this._element);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }

    // Static
  }], [{
    key: "getInstance",
    value: function getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
  }, {
    key: "getOrCreateInstance",
    value: function getOrCreateInstance(element) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.getInstance(element) || new this(element, _typeof(config) === 'object' ? config : null);
    }
  }, {
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "DATA_KEY",
    get: function get() {
      return "bs.".concat(this.NAME);
    }
  }, {
    key: "EVENT_KEY",
    get: function get() {
      return ".".concat(this.DATA_KEY);
    }
  }, {
    key: "eventName",
    value: function eventName(name) {
      return "".concat(name).concat(this.EVENT_KEY);
    }
  }]);
}(Config);
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/selector-engine.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
var getSelector = function getSelector(element) {
  var selector = element.getAttribute('data-bs-target');
  if (!selector || selector === '#') {
    var hrefAttribute = element.getAttribute('href');

    // The only valid content that could double as a selector are IDs or classes,
    // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
    // `document.querySelector` will rightfully complain it is invalid.
    // See https://github.com/twbs/bootstrap/issues/32273
    if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
      return null;
    }

    // Just in case some CMS puts out a full URL with the anchor appended
    if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
      hrefAttribute = "#".concat(hrefAttribute.split('#')[1]);
    }
    selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
  }
  return selector ? selector.split(',').map(function (sel) {
    return parseSelector(sel);
  }).join(',') : null;
};
var SelectorEngine = {
  find: function find(selector) {
    var _ref2;
    var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
    return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(Element.prototype.querySelectorAll.call(element, selector)));
  },
  findOne: function findOne(selector) {
    var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
    return Element.prototype.querySelector.call(element, selector);
  },
  children: function children(element, selector) {
    var _ref3;
    return (_ref3 = []).concat.apply(_ref3, _toConsumableArray(element.children)).filter(function (child) {
      return child.matches(selector);
    });
  },
  parents: function parents(element, selector) {
    var parents = [];
    var ancestor = element.parentNode.closest(selector);
    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }
    return parents;
  },
  prev: function prev(element, selector) {
    var previous = element.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next: function next(element, selector) {
    var next = element.nextElementSibling;
    while (next) {
      if (next.matches(selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren: function focusableChildren(element) {
    var focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(function (selector) {
      return "".concat(selector, ":not([tabindex^=\"-\"])");
    }).join(',');
    return this.find(focusables, element).filter(function (el) {
      return !isDisabled(el) && isVisible(el);
    });
  },
  getSelectorFromElement: function getSelectorFromElement(element) {
    var selector = getSelector(element);
    if (selector) {
      return SelectorEngine.findOne(selector) ? selector : null;
    }
    return null;
  },
  getElementFromSelector: function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? SelectorEngine.findOne(selector) : null;
  },
  getMultipleElementsFromSelector: function getMultipleElementsFromSelector(element) {
    var selector = getSelector(element);
    return selector ? SelectorEngine.find(selector) : [];
  }
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

var enableDismissTrigger = function enableDismissTrigger(component) {
  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';
  var clickEvent = "click.dismiss".concat(component.EVENT_KEY);
  var name = component.NAME;
  EventHandler.on(document, clickEvent, "[data-bs-dismiss=\"".concat(name, "\"]"), function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    var target = SelectorEngine.getElementFromSelector(this) || this.closest(".".concat(name));
    var instance = component.getOrCreateInstance(target);

    // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
    instance[method]();
  });
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$f = 'alert';
var DATA_KEY$a = 'bs.alert';
var EVENT_KEY$b = ".".concat(DATA_KEY$a);
var EVENT_CLOSE = "close".concat(EVENT_KEY$b);
var EVENT_CLOSED = "closed".concat(EVENT_KEY$b);
var CLASS_NAME_FADE$5 = 'fade';
var CLASS_NAME_SHOW$8 = 'show';

/**
 * Class definition
 */
var Alert = exports.Alert = /*#__PURE__*/function (_BaseComponent) {
  function Alert() {
    _classCallCheck(this, Alert);
    return _callSuper(this, Alert, arguments);
  }
  _inherits(Alert, _BaseComponent);
  return _createClass(Alert, [{
    key: "close",
    value:
    // Public
    function close() {
      var _this2 = this;
      var closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      var isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(function () {
        return _this2._destroyElement();
      }, this._element, isAnimated);
    }

    // Private
  }, {
    key: "_destroyElement",
    value: function _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }

    // Static
  }], [{
    key: "NAME",
    get:
    // Getters
    function get() {
      return NAME$f;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Alert.getOrCreateInstance(this);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }
        data[config](this);
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
enableDismissTrigger(Alert, 'close');

/**
 * jQuery
 */

defineJQueryPlugin(Alert);

/**
 * --------------------------------------------------------------------------
 * Bootstrap button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$e = 'button';
var DATA_KEY$9 = 'bs.button';
var EVENT_KEY$a = ".".concat(DATA_KEY$9);
var DATA_API_KEY$6 = '.data-api';
var CLASS_NAME_ACTIVE$3 = 'active';
var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
var EVENT_CLICK_DATA_API$6 = "click".concat(EVENT_KEY$a).concat(DATA_API_KEY$6);

/**
 * Class definition
 */
var Button = exports.Button = /*#__PURE__*/function (_BaseComponent2) {
  function Button() {
    _classCallCheck(this, Button);
    return _callSuper(this, Button, arguments);
  }
  _inherits(Button, _BaseComponent2);
  return _createClass(Button, [{
    key: "toggle",
    value:
    // Public
    function toggle() {
      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
      this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }

    // Static
  }], [{
    key: "NAME",
    get:
    // Getters
    function get() {
      return NAME$e;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Button.getOrCreateInstance(this);
        if (config === 'toggle') {
          data[config]();
        }
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, function (event) {
  event.preventDefault();
  var button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  var data = Button.getOrCreateInstance(button);
  data.toggle();
});

/**
 * jQuery
 */

defineJQueryPlugin(Button);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/swipe.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$d = 'swipe';
var EVENT_KEY$9 = '.bs.swipe';
var EVENT_TOUCHSTART = "touchstart".concat(EVENT_KEY$9);
var EVENT_TOUCHMOVE = "touchmove".concat(EVENT_KEY$9);
var EVENT_TOUCHEND = "touchend".concat(EVENT_KEY$9);
var EVENT_POINTERDOWN = "pointerdown".concat(EVENT_KEY$9);
var EVENT_POINTERUP = "pointerup".concat(EVENT_KEY$9);
var POINTER_TYPE_TOUCH = 'touch';
var POINTER_TYPE_PEN = 'pen';
var CLASS_NAME_POINTER_EVENT = 'pointer-event';
var SWIPE_THRESHOLD = 40;
var Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
var DefaultType$c = {
  endCallback: '(function|null)',
  leftCallback: '(function|null)',
  rightCallback: '(function|null)'
};

/**
 * Class definition
 */
var Swipe = /*#__PURE__*/function (_Config2) {
  function Swipe(element, config) {
    var _this3;
    _classCallCheck(this, Swipe);
    _this3 = _callSuper(this, Swipe);
    _this3._element = element;
    if (!element || !Swipe.isSupported()) {
      return _possibleConstructorReturn(_this3);
    }
    _this3._config = _this3._getConfig(config);
    _this3._deltaX = 0;
    _this3._supportPointerEvents = Boolean(window.PointerEvent);
    _this3._initEvents();
    return _this3;
  }

  // Getters
  _inherits(Swipe, _Config2);
  return _createClass(Swipe, [{
    key: "dispose",
    value:
    // Public
    function dispose() {
      EventHandler.off(this._element, EVENT_KEY$9);
    }

    // Private
  }, {
    key: "_start",
    value: function _start(event) {
      if (!this._supportPointerEvents) {
        this._deltaX = event.touches[0].clientX;
        return;
      }
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX;
      }
    }
  }, {
    key: "_end",
    value: function _end(event) {
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX - this._deltaX;
      }
      this._handleSwipe();
      execute(this._config.endCallback);
    }
  }, {
    key: "_move",
    value: function _move(event) {
      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
  }, {
    key: "_handleSwipe",
    value: function _handleSwipe() {
      var absDeltaX = Math.abs(this._deltaX);
      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }
      var direction = absDeltaX / this._deltaX;
      this._deltaX = 0;
      if (!direction) {
        return;
      }
      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
  }, {
    key: "_initEvents",
    value: function _initEvents() {
      var _this4 = this;
      if (this._supportPointerEvents) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, function (event) {
          return _this4._start(event);
        });
        EventHandler.on(this._element, EVENT_POINTERUP, function (event) {
          return _this4._end(event);
        });
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, function (event) {
          return _this4._start(event);
        });
        EventHandler.on(this._element, EVENT_TOUCHMOVE, function (event) {
          return _this4._move(event);
        });
        EventHandler.on(this._element, EVENT_TOUCHEND, function (event) {
          return _this4._end(event);
        });
      }
    }
  }, {
    key: "_eventIsPointerPenTouch",
    value: function _eventIsPointerPenTouch(event) {
      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default$c;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$c;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$d;
    }
  }, {
    key: "isSupported",
    value: function isSupported() {
      return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
    }
  }]);
}(Config);
/**
 * --------------------------------------------------------------------------
 * Bootstrap carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * Constants
 */
var NAME$c = 'carousel';
var DATA_KEY$8 = 'bs.carousel';
var EVENT_KEY$8 = ".".concat(DATA_KEY$8);
var DATA_API_KEY$5 = '.data-api';
var ARROW_LEFT_KEY$1 = 'ArrowLeft';
var ARROW_RIGHT_KEY$1 = 'ArrowRight';
var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

var ORDER_NEXT = 'next';
var ORDER_PREV = 'prev';
var DIRECTION_LEFT = 'left';
var DIRECTION_RIGHT = 'right';
var EVENT_SLIDE = "slide".concat(EVENT_KEY$8);
var EVENT_SLID = "slid".concat(EVENT_KEY$8);
var EVENT_KEYDOWN$1 = "keydown".concat(EVENT_KEY$8);
var EVENT_MOUSEENTER$1 = "mouseenter".concat(EVENT_KEY$8);
var EVENT_MOUSELEAVE$1 = "mouseleave".concat(EVENT_KEY$8);
var EVENT_DRAG_START = "dragstart".concat(EVENT_KEY$8);
var EVENT_LOAD_DATA_API$3 = "load".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);
var EVENT_CLICK_DATA_API$5 = "click".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);
var CLASS_NAME_CAROUSEL = 'carousel';
var CLASS_NAME_ACTIVE$2 = 'active';
var CLASS_NAME_SLIDE = 'slide';
var CLASS_NAME_END = 'carousel-item-end';
var CLASS_NAME_START = 'carousel-item-start';
var CLASS_NAME_NEXT = 'carousel-item-next';
var CLASS_NAME_PREV = 'carousel-item-prev';
var SELECTOR_ACTIVE = '.active';
var SELECTOR_ITEM = '.carousel-item';
var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
var SELECTOR_ITEM_IMG = '.carousel-item img';
var SELECTOR_INDICATORS = '.carousel-indicators';
var SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
var KEY_TO_DIRECTION = _defineProperty(_defineProperty({}, ARROW_LEFT_KEY$1, DIRECTION_RIGHT), ARROW_RIGHT_KEY$1, DIRECTION_LEFT);
var Default$b = {
  interval: 5000,
  keyboard: true,
  pause: 'hover',
  ride: false,
  touch: true,
  wrap: true
};
var DefaultType$b = {
  interval: '(number|boolean)',
  // TODO:v6 remove boolean support
  keyboard: 'boolean',
  pause: '(string|boolean)',
  ride: '(boolean|string)',
  touch: 'boolean',
  wrap: 'boolean'
};

/**
 * Class definition
 */
var Carousel = exports.Carousel = /*#__PURE__*/function (_BaseComponent3) {
  function Carousel(element, config) {
    var _this5;
    _classCallCheck(this, Carousel);
    _this5 = _callSuper(this, Carousel, [element, config]);
    _this5._interval = null;
    _this5._activeElement = null;
    _this5._isSliding = false;
    _this5.touchTimeout = null;
    _this5._swipeHelper = null;
    _this5._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, _this5._element);
    _this5._addEventListeners();
    if (_this5._config.ride === CLASS_NAME_CAROUSEL) {
      _this5.cycle();
    }
    return _this5;
  }

  // Getters
  _inherits(Carousel, _BaseComponent3);
  return _createClass(Carousel, [{
    key: "next",
    value:
    // Public
    function next() {
      this._slide(ORDER_NEXT);
    }
  }, {
    key: "nextWhenVisible",
    value: function nextWhenVisible() {
      // FIXME TODO use `document.visibilityState`
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
  }, {
    key: "prev",
    value: function prev() {
      this._slide(ORDER_PREV);
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this._isSliding) {
        triggerTransitionEnd(this._element);
      }
      this._clearInterval();
    }
  }, {
    key: "cycle",
    value: function cycle() {
      var _this6 = this;
      this._clearInterval();
      this._updateInterval();
      this._interval = setInterval(function () {
        return _this6.nextWhenVisible();
      }, this._config.interval);
    }
  }, {
    key: "_maybeEnableCycle",
    value: function _maybeEnableCycle() {
      var _this7 = this;
      if (!this._config.ride) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, function () {
          return _this7.cycle();
        });
        return;
      }
      this.cycle();
    }
  }, {
    key: "to",
    value: function to(index) {
      var _this8 = this;
      var items = this._getItems();
      if (index > items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, function () {
          return _this8.to(index);
        });
        return;
      }
      var activeIndex = this._getItemIndex(this._getActive());
      if (activeIndex === index) {
        return;
      }
      var order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order, items[index]);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this._swipeHelper) {
        this._swipeHelper.dispose();
      }
      _superPropGet(Carousel, "dispose", this, 3)([]);
    }

    // Private
  }, {
    key: "_configAfterMerge",
    value: function _configAfterMerge(config) {
      config.defaultInterval = config.interval;
      return config;
    }
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var _this9 = this;
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN$1, function (event) {
          return _this9._keydown(event);
        });
      }
      if (this._config.pause === 'hover') {
        EventHandler.on(this._element, EVENT_MOUSEENTER$1, function () {
          return _this9.pause();
        });
        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, function () {
          return _this9._maybeEnableCycle();
        });
      }
      if (this._config.touch && Swipe.isSupported()) {
        this._addTouchEventListeners();
      }
    }
  }, {
    key: "_addTouchEventListeners",
    value: function _addTouchEventListeners() {
      var _this0 = this;
      var _iterator4 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var img = _step4.value;
          EventHandler.on(img, EVENT_DRAG_START, function (event) {
            return event.preventDefault();
          });
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      var endCallBack = function endCallBack() {
        if (_this0._config.pause !== 'hover') {
          return;
        }

        // If it's a touch-enabled device, mouseenter/leave are fired as
        // part of the mouse compatibility events on first tap - the carousel
        // would stop cycling until user tapped out of it;
        // here, we listen for touchend, explicitly pause the carousel
        // (as if it's the second time we tap on it, mouseenter compat event
        // is NOT fired) and after a timeout (to allow for mouse compatibility
        // events to fire) we explicitly restart cycling

        _this0.pause();
        if (_this0.touchTimeout) {
          clearTimeout(_this0.touchTimeout);
        }
        _this0.touchTimeout = setTimeout(function () {
          return _this0._maybeEnableCycle();
        }, TOUCHEVENT_COMPAT_WAIT + _this0._config.interval);
      };
      var swipeConfig = {
        leftCallback: function leftCallback() {
          return _this0._slide(_this0._directionToOrder(DIRECTION_LEFT));
        },
        rightCallback: function rightCallback() {
          return _this0._slide(_this0._directionToOrder(DIRECTION_RIGHT));
        },
        endCallback: endCallBack
      };
      this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
  }, {
    key: "_keydown",
    value: function _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      var direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(this._directionToOrder(direction));
      }
    }
  }, {
    key: "_getItemIndex",
    value: function _getItemIndex(element) {
      return this._getItems().indexOf(element);
    }
  }, {
    key: "_setActiveIndicatorElement",
    value: function _setActiveIndicatorElement(index) {
      if (!this._indicatorsElement) {
        return;
      }
      var activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute('aria-current');
      var newActiveIndicator = SelectorEngine.findOne("[data-bs-slide-to=\"".concat(index, "\"]"), this._indicatorsElement);
      if (newActiveIndicator) {
        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
        newActiveIndicator.setAttribute('aria-current', 'true');
      }
    }
  }, {
    key: "_updateInterval",
    value: function _updateInterval() {
      var element = this._activeElement || this._getActive();
      if (!element) {
        return;
      }
      var elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
      this._config.interval = elementInterval || this._config.defaultInterval;
    }
  }, {
    key: "_slide",
    value: function _slide(order) {
      var _this1 = this;
      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (this._isSliding) {
        return;
      }
      var activeElement = this._getActive();
      var isNext = order === ORDER_NEXT;
      var nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
      if (nextElement === activeElement) {
        return;
      }
      var nextElementIndex = this._getItemIndex(nextElement);
      var triggerEvent = function triggerEvent(eventName) {
        return EventHandler.trigger(_this1._element, eventName, {
          relatedTarget: nextElement,
          direction: _this1._orderToDirection(order),
          from: _this1._getItemIndex(activeElement),
          to: nextElementIndex
        });
      };
      var slideEvent = triggerEvent(EVENT_SLIDE);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        // TODO: change tests that use empty divs to avoid this check
        return;
      }
      var isCycling = Boolean(this._interval);
      this.pause();
      this._isSliding = true;
      this._setActiveIndicatorElement(nextElementIndex);
      this._activeElement = nextElement;
      var directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      var orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);
      var completeCallBack = function completeCallBack() {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
        _this1._isSliding = false;
        triggerEvent(EVENT_SLID);
      };
      this._queueCallback(completeCallBack, activeElement, this._isAnimated());
      if (isCycling) {
        this.cycle();
      }
    }
  }, {
    key: "_isAnimated",
    value: function _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
  }, {
    key: "_getActive",
    value: function _getActive() {
      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
  }, {
    key: "_getItems",
    value: function _getItems() {
      return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
  }, {
    key: "_clearInterval",
    value: function _clearInterval() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
  }, {
    key: "_directionToOrder",
    value: function _directionToOrder(direction) {
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
  }, {
    key: "_orderToDirection",
    value: function _orderToDirection(order) {
      if (isRTL()) {
        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default$b;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$b;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$c;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Carousel.getOrCreateInstance(this, config);
        if (typeof config === 'number') {
          data.to(config);
          return;
        }
        if (typeof config === 'string') {
          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }
          data[config]();
        }
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {
  var target = SelectorEngine.getElementFromSelector(this);
  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }
  event.preventDefault();
  var carousel = Carousel.getOrCreateInstance(target);
  var slideIndex = this.getAttribute('data-bs-slide-to');
  if (slideIndex) {
    carousel.to(slideIndex);
    carousel._maybeEnableCycle();
    return;
  }
  if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
    carousel.next();
    carousel._maybeEnableCycle();
    return;
  }
  carousel.prev();
  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, function () {
  var carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
  var _iterator5 = _createForOfIteratorHelper(carousels),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var carousel = _step5.value;
      Carousel.getOrCreateInstance(carousel);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(Carousel);

/**
 * --------------------------------------------------------------------------
 * Bootstrap collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$b = 'collapse';
var DATA_KEY$7 = 'bs.collapse';
var EVENT_KEY$7 = ".".concat(DATA_KEY$7);
var DATA_API_KEY$4 = '.data-api';
var EVENT_SHOW$6 = "show".concat(EVENT_KEY$7);
var EVENT_SHOWN$6 = "shown".concat(EVENT_KEY$7);
var EVENT_HIDE$6 = "hide".concat(EVENT_KEY$7);
var EVENT_HIDDEN$6 = "hidden".concat(EVENT_KEY$7);
var EVENT_CLICK_DATA_API$4 = "click".concat(EVENT_KEY$7).concat(DATA_API_KEY$4);
var CLASS_NAME_SHOW$7 = 'show';
var CLASS_NAME_COLLAPSE = 'collapse';
var CLASS_NAME_COLLAPSING = 'collapsing';
var CLASS_NAME_COLLAPSED = 'collapsed';
var CLASS_NAME_DEEPER_CHILDREN = ":scope .".concat(CLASS_NAME_COLLAPSE, " .").concat(CLASS_NAME_COLLAPSE);
var CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
var WIDTH = 'width';
var HEIGHT = 'height';
var SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
var Default$a = {
  parent: null,
  toggle: true
};
var DefaultType$a = {
  parent: '(null|element)',
  toggle: 'boolean'
};

/**
 * Class definition
 */
var Collapse = exports.Collapse = /*#__PURE__*/function (_BaseComponent4) {
  function Collapse(element, config) {
    var _this10;
    _classCallCheck(this, Collapse);
    _this10 = _callSuper(this, Collapse, [element, config]);
    _this10._isTransitioning = false;
    _this10._triggerArray = [];
    var toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    var _iterator6 = _createForOfIteratorHelper(toggleList),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var elem = _step6.value;
        var selector = SelectorEngine.getSelectorFromElement(elem);
        var filterElement = SelectorEngine.find(selector).filter(function (foundElement) {
          return foundElement === _this10._element;
        });
        if (selector !== null && filterElement.length) {
          _this10._triggerArray.push(elem);
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
    _this10._initializeChildren();
    if (!_this10._config.parent) {
      _this10._addAriaAndCollapsedClass(_this10._triggerArray, _this10._isShown());
    }
    if (_this10._config.toggle) {
      _this10.toggle();
    }
    return _this10;
  }

  // Getters
  _inherits(Collapse, _BaseComponent4);
  return _createClass(Collapse, [{
    key: "toggle",
    value:
    // Public
    function toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: "show",
    value: function show() {
      var _this11 = this;
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      var activeChildren = [];

      // find active children
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(function (element) {
          return element !== _this11._element;
        }).map(function (element) {
          return Collapse.getOrCreateInstance(element, {
            toggle: false
          });
        });
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      var startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      var _iterator7 = _createForOfIteratorHelper(activeChildren),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var activeInstance = _step7.value;
          activeInstance.hide();
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      var dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      var complete = function complete() {
        _this11._isTransitioning = false;
        _this11._element.classList.remove(CLASS_NAME_COLLAPSING);
        _this11._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        _this11._element.style[dimension] = '';
        EventHandler.trigger(_this11._element, EVENT_SHOWN$6);
      };
      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll".concat(capitalizedDimension);
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = "".concat(this._element[scrollSize], "px");
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this12 = this;
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      var startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      var dimension = this._getDimension();
      this._element.style[dimension] = "".concat(this._element.getBoundingClientRect()[dimension], "px");
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      var _iterator8 = _createForOfIteratorHelper(this._triggerArray),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var trigger = _step8.value;
          var element = SelectorEngine.getElementFromSelector(trigger);
          if (element && !this._isShown(element)) {
            this._addAriaAndCollapsedClass([trigger], false);
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      this._isTransitioning = true;
      var complete = function complete() {
        _this12._isTransitioning = false;
        _this12._element.classList.remove(CLASS_NAME_COLLAPSING);
        _this12._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(_this12._element, EVENT_HIDDEN$6);
      };
      this._element.style[dimension] = '';
      this._queueCallback(complete, this._element, true);
    }

    // Private
  }, {
    key: "_isShown",
    value: function _isShown() {
      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }
  }, {
    key: "_configAfterMerge",
    value: function _configAfterMerge(config) {
      config.toggle = Boolean(config.toggle); // Coerce string values
      config.parent = getElement(config.parent);
      return config;
    }
  }, {
    key: "_getDimension",
    value: function _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
  }, {
    key: "_initializeChildren",
    value: function _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      var children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
      var _iterator9 = _createForOfIteratorHelper(children),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var element = _step9.value;
          var selected = SelectorEngine.getElementFromSelector(element);
          if (selected) {
            this._addAriaAndCollapsedClass([element], this._isShown(selected));
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
    }
  }, {
    key: "_getFirstLevelChildren",
    value: function _getFirstLevelChildren(selector) {
      var children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      // remove children if greater depth
      return SelectorEngine.find(selector, this._config.parent).filter(function (element) {
        return !children.includes(element);
      });
    }
  }, {
    key: "_addAriaAndCollapsedClass",
    value: function _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      var _iterator0 = _createForOfIteratorHelper(triggerArray),
        _step0;
      try {
        for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
          var element = _step0.value;
          element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
          element.setAttribute('aria-expanded', isOpen);
        }
      } catch (err) {
        _iterator0.e(err);
      } finally {
        _iterator0.f();
      }
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default$a;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$a;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$b;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      var _config = {};
      if (typeof config === 'string' && /show|hide/.test(config)) {
        _config.toggle = false;
      }
      return this.each(function () {
        var data = Collapse.getOrCreateInstance(this, _config);
        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }
          data[config]();
        }
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
    event.preventDefault();
  }
  var _iterator1 = _createForOfIteratorHelper(SelectorEngine.getMultipleElementsFromSelector(this)),
    _step1;
  try {
    for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
      var element = _step1.value;
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    }
  } catch (err) {
    _iterator1.e(err);
  } finally {
    _iterator1.f();
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(Collapse);

/**
 * --------------------------------------------------------------------------
 * Bootstrap dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$a = 'dropdown';
var DATA_KEY$6 = 'bs.dropdown';
var EVENT_KEY$6 = ".".concat(DATA_KEY$6);
var DATA_API_KEY$3 = '.data-api';
var ESCAPE_KEY$2 = 'Escape';
var TAB_KEY$1 = 'Tab';
var ARROW_UP_KEY$1 = 'ArrowUp';
var ARROW_DOWN_KEY$1 = 'ArrowDown';
var RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

var EVENT_HIDE$5 = "hide".concat(EVENT_KEY$6);
var EVENT_HIDDEN$5 = "hidden".concat(EVENT_KEY$6);
var EVENT_SHOW$5 = "show".concat(EVENT_KEY$6);
var EVENT_SHOWN$5 = "shown".concat(EVENT_KEY$6);
var EVENT_CLICK_DATA_API$3 = "click".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);
var EVENT_KEYDOWN_DATA_API = "keydown".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);
var EVENT_KEYUP_DATA_API = "keyup".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);
var CLASS_NAME_SHOW$6 = 'show';
var CLASS_NAME_DROPUP = 'dropup';
var CLASS_NAME_DROPEND = 'dropend';
var CLASS_NAME_DROPSTART = 'dropstart';
var CLASS_NAME_DROPUP_CENTER = 'dropup-center';
var CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
var SELECTOR_DATA_TOGGLE_SHOWN = "".concat(SELECTOR_DATA_TOGGLE$3, ".").concat(CLASS_NAME_SHOW$6);
var SELECTOR_MENU = '.dropdown-menu';
var SELECTOR_NAVBAR = '.navbar';
var SELECTOR_NAVBAR_NAV = '.navbar-nav';
var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
var PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
var PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
var PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
var PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
var PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
var PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
var PLACEMENT_TOPCENTER = 'top';
var PLACEMENT_BOTTOMCENTER = 'bottom';
var Default$9 = {
  autoClose: true,
  boundary: 'clippingParents',
  display: 'dynamic',
  offset: [0, 2],
  popperConfig: null,
  reference: 'toggle'
};
var DefaultType$9 = {
  autoClose: '(boolean|string)',
  boundary: '(string|element)',
  display: 'string',
  offset: '(array|string|function)',
  popperConfig: '(null|object|function)',
  reference: '(string|element|object)'
};

/**
 * Class definition
 */
var Dropdown = exports.Dropdown = /*#__PURE__*/function (_BaseComponent5) {
  function Dropdown(element, config) {
    var _this13;
    _classCallCheck(this, Dropdown);
    _this13 = _callSuper(this, Dropdown, [element, config]);
    _this13._popper = null;
    _this13._parent = _this13._element.parentNode; // dropdown wrapper
    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
    _this13._menu = SelectorEngine.next(_this13._element, SELECTOR_MENU)[0] || SelectorEngine.prev(_this13._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, _this13._parent);
    _this13._inNavbar = _this13._detectNavbar();
    return _this13;
  }

  // Getters
  _inherits(Dropdown, _BaseComponent5);
  return _createClass(Dropdown, [{
    key: "toggle",
    value:
    // Public
    function toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
  }, {
    key: "show",
    value: function show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
        var _ref4;
        var _iterator10 = _createForOfIteratorHelper((_ref4 = []).concat.apply(_ref4, _toConsumableArray(document.body.children))),
          _step10;
        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var element = _step10.value;
            EventHandler.on(element, 'mouseover', noop);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
      }
      this._element.focus();
      this._element.setAttribute('aria-expanded', true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
  }, {
    key: "hide",
    value: function hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      var relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      _superPropGet(Dropdown, "dispose", this, 3)([]);
    }
  }, {
    key: "update",
    value: function update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }

    // Private
  }, {
    key: "_completeHide",
    value: function _completeHide(relatedTarget) {
      var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }

      // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support
      if ('ontouchstart' in document.documentElement) {
        var _ref5;
        var _iterator11 = _createForOfIteratorHelper((_ref5 = []).concat.apply(_ref5, _toConsumableArray(document.body.children))),
          _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var element = _step11.value;
            EventHandler.off(element, 'mouseover', noop);
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute('aria-expanded', 'false');
      Manipulator.removeDataAttribute(this._menu, 'popper');
      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);

      // Explicitly return focus to the trigger element
      this._element.focus();
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _superPropGet(Dropdown, "_getConfig", this, 3)([config]);
      if (_typeof(config.reference) === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
        // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError("".concat(NAME$a.toUpperCase(), ": Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method."));
      }
      return config;
    }
  }, {
    key: "_createPopper",
    value: function _createPopper() {
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org/docs/v2/)');
      }
      var referenceElement = this._element;
      if (this._config.reference === 'parent') {
        referenceElement = this._parent;
      } else if (isElement(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (_typeof(this._config.reference) === 'object') {
        referenceElement = this._config.reference;
      }
      var popperConfig = this._getPopperConfig();
      this._popper = Popper.createPopper(referenceElement, this._menu, popperConfig);
    }
  }, {
    key: "_isShown",
    value: function _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
  }, {
    key: "_getPlacement",
    value: function _getPlacement() {
      var parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }

      // We need to trim the value because custom properties can also include spaces
      var isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
  }, {
    key: "_detectNavbar",
    value: function _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
  }, {
    key: "_getOffset",
    value: function _getOffset() {
      var _this14 = this;
      var offset = this._config.offset;
      if (typeof offset === 'string') {
        return offset.split(',').map(function (value) {
          return Number.parseInt(value, 10);
        });
      }
      if (typeof offset === 'function') {
        return function (popperData) {
          return offset(popperData, _this14._element);
        };
      }
      return offset;
    }
  }, {
    key: "_getPopperConfig",
    value: function _getPopperConfig() {
      var defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }]
      };

      // Disable Popper if we have a static display or Dropdown is in Navbar
      if (this._inNavbar || this._config.display === 'static') {
        Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove
        defaultBsPopperConfig.modifiers = [{
          name: 'applyStyles',
          enabled: false
        }];
      }
      return _objectSpread(_objectSpread({}, defaultBsPopperConfig), execute(this._config.popperConfig, [undefined, defaultBsPopperConfig]));
    }
  }, {
    key: "_selectMenuItem",
    value: function _selectMenuItem(_ref6) {
      var key = _ref6.key,
        target = _ref6.target;
      var items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(function (element) {
        return isVisible(element);
      });
      if (!items.length) {
        return;
      }

      // if target isn't included in items (e.g. when expanding the dropdown)
      // allow cycling to get the last item in case key equals ARROW_UP_KEY
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default$9;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$9;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$a;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Dropdown.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }
        data[config]();
      });
    }
  }, {
    key: "clearMenus",
    value: function clearMenus(event) {
      if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {
        return;
      }
      var openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
      var _iterator12 = _createForOfIteratorHelper(openToggles),
        _step12;
      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var toggle = _step12.value;
          var context = Dropdown.getInstance(toggle);
          if (!context || context._config.autoClose === false) {
            continue;
          }
          var composedPath = event.composedPath();
          var isMenuTarget = composedPath.includes(context._menu);
          if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
            continue;
          }

          // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
          if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
            continue;
          }
          var relatedTarget = {
            relatedTarget: context._element
          };
          if (event.type === 'click') {
            relatedTarget.clickEvent = event;
          }
          context._completeHide(relatedTarget);
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
    }
  }, {
    key: "dataApiKeydownHandler",
    value: function dataApiKeydownHandler(event) {
      // If not an UP | DOWN | ESCAPE key => not a dropdown command
      // If input/textarea && if key is other than ESCAPE => not a dropdown command

      var isInput = /input|textarea/i.test(event.target.tagName);
      var isEscapeEvent = event.key === ESCAPE_KEY$2;
      var isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();

      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
      var getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
      var instance = Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        // else is escape and we check if it is shown
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});

/**
 * jQuery
 */

defineJQueryPlugin(Dropdown);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/backdrop.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$9 = 'backdrop';
var CLASS_NAME_FADE$4 = 'fade';
var CLASS_NAME_SHOW$5 = 'show';
var EVENT_MOUSEDOWN = "mousedown.bs.".concat(NAME$9);
var Default$8 = {
  className: 'modal-backdrop',
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: 'body' // give the choice to place backdrop under different elements
};
var DefaultType$8 = {
  className: 'string',
  clickCallback: '(function|null)',
  isAnimated: 'boolean',
  isVisible: 'boolean',
  rootElement: '(element|string)'
};

/**
 * Class definition
 */
var Backdrop = /*#__PURE__*/function (_Config3) {
  function Backdrop(config) {
    var _this15;
    _classCallCheck(this, Backdrop);
    _this15 = _callSuper(this, Backdrop);
    _this15._config = _this15._getConfig(config);
    _this15._isAppended = false;
    _this15._element = null;
    return _this15;
  }

  // Getters
  _inherits(Backdrop, _Config3);
  return _createClass(Backdrop, [{
    key: "show",
    value:
    // Public
    function show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      var element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(function () {
        execute(callback);
      });
    }
  }, {
    key: "hide",
    value: function hide(callback) {
      var _this16 = this;
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(function () {
        _this16.dispose();
        execute(callback);
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }

    // Private
  }, {
    key: "_getElement",
    value: function _getElement() {
      if (!this._element) {
        var backdrop = document.createElement('div');
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
  }, {
    key: "_configAfterMerge",
    value: function _configAfterMerge(config) {
      // use getElement() with the default "body" to get a fresh Element on each instantiation
      config.rootElement = getElement(config.rootElement);
      return config;
    }
  }, {
    key: "_append",
    value: function _append() {
      var _this17 = this;
      if (this._isAppended) {
        return;
      }
      var element = this._getElement();
      this._config.rootElement.append(element);
      EventHandler.on(element, EVENT_MOUSEDOWN, function () {
        execute(_this17._config.clickCallback);
      });
      this._isAppended = true;
    }
  }, {
    key: "_emulateAnimation",
    value: function _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  }], [{
    key: "Default",
    get: function get() {
      return Default$8;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$8;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$9;
    }
  }]);
}(Config);
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/focustrap.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * Constants
 */
var NAME$8 = 'focustrap';
var DATA_KEY$5 = 'bs.focustrap';
var EVENT_KEY$5 = ".".concat(DATA_KEY$5);
var EVENT_FOCUSIN$2 = "focusin".concat(EVENT_KEY$5);
var EVENT_KEYDOWN_TAB = "keydown.tab".concat(EVENT_KEY$5);
var TAB_KEY = 'Tab';
var TAB_NAV_FORWARD = 'forward';
var TAB_NAV_BACKWARD = 'backward';
var Default$7 = {
  autofocus: true,
  trapElement: null // The element to trap focus inside of
};
var DefaultType$7 = {
  autofocus: 'boolean',
  trapElement: 'element'
};

/**
 * Class definition
 */
var FocusTrap = /*#__PURE__*/function (_Config4) {
  function FocusTrap(config) {
    var _this18;
    _classCallCheck(this, FocusTrap);
    _this18 = _callSuper(this, FocusTrap);
    _this18._config = _this18._getConfig(config);
    _this18._isActive = false;
    _this18._lastTabNavDirection = null;
    return _this18;
  }

  // Getters
  _inherits(FocusTrap, _Config4);
  return _createClass(FocusTrap, [{
    key: "activate",
    value:
    // Public
    function activate() {
      var _this19 = this;
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
      EventHandler.on(document, EVENT_FOCUSIN$2, function (event) {
        return _this19._handleFocusin(event);
      });
      EventHandler.on(document, EVENT_KEYDOWN_TAB, function (event) {
        return _this19._handleKeydown(event);
      });
      this._isActive = true;
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$5);
    }

    // Private
  }, {
    key: "_handleFocusin",
    value: function _handleFocusin(event) {
      var trapElement = this._config.trapElement;
      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
        return;
      }
      var elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
  }, {
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  }], [{
    key: "Default",
    get: function get() {
      return Default$7;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$7;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$8;
    }
  }]);
}(Config);
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/scrollBar.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * Constants
 */
var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
var SELECTOR_STICKY_CONTENT = '.sticky-top';
var PROPERTY_PADDING = 'padding-right';
var PROPERTY_MARGIN = 'margin-right';

/**
 * Class definition
 */
var ScrollBarHelper = /*#__PURE__*/function () {
  function ScrollBarHelper() {
    _classCallCheck(this, ScrollBarHelper);
    this._element = document.body;
  }

  // Public
  return _createClass(ScrollBarHelper, [{
    key: "getWidth",
    value: function getWidth() {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
      var documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
  }, {
    key: "hide",
    value: function hide() {
      var width = this.getWidth();
      this._disableOverFlow();
      // give padding to element to balance the hidden scrollbar width
      this._setElementAttributes(this._element, PROPERTY_PADDING, function (calculatedValue) {
        return calculatedValue + width;
      });
      // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, function (calculatedValue) {
        return calculatedValue + width;
      });
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, function (calculatedValue) {
        return calculatedValue - width;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this._resetElementAttributes(this._element, 'overflow');
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
  }, {
    key: "isOverflowing",
    value: function isOverflowing() {
      return this.getWidth() > 0;
    }

    // Private
  }, {
    key: "_disableOverFlow",
    value: function _disableOverFlow() {
      this._saveInitialAttribute(this._element, 'overflow');
      this._element.style.overflow = 'hidden';
    }
  }, {
    key: "_setElementAttributes",
    value: function _setElementAttributes(selector, styleProperty, callback) {
      var _this20 = this;
      var scrollbarWidth = this.getWidth();
      var manipulationCallBack = function manipulationCallBack(element) {
        if (element !== _this20._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        _this20._saveInitialAttribute(element, styleProperty);
        var calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
        element.style.setProperty(styleProperty, "".concat(callback(Number.parseFloat(calculatedValue)), "px"));
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
  }, {
    key: "_saveInitialAttribute",
    value: function _saveInitialAttribute(element, styleProperty) {
      var actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProperty, actualValue);
      }
    }
  }, {
    key: "_resetElementAttributes",
    value: function _resetElementAttributes(selector, styleProperty) {
      var manipulationCallBack = function manipulationCallBack(element) {
        var value = Manipulator.getDataAttribute(element, styleProperty);
        // We only want to remove the property if the value is `null`; the value can also be zero
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        Manipulator.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
  }, {
    key: "_applyManipulationCallback",
    value: function _applyManipulationCallback(selector, callBack) {
      if (isElement(selector)) {
        callBack(selector);
        return;
      }
      var _iterator13 = _createForOfIteratorHelper(SelectorEngine.find(selector, this._element)),
        _step13;
      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var sel = _step13.value;
          callBack(sel);
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
    }
  }]);
}();
/**
 * --------------------------------------------------------------------------
 * Bootstrap modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * Constants
 */
var NAME$7 = 'modal';
var DATA_KEY$4 = 'bs.modal';
var EVENT_KEY$4 = ".".concat(DATA_KEY$4);
var DATA_API_KEY$2 = '.data-api';
var ESCAPE_KEY$1 = 'Escape';
var EVENT_HIDE$4 = "hide".concat(EVENT_KEY$4);
var EVENT_HIDE_PREVENTED$1 = "hidePrevented".concat(EVENT_KEY$4);
var EVENT_HIDDEN$4 = "hidden".concat(EVENT_KEY$4);
var EVENT_SHOW$4 = "show".concat(EVENT_KEY$4);
var EVENT_SHOWN$4 = "shown".concat(EVENT_KEY$4);
var EVENT_RESIZE$1 = "resize".concat(EVENT_KEY$4);
var EVENT_CLICK_DISMISS = "click.dismiss".concat(EVENT_KEY$4);
var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss".concat(EVENT_KEY$4);
var EVENT_KEYDOWN_DISMISS$1 = "keydown.dismiss".concat(EVENT_KEY$4);
var EVENT_CLICK_DATA_API$2 = "click".concat(EVENT_KEY$4).concat(DATA_API_KEY$2);
var CLASS_NAME_OPEN = 'modal-open';
var CLASS_NAME_FADE$3 = 'fade';
var CLASS_NAME_SHOW$4 = 'show';
var CLASS_NAME_STATIC = 'modal-static';
var OPEN_SELECTOR$1 = '.modal.show';
var SELECTOR_DIALOG = '.modal-dialog';
var SELECTOR_MODAL_BODY = '.modal-body';
var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
var Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
var DefaultType$6 = {
  backdrop: '(boolean|string)',
  focus: 'boolean',
  keyboard: 'boolean'
};

/**
 * Class definition
 */
var Modal = exports.Modal = /*#__PURE__*/function (_BaseComponent6) {
  function Modal(element, config) {
    var _this21;
    _classCallCheck(this, Modal);
    _this21 = _callSuper(this, Modal, [element, config]);
    _this21._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, _this21._element);
    _this21._backdrop = _this21._initializeBackDrop();
    _this21._focustrap = _this21._initializeFocusTrap();
    _this21._isShown = false;
    _this21._isTransitioning = false;
    _this21._scrollBar = new ScrollBarHelper();
    _this21._addEventListeners();
    return _this21;
  }

  // Getters
  _inherits(Modal, _BaseComponent6);
  return _createClass(Modal, [{
    key: "toggle",
    value:
    // Public
    function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
  }, {
    key: "show",
    value: function show(relatedTarget) {
      var _this22 = this;
      if (this._isShown || this._isTransitioning) {
        return;
      }
      var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
        relatedTarget: relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(function () {
        return _this22._showElement(relatedTarget);
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this23 = this;
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      this._queueCallback(function () {
        return _this23._hideModal();
      }, this._element, this._isAnimated());
    }
  }, {
    key: "dispose",
    value: function dispose() {
      EventHandler.off(window, EVENT_KEY$4);
      EventHandler.off(this._dialog, EVENT_KEY$4);
      this._backdrop.dispose();
      this._focustrap.deactivate();
      _superPropGet(Modal, "dispose", this, 3)([]);
    }
  }, {
    key: "handleUpdate",
    value: function handleUpdate() {
      this._adjustDialog();
    }

    // Private
  }, {
    key: "_initializeBackDrop",
    value: function _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
  }, {
    key: "_initializeFocusTrap",
    value: function _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
  }, {
    key: "_showElement",
    value: function _showElement(relatedTarget) {
      var _this24 = this;
      // try to append dynamic modal
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = 'block';
      this._element.removeAttribute('aria-hidden');
      this._element.setAttribute('aria-modal', true);
      this._element.setAttribute('role', 'dialog');
      this._element.scrollTop = 0;
      var modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW$4);
      var transitionComplete = function transitionComplete() {
        if (_this24._config.focus) {
          _this24._focustrap.activate();
        }
        _this24._isTransitioning = false;
        EventHandler.trigger(_this24._element, EVENT_SHOWN$4, {
          relatedTarget: relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var _this25 = this;
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, function (event) {
        if (event.key !== ESCAPE_KEY$1) {
          return;
        }
        if (_this25._config.keyboard) {
          _this25.hide();
          return;
        }
        _this25._triggerBackdropTransition();
      });
      EventHandler.on(window, EVENT_RESIZE$1, function () {
        if (_this25._isShown && !_this25._isTransitioning) {
          _this25._adjustDialog();
        }
      });
      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, function (event) {
        // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
        EventHandler.one(_this25._element, EVENT_CLICK_DISMISS, function (event2) {
          if (_this25._element !== event.target || _this25._element !== event2.target) {
            return;
          }
          if (_this25._config.backdrop === 'static') {
            _this25._triggerBackdropTransition();
            return;
          }
          if (_this25._config.backdrop) {
            _this25.hide();
          }
        });
      });
    }
  }, {
    key: "_hideModal",
    value: function _hideModal() {
      var _this26 = this;
      this._element.style.display = 'none';
      this._element.setAttribute('aria-hidden', true);
      this._element.removeAttribute('aria-modal');
      this._element.removeAttribute('role');
      this._isTransitioning = false;
      this._backdrop.hide(function () {
        document.body.classList.remove(CLASS_NAME_OPEN);
        _this26._resetAdjustments();
        _this26._scrollBar.reset();
        EventHandler.trigger(_this26._element, EVENT_HIDDEN$4);
      });
    }
  }, {
    key: "_isAnimated",
    value: function _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
  }, {
    key: "_triggerBackdropTransition",
    value: function _triggerBackdropTransition() {
      var _this27 = this;
      var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
      if (hideEvent.defaultPrevented) {
        return;
      }
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      var initialOverflowY = this._element.style.overflowY;
      // return if the following background transition hasn't yet completed
      if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = 'hidden';
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(function () {
        _this27._element.classList.remove(CLASS_NAME_STATIC);
        _this27._queueCallback(function () {
          _this27._element.style.overflowY = initialOverflowY;
        }, _this27._dialog);
      }, this._dialog);
      this._element.focus();
    }

    /**
     * The following methods are used to handle overflowing modals
     */
  }, {
    key: "_adjustDialog",
    value: function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      var scrollbarWidth = this._scrollBar.getWidth();
      var isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        var property = isRTL() ? 'paddingLeft' : 'paddingRight';
        this._element.style[property] = "".concat(scrollbarWidth, "px");
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        var _property = isRTL() ? 'paddingRight' : 'paddingLeft';
        this._element.style[_property] = "".concat(scrollbarWidth, "px");
      }
    }
  }, {
    key: "_resetAdjustments",
    value: function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default$6;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$6;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$7;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = Modal.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }
        data[config](relatedTarget);
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
  var _this28 = this;
  var target = SelectorEngine.getElementFromSelector(this);
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  EventHandler.one(target, EVENT_SHOW$4, function (showEvent) {
    if (showEvent.defaultPrevented) {
      // only register focus restorer if modal will actually get shown
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$4, function () {
      if (isVisible(_this28)) {
        _this28.focus();
      }
    });
  });

  // avoid conflict when clicking modal toggler while another one is open
  var alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }
  var data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});
enableDismissTrigger(Modal);

/**
 * jQuery
 */

defineJQueryPlugin(Modal);

/**
 * --------------------------------------------------------------------------
 * Bootstrap offcanvas.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$6 = 'offcanvas';
var DATA_KEY$3 = 'bs.offcanvas';
var EVENT_KEY$3 = ".".concat(DATA_KEY$3);
var DATA_API_KEY$1 = '.data-api';
var EVENT_LOAD_DATA_API$2 = "load".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);
var ESCAPE_KEY = 'Escape';
var CLASS_NAME_SHOW$3 = 'show';
var CLASS_NAME_SHOWING$1 = 'showing';
var CLASS_NAME_HIDING = 'hiding';
var CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
var OPEN_SELECTOR = '.offcanvas.show';
var EVENT_SHOW$3 = "show".concat(EVENT_KEY$3);
var EVENT_SHOWN$3 = "shown".concat(EVENT_KEY$3);
var EVENT_HIDE$3 = "hide".concat(EVENT_KEY$3);
var EVENT_HIDE_PREVENTED = "hidePrevented".concat(EVENT_KEY$3);
var EVENT_HIDDEN$3 = "hidden".concat(EVENT_KEY$3);
var EVENT_RESIZE = "resize".concat(EVENT_KEY$3);
var EVENT_CLICK_DATA_API$1 = "click".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);
var EVENT_KEYDOWN_DISMISS = "keydown.dismiss".concat(EVENT_KEY$3);
var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
var Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
var DefaultType$5 = {
  backdrop: '(boolean|string)',
  keyboard: 'boolean',
  scroll: 'boolean'
};

/**
 * Class definition
 */
var Offcanvas = exports.Offcanvas = /*#__PURE__*/function (_BaseComponent7) {
  function Offcanvas(element, config) {
    var _this29;
    _classCallCheck(this, Offcanvas);
    _this29 = _callSuper(this, Offcanvas, [element, config]);
    _this29._isShown = false;
    _this29._backdrop = _this29._initializeBackDrop();
    _this29._focustrap = _this29._initializeFocusTrap();
    _this29._addEventListeners();
    return _this29;
  }

  // Getters
  _inherits(Offcanvas, _BaseComponent7);
  return _createClass(Offcanvas, [{
    key: "toggle",
    value:
    // Public
    function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
  }, {
    key: "show",
    value: function show(relatedTarget) {
      var _this30 = this;
      if (this._isShown) {
        return;
      }
      var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget: relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.setAttribute('aria-modal', true);
      this._element.setAttribute('role', 'dialog');
      this._element.classList.add(CLASS_NAME_SHOWING$1);
      var completeCallBack = function completeCallBack() {
        if (!_this30._config.scroll || _this30._config.backdrop) {
          _this30._focustrap.activate();
        }
        _this30._element.classList.add(CLASS_NAME_SHOW$3);
        _this30._element.classList.remove(CLASS_NAME_SHOWING$1);
        EventHandler.trigger(_this30._element, EVENT_SHOWN$3, {
          relatedTarget: relatedTarget
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this31 = this;
      if (!this._isShown) {
        return;
      }
      var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.add(CLASS_NAME_HIDING);
      this._backdrop.hide();
      var completeCallback = function completeCallback() {
        _this31._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
        _this31._element.removeAttribute('aria-modal');
        _this31._element.removeAttribute('role');
        if (!_this31._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(_this31._element, EVENT_HIDDEN$3);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      _superPropGet(Offcanvas, "dispose", this, 3)([]);
    }

    // Private
  }, {
    key: "_initializeBackDrop",
    value: function _initializeBackDrop() {
      var _this32 = this;
      var clickCallback = function clickCallback() {
        if (_this32._config.backdrop === 'static') {
          EventHandler.trigger(_this32._element, EVENT_HIDE_PREVENTED);
          return;
        }
        _this32.hide();
      };

      // 'static' option will be translated to true, and booleans will keep their value
      var isVisible = Boolean(this._config.backdrop);
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible: isVisible,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: isVisible ? clickCallback : null
      });
    }
  }, {
    key: "_initializeFocusTrap",
    value: function _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var _this33 = this;
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {
        if (event.key !== ESCAPE_KEY) {
          return;
        }
        if (_this33._config.keyboard) {
          _this33.hide();
          return;
        }
        EventHandler.trigger(_this33._element, EVENT_HIDE_PREVENTED);
      });
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default$5;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$5;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$6;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Offcanvas.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }
        data[config](this);
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
  var _this34 = this;
  var target = SelectorEngine.getElementFromSelector(this);
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  EventHandler.one(target, EVENT_HIDDEN$3, function () {
    // focus on trigger when it is closed
    if (isVisible(_this34)) {
      _this34.focus();
    }
  });

  // avoid conflict when clicking a toggler of an offcanvas, while another is open
  var alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }
  var data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, function () {
  var _iterator14 = _createForOfIteratorHelper(SelectorEngine.find(OPEN_SELECTOR)),
    _step14;
  try {
    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
      var selector = _step14.value;
      Offcanvas.getOrCreateInstance(selector).show();
    }
  } catch (err) {
    _iterator14.e(err);
  } finally {
    _iterator14.f();
  }
});
EventHandler.on(window, EVENT_RESIZE, function () {
  var _iterator15 = _createForOfIteratorHelper(SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')),
    _step15;
  try {
    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
      var element = _step15.value;
      if (getComputedStyle(element).position !== 'fixed') {
        Offcanvas.getOrCreateInstance(element).hide();
      }
    }
  } catch (err) {
    _iterator15.e(err);
  } finally {
    _iterator15.f();
  }
});
enableDismissTrigger(Offcanvas);

/**
 * jQuery
 */

defineJQueryPlugin(Offcanvas);

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

// js-docs-start allow-list
var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
var DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
  a: ['target', 'href', 'title', 'rel'],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  dd: [],
  div: [],
  dl: [],
  dt: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
// js-docs-end allow-list

var uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);

/**
 * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation
 * contexts.
 *
 * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38
 */
var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
var allowedAttribute = function allowedAttribute(attribute, allowedAttributeList) {
  var attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
    }
    return true;
  }

  // Check if a regular expression validates the attribute.
  return allowedAttributeList.filter(function (attributeRegex) {
    return attributeRegex instanceof RegExp;
  }).some(function (regex) {
    return regex.test(attributeName);
  });
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
  var _ref7;
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFunction && typeof sanitizeFunction === 'function') {
    return sanitizeFunction(unsafeHtml);
  }
  var domParser = new window.DOMParser();
  var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
  var elements = (_ref7 = []).concat.apply(_ref7, _toConsumableArray(createdDocument.body.querySelectorAll('*')));
  var _iterator16 = _createForOfIteratorHelper(elements),
    _step16;
  try {
    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
      var _ref8;
      var element = _step16.value;
      var elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      var attributeList = (_ref8 = []).concat.apply(_ref8, _toConsumableArray(element.attributes));
      var allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
      var _iterator17 = _createForOfIteratorHelper(attributeList),
        _step17;
      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var attribute = _step17.value;
          if (!allowedAttribute(attribute, allowedAttributes)) {
            element.removeAttribute(attribute.nodeName);
          }
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }
    }
  } catch (err) {
    _iterator16.e(err);
  } finally {
    _iterator16.f();
  }
  return createdDocument.body.innerHTML;
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap util/template-factory.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$5 = 'TemplateFactory';
var Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: '',
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: '<div></div>'
};
var DefaultType$4 = {
  allowList: 'object',
  content: 'object',
  extraClass: '(string|function)',
  html: 'boolean',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  template: 'string'
};
var DefaultContentType = {
  entry: '(string|element|function|null)',
  selector: '(string|element)'
};

/**
 * Class definition
 */
var TemplateFactory = /*#__PURE__*/function (_Config5) {
  function TemplateFactory(config) {
    var _this35;
    _classCallCheck(this, TemplateFactory);
    _this35 = _callSuper(this, TemplateFactory);
    _this35._config = _this35._getConfig(config);
    return _this35;
  }

  // Getters
  _inherits(TemplateFactory, _Config5);
  return _createClass(TemplateFactory, [{
    key: "getContent",
    value:
    // Public
    function getContent() {
      var _this36 = this;
      return Object.values(this._config.content).map(function (config) {
        return _this36._resolvePossibleFunction(config);
      }).filter(Boolean);
    }
  }, {
    key: "hasContent",
    value: function hasContent() {
      return this.getContent().length > 0;
    }
  }, {
    key: "changeContent",
    value: function changeContent(content) {
      this._checkContent(content);
      this._config.content = _objectSpread(_objectSpread({}, this._config.content), content);
      return this;
    }
  }, {
    key: "toHtml",
    value: function toHtml() {
      var templateWrapper = document.createElement('div');
      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
      for (var _i7 = 0, _Object$entries5 = Object.entries(this._config.content); _i7 < _Object$entries5.length; _i7++) {
        var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i7], 2),
          selector = _Object$entries5$_i[0],
          text = _Object$entries5$_i[1];
        this._setContent(templateWrapper, text, selector);
      }
      var template = templateWrapper.children[0];
      var extraClass = this._resolvePossibleFunction(this._config.extraClass);
      if (extraClass) {
        var _template$classList;
        (_template$classList = template.classList).add.apply(_template$classList, _toConsumableArray(extraClass.split(' ')));
      }
      return template;
    }

    // Private
  }, {
    key: "_typeCheckConfig",
    value: function _typeCheckConfig(config) {
      _superPropGet(TemplateFactory, "_typeCheckConfig", this, 3)([config]);
      this._checkContent(config.content);
    }
  }, {
    key: "_checkContent",
    value: function _checkContent(arg) {
      for (var _i8 = 0, _Object$entries6 = Object.entries(arg); _i8 < _Object$entries6.length; _i8++) {
        var _Object$entries6$_i = _slicedToArray(_Object$entries6[_i8], 2),
          selector = _Object$entries6$_i[0],
          content = _Object$entries6$_i[1];
        _superPropGet(TemplateFactory, "_typeCheckConfig", this, 3)([{
          selector: selector,
          entry: content
        }, DefaultContentType]);
      }
    }
  }, {
    key: "_setContent",
    value: function _setContent(template, content, selector) {
      var templateElement = SelectorEngine.findOne(selector, template);
      if (!templateElement) {
        return;
      }
      content = this._resolvePossibleFunction(content);
      if (!content) {
        templateElement.remove();
        return;
      }
      if (isElement(content)) {
        this._putElementInTemplate(getElement(content), templateElement);
        return;
      }
      if (this._config.html) {
        templateElement.innerHTML = this._maybeSanitize(content);
        return;
      }
      templateElement.textContent = content;
    }
  }, {
    key: "_maybeSanitize",
    value: function _maybeSanitize(arg) {
      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
  }, {
    key: "_resolvePossibleFunction",
    value: function _resolvePossibleFunction(arg) {
      return execute(arg, [undefined, this]);
    }
  }, {
    key: "_putElementInTemplate",
    value: function _putElementInTemplate(element, templateElement) {
      if (this._config.html) {
        templateElement.innerHTML = '';
        templateElement.append(element);
        return;
      }
      templateElement.textContent = element.textContent;
    }
  }], [{
    key: "Default",
    get: function get() {
      return Default$4;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$4;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$5;
    }
  }]);
}(Config);
/**
 * --------------------------------------------------------------------------
 * Bootstrap tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * Constants
 */
var NAME$4 = 'tooltip';
var DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
var CLASS_NAME_FADE$2 = 'fade';
var CLASS_NAME_MODAL = 'modal';
var CLASS_NAME_SHOW$2 = 'show';
var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
var SELECTOR_MODAL = ".".concat(CLASS_NAME_MODAL);
var EVENT_MODAL_HIDE = 'hide.bs.modal';
var TRIGGER_HOVER = 'hover';
var TRIGGER_FOCUS = 'focus';
var TRIGGER_CLICK = 'click';
var TRIGGER_MANUAL = 'manual';
var EVENT_HIDE$2 = 'hide';
var EVENT_HIDDEN$2 = 'hidden';
var EVENT_SHOW$2 = 'show';
var EVENT_SHOWN$2 = 'shown';
var EVENT_INSERTED = 'inserted';
var EVENT_CLICK$1 = 'click';
var EVENT_FOCUSIN$1 = 'focusin';
var EVENT_FOCUSOUT$1 = 'focusout';
var EVENT_MOUSEENTER = 'mouseenter';
var EVENT_MOUSELEAVE = 'mouseleave';
var AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: isRTL() ? 'left' : 'right',
  BOTTOM: 'bottom',
  LEFT: isRTL() ? 'right' : 'left'
};
var Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: 'clippingParents',
  container: false,
  customClass: '',
  delay: 0,
  fallbackPlacements: ['top', 'right', 'bottom', 'left'],
  html: false,
  offset: [0, 6],
  placement: 'top',
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
  title: '',
  trigger: 'hover focus'
};
var DefaultType$3 = {
  allowList: 'object',
  animation: 'boolean',
  boundary: '(string|element)',
  container: '(string|element|boolean)',
  customClass: '(string|function)',
  delay: '(number|object)',
  fallbackPlacements: 'array',
  html: 'boolean',
  offset: '(array|string|function)',
  placement: '(string|function)',
  popperConfig: '(null|object|function)',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  selector: '(string|boolean)',
  template: 'string',
  title: '(string|element|function)',
  trigger: 'string'
};

/**
 * Class definition
 */
var Tooltip = exports.Tooltip = /*#__PURE__*/function (_BaseComponent8) {
  function Tooltip(element, config) {
    var _this37;
    _classCallCheck(this, Tooltip);
    if (typeof Popper === 'undefined') {
      throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org/docs/v2/)');
    }
    _this37 = _callSuper(this, Tooltip, [element, config]);

    // Private
    _this37._isEnabled = true;
    _this37._timeout = 0;
    _this37._isHovered = null;
    _this37._activeTrigger = {};
    _this37._popper = null;
    _this37._templateFactory = null;
    _this37._newContent = null;

    // Protected
    _this37.tip = null;
    _this37._setListeners();
    if (!_this37._config.selector) {
      _this37._fixTitle();
    }
    return _this37;
  }

  // Getters
  _inherits(Tooltip, _BaseComponent8);
  return _createClass(Tooltip, [{
    key: "enable",
    value:
    // Public
    function enable() {
      this._isEnabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      this._isEnabled = false;
    }
  }, {
    key: "toggleEnabled",
    value: function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
  }, {
    key: "toggle",
    value: function toggle() {
      if (!this._isEnabled) {
        return;
      }
      if (this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this._element.getAttribute('data-bs-original-title')) {
        this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
      }
      this._disposePopper();
      _superPropGet(Tooltip, "dispose", this, 3)([]);
    }
  }, {
    key: "show",
    value: function show() {
      var _this38 = this;
      if (this._element.style.display === 'none') {
        throw new Error('Please use show on visible elements');
      }
      if (!(this._isWithContent() && this._isEnabled)) {
        return;
      }
      var showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
      var shadowRoot = _findShadowRoot(this._element);
      var isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }

      // TODO: v6 remove this or make it optional
      this._disposePopper();
      var tip = this._getTipElement();
      this._element.setAttribute('aria-describedby', tip.getAttribute('id'));
      var container = this._config.container;
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
      }
      this._popper = this._createPopper(tip);
      tip.classList.add(CLASS_NAME_SHOW$2);

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ('ontouchstart' in document.documentElement) {
        var _ref9;
        var _iterator18 = _createForOfIteratorHelper((_ref9 = []).concat.apply(_ref9, _toConsumableArray(document.body.children))),
          _step18;
        try {
          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
            var element = _step18.value;
            EventHandler.on(element, 'mouseover', noop);
          }
        } catch (err) {
          _iterator18.e(err);
        } finally {
          _iterator18.f();
        }
      }
      var complete = function complete() {
        EventHandler.trigger(_this38._element, _this38.constructor.eventName(EVENT_SHOWN$2));
        if (_this38._isHovered === false) {
          _this38._leave();
        }
        _this38._isHovered = false;
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this39 = this;
      if (!this._isShown()) {
        return;
      }
      var hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
      if (hideEvent.defaultPrevented) {
        return;
      }
      var tip = this._getTipElement();
      tip.classList.remove(CLASS_NAME_SHOW$2);

      // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support
      if ('ontouchstart' in document.documentElement) {
        var _ref0;
        var _iterator19 = _createForOfIteratorHelper((_ref0 = []).concat.apply(_ref0, _toConsumableArray(document.body.children))),
          _step19;
        try {
          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
            var element = _step19.value;
            EventHandler.off(element, 'mouseover', noop);
          }
        } catch (err) {
          _iterator19.e(err);
        } finally {
          _iterator19.f();
        }
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      this._isHovered = null; // it is a trick to support manual triggering

      var complete = function complete() {
        if (_this39._isWithActiveTrigger()) {
          return;
        }
        if (!_this39._isHovered) {
          _this39._disposePopper();
        }
        _this39._element.removeAttribute('aria-describedby');
        EventHandler.trigger(_this39._element, _this39.constructor.eventName(EVENT_HIDDEN$2));
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
  }, {
    key: "update",
    value: function update() {
      if (this._popper) {
        this._popper.update();
      }
    }

    // Protected
  }, {
    key: "_isWithContent",
    value: function _isWithContent() {
      return Boolean(this._getTitle());
    }
  }, {
    key: "_getTipElement",
    value: function _getTipElement() {
      if (!this.tip) {
        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
      }
      return this.tip;
    }
  }, {
    key: "_createTipElement",
    value: function _createTipElement(content) {
      var tip = this._getTemplateFactory(content).toHtml();

      // TODO: remove this check in v6
      if (!tip) {
        return null;
      }
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      // TODO: v6 the following can be achieved with CSS only
      tip.classList.add("bs-".concat(this.constructor.NAME, "-auto"));
      var tipId = getUID(this.constructor.NAME).toString();
      tip.setAttribute('id', tipId);
      if (this._isAnimated()) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      return tip;
    }
  }, {
    key: "setContent",
    value: function setContent(content) {
      this._newContent = content;
      if (this._isShown()) {
        this._disposePopper();
        this.show();
      }
    }
  }, {
    key: "_getTemplateFactory",
    value: function _getTemplateFactory(content) {
      if (this._templateFactory) {
        this._templateFactory.changeContent(content);
      } else {
        this._templateFactory = new TemplateFactory(_objectSpread(_objectSpread({}, this._config), {}, {
          // the `content` var has to be after `this._config`
          // to override config.content in case of popover
          content: content,
          extraClass: this._resolvePossibleFunction(this._config.customClass)
        }));
      }
      return this._templateFactory;
    }
  }, {
    key: "_getContentForTemplate",
    value: function _getContentForTemplate() {
      return _defineProperty({}, SELECTOR_TOOLTIP_INNER, this._getTitle());
    }
  }, {
    key: "_getTitle",
    value: function _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');
    }

    // Private
  }, {
    key: "_initializeOnDelegatedTarget",
    value: function _initializeOnDelegatedTarget(event) {
      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
  }, {
    key: "_isAnimated",
    value: function _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
  }, {
    key: "_isShown",
    value: function _isShown() {
      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
  }, {
    key: "_createPopper",
    value: function _createPopper(tip) {
      var placement = execute(this._config.placement, [this, tip, this._element]);
      var attachment = AttachmentMap[placement.toUpperCase()];
      return Popper.createPopper(this._element, tip, this._getPopperConfig(attachment));
    }
  }, {
    key: "_getOffset",
    value: function _getOffset() {
      var _this40 = this;
      var offset = this._config.offset;
      if (typeof offset === 'string') {
        return offset.split(',').map(function (value) {
          return Number.parseInt(value, 10);
        });
      }
      if (typeof offset === 'function') {
        return function (popperData) {
          return offset(popperData, _this40._element);
        };
      }
      return offset;
    }
  }, {
    key: "_resolvePossibleFunction",
    value: function _resolvePossibleFunction(arg) {
      return execute(arg, [this._element, this._element]);
    }
  }, {
    key: "_getPopperConfig",
    value: function _getPopperConfig(attachment) {
      var _this41 = this;
      var defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: 'flip',
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }, {
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'arrow',
          options: {
            element: ".".concat(this.constructor.NAME, "-arrow")
          }
        }, {
          name: 'preSetPlacement',
          enabled: true,
          phase: 'beforeMain',
          fn: function fn(data) {
            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
            _this41._getTipElement().setAttribute('data-popper-placement', data.state.placement);
          }
        }]
      };
      return _objectSpread(_objectSpread({}, defaultBsPopperConfig), execute(this._config.popperConfig, [undefined, defaultBsPopperConfig]));
    }
  }, {
    key: "_setListeners",
    value: function _setListeners() {
      var _this42 = this;
      var triggers = this._config.trigger.split(' ');
      var _iterator20 = _createForOfIteratorHelper(triggers),
        _step20;
      try {
        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
          var trigger = _step20.value;
          if (trigger === 'click') {
            EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, function (event) {
              var context = _this42._initializeOnDelegatedTarget(event);
              context._activeTrigger[TRIGGER_CLICK] = !(context._isShown() && context._activeTrigger[TRIGGER_CLICK]);
              context.toggle();
            });
          } else if (trigger !== TRIGGER_MANUAL) {
            var eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
            var eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
            EventHandler.on(this._element, eventIn, this._config.selector, function (event) {
              var context = _this42._initializeOnDelegatedTarget(event);
              context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
              context._enter();
            });
            EventHandler.on(this._element, eventOut, this._config.selector, function (event) {
              var context = _this42._initializeOnDelegatedTarget(event);
              context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
              context._leave();
            });
          }
        }
      } catch (err) {
        _iterator20.e(err);
      } finally {
        _iterator20.f();
      }
      this._hideModalHandler = function () {
        if (_this42._element) {
          _this42.hide();
        }
      };
      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
  }, {
    key: "_fixTitle",
    value: function _fixTitle() {
      var title = this._element.getAttribute('title');
      if (!title) {
        return;
      }
      if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {
        this._element.setAttribute('aria-label', title);
      }
      this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility
      this._element.removeAttribute('title');
    }
  }, {
    key: "_enter",
    value: function _enter() {
      var _this43 = this;
      if (this._isShown() || this._isHovered) {
        this._isHovered = true;
        return;
      }
      this._isHovered = true;
      this._setTimeout(function () {
        if (_this43._isHovered) {
          _this43.show();
        }
      }, this._config.delay.show);
    }
  }, {
    key: "_leave",
    value: function _leave() {
      var _this44 = this;
      if (this._isWithActiveTrigger()) {
        return;
      }
      this._isHovered = false;
      this._setTimeout(function () {
        if (!_this44._isHovered) {
          _this44.hide();
        }
      }, this._config.delay.hide);
    }
  }, {
    key: "_setTimeout",
    value: function _setTimeout(handler, timeout) {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(handler, timeout);
    }
  }, {
    key: "_isWithActiveTrigger",
    value: function _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(true);
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      var dataAttributes = Manipulator.getDataAttributes(this._element);
      for (var _i9 = 0, _Object$keys2 = Object.keys(dataAttributes); _i9 < _Object$keys2.length; _i9++) {
        var dataAttribute = _Object$keys2[_i9];
        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
          delete dataAttributes[dataAttribute];
        }
      }
      config = _objectSpread(_objectSpread({}, dataAttributes), _typeof(config) === 'object' && config ? config : {});
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
  }, {
    key: "_configAfterMerge",
    value: function _configAfterMerge(config) {
      config.container = config.container === false ? document.body : getElement(config.container);
      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }
      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }
      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }
      return config;
    }
  }, {
    key: "_getDelegateConfig",
    value: function _getDelegateConfig() {
      var config = {};
      for (var _i0 = 0, _Object$entries7 = Object.entries(this._config); _i0 < _Object$entries7.length; _i0++) {
        var _Object$entries7$_i = _slicedToArray(_Object$entries7[_i0], 2),
          key = _Object$entries7$_i[0],
          value = _Object$entries7$_i[1];
        if (this.constructor.Default[key] !== value) {
          config[key] = value;
        }
      }
      config.selector = false;
      config.trigger = 'manual';

      // In the future can be replaced with:
      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
      // `Object.fromEntries(keysWithDifferentValues)`
      return config;
    }
  }, {
    key: "_disposePopper",
    value: function _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
      if (this.tip) {
        this.tip.remove();
        this.tip = null;
      }
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default$3;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$3;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$4;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Tooltip.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }
        data[config]();
      });
    }
  }]);
}(BaseComponent);
/**
 * jQuery
 */
defineJQueryPlugin(Tooltip);

/**
 * --------------------------------------------------------------------------
 * Bootstrap popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$3 = 'popover';
var SELECTOR_TITLE = '.popover-header';
var SELECTOR_CONTENT = '.popover-body';
var Default$2 = _objectSpread(_objectSpread({}, Tooltip.Default), {}, {
  content: '',
  offset: [0, 8],
  placement: 'right',
  template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>',
  trigger: 'click'
});
var DefaultType$2 = _objectSpread(_objectSpread({}, Tooltip.DefaultType), {}, {
  content: '(null|string|element|function)'
});

/**
 * Class definition
 */
var Popover = exports.Popover = /*#__PURE__*/function (_Tooltip) {
  function Popover() {
    _classCallCheck(this, Popover);
    return _callSuper(this, Popover, arguments);
  }
  _inherits(Popover, _Tooltip);
  return _createClass(Popover, [{
    key: "_isWithContent",
    value:
    // Overrides
    function _isWithContent() {
      return this._getTitle() || this._getContent();
    }

    // Private
  }, {
    key: "_getContentForTemplate",
    value: function _getContentForTemplate() {
      return _defineProperty(_defineProperty({}, SELECTOR_TITLE, this._getTitle()), SELECTOR_CONTENT, this._getContent());
    }
  }, {
    key: "_getContent",
    value: function _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }

    // Static
  }], [{
    key: "Default",
    get:
    // Getters
    function get() {
      return Default$2;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$2;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$3;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Popover.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }
        data[config]();
      });
    }
  }]);
}(Tooltip);
/**
 * jQuery
 */
defineJQueryPlugin(Popover);

/**
 * --------------------------------------------------------------------------
 * Bootstrap scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$2 = 'scrollspy';
var DATA_KEY$2 = 'bs.scrollspy';
var EVENT_KEY$2 = ".".concat(DATA_KEY$2);
var DATA_API_KEY = '.data-api';
var EVENT_ACTIVATE = "activate".concat(EVENT_KEY$2);
var EVENT_CLICK = "click".concat(EVENT_KEY$2);
var EVENT_LOAD_DATA_API$1 = "load".concat(EVENT_KEY$2).concat(DATA_API_KEY);
var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
var CLASS_NAME_ACTIVE$1 = 'active';
var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
var SELECTOR_TARGET_LINKS = '[href]';
var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
var SELECTOR_NAV_LINKS = '.nav-link';
var SELECTOR_NAV_ITEMS = '.nav-item';
var SELECTOR_LIST_ITEMS = '.list-group-item';
var SELECTOR_LINK_ITEMS = "".concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_NAV_ITEMS, " > ").concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_LIST_ITEMS);
var SELECTOR_DROPDOWN = '.dropdown';
var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
var Default$1 = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: '0px 0px -25%',
  smoothScroll: false,
  target: null,
  threshold: [0.1, 0.5, 1]
};
var DefaultType$1 = {
  offset: '(number|null)',
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: 'string',
  smoothScroll: 'boolean',
  target: 'element',
  threshold: 'array'
};

/**
 * Class definition
 */
var ScrollSpy = exports.ScrollSpy = /*#__PURE__*/function (_BaseComponent9) {
  function ScrollSpy(element, config) {
    var _this45;
    _classCallCheck(this, ScrollSpy);
    _this45 = _callSuper(this, ScrollSpy, [element, config]);

    // this._element is the observablesContainer and config.target the menu links wrapper
    _this45._targetLinks = new Map();
    _this45._observableSections = new Map();
    _this45._rootElement = getComputedStyle(_this45._element).overflowY === 'visible' ? null : _this45._element;
    _this45._activeTarget = null;
    _this45._observer = null;
    _this45._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    _this45.refresh(); // initialize
    return _this45;
  }

  // Getters
  _inherits(ScrollSpy, _BaseComponent9);
  return _createClass(ScrollSpy, [{
    key: "refresh",
    value:
    // Public
    function refresh() {
      this._initializeTargetsAndObservables();
      this._maybeEnableSmoothScroll();
      if (this._observer) {
        this._observer.disconnect();
      } else {
        this._observer = this._getNewObserver();
      }
      var _iterator21 = _createForOfIteratorHelper(this._observableSections.values()),
        _step21;
      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var section = _step21.value;
          this._observer.observe(section);
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._observer.disconnect();
      _superPropGet(ScrollSpy, "dispose", this, 3)([]);
    }

    // Private
  }, {
    key: "_configAfterMerge",
    value: function _configAfterMerge(config) {
      // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
      config.target = getElement(config.target) || document.body;

      // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
      config.rootMargin = config.offset ? "".concat(config.offset, "px 0px -30%") : config.rootMargin;
      if (typeof config.threshold === 'string') {
        config.threshold = config.threshold.split(',').map(function (value) {
          return Number.parseFloat(value);
        });
      }
      return config;
    }
  }, {
    key: "_maybeEnableSmoothScroll",
    value: function _maybeEnableSmoothScroll() {
      var _this46 = this;
      if (!this._config.smoothScroll) {
        return;
      }

      // unregister any previous listeners
      EventHandler.off(this._config.target, EVENT_CLICK);
      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, function (event) {
        var observableSection = _this46._observableSections.get(event.target.hash);
        if (observableSection) {
          event.preventDefault();
          var root = _this46._rootElement || window;
          var height = observableSection.offsetTop - _this46._element.offsetTop;
          if (root.scrollTo) {
            root.scrollTo({
              top: height,
              behavior: 'smooth'
            });
            return;
          }

          // Chrome 60 doesn't support `scrollTo`
          root.scrollTop = height;
        }
      });
    }
  }, {
    key: "_getNewObserver",
    value: function _getNewObserver() {
      var _this47 = this;
      var options = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver(function (entries) {
        return _this47._observerCallback(entries);
      }, options);
    }

    // The logic of selection
  }, {
    key: "_observerCallback",
    value: function _observerCallback(entries) {
      var _this48 = this;
      var targetElement = function targetElement(entry) {
        return _this48._targetLinks.get("#".concat(entry.target.id));
      };
      var activate = function activate(entry) {
        _this48._previousScrollData.visibleEntryTop = entry.target.offsetTop;
        _this48._process(targetElement(entry));
      };
      var parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
      var userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = parentScrollTop;
      var _iterator22 = _createForOfIteratorHelper(entries),
        _step22;
      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var entry = _step22.value;
          if (!entry.isIntersecting) {
            this._activeTarget = null;
            this._clearActiveClass(targetElement(entry));
            continue;
          }
          var entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
          // if we are scrolling down, pick the bigger offsetTop
          if (userScrollsDown && entryIsLowerThanPrevious) {
            activate(entry);
            // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
            if (!parentScrollTop) {
              return;
            }
            continue;
          }

          // if we are scrolling up, pick the smallest offsetTop
          if (!userScrollsDown && !entryIsLowerThanPrevious) {
            activate(entry);
          }
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }
    }
  }, {
    key: "_initializeTargetsAndObservables",
    value: function _initializeTargetsAndObservables() {
      this._targetLinks = new Map();
      this._observableSections = new Map();
      var targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
      var _iterator23 = _createForOfIteratorHelper(targetLinks),
        _step23;
      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var anchor = _step23.value;
          // ensure that the anchor has an id and is not disabled
          if (!anchor.hash || isDisabled(anchor)) {
            continue;
          }
          var observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);

          // ensure that the observableSection exists & is visible
          if (isVisible(observableSection)) {
            this._targetLinks.set(decodeURI(anchor.hash), anchor);
            this._observableSections.set(anchor.hash, observableSection);
          }
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
    }
  }, {
    key: "_process",
    value: function _process(target) {
      if (this._activeTarget === target) {
        return;
      }
      this._clearActiveClass(this._config.target);
      this._activeTarget = target;
      target.classList.add(CLASS_NAME_ACTIVE$1);
      this._activateParents(target);
      EventHandler.trigger(this._element, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
  }, {
    key: "_activateParents",
    value: function _activateParents(target) {
      // Activate dropdown parents
      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
        return;
      }
      var _iterator24 = _createForOfIteratorHelper(SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)),
        _step24;
      try {
        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
          var listGroup = _step24.value;
          // Set triggered links parents as active
          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
          var _iterator25 = _createForOfIteratorHelper(SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)),
            _step25;
          try {
            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
              var item = _step25.value;
              item.classList.add(CLASS_NAME_ACTIVE$1);
            }
          } catch (err) {
            _iterator25.e(err);
          } finally {
            _iterator25.f();
          }
        }
      } catch (err) {
        _iterator24.e(err);
      } finally {
        _iterator24.f();
      }
    }
  }, {
    key: "_clearActiveClass",
    value: function _clearActiveClass(parent) {
      parent.classList.remove(CLASS_NAME_ACTIVE$1);
      var activeNodes = SelectorEngine.find("".concat(SELECTOR_TARGET_LINKS, ".").concat(CLASS_NAME_ACTIVE$1), parent);
      var _iterator26 = _createForOfIteratorHelper(activeNodes),
        _step26;
      try {
        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
          var node = _step26.value;
          node.classList.remove(CLASS_NAME_ACTIVE$1);
        }
      } catch (err) {
        _iterator26.e(err);
      } finally {
        _iterator26.f();
      }
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default$1;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType$1;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME$2;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = ScrollSpy.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }
        data[config]();
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
EventHandler.on(window, EVENT_LOAD_DATA_API$1, function () {
  var _iterator27 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_DATA_SPY)),
    _step27;
  try {
    for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
      var spy = _step27.value;
      ScrollSpy.getOrCreateInstance(spy);
    }
  } catch (err) {
    _iterator27.e(err);
  } finally {
    _iterator27.f();
  }
});

/**
 * jQuery
 */

defineJQueryPlugin(ScrollSpy);

/**
 * --------------------------------------------------------------------------
 * Bootstrap tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME$1 = 'tab';
var DATA_KEY$1 = 'bs.tab';
var EVENT_KEY$1 = ".".concat(DATA_KEY$1);
var EVENT_HIDE$1 = "hide".concat(EVENT_KEY$1);
var EVENT_HIDDEN$1 = "hidden".concat(EVENT_KEY$1);
var EVENT_SHOW$1 = "show".concat(EVENT_KEY$1);
var EVENT_SHOWN$1 = "shown".concat(EVENT_KEY$1);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY$1);
var EVENT_KEYDOWN = "keydown".concat(EVENT_KEY$1);
var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY$1);
var ARROW_LEFT_KEY = 'ArrowLeft';
var ARROW_RIGHT_KEY = 'ArrowRight';
var ARROW_UP_KEY = 'ArrowUp';
var ARROW_DOWN_KEY = 'ArrowDown';
var HOME_KEY = 'Home';
var END_KEY = 'End';
var CLASS_NAME_ACTIVE = 'active';
var CLASS_NAME_FADE$1 = 'fade';
var CLASS_NAME_SHOW$1 = 'show';
var CLASS_DROPDOWN = 'dropdown';
var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
var SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
var NOT_SELECTOR_DROPDOWN_TOGGLE = ":not(".concat(SELECTOR_DROPDOWN_TOGGLE, ")");
var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
var SELECTOR_OUTER = '.nav-item, .list-group-item';
var SELECTOR_INNER = ".nav-link".concat(NOT_SELECTOR_DROPDOWN_TOGGLE, ", .list-group-item").concat(NOT_SELECTOR_DROPDOWN_TOGGLE, ", [role=\"tab\"]").concat(NOT_SELECTOR_DROPDOWN_TOGGLE);
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // TODO: could only be `tab` in v6
var SELECTOR_INNER_ELEM = "".concat(SELECTOR_INNER, ", ").concat(SELECTOR_DATA_TOGGLE);
var SELECTOR_DATA_TOGGLE_ACTIVE = ".".concat(CLASS_NAME_ACTIVE, "[data-bs-toggle=\"tab\"], .").concat(CLASS_NAME_ACTIVE, "[data-bs-toggle=\"pill\"], .").concat(CLASS_NAME_ACTIVE, "[data-bs-toggle=\"list\"]");

/**
 * Class definition
 */
var Tab = exports.Tab = /*#__PURE__*/function (_BaseComponent0) {
  function Tab(element) {
    var _this49;
    _classCallCheck(this, Tab);
    _this49 = _callSuper(this, Tab, [element]);
    _this49._parent = _this49._element.closest(SELECTOR_TAB_PANEL);
    if (!_this49._parent) {
      return _possibleConstructorReturn(_this49);
      // TODO: should throw exception in v6
      // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
    }

    // Set up initial aria attributes
    _this49._setInitialAttributes(_this49._parent, _this49._getChildren());
    EventHandler.on(_this49._element, EVENT_KEYDOWN, function (event) {
      return _this49._keydown(event);
    });
    return _this49;
  }

  // Getters
  _inherits(Tab, _BaseComponent0);
  return _createClass(Tab, [{
    key: "show",
    value:
    // Public
    function show() {
      // Shows this elem and deactivate the active sibling if exists
      var innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }

      // Search for active tab on same parent to deactivate it
      var active = this._getActiveElem();
      var hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
        relatedTarget: innerElem
      }) : null;
      var showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
        relatedTarget: active
      });
      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }

    // Private
  }, {
    key: "_activate",
    value: function _activate(element, relatedElem) {
      var _this50 = this;
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section

      var complete = function complete() {
        if (element.getAttribute('role') !== 'tab') {
          element.classList.add(CLASS_NAME_SHOW$1);
          return;
        }
        element.removeAttribute('tabindex');
        element.setAttribute('aria-selected', true);
        _this50._toggleDropDown(element, true);
        EventHandler.trigger(element, EVENT_SHOWN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
  }, {
    key: "_deactivate",
    value: function _deactivate(element, relatedElem) {
      var _this51 = this;
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too

      var complete = function complete() {
        if (element.getAttribute('role') !== 'tab') {
          element.classList.remove(CLASS_NAME_SHOW$1);
          return;
        }
        element.setAttribute('aria-selected', false);
        element.setAttribute('tabindex', '-1');
        _this51._toggleDropDown(element, false);
        EventHandler.trigger(element, EVENT_HIDDEN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
  }, {
    key: "_keydown",
    value: function _keydown(event) {
      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
        return;
      }
      event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
      event.preventDefault();
      var children = this._getChildren().filter(function (element) {
        return !isDisabled(element);
      });
      var nextActiveElement;
      if ([HOME_KEY, END_KEY].includes(event.key)) {
        nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
      } else {
        var isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
        nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
      }
      if (nextActiveElement) {
        nextActiveElement.focus({
          preventScroll: true
        });
        Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
  }, {
    key: "_getChildren",
    value: function _getChildren() {
      // collection of inner elements
      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
  }, {
    key: "_getActiveElem",
    value: function _getActiveElem() {
      var _this52 = this;
      return this._getChildren().find(function (child) {
        return _this52._elemIsActive(child);
      }) || null;
    }
  }, {
    key: "_setInitialAttributes",
    value: function _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, 'role', 'tablist');
      var _iterator28 = _createForOfIteratorHelper(children),
        _step28;
      try {
        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
          var child = _step28.value;
          this._setInitialAttributesOnChild(child);
        }
      } catch (err) {
        _iterator28.e(err);
      } finally {
        _iterator28.f();
      }
    }
  }, {
    key: "_setInitialAttributesOnChild",
    value: function _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      var isActive = this._elemIsActive(child);
      var outerElem = this._getOuterElement(child);
      child.setAttribute('aria-selected', isActive);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
      }
      if (!isActive) {
        child.setAttribute('tabindex', '-1');
      }
      this._setAttributeIfNotExists(child, 'role', 'tab');

      // set attributes to the related panel too
      this._setInitialAttributesOnTargetPanel(child);
    }
  }, {
    key: "_setInitialAttributesOnTargetPanel",
    value: function _setInitialAttributesOnTargetPanel(child) {
      var target = SelectorEngine.getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, 'role', 'tabpanel');
      if (child.id) {
        this._setAttributeIfNotExists(target, 'aria-labelledby', "".concat(child.id));
      }
    }
  }, {
    key: "_toggleDropDown",
    value: function _toggleDropDown(element, open) {
      var outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      var toggle = function toggle(selector, className) {
        var element = SelectorEngine.findOne(selector, outerElem);
        if (element) {
          element.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
      outerElem.setAttribute('aria-expanded', open);
    }
  }, {
    key: "_setAttributeIfNotExists",
    value: function _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
  }, {
    key: "_elemIsActive",
    value: function _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }

    // Try to get the inner element (usually the .nav-link)
  }, {
    key: "_getInnerElement",
    value: function _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }

    // Try to get the outer element (usually the .nav-item)
  }, {
    key: "_getOuterElement",
    value: function _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }

    // Static
  }], [{
    key: "NAME",
    get: function get() {
      return NAME$1;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Tab.getOrCreateInstance(this);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }
        data[config]();
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  Tab.getOrCreateInstance(this).show();
});

/**
 * Initialize on focus
 */
EventHandler.on(window, EVENT_LOAD_DATA_API, function () {
  var _iterator29 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)),
    _step29;
  try {
    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
      var element = _step29.value;
      Tab.getOrCreateInstance(element);
    }
  } catch (err) {
    _iterator29.e(err);
  } finally {
    _iterator29.f();
  }
});
/**
 * jQuery
 */

defineJQueryPlugin(Tab);

/**
 * --------------------------------------------------------------------------
 * Bootstrap toast.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

var NAME = 'toast';
var DATA_KEY = 'bs.toast';
var EVENT_KEY = ".".concat(DATA_KEY);
var EVENT_MOUSEOVER = "mouseover".concat(EVENT_KEY);
var EVENT_MOUSEOUT = "mouseout".concat(EVENT_KEY);
var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY);
var EVENT_FOCUSOUT = "focusout".concat(EVENT_KEY);
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_SHOWING = 'showing';
var DefaultType = {
  animation: 'boolean',
  autohide: 'boolean',
  delay: 'number'
};
var Default = {
  animation: true,
  autohide: true,
  delay: 5000
};

/**
 * Class definition
 */
var Toast = exports.Toast = /*#__PURE__*/function (_BaseComponent1) {
  function Toast(element, config) {
    var _this53;
    _classCallCheck(this, Toast);
    _this53 = _callSuper(this, Toast, [element, config]);
    _this53._timeout = null;
    _this53._hasMouseInteraction = false;
    _this53._hasKeyboardInteraction = false;
    _this53._setListeners();
    return _this53;
  }

  // Getters
  _inherits(Toast, _BaseComponent1);
  return _createClass(Toast, [{
    key: "show",
    value:
    // Public
    function show() {
      var _this54 = this;
      var showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      var complete = function complete() {
        _this54._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(_this54._element, EVENT_SHOWN);
        _this54._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this55 = this;
      if (!this.isShown()) {
        return;
      }
      var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      var complete = function complete() {
        _this55._element.classList.add(CLASS_NAME_HIDE); // @deprecated
        _this55._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
        EventHandler.trigger(_this55._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._clearTimeout();
      if (this.isShown()) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      _superPropGet(Toast, "dispose", this, 3)([]);
    }
  }, {
    key: "isShown",
    value: function isShown() {
      return this._element.classList.contains(CLASS_NAME_SHOW);
    }

    // Private
  }, {
    key: "_maybeScheduleHide",
    value: function _maybeScheduleHide() {
      var _this56 = this;
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(function () {
        _this56.hide();
      }, this._config.delay);
    }
  }, {
    key: "_onInteraction",
    value: function _onInteraction(event, isInteracting) {
      switch (event.type) {
        case 'mouseover':
        case 'mouseout':
          {
            this._hasMouseInteraction = isInteracting;
            break;
          }
        case 'focusin':
        case 'focusout':
          {
            this._hasKeyboardInteraction = isInteracting;
            break;
          }
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      var nextElement = event.relatedTarget;
      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }
      this._maybeScheduleHide();
    }
  }, {
    key: "_setListeners",
    value: function _setListeners() {
      var _this57 = this;
      EventHandler.on(this._element, EVENT_MOUSEOVER, function (event) {
        return _this57._onInteraction(event, true);
      });
      EventHandler.on(this._element, EVENT_MOUSEOUT, function (event) {
        return _this57._onInteraction(event, false);
      });
      EventHandler.on(this._element, EVENT_FOCUSIN, function (event) {
        return _this57._onInteraction(event, true);
      });
      EventHandler.on(this._element, EVENT_FOCUSOUT, function (event) {
        return _this57._onInteraction(event, false);
      });
    }
  }, {
    key: "_clearTimeout",
    value: function _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }

    // Static
  }], [{
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Toast.getOrCreateInstance(this, config);
        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }
          data[config](this);
        }
      });
    }
  }]);
}(BaseComponent);
/**
 * Data API implementation
 */
enableDismissTrigger(Toast);

/**
 * jQuery
 */

defineJQueryPlugin(Toast);

},{"@popperjs/core":31}],66:[function(require,module,exports){

},{}],67:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":64,"buffer":67,"ieee754":96}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Loader = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
!function (e, t) {
  void 0 === t && (t = {});
  var n = t.insertAt;
  if (e && "undefined" != typeof document) {
    var o = document.head || document.getElementsByTagName("head")[0],
      i = document.createElement("style");
    i.type = "text/css", "top" === n && o.firstChild ? o.insertBefore(i, o.firstChild) : o.appendChild(i), i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(document.createTextNode(e));
  }
}(".loading-overlay{align-items:center;background-color:#1a1a1a;bottom:0;display:flex;flex-direction:column;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:1000}.loading-spinner{animation:spin 1s linear infinite;border-color:rgba(59,59,59,.1) rgba(255,0,0,.938) rgba(0,0,0,.1) blue;border-radius:50%;border-style:solid;border-width:8px;height:50px;width:50px}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.loading-overlay p{color:#f9f9f9;font-size:18px;margin-top:10px}");
var e = exports.Loader = /*#__PURE__*/function () {
  function e() {
    _classCallCheck(this, e);
  }
  return _createClass(e, null, [{
    key: "start",
    value: function start() {
      var _e4, _e5, _e6, _e7, _e8, _e9, _e0, _e1;
      for (var _len = arguments.length, _e = new Array(_len), _key = 0; _key < _len; _key++) {
        _e[_key] = arguments[_key];
      }
      var t = new Map();
      _e.length > 2 ? _e.length = 2 : _e.length;
      var n = "string" == typeof ((_e4 = _e) === null || _e4 === void 0 ? void 0 : _e4[0]) ? (_e5 = _e) === null || _e5 === void 0 ? void 0 : _e5[0] : "string" == typeof ((_e6 = _e) === null || _e6 === void 0 ? void 0 : _e6[1]) ? (_e7 = _e) === null || _e7 === void 0 ? void 0 : _e7[1] : "Loading...";
      _e = "object" == _typeof((_e8 = _e) === null || _e8 === void 0 ? void 0 : _e8[0]) ? (_e9 = _e) === null || _e9 === void 0 ? void 0 : _e9[0] : "object" == _typeof((_e0 = _e) === null || _e0 === void 0 ? void 0 : _e0[1]) ? (_e1 = _e) === null || _e1 === void 0 ? void 0 : _e1[1] : null;
      for (var _n in _e) {
        var o = "";
        for (var _t in _e[_n]) {
          var _t$replace;
          var i = _t === null || _t === void 0 || (_t$replace = _t.replace(/([A-Z])/g, "-$1")) === null || _t$replace === void 0 ? void 0 : _t$replace.toLowerCase();
          o += "".concat(i, ": ").concat(_e[_n][_t], " !important;");
        }
        t.has(_n) || t.set(_n, o);
      }
      if (!document.querySelector(".loading-overlay")) {
        var _e2 = document.createElement("div");
        _e2.innerHTML = "\n\t\t\t<div class=\"loading-overlay\" style=\"".concat(t.get("loadingOverlayStyles"), "\">\n\t\t\t<div class=\"loading-spinner\" style=\"").concat(t.get("loadingSpinnerStyles"), ";\"></div>\n\t\t\t<p style=\"").concat(t.get("loadingTextStyles"), "\">").concat(n, "</p>\n\t\t\t</div>"), document.body.appendChild(_e2);
      }
    }
  }, {
    key: "close",
    value: function close() {
      var _e3 = document.querySelector(".loading-overlay");
      _e3 && _e3.remove();
    }
  }]);
}();

},{}],69:[function(require,module,exports){
(function (Buffer){(function (){
var clone = (function() {
'use strict';

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":67}],70:[function(require,module,exports){
'use strict';

/******************************************************************************
 * Created 2008-08-19.
 *
 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
 *
 * Copyright (C) 2008
 *   Wyatt Baldwin <self@wyattbaldwin.com>
 *   All rights reserved
 *
 * Licensed under the MIT license.
 *
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *****************************************************************************/
var dijkstra = {
  single_source_shortest_paths: function(graph, s, d) {
    // Predecessor map for each node that has been encountered.
    // node ID => predecessor node ID
    var predecessors = {};

    // Costs of shortest paths from s to all nodes encountered.
    // node ID => cost
    var costs = {};
    costs[s] = 0;

    // Costs of shortest paths from s to all nodes encountered; differs from
    // `costs` in that it provides easy access to the node that currently has
    // the known shortest path from s.
    // XXX: Do we actually need both `costs` and `open`?
    var open = dijkstra.PriorityQueue.make();
    open.push(s, 0);

    var closest,
        u, v,
        cost_of_s_to_u,
        adjacent_nodes,
        cost_of_e,
        cost_of_s_to_u_plus_cost_of_e,
        cost_of_s_to_v,
        first_visit;
    while (!open.empty()) {
      // In the nodes remaining in graph that have a known cost from s,
      // find the node, u, that currently has the shortest path from s.
      closest = open.pop();
      u = closest.value;
      cost_of_s_to_u = closest.cost;

      // Get nodes adjacent to u...
      adjacent_nodes = graph[u] || {};

      // ...and explore the edges that connect u to those nodes, updating
      // the cost of the shortest paths to any or all of those nodes as
      // necessary. v is the node across the current edge from u.
      for (v in adjacent_nodes) {
        if (adjacent_nodes.hasOwnProperty(v)) {
          // Get the cost of the edge running from u to v.
          cost_of_e = adjacent_nodes[v];

          // Cost of s to u plus the cost of u to v across e--this is *a*
          // cost from s to v that may or may not be less than the current
          // known cost to v.
          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

          // If we haven't visited v yet OR if the current known cost from s to
          // v is greater than the new cost we just found (cost of s to u plus
          // cost of u to v across e), update v's cost in the cost list and
          // update v's predecessor in the predecessor list (it's now u).
          cost_of_s_to_v = costs[v];
          first_visit = (typeof costs[v] === 'undefined');
          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
            costs[v] = cost_of_s_to_u_plus_cost_of_e;
            open.push(v, cost_of_s_to_u_plus_cost_of_e);
            predecessors[v] = u;
          }
        }
      }
    }

    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
      throw new Error(msg);
    }

    return predecessors;
  },

  extract_shortest_path_from_predecessor_list: function(predecessors, d) {
    var nodes = [];
    var u = d;
    var predecessor;
    while (u) {
      nodes.push(u);
      predecessor = predecessors[u];
      u = predecessors[u];
    }
    nodes.reverse();
    return nodes;
  },

  find_path: function(graph, s, d) {
    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
    return dijkstra.extract_shortest_path_from_predecessor_list(
      predecessors, d);
  },

  /**
   * A very naive priority queue implementation.
   */
  PriorityQueue: {
    make: function (opts) {
      var T = dijkstra.PriorityQueue,
          t = {},
          key;
      opts = opts || {};
      for (key in T) {
        if (T.hasOwnProperty(key)) {
          t[key] = T[key];
        }
      }
      t.queue = [];
      t.sorter = opts.sorter || T.default_sorter;
      return t;
    },

    default_sorter: function (a, b) {
      return a.cost - b.cost;
    },

    /**
     * Add a new item to the queue and ensure the highest priority element
     * is at the front of the queue.
     */
    push: function (value, cost) {
      var item = {value: value, cost: cost};
      this.queue.push(item);
      this.queue.sort(this.sorter);
    },

    /**
     * Return the highest priority element in the queue.
     */
    pop: function () {
      return this.queue.shift();
    },

    empty: function () {
      return this.queue.length === 0;
    }
  }
};


// node.js module exports
if (typeof module !== 'undefined') {
  module.exports = dijkstra;
}

},{}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasCORS = void 0;
// imported from https://github.com/component/has-cors
let value = false;
try {
    value = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
}
catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
}
exports.hasCORS = value;

},{}],72:[function(require,module,exports){
"use strict";
// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = encode;
exports.decode = decode;
function encode(obj) {
    let str = '';
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (str.length)
                str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
    }
    return str;
}
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function decode(qs) {
    let qry = {};
    let pairs = qs.split('&');
    for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}

},{}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
function parse(str) {
  if (str.length > 8000) {
    throw "URI too long";
  }
  var src = str,
    b = str.indexOf('['),
    e = str.indexOf(']');
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }
  var m = re.exec(str || ''),
    uri = {},
    i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || '';
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri['path']);
  uri.queryKey = queryKey(uri, uri['query']);
  return uri;
}
function pathNames(obj, path) {
  var regx = /\/{2,9}/g,
    names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == '/' || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == '/') {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  var data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBinaryType = exports.globalThisShim = exports.nextTick = void 0;
exports.createCookieJar = createCookieJar;
exports.nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
exports.globalThisShim = (() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})();
exports.defaultBinaryType = "arraybuffer";
function createCookieJar() { }

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.TransportError = exports.Transport = exports.protocol = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = exports.Socket = void 0;
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
var socket_js_2 = require("./socket.js");
Object.defineProperty(exports, "SocketWithoutUpgrade", { enumerable: true, get: function () { return socket_js_2.SocketWithoutUpgrade; } });
Object.defineProperty(exports, "SocketWithUpgrade", { enumerable: true, get: function () { return socket_js_2.SocketWithUpgrade; } });
exports.protocol = socket_js_1.Socket.protocol;
var transport_js_1 = require("./transport.js");
Object.defineProperty(exports, "Transport", { enumerable: true, get: function () { return transport_js_1.Transport; } });
Object.defineProperty(exports, "TransportError", { enumerable: true, get: function () { return transport_js_1.TransportError; } });
var index_js_1 = require("./transports/index.js");
Object.defineProperty(exports, "transports", { enumerable: true, get: function () { return index_js_1.transports; } });
var util_js_1 = require("./util.js");
Object.defineProperty(exports, "installTimerFunctions", { enumerable: true, get: function () { return util_js_1.installTimerFunctions; } });
var parseuri_js_1 = require("./contrib/parseuri.js");
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parseuri_js_1.parse; } });
var globals_node_js_1 = require("./globals.node.js");
Object.defineProperty(exports, "nextTick", { enumerable: true, get: function () { return globals_node_js_1.nextTick; } });
var polling_fetch_js_1 = require("./transports/polling-fetch.js");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return polling_fetch_js_1.Fetch; } });
var polling_xhr_node_js_1 = require("./transports/polling-xhr.node.js");
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return polling_xhr_node_js_1.XHR; } });
var polling_xhr_js_1 = require("./transports/polling-xhr.js");
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return polling_xhr_js_1.XHR; } });
var websocket_node_js_1 = require("./transports/websocket.node.js");
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return websocket_node_js_1.WS; } });
var websocket_js_1 = require("./transports/websocket.js");
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return websocket_js_1.WS; } });
var webtransport_js_1 = require("./transports/webtransport.js");
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return webtransport_js_1.WT; } });

},{"./contrib/parseuri.js":73,"./globals.node.js":74,"./socket.js":76,"./transport.js":77,"./transports/index.js":78,"./transports/polling-fetch.js":79,"./transports/polling-xhr.js":80,"./transports/polling-xhr.node.js":80,"./transports/websocket.js":82,"./transports/websocket.node.js":82,"./transports/webtransport.js":83,"./util.js":84}],76:[function(require,module,exports){
"use strict";

function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = void 0;
var index_js_1 = require("./transports/index.js");
var util_js_1 = require("./util.js");
var parseqs_js_1 = require("./contrib/parseqs.js");
var parseuri_js_1 = require("./contrib/parseuri.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var engine_io_parser_1 = require("engine.io-parser");
var globals_node_js_1 = require("./globals.node.js");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:socket"); // debug()
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
  // script, so we create one single event listener here which will forward the event to the socket instances
  addEventListener("offline", function () {
    debug("closing %d connection(s) because the network was lost", OFFLINE_EVENT_LISTENERS.length);
    OFFLINE_EVENT_LISTENERS.forEach(function (listener) {
      return listener();
    });
  }, false);
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
 * successfully establishes the connection.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithoutUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithUpgrade
 * @see Socket
 */
var SocketWithoutUpgrade = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  function SocketWithoutUpgrade(uri, opts) {
    var _this;
    _classCallCheck(this, SocketWithoutUpgrade);
    _this = _callSuper(this, SocketWithoutUpgrade);
    _this.binaryType = globals_node_js_1.defaultBinaryType;
    _this.writeBuffer = [];
    _this._prevBufferLen = 0;
    _this._pingInterval = -1;
    _this._pingTimeout = -1;
    _this._maxPayload = -1;
    /**
     * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
     * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
     */
    _this._pingTimeoutTime = Infinity;
    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      var parsedUri = (0, parseuri_js_1.parse)(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query) opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
    }
    (0, util_js_1.installTimerFunctions)(_this, opts);
    _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = _this.secure ? "443" : "80";
    }
    _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? "443" : "80");
    _this.transports = [];
    _this._transportsByName = {};
    opts.transports.forEach(function (t) {
      var transportName = t.prototype.name;
      _this.transports.push(transportName);
      _this._transportsByName[transportName] = t;
    });
    _this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    _this.opts.path = _this.opts.path.replace(/\/$/, "") + (_this.opts.addTrailingSlash ? "/" : "");
    if (typeof _this.opts.query === "string") {
      _this.opts.query = (0, parseqs_js_1.decode)(_this.opts.query);
    }
    if (withEventListeners) {
      if (_this.opts.closeOnBeforeunload) {
        // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
        // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
        // closed/reloaded)
        _this._beforeunloadEventListener = function () {
          if (_this.transport) {
            // silently close the transport
            _this.transport.removeAllListeners();
            _this.transport.close();
          }
        };
        addEventListener("beforeunload", _this._beforeunloadEventListener, false);
      }
      if (_this.hostname !== "localhost") {
        debug("adding listener for the 'offline' event");
        _this._offlineEventListener = function () {
          _this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(_this._offlineEventListener);
      }
    }
    if (_this.opts.withCredentials) {
      _this._cookieJar = (0, globals_node_js_1.createCookieJar)();
    }
    _this._open();
    return _this;
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  _inherits(SocketWithoutUpgrade, _component_emitter_1$);
  return _createClass(SocketWithoutUpgrade, [{
    key: "createTransport",
    value: function createTransport(name) {
      debug('creating transport "%s"', name);
      var query = Object.assign({}, this.opts.query);
      // append engine.io protocol identifier
      query.EIO = engine_io_parser_1.protocol;
      // transport name
      query.transport = name;
      // session id if we already have one
      if (this.id) query.sid = this.id;
      var opts = Object.assign({}, this.opts, {
        query: query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[name]);
      debug("options: %j", opts);
      return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
  }, {
    key: "_open",
    value: function _open() {
      var _this2 = this;
      if (this.transports.length === 0) {
        // Emit error on next tick so it can be listened to
        this.setTimeoutFn(function () {
          _this2.emitReserved("error", "No transports available");
        }, 0);
        return;
      }
      var transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
      this.readyState = "opening";
      var transport = this.createTransport(transportName);
      transport.open();
      this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var _this3 = this;
      debug("setting transport %s", transport.name);
      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      // set up transport
      this.transport = transport;
      // set up transport listeners
      transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", function (reason) {
        return _this3._onClose("transport close", reason);
      });
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
  }, {
    key: "onOpen",
    value: function onOpen() {
      debug("socket open");
      this.readyState = "open";
      SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emitReserved("open");
      this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */
  }, {
    key: "_onPacket",
    value: function _onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emitReserved("packet", packet);
        // Socket is live - any packet counts
        this.emitReserved("heartbeat");
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this._sendPacket("pong");
            this.emitReserved("ping");
            this.emitReserved("pong");
            this._resetPingTimeout();
            break;
          case "error":
            var err = new Error("server error");
            // @ts-ignore
            err.code = packet.data;
            this._onError(err);
            break;
          case "message":
            this.emitReserved("data", packet.data);
            this.emitReserved("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this.emitReserved("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this._pingInterval = data.pingInterval;
      this._pingTimeout = data.pingTimeout;
      this._maxPayload = data.maxPayload;
      this.onOpen();
      // In case open handler closes socket
      if ("closed" === this.readyState) return;
      this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
  }, {
    key: "_resetPingTimeout",
    value: function _resetPingTimeout() {
      var _this4 = this;
      this.clearTimeoutFn(this._pingTimeoutTimer);
      var delay = this._pingInterval + this._pingTimeout;
      this._pingTimeoutTime = Date.now() + delay;
      this._pingTimeoutTimer = this.setTimeoutFn(function () {
        _this4._onClose("ping timeout");
      }, delay);
      if (this.opts.autoUnref) {
        this._pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
  }, {
    key: "_onDrain",
    value: function _onDrain() {
      this.writeBuffer.splice(0, this._prevBufferLen);
      // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`
      this._prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emitReserved("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        var packets = this._getWritablePackets();
        debug("flushing %d packets in socket", packets.length);
        this.transport.send(packets);
        // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`
        this._prevBufferLen = packets.length;
        this.emitReserved("flush");
      }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
  }, {
    key: "_getWritablePackets",
    value: function _getWritablePackets() {
      var shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
      if (!shouldCheckPayloadSize) {
        return this.writeBuffer;
      }
      var payloadSize = 1; // first packet type
      for (var i = 0; i < this.writeBuffer.length; i++) {
        var data = this.writeBuffer[i].data;
        if (data) {
          payloadSize += (0, util_js_1.byteLength)(data);
        }
        if (i > 0 && payloadSize > this._maxPayload) {
          debug("only send %d out of %d packets", i, this.writeBuffer.length);
          return this.writeBuffer.slice(0, i);
        }
        payloadSize += 2; // separator + packet type
      }
      debug("payload size is %d (max: %d)", payloadSize, this._maxPayload);
      return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    /* private */
  }, {
    key: "_hasPingExpired",
    value: function _hasPingExpired() {
      var _this5 = this;
      if (!this._pingTimeoutTime) return true;
      var hasExpired = Date.now() > this._pingTimeoutTime;
      if (hasExpired) {
        debug("throttled timer detected, scheduling connection close");
        this._pingTimeoutTime = 0;
        (0, globals_node_js_1.nextTick)(function () {
          _this5._onClose("ping timeout");
        }, this.setTimeoutFn);
      }
      return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
  }, {
    key: "write",
    value: function write(msg, options, fn) {
      this._sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
  }, {
    key: "send",
    value: function send(msg, options, fn) {
      this._sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
  }, {
    key: "_sendPacket",
    value: function _sendPacket(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = undefined;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emitReserved("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn) this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     */
  }, {
    key: "close",
    value: function close() {
      var _this6 = this;
      var close = function close() {
        _this6._onClose("forced close");
        debug("socket closing - telling transport to close");
        _this6.transport.close();
      };
      var _cleanupAndClose = function cleanupAndClose() {
        _this6.off("upgrade", _cleanupAndClose);
        _this6.off("upgradeError", _cleanupAndClose);
        close();
      };
      var waitForUpgrade = function waitForUpgrade() {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        _this6.once("upgrade", _cleanupAndClose);
        _this6.once("upgradeError", _cleanupAndClose);
      };
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", function () {
            if (_this6.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
  }, {
    key: "_onError",
    value: function _onError(err) {
      debug("socket error %j", err);
      SocketWithoutUpgrade.priorWebsocketSuccess = false;
      if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
        debug("trying next transport");
        this.transports.shift();
        return this._open();
      }
      this.emitReserved("error", err);
      this._onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
  }, {
    key: "_onClose",
    value: function _onClose(reason, description) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket close with reason: "%s"', reason);
        // clear timers
        this.clearTimeoutFn(this._pingTimeoutTimer);
        // stop event from firing again for transport
        this.transport.removeAllListeners("close");
        // ensure transport won't stay open
        this.transport.close();
        // ignore further transport communication
        this.transport.removeAllListeners();
        if (withEventListeners) {
          if (this._beforeunloadEventListener) {
            removeEventListener("beforeunload", this._beforeunloadEventListener, false);
          }
          if (this._offlineEventListener) {
            var i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
            if (i !== -1) {
              debug("removing listener for the 'offline' event");
              OFFLINE_EVENT_LISTENERS.splice(i, 1);
            }
          }
        }
        // set ready state
        this.readyState = "closed";
        // clear session id
        this.id = null;
        // emit close event
        this.emitReserved("close", reason, description);
        // clean buffers after, so users can still
        // grab the buffers on `close` event
        this.writeBuffer = [];
        this._prevBufferLen = 0;
      }
    }
  }]);
}(component_emitter_1.Emitter);
exports.SocketWithoutUpgrade = SocketWithoutUpgrade;
SocketWithoutUpgrade.protocol = engine_io_parser_1.protocol;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see Socket
 */
var SocketWithUpgrade = /*#__PURE__*/function (_SocketWithoutUpgrade) {
  function SocketWithUpgrade() {
    var _this7;
    _classCallCheck(this, SocketWithUpgrade);
    _this7 = _callSuper(this, SocketWithUpgrade, arguments);
    _this7._upgrades = [];
    return _this7;
  }
  _inherits(SocketWithUpgrade, _SocketWithoutUpgrade);
  return _createClass(SocketWithUpgrade, [{
    key: "onOpen",
    value: function onOpen() {
      _superPropGet(SocketWithUpgrade, "onOpen", this, 3)([]);
      if ("open" === this.readyState && this.opts.upgrade) {
        debug("starting upgrade probes");
        for (var i = 0; i < this._upgrades.length; i++) {
          this._probe(this._upgrades[i]);
        }
      }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
  }, {
    key: "_probe",
    value: function _probe(name) {
      var _this8 = this;
      debug('probing transport "%s"', name);
      var transport = this.createTransport(name);
      var failed = false;
      SocketWithoutUpgrade.priorWebsocketSuccess = false;
      var onTransportOpen = function onTransportOpen() {
        if (failed) return;
        debug('probe transport "%s" opened', name);
        transport.send([{
          type: "ping",
          data: "probe"
        }]);
        transport.once("packet", function (msg) {
          if (failed) return;
          if ("pong" === msg.type && "probe" === msg.data) {
            debug('probe transport "%s" pong', name);
            _this8.upgrading = true;
            _this8.emitReserved("upgrading", transport);
            if (!transport) return;
            SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
            debug('pausing current transport "%s"', _this8.transport.name);
            _this8.transport.pause(function () {
              if (failed) return;
              if ("closed" === _this8.readyState) return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              _this8.setTransport(transport);
              transport.send([{
                type: "upgrade"
              }]);
              _this8.emitReserved("upgrade", transport);
              transport = null;
              _this8.upgrading = false;
              _this8.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            var err = new Error("probe error");
            // @ts-ignore
            err.transport = transport.name;
            _this8.emitReserved("upgradeError", err);
          }
        });
      };
      function freezeTransport() {
        if (failed) return;
        // Any callback called by transport should be ignored since now
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      // Handle any error that happens while probing
      var onerror = function onerror(err) {
        var error = new Error("probe error: " + err);
        // @ts-ignore
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        _this8.emitReserved("upgradeError", error);
      };
      function onTransportClose() {
        onerror("transport closed");
      }
      // When the socket is closed while we're probing
      function onclose() {
        onerror("socket closed");
      }
      // When the socket is upgraded while we're probing
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }
      // Remove all listeners on the transport and on self
      var cleanup = function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        _this8.off("close", onclose);
        _this8.off("upgrading", onupgrade);
      };
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
        // favor WebTransport
        this.setTimeoutFn(function () {
          if (!failed) {
            transport.open();
          }
        }, 200);
      } else {
        transport.open();
      }
    }
  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this._upgrades = this._filterUpgrades(data.upgrades);
      _superPropGet(SocketWithUpgrade, "onHandshake", this, 3)([data]);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
  }, {
    key: "_filterUpgrades",
    value: function _filterUpgrades(upgrades) {
      var filteredUpgrades = [];
      for (var i = 0; i < upgrades.length; i++) {
        if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    }
  }]);
}(SocketWithoutUpgrade);
exports.SocketWithUpgrade = SocketWithUpgrade;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * @example
 * import { Socket } from "engine.io-client";
 *
 * const socket = new Socket();
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see SocketWithUpgrade
 */
var Socket = /*#__PURE__*/function (_SocketWithUpgrade) {
  function Socket(uri) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Socket);
    var o = _typeof(uri) === "object" ? uri : opts;
    if (!o.transports || o.transports && typeof o.transports[0] === "string") {
      o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map(function (transportName) {
        return index_js_1.transports[transportName];
      }).filter(function (t) {
        return !!t;
      });
    }
    return _callSuper(this, Socket, [uri, o]);
  }
  _inherits(Socket, _SocketWithUpgrade);
  return _createClass(Socket);
}(SocketWithUpgrade);
exports.Socket = Socket;

},{"./contrib/parseqs.js":72,"./contrib/parseuri.js":73,"./globals.node.js":74,"./transports/index.js":78,"./util.js":84,"@socket.io/component-emitter":63,"debug":85,"engine.io-parser":91}],77:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = exports.TransportError = void 0;
const engine_io_parser_1 = require("engine.io-parser");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("./util.js");
const parseqs_js_1 = require("./contrib/parseqs.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:transport"); // debug()
class TransportError extends Error {
    constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
exports.TransportError = TransportError;
class Transport extends component_emitter_1.Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
        super();
        this.writable = false;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
        this.supportsBinary = !opts.forceBase64;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */
    open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */
    close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
        if (this.readyState === "open") {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
            debug("transport is not open, discarding packets");
        }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) { }
    createUri(schema, query = {}) {
        return (schema +
            "://" +
            this._hostname() +
            this._port() +
            this.opts.path +
            this._query(query));
    }
    _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
        if (this.opts.port &&
            ((this.opts.secure && Number(this.opts.port !== 443)) ||
                (!this.opts.secure && Number(this.opts.port) !== 80))) {
            return ":" + this.opts.port;
        }
        else {
            return "";
        }
    }
    _query(query) {
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
    }
}
exports.Transport = Transport;

},{"./contrib/parseqs.js":72,"./util.js":84,"@socket.io/component-emitter":63,"debug":85,"engine.io-parser":91}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transports = void 0;
const polling_xhr_node_js_1 = require("./polling-xhr.node.js");
const websocket_node_js_1 = require("./websocket.node.js");
const webtransport_js_1 = require("./webtransport.js");
exports.transports = {
    websocket: websocket_node_js_1.WS,
    webtransport: webtransport_js_1.WT,
    polling: polling_xhr_node_js_1.XHR,
};

},{"./polling-xhr.node.js":80,"./websocket.node.js":82,"./webtransport.js":83}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fetch = void 0;
const polling_js_1 = require("./polling.js");
/**
 * HTTP long-polling based on the built-in `fetch()` method.
 *
 * Usage: browser, Node.js (since v18), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch
 * @see https://caniuse.com/fetch
 * @see https://nodejs.org/api/globals.html#fetch
 */
class Fetch extends polling_js_1.Polling {
    doPoll() {
        this._fetch()
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch read error", res.status, res);
            }
            res.text().then((data) => this.onData(data));
        })
            .catch((err) => {
            this.onError("fetch read error", err);
        });
    }
    doWrite(data, callback) {
        this._fetch(data)
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch write error", res.status, res);
            }
            callback();
        })
            .catch((err) => {
            this.onError("fetch write error", err);
        });
    }
    _fetch(data) {
        var _a;
        const isPost = data !== undefined;
        const headers = new Headers(this.opts.extraHeaders);
        if (isPost) {
            headers.set("content-type", "text/plain;charset=UTF-8");
        }
        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
        return fetch(this.uri(), {
            method: isPost ? "POST" : "GET",
            body: isPost ? data : null,
            headers,
            credentials: this.opts.withCredentials ? "include" : "omit",
        }).then((res) => {
            var _a;
            // @ts-ignore getSetCookie() was added in Node.js v19.7.0
            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());
            return res;
        });
    }
}
exports.Fetch = Fetch;

},{"./polling.js":81}],80:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XHR = exports.Request = exports.BaseXHR = void 0;
const polling_js_1 = require("./polling.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("../util.js");
const globals_node_js_1 = require("../globals.node.js");
const has_cors_js_1 = require("../contrib/has-cors.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
function empty() { }
class BaseXHR extends polling_js_1.Polling {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
        }
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data,
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
        debug("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
exports.BaseXHR = BaseXHR;
class Request extends component_emitter_1.Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(createRequest, uri, opts) {
        super();
        this.createRequest = createRequest;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this._opts = opts;
        this._method = opts.method || "GET";
        this._uri = uri;
        this._data = undefined !== opts.data ? opts.data : null;
        this._create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    _create() {
        var _a;
        const opts = (0, util_js_1.pick)(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this._opts.xd;
        const xhr = (this._xhr = this.createRequest(opts));
        try {
            debug("xhr open %s: %s", this._method, this._uri);
            xhr.open(this._method, this._uri, true);
            try {
                if (this._opts.extraHeaders) {
                    // @ts-ignore
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this._opts.extraHeaders) {
                        if (this._opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this._method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this._opts.withCredentials;
            }
            if (this._opts.requestTimeout) {
                xhr.timeout = this._opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                var _a;
                if (xhr.readyState === 3) {
                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(
                    // @ts-ignore
                    xhr.getResponseHeader("set-cookie"));
                }
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this._onLoad();
                }
                else {
                    // make sure the `error` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this._onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            debug("xhr data %s", this._data);
            xhr.send(this._data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this._onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this._index = Request.requestsCount++;
            Request.requests[this._index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    _onError(err) {
        this.emitReserved("error", err, this._xhr);
        this._cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    _cleanup(fromError) {
        if ("undefined" === typeof this._xhr || null === this._xhr) {
            return;
        }
        this._xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this._xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this._index];
        }
        this._xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    _onLoad() {
        const data = this._xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this._cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
        this._cleanup();
    }
}
exports.Request = Request;
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globals_node_js_1.globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}
const hasXHR2 = (function () {
    const xhr = newRequest({
        xdomain: false,
    });
    return xhr && xhr.responseType !== null;
})();
/**
 * HTTP long-polling based on the built-in `XMLHttpRequest` object.
 *
 * Usage: browser
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 */
class XHR extends BaseXHR {
    constructor(opts) {
        super(opts);
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd }, this.opts);
        return new Request(newRequest, this.uri(), opts);
    }
}
exports.XHR = XHR;
function newRequest(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new globals_node_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
}

},{"../contrib/has-cors.js":71,"../globals.node.js":74,"../util.js":84,"./polling.js":81,"@socket.io/component-emitter":63,"debug":85}],81:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Polling = void 0;
const transport_js_1 = require("../transport.js");
const util_js_1 = require("../util.js");
const engine_io_parser_1 = require("engine.io-parser");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
class Polling extends transport_js_1.Transport {
    constructor() {
        super(...arguments);
        this._polling = false;
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
        this._poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            debug("paused");
            this.readyState = "paused";
            onPause();
        };
        if (this._polling || !this.writable) {
            let total = 0;
            if (this._polling) {
                debug("we are currently polling - waiting to pause");
                total++;
                this.once("pollComplete", function () {
                    debug("pre-pause polling complete");
                    --total || pause();
                });
            }
            if (!this.writable) {
                debug("we are currently writing - waiting to pause");
                total++;
                this.once("drain", function () {
                    debug("pre-pause writing complete");
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    _poll() {
        debug("polling");
        this._polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
        debug("polling got data %s", data);
        const callback = (packet) => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({ description: "transport closed by the server" });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this._polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
                this._poll();
            }
            else {
                debug('ignoring poll - transport state "%s"', this.readyState);
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
        const close = () => {
            debug("writing close packet");
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            debug("transport open - closing");
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            debug("transport not open - deferring close");
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
        this.writable = false;
        (0, engine_io_parser_1.encodePayload)(packets, (data) => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, util_js_1.randomString)();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
exports.Polling = Polling;

},{"../transport.js":77,"../util.js":84,"debug":85,"engine.io-parser":91}],82:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WS = exports.BaseWS = void 0;
const transport_js_1 = require("../transport.js");
const util_js_1 = require("../util.js");
const engine_io_parser_1 = require("engine.io-parser");
const globals_node_js_1 = require("../globals.node.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:websocket"); // debug()
// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class BaseWS extends transport_js_1.Transport {
    get name() {
        return "websocket";
    }
    doOpen() {
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws = this.createSocket(uri, protocols, opts);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
            description: "websocket connection closed",
            context: closeEvent,
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    this.doWrite(packet, data);
                }
                catch (e) {
                    debug("websocket closed before onclose event");
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    (0, globals_node_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.onerror = () => { };
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, util_js_1.randomString)();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
exports.BaseWS = BaseWS;
const WebSocketCtor = globals_node_js_1.globalThisShim.WebSocket || globals_node_js_1.globalThisShim.MozWebSocket;
/**
 * WebSocket transport based on the built-in `WebSocket` object.
 *
 * Usage: browser, Node.js (since v21), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
 * @see https://caniuse.com/mdn-api_websocket
 * @see https://nodejs.org/api/globals.html#websocket
 */
class WS extends BaseWS {
    createSocket(uri, protocols, opts) {
        return !isReactNative
            ? protocols
                ? new WebSocketCtor(uri, protocols)
                : new WebSocketCtor(uri)
            : new WebSocketCtor(uri, protocols, opts);
    }
    doWrite(_packet, data) {
        this.ws.send(data);
    }
}
exports.WS = WS;

},{"../globals.node.js":74,"../transport.js":77,"../util.js":84,"debug":85,"engine.io-parser":91}],83:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WT = void 0;
const transport_js_1 = require("../transport.js");
const globals_node_js_1 = require("../globals.node.js");
const engine_io_parser_1 = require("engine.io-parser");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:webtransport"); // debug()
/**
 * WebTransport transport based on the built-in `WebTransport` object.
 *
 * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
 * @see https://caniuse.com/webtransport
 */
class WT extends transport_js_1.Transport {
    get name() {
        return "webtransport";
    }
    doOpen() {
        try {
            // @ts-ignore
            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this._transport.closed
            .then(() => {
            debug("transport closed gracefully");
            this.onClose();
        })
            .catch((err) => {
            debug("transport closed due to %s", err);
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
        this._transport.ready.then(() => {
            this._transport.createBidirectionalStream().then((stream) => {
                const decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();
                encoderStream.readable.pipeTo(stream.writable);
                this._writer = encoderStream.writable.getWriter();
                const read = () => {
                    reader
                        .read()
                        .then(({ done, value }) => {
                        if (done) {
                            debug("session is closed");
                            return;
                        }
                        debug("received chunk: %o", value);
                        this.onPacket(value);
                        read();
                    })
                        .catch((err) => {
                        debug("an error occurred while reading: %s", err);
                    });
                };
                read();
                const packet = { type: "open" };
                if (this.query.sid) {
                    packet.data = `{"sid":"${this.query.sid}"}`;
                }
                this._writer.write(packet).then(() => this.onOpen());
            });
        });
    }
    write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            this._writer.write(packet).then(() => {
                if (lastPacket) {
                    (0, globals_node_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        var _a;
        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
    }
}
exports.WT = WT;

},{"../globals.node.js":74,"../transport.js":77,"debug":85,"engine.io-parser":91}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = pick;
exports.installTimerFunctions = installTimerFunctions;
exports.byteLength = byteLength;
exports.randomString = randomString;
const globals_node_js_1 = require("./globals.node.js");
function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = globals_node_js_1.globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globals_node_js_1.globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globals_node_js_1.globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globals_node_js_1.globalThisShim);
    }
    else {
        obj.setTimeoutFn = globals_node_js_1.globalThisShim.setTimeout.bind(globals_node_js_1.globalThisShim);
        obj.clearTimeoutFn = globals_node_js_1.globalThisShim.clearTimeout.bind(globals_node_js_1.globalThisShim);
    }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
    if (typeof obj === "string") {
        return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
    let c = 0, length = 0;
    for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 0x80) {
            length += 1;
        }
        else if (c < 0x800) {
            length += 2;
        }
        else if (c < 0xd800 || c >= 0xe000) {
            length += 3;
        }
        else {
            i++;
            length += 4;
        }
    }
    return length;
}
/**
 * Generates a random 8-characters string.
 */
function randomString() {
    return (Date.now().toString(36).substring(3) +
        Math.random().toString(36).substring(2, 5));
}

},{"./globals.node.js":74}],85:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))
},{"./common":86,"_process":111}],86:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":105}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
exports.ERROR_PACKET = ERROR_PACKET;

},{}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
// imported from https://github.com/socketio/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
const encode = (arraybuffer) => {
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
exports.encode = encode;
const decode = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};
exports.decode = decode;

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePacket = void 0;
const commons_js_1 = require("./commons.js");
const base64_arraybuffer_js_1 = require("./contrib/base64-arraybuffer.js");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType),
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),
        };
    }
    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
    if (!packetType) {
        return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
        }
        : {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
        };
};
exports.decodePacket = decodePacket;
const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
        const decoded = (0, base64_arraybuffer_js_1.decode)(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            if (data instanceof Blob) {
                // from WebSocket + binaryType "blob"
                return data;
            }
            else {
                // from HTTP long-polling or WebTransport
                return new Blob([data]);
            }
        case "arraybuffer":
        default:
            if (data instanceof ArrayBuffer) {
                // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
                return data;
            }
            else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
    }
};

},{"./commons.js":87,"./contrib/base64-arraybuffer.js":88}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePacket = void 0;
exports.encodePacketToBinary = encodePacketToBinary;
const commons_js_1 = require("./commons.js");
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};
exports.encodePacket = encodePacket;
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
};
function toArray(data) {
    if (data instanceof Uint8Array) {
        return data;
    }
    else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    else {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (withNativeBlob && packet.data instanceof Blob) {
        return packet.data.arrayBuffer().then(toArray).then(callback);
    }
    else if (withNativeArrayBuffer &&
        (packet.data instanceof ArrayBuffer || isView(packet.data))) {
        return callback(toArray(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
        if (!TEXT_ENCODER) {
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}

},{"./commons.js":87}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;
exports.createPacketEncoderStream = createPacketEncoderStream;
exports.createPacketDecoderStream = createPacketDecoderStream;
const encodePacket_js_1 = require("./encodePacket.js");
Object.defineProperty(exports, "encodePacket", { enumerable: true, get: function () { return encodePacket_js_1.encodePacket; } });
const decodePacket_js_1 = require("./decodePacket.js");
Object.defineProperty(exports, "decodePacket", { enumerable: true, get: function () { return decodePacket_js_1.decodePacket; } });
const commons_js_1 = require("./commons.js");
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
exports.encodePayload = encodePayload;
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
exports.decodePayload = decodePayload;
function createPacketEncoderStream() {
    return new TransformStream({
        transform(packet, controller) {
            (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                }
                else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                }
                else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        },
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* State.READ_HEADER */;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            while (true) {
                if (state === 0 /* State.READ_HEADER */) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* State.READ_PAYLOAD */;
                    }
                    else if (expectedLength === 126) {
                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
                    }
                    else {
                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
                    }
                }
                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(commons_js_1.ERROR_PACKET);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* State.READ_HEADER */;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(commons_js_1.ERROR_PACKET);
                    break;
                }
            }
        },
    });
}
exports.protocol = 4;

},{"./commons.js":87,"./decodePacket.js":89,"./encodePacket.js":90}],92:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],93:[function(require,module,exports){
(function (global){(function (){
(function(a,b){if("function"==typeof define&&define.amd)define([],b);else if("undefined"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error("could not download file")},d.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof global&&global.global===global?global:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,"undefined"!=typeof module&&(module.exports=g)});


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = forPromise;
var _essentials = require("./utils/essentials.mjs");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } //  Libs
/**
 * @typedef {Object} forPromiseIteration
 * @property {Record<string, any>|any[]|number} data - The main data source. Can be an array-like object, number (as count), or object for keys.
 * @property {string} [type] - Optional type of iteration. Currently supports "while" for while-like looping.
 * @property {*} [while] - While validator
 * @property {Function} [checker] - Used only with type: "while" to determine loop continuation.
 */
/**
 * Extra control object.
 *
 * @typedef {Object} forPromiseExtra
 * @property {boolean} complete - Whether the extra item has completed processing.
 * @property {boolean} forceBreak - Whether the extra item has triggered a forced break.
 * @property {number} count - Number of processed items.
 * @property {number|null} total - Total expected items, or null if not set.
 * @property {Array<any>} items - List of items processed.
 * @property {string} [type] - Optional type of processing (e.g., 'while').
 * @property {boolean} [error] - Is error.
 */
/**
 * @typedef {{
 *  error: boolean;
 *  forceBreak: boolean;
 *  type?: string;
 *  extra?: Array<forPromiseExtra>;
 *  count: number;
 *  total: number|null;
 *  items: Array<any>
 * }} ForPromiseStatus
 */
/**
 * Runs an asynchronous iterative operation with advanced control over flow, breaks, and nested (extra) iterations.
 * The function accepts a data object and a callback, and returns a Promise that resolves with iteration results.
 *
 * @param {forPromiseIteration} obj - The data object used to control the iteration process. It must follow a specific structure.
 * @param {Function} callback - A function that will be called on each iteration step.
 *
 * @returns {Promise<ForPromiseStatus>}
 */
function forPromise(obj, callback) {
  return new Promise(function (resolve, reject) {
    try {
      if (_typeof(obj) !== 'object' || obj === null) throw new Error('Invalid object provided.');
      if (typeof callback !== 'function') throw new Error('Callback must be a function.');
    } catch (err) {
      return reject(err);
    }
    // Validate Obj
    var objValidated = (0, _essentials.superValidator)(obj);
    // Validator
    if (objValidated.confirmed) {
      /** @type {ForPromiseStatus} */
      var items = {
        error: false,
        forceBreak: false,
        count: 0,
        total: null,
        items: []
      };
      // Error Result
      /** @param {Error} err */
      var error_result = function error_result(err) {
        // Send Error Reject
        items.error = true;
        reject(err);
      };
      /**
       * Prepare Result
       *
       * @param {boolean} isExtra
       * @param {number} extraIndex
       * @param {*} item
       * @param {boolean|{ break: boolean; dontSendResult: boolean; forceResult: boolean;}} [forceBreak=false]
       */
      var result = function result(isExtra, extraIndex, item) {
        var forceBreak = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        // Prepare Edit
        var item_to_edit = null;
        // Not Extra
        if (!isExtra) {
          item_to_edit = items;
        } else {
          item_to_edit = extra.list[extraIndex];
        }
        if (typeof item_to_edit.total !== 'number') return reject(new Error('Invalid "item_to_edit.total" value: null or undefined.'));
        // Force Break
        /**
         * @typedef {Object} ForceBreakResult
         * @property {boolean} isObject
         * @property {boolean} [allowed]
         * @property {boolean} [dontSendResult]
         * @property {boolean} [forceResult]
         */
        /** @type {ForceBreakResult} */
        var forceBreakResult = {
          isObject: (/** @type {boolean} */(0, _essentials.objType)(forceBreak, 'object'))
        };
        // Is Boolean
        if (!forceBreakResult.isObject) {
          if (!item_to_edit.forceBreak) {
            forceBreakResult.allowed = typeof forceBreak === 'boolean' && forceBreak;
          } else {
            forceBreakResult.allowed = false;
          }
          forceBreakResult.dontSendResult = false;
          forceBreakResult.forceResult = false;
        }
        // Object
        else if (_typeof(forceBreak) === 'object') {
          if (!item_to_edit.forceBreak) forceBreakResult.allowed = typeof forceBreak["break"] === 'boolean' && forceBreak["break"];else forceBreakResult.allowed = false;
          forceBreakResult.dontSendResult = typeof forceBreak.dontSendResult === 'boolean' && forceBreak.dontSendResult;
          forceBreakResult.forceResult = typeof forceBreak.forceResult === 'boolean' && forceBreak.forceResult;
        }
        // No Error
        if (!item_to_edit.error && !item_to_edit.forceBreak || forceBreakResult.forceResult) {
          // Count
          item_to_edit.count++;
          // Normal
          if (item !== null) {
            // Add Item
            item_to_edit.items.push(item);
          }
          // Set Force Break
          if (!item_to_edit.forceBreak && forceBreakResult.allowed) {
            item_to_edit.forceBreak = true;
            item_to_edit.count = item_to_edit.total + 1;
          }
          // Complete
          if (
          // Can Send Results
          !forceBreakResult.dontSendResult && (
          // Count is Bigger
          item_to_edit.count >= item_to_edit.total ||
          // Type
          typeof item_to_edit.type === 'string' &&
          // While
          item_to_edit.type === 'while' && item_to_edit.count > 0)) {
            // Normal Result
            if (!isExtra) {
              if (!extra.enabled) resolve(items);
            }
            // Extra Result
            else {
              // Check Extra Exist
              if (extra.list[extraIndex]) {
                // Complete Check
                extra.list[extraIndex].complete = true;
                // Check List
                var confirmation_checked = true;
                // Detect Progress
                for (var _item in extra.list) {
                  if (!extra.list[_item].complete) {
                    confirmation_checked = false;
                    break;
                  }
                }
                // Complete
                if (confirmation_checked) {
                  // Add Extra Info
                  items.extra = extra.list;
                  // Resolve
                  resolve(items);
                }
              }
              // Nope
              else {
                items.error = true;
                reject(new Error("forAwait Extra Index ".concat(extraIndex, " not found.")));
              }
            }
          }
        }
      };
      /**
       * @param {Function} callback
       * @param {boolean} [isExtra=false]
       * @param {number} [index=-1]
       * @param {{data: any, type?: string, checker?: Function}|null} [new_extra=null]
       * @returns {void}
       */
      var runFor = function runFor(callback) {
        var isExtra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        var new_extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var the_item = null;
        // Normal
        if (!isExtra) the_item = obj;else if (_typeof(new_extra) === 'object') the_item = new_extra;
        /**
         * @param {number|string|null} [item=null]
         * @returns {boolean}
         */
        var runFor_script = function runFor_script() {
          var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          // No Error
          if (!items.error && !items.forceBreak) {
            // Try
            try {
              // Result Function
              var result_data = /**  @param {boolean} forceBreak */function result_data(forceBreak) {
                return result(isExtra, index, item, forceBreak);
              };
              // Exist Item
              if (item !== null) callback(item, result_data, error_result, extra.extra_function);
              // Nope
              else callback(result_data, error_result, extra.extra_function);
            } catch (err) {
              // Error
              items.error = true;
              reject(err);
              return false;
            }
            // Normal Return
            return true;
          }
          // Error
          else return false;
        };
        if (the_item === null) throw new Error('Invalid "the_item" value: null or undefined.');
        // Start the For
        if (typeof the_item.data !== 'number') {
          // For Object
          if (!the_item.type) {
            // Start For
            var for_used = false;
            for (var item in the_item.data) {
              for_used = true;
              if (!runFor_script(item)) {
                break;
              }
            }
            // Not Used? Confirmed
            if (!for_used) return result(isExtra, index, null);
          }
          // Type
          else {
            // Start a While
            if (the_item.type === 'while') {
              /** @returns {object|void} */
              var _custom_do = function custom_do() {
                if (typeof the_item.checker !== 'function') throw new Error('Invalid "checker" function in "the_item".');
                // Validate
                if (the_item.checker()) {
                  // Prepare Edit
                  var item_to_edit = null;
                  // Not Extra
                  if (!isExtra) {
                    item_to_edit = items;
                  } else item_to_edit = extra.list[index];
                  if (typeof item_to_edit.total !== 'number') throw new Error('Invalid "item_to_edit.total" value: null or undefined.');
                  // Add Total
                  item_to_edit.total++;
                  // Callback and Continue
                  callback(
                  /**
                   * Increments the item count and returns the result handler.
                   *
                   * @param {boolean} forceBreak - Whether to forcefully break the loop.
                   * @returns {*} The result of the handler execution.
                   */
                  function (forceBreak) {
                    item_to_edit.count++;
                    return result(isExtra, index, null, forceBreak);
                  }, error_result, extra.extra_function);
                  return _custom_do();
                }
                // Nope
                else return result(isExtra, index, null);
              };
              // Start
              _custom_do();
            }
            // Nothing
            else {
              items.error = true;
              reject(new Error('Invalid Function Type!'));
            }
          }
        }
        // Number Type
        else {
          // Exist Number
          if (the_item.data > 0) {
            for (var _item2 = 0; _item2 < the_item.data; _item2++) {
              if (!runFor_script(_item2)) {
                break;
              }
            }
          }
          // Nope
          else return result(isExtra, index, null);
        }
      };
      // Detect Object Module
      items.total = (0, _essentials.validateTotal)(obj.data);
      // Type
      if (objValidated.type) items.type = objValidated.type;
      /**
       * Represents the extra handling structure.
       *
       * @typedef {Object} Extra
       * @property {boolean} enabled - Whether extra processing is enabled.
       * @property {Array<forPromiseExtra>} list - List of extra items.
       * @property {function(forPromiseIteration): {run: function(Function): void}|null} extra_function - Function to add a new extra item.
       */
      /** @type {Extra} */
      var extra = {
        // Enabled
        enabled: false,
        // Extra List
        list: [],
        /**
         * @param {forPromiseIteration} new_extra
         * @returns {{run: function(Function): void}|null}
         */
        extra_function: function extra_function(new_extra) {
          // Validate Obj
          var objValidated = (0, _essentials.superValidator)(new_extra);
          // Validator
          if (objValidated.confirmed) {
            // Prepare Extra
            extra.enabled = true;
            extra.list.push({
              complete: false,
              forceBreak: false,
              count: 0,
              total: null,
              items: []
            });
            // Index
            var index = extra.list.length - 1;
            // Get Total
            extra.list[index].total = (0, _essentials.validateTotal)(new_extra.data);
            // Type
            if (objValidated.type) extra.list[index].type = objValidated.type;
            // Callback
            return {
              // Run Extra
              run: function run(callback) {
                // Run For
                if (!items.error && !items.forceBreak) runFor(callback, true, index, new_extra);
              }
            };
          }
          // Nope
          else {
            var err = new Error('Invalid Object Extra Type to start the Script.');
            items.error = true;
            reject(err);
            return null;
          }
        }
      };
      // Run For
      runFor(callback);
    }
    // Nope
    else reject(new Error('Invalid Object Type to start the Script.'));
  });
}

},{"./utils/essentials.mjs":95}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.countObj = countObj;
exports.objType = objType;
exports.superValidator = superValidator;
exports.validateTotal = validateTotal;
/**
 * Validates the total value based on the type of the input.
 *
 * - If the input is a number, subtracts 1 and returns it.
 * - If it's an object or array, returns its size using `countObj`.
 * - Otherwise, returns 0.
 *
 * @param {*} obj - The input to validate and process.
 * @returns {number} - The resulting total based on the input type.
 *
 * @example
 * validateTotal(5); // 4
 * validateTotal([1, 2, 3]); // 3
 * validateTotal({ a: 1, b: 2 }); // 2
 * validateTotal('invalid'); // 0
 */
function validateTotal(obj) {
  // Get Total
  var newTotal = 0;
  if (typeof obj !== 'number') {
    if (objType(obj, 'object') || Array.isArray(obj)) newTotal = countObj(obj);
  } else newTotal = obj - 1;
  // Insert New Total
  return newTotal;
}
/**
 * Performs a structured validation on a given object and returns a confirmation result.
 *
 * - Confirms validity if `obj.data` is an object, array, or number.
 * - Also confirms if `obj.type` is `'while'`, and `obj.while` is defined, and `obj.checker` is a function.
 *
 * @param {import("../index.mjs").forPromiseIteration} obj - The input object to validate.
 * @returns {{ confirmed: boolean, type?: string }} - Returns an object with a `confirmed` boolean.
 *   If a "while" validation is detected, includes `type: 'while'`.
 *
 * @example
 * superValidator({ data: [1, 2, 3] }); // { confirmed: true }
 * superValidator({ type: 'while', while: true, checker: () => true }); // { confirmed: true, type: 'while' }
 * superValidator({}); // { confirmed: false }
 */
function superValidator(obj) {
  // Start Module
  /**  @type {{ confirmed: boolean, type?: string }} */
  var result = {
    confirmed: false
  };
  // Normal
  if (
  // Main Type
  objType(obj, 'object') && (
  // Object
  objType(obj.data, 'object') ||
  // Array
  Array.isArray(obj.data) ||
  // Number
  typeof obj.data === 'number')) result.confirmed = true;
  // Type
  else if (typeof obj.type === 'string') {
    // While
    if (
    // Confirm Type
    obj.type === 'while' &&
    // Not Empty
    typeof obj["while"] !== 'undefined' &&
    // Detect Function
    typeof obj.checker === 'function') {
      result.confirmed = true;
      result.type = 'while';
    }
  }
  // Complete
  return result;
}
/**
 * Checks the type of a given object or returns its type as a string.
 *
 * @param {*} obj - The object to check or identify.
 * @param {string} [type] - Optional. If provided, checks whether the object matches this type (e.g., "object", "array", "string").
 * @returns {boolean|string|null} - Returns `true` if the type matches, `false` if not,
 *                                   the type string if no type is provided, or `null` if the object is `undefined`.
 *
 * @example
 * objType([], 'array'); // true
 * objType({}, 'object'); // true
 * objType('hello'); // "string"
 * objType(undefined); // null
 */
function objType(obj, type) {
  // Is Defined
  if (typeof obj !== 'undefined') {
    // Get Obj Type
    var result = Object.prototype.toString.call(obj).toLowerCase();
    // Check Obj Type
    if (typeof type === 'string') {
      if (result === "[object ".concat(type, "]")) return true;
      return false;
    }
    // Send Result
    return result.substring(8, result.length - 1);
  }
  // Nope
  return null;
}
/**
 * Counts the number of elements in an array or the number of properties in an object.
 *
 * @param {*} obj - The array or object to count.
 * @returns {number} - The count of items (array elements or object keys), or `0` if the input is neither an array nor an object.
 *
 * @example
 * countObj([1, 2, 3]); // 3
 * countObj({ a: 1, b: 2 }); // 2
 * countObj('not an object'); // 0
 */
function countObj(obj) {
  // Is Array
  if (Array.isArray(obj)) return obj.length;
  // Object
  if (objType(obj, 'object')) return Object.keys(obj).length;
  // Nothing
  return 0;
}

},{}],96:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],97:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],98:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = exports.utob = exports.toUint8Array = exports.toBase64 = exports.isValid = exports.fromUint8Array = exports.fromBase64 = exports.extendUint8Array = exports.extendString = exports.extendBuiltins = exports.encodeURL = exports.encodeURI = exports.encode = exports.decode = exports.btou = exports.btoaPolyfill = exports.btoa = exports.atobPolyfill = exports.atob = exports.VERSION = exports.Base64 = void 0;
/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
var version = exports.version = '3.7.8';
/**
 * @deprecated use lowercase `version`.
 */
var VERSION = exports.VERSION = version;
var _hasBuffer = typeof Buffer === 'function';
var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = function (a) {
  var tab = {};
  a.forEach(function (c, i) {
    return tab[c] = i;
  });
  return tab;
}(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === 'function' ? Uint8Array.from.bind(Uint8Array) : function (it) {
  return new Uint8Array(Array.prototype.slice.call(it, 0));
};
var _mkUriSafe = function _mkUriSafe(src) {
  return src.replace(/=/g, '').replace(/[+\/]/g, function (m0) {
    return m0 == '+' ? '-' : '_';
  });
};
var _tidyB64 = function _tidyB64(s) {
  return s.replace(/[^A-Za-z0-9\+\/]/g, '');
};
/**
 * polyfill version of `btoa`
 */
var btoaPolyfill = exports.btoaPolyfill = function btoaPolyfill(bin) {
  // console.log('polyfilled');
  var u32,
    c0,
    c1,
    c2,
    asc = '';
  var pad = bin.length % 3;
  for (var i = 0; i < bin.length;) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError('invalid character found');
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
var _btoa = exports.btoa = typeof btoa === 'function' ? function (bin) {
  return btoa(bin);
} : _hasBuffer ? function (bin) {
  return Buffer.from(bin, 'binary').toString('base64');
} : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? function (u8a) {
  return Buffer.from(u8a).toString('base64');
} : function (u8a) {
  // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
  var maxargs = 0x1000;
  var strs = [];
  for (var i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(''));
};
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 Â§5
 * @returns {string} Base64 string
 */
var fromUint8Array = exports.fromUint8Array = function fromUint8Array(u8a) {
  var urlsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
};
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
var cb_utob = function cb_utob(c) {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
  } else {
    var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
    return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
var utob = exports.utob = function utob(u) {
  return u.replace(re_utob, cb_utob);
};
//
var _encode = _hasBuffer ? function (s) {
  return Buffer.from(s, 'utf8').toString('base64');
} : _TE ? function (s) {
  return _fromUint8Array(_TE.encode(s));
} : function (s) {
  return _btoa(utob(s));
};
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
var encode = exports.encode = exports.toBase64 = function encode(src) {
  var urlsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
};
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 Â§5.
 * @returns {string} Base64 string
 */
var encodeURI = exports.encodeURL = exports.encodeURI = function encodeURI(src) {
  return encode(src, true);
};
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = function cb_btou(cccc) {
  switch (cccc.length) {
    case 4:
      var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),
        offset = cp - 0x10000;
      return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);
    case 3:
      return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
    default:
      return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
  }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
var btou = exports.btou = function btou(b) {
  return b.replace(re_btou, cb_btou);
};
/**
 * polyfill version of `atob`
 */
var atobPolyfill = exports.atobPolyfill = function atobPolyfill(asc) {
  // console.log('polyfilled');
  asc = asc.replace(/\s+/g, '');
  if (!b64re.test(asc)) throw new TypeError('malformed base64.');
  asc += '=='.slice(2 - (asc.length & 3));
  var u24, r1, r2;
  var binArray = []; // use array to avoid minor gc in loop
  for (var i = 0; i < asc.length;) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    if (r1 === 64) {
      binArray.push(_fromCC(u24 >> 16 & 255));
    } else if (r2 === 64) {
      binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
    } else {
      binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
    }
  }
  return binArray.join('');
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
var _atob = exports.atob = typeof atob === 'function' ? function (asc) {
  return atob(_tidyB64(asc));
} : _hasBuffer ? function (asc) {
  return Buffer.from(asc, 'base64').toString('binary');
} : atobPolyfill;
//
var _toUint8Array = _hasBuffer ? function (a) {
  return _U8Afrom(Buffer.from(a, 'base64'));
} : function (a) {
  return _U8Afrom(_atob(a).split('').map(function (c) {
    return c.charCodeAt(0);
  }));
};
/**
 * converts a Base64 string to a Uint8Array.
 */
var toUint8Array = exports.toUint8Array = function toUint8Array(a) {
  return _toUint8Array(_unURI(a));
};
//
var _decode = _hasBuffer ? function (a) {
  return Buffer.from(a, 'base64').toString('utf8');
} : _TD ? function (a) {
  return _TD.decode(_toUint8Array(a));
} : function (a) {
  return btou(_atob(a));
};
var _unURI = function _unURI(a) {
  return _tidyB64(a.replace(/[-_]/g, function (m0) {
    return m0 == '-' ? '+' : '/';
  }));
};
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
var decode = exports.decode = exports.fromBase64 = function decode(src) {
  return _decode(_unURI(src));
};
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
var isValid = exports.isValid = function isValid(src) {
  if (typeof src !== 'string') return false;
  var s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
var _noEnum = function _noEnum(v) {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
/**
 * extend String.prototype with relevant methods
 */
var extendString = exports.extendString = function extendString() {
  var _add = function _add(name, body) {
    return Object.defineProperty(String.prototype, name, _noEnum(body));
  };
  _add('fromBase64', function () {
    return decode(this);
  });
  _add('toBase64', function (urlsafe) {
    return encode(this, urlsafe);
  });
  _add('toBase64URI', function () {
    return encode(this, true);
  });
  _add('toBase64URL', function () {
    return encode(this, true);
  });
  _add('toUint8Array', function () {
    return toUint8Array(this);
  });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
var extendUint8Array = exports.extendUint8Array = function extendUint8Array() {
  var _add = function _add(name, body) {
    return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  };
  _add('toBase64', function (urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add('toBase64URI', function () {
    return fromUint8Array(this, true);
  });
  _add('toBase64URL', function () {
    return fromUint8Array(this, true);
  });
};
/**
 * extend Builtin prototypes with relevant methods
 */
var extendBuiltins = exports.extendBuiltins = function extendBuiltins() {
  extendString();
  extendUint8Array();
};
var gBase64 = exports.Base64 = {
  version: version,
  VERSION: VERSION,
  atob: _atob,
  atobPolyfill: atobPolyfill,
  btoa: _btoa,
  btoaPolyfill: btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode: encode,
  encodeURI: encodeURI,
  encodeURL: encodeURI,
  utob: utob,
  btou: btou,
  decode: decode,
  isValid: isValid,
  fromUint8Array: fromUint8Array,
  toUint8Array: toUint8Array,
  extendString: extendString,
  extendUint8Array: extendUint8Array,
  extendBuiltins: extendBuiltins
};
// makecjs:CUT //

// and finally,

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":67}],99:[function(require,module,exports){
((t,n)=>{"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).JSONRepair={})})(this,function(t){class y extends Error{constructor(t,n){super("".concat(t," at position ").concat(n)),this.position=n}}let e=32,r=10,i=9,f=13,a=160,h=8192,$=8202,O=8239,N=8287,J=12288;function S(t){return"0"<=t&&t<="9"}function j(t){return",:[]/{}()\n+".includes(t)}function k(t){return"a"<=t&&t<="z"||"A"<=t&&t<="Z"||"_"===t||"$"===t}function C(t){return"a"<=t&&t<="z"||"A"<=t&&t<="Z"||"_"===t||"$"===t||"0"<=t&&t<="9"}let m=/^(http|https|ftp|mailto|file|data|irc):\/\/$/,z=/^[A-Za-z0-9-._~:/?#@!$&'()*+;=]$/;function E(t){return",[]/{}\n+".includes(t)}function I(t){return _(t)||n.test(t)}let n=/^[[{\w-]$/;function T(t,n){t=t.charCodeAt(n);return t===e||t===r||t===i||t===f}function Z(t,n){t=t.charCodeAt(n);return t===e||t===i||t===f}function _(t){return F(t)||U(t)}function F(t){return'"'===t||"â"===t||"â"===t}function R(t){return'"'===t}function U(t){return"'"===t||"â"===t||"â"===t||"`"===t||"Â´"===t}function q(t){return"'"===t}function B(t,n,e){e=2<arguments.length&&void 0!==e&&e,n=t.lastIndexOf(n);return-1!==n?t.substring(0,n)+(e?"":t.substring(n+1)):t}function D(t,n){let e=t.length;if(!T(t,e-1))return t+n;for(;T(t,e-1);)e--;return t.substring(0,e)+n+t.substring(e)}let G={"\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},H={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};t.JSONRepairError=y,t.jsonrepair=function(g){let d=0,b="";if(n(),!f())throw new y("Unexpected end of json string",g.length);n();var t=u(",");if(t&&v(),I(g[d])&&/[,\n][ \t\r]*$/.test(b)){t||(b=D(b,","));{let t=!0,n=!0;for(;n;)t?t=!1:u(",")||(b=D(b,",")),n=f();n||(b=B(b,",")),b="[\n".concat(b,"\n]")}}else t&&(b=B(b,","));for(;"}"===g[d]||"]"===g[d];)d++,v();if(d>=g.length)return b;throw new y("Unexpected character ".concat(JSON.stringify(g[d])),d);function f(){v();var t=(()=>{if("{"!==g[d])return!1;{b+="{",d++,v(),p(",")&&v();let n=!0;for(;d<g.length&&"}"!==g[d];){let t;if(n?(t=!0,n=!1):((t=u(","))||(b=D(b,",")),v()),o(),!(w()||l(!0))){"}"===g[d]||"{"===g[d]||"]"===g[d]||"["===g[d]||void 0===g[d]?b=B(b,","):(()=>{throw new y("Object key expected",d)})();break}v();var e=u(":"),r=d>=g.length,i=(e||(I(g[d])||r?b=D(b,":"):s()),f());i||(e||r?b+="null":s())}return"}"===g[d]?(b+="}",d++):b=D(b,"}"),!0}})()||(()=>{if("["!==g[d])return!1;{b+="[",d++,v(),p(",")&&v();let t=!0;for(;d<g.length&&"]"!==g[d];){t?t=!1:u(",")||(b=D(b,",")),o();var n=f();if(!n){b=B(b,",");break}}return"]"===g[d]?(b+="]",d++):b=D(b,"]"),!0}})()||w()||(()=>{var t,n,e=d;if("-"===g[d]){if(d++,i())return c(e),!0;if(!S(g[d]))return d=e,!1}for(;S(g[d]);)d++;if("."===g[d]){if(d++,i())return c(e),!0;if(!S(g[d]))return d=e,!1;for(;S(g[d]);)d++}if("e"===g[d]||"E"===g[d]){if(d++,"-"!==g[d]&&"+"!==g[d]||d++,i())return c(e),!0;if(!S(g[d]))return d=e,!1;for(;S(g[d]);)d++}if(i()){if(d>e)return t=g.slice(e,d),n=/^0\d/.test(t),b+=n?'"'.concat(t,'"'):t,!0}else d=e;return!1})()||e("true","true")||e("false","false")||e("null","null")||e("True","true")||e("False","false")||e("None","null")||l(!1)||(()=>{if("/"===g[d]){var t=d;for(d++;d<g.length&&("/"!==g[d]||"\\"===g[d-1]);)d++;return d++,b+='"'.concat(g.substring(t,d),'"'),!0}})();return v(),t}function v(t){var n=!(0<arguments.length&&void 0!==t)||t;d;let e=r(n);for(;e=(e=(()=>{if("/"===g[d]&&"*"===g[d+1]){for(;d<g.length&&!((t,n)=>"*"===t[n]&&"/"===t[n+1])(g,d);)d++;d+=2}else{if("/"!==g[d]||"/"!==g[d+1])return!1;for(;d<g.length&&"\n"!==g[d];)d++}return!0})())&&r(n););d}function r(t){var n,e,r=t?T:Z;let i="";for(;;){if(r(g,d))i+=g[d];else{if(n=g,e=d,!((n=n.charCodeAt(e))===a||n>=h&&n<=$||n===O||n===N||n===J))break;i+=" "}d++}return 0<i.length&&(b+=i,!0)}function n(){if("```"===g.slice(d,d+3)){if(d+=3,k(g[d]))for(;d<g.length&&C(g[d]);)d++;v()}}function u(t){return g[d]===t&&(b+=g[d],d++,!0)}function p(t){return g[d]===t&&(d++,!0)}function o(){v(),"."===g[d]&&"."===g[d+1]&&"."===g[d+2]&&(d+=3,v(),p(","))}function w(t,n){var e=0<arguments.length&&void 0!==t&&t,r=1<arguments.length&&void 0!==n?n:-1;let i="\\"===g[d];if(i&&(d++,i=!0),_(g[d])){var f=R(g[d])?R:q(g[d])?q:U(g[d])?U:F,u=d,o=b.length;let n='"';for(d++;;){if(d>=g.length)return l=x(d-1),!e&&j(g.charAt(l))?(d=u,b=b.substring(0,o),w(!0)):(n=D(n,'"'),b+=n,!0);if(d===r)return n=D(n,'"'),b+=n,!0;if(f(g[d])){var l=d,c=n.length;if(n+='"',d++,b+=n,v(!1),e||d>=g.length||j(g[d])||_(g[d])||S(g[d]))return A(),!0;var s=x(l-1),a=g.charAt(s);if(","===a)return d=u,b=b.substring(0,o),w(!1,s);if(j(a))return d=u,b=b.substring(0,o),w(!0);b=b.substring(0,o),d=l+1,n="".concat(n.substring(0,c),"\\").concat(n.substring(c))}else{if(e&&E(g[d])){if(":"===g[d-1]&&m.test(g.substring(u+1,d+2)))for(;d<g.length&&z.test(g[d]);)n+=g[d],d++;return n=D(n,'"'),b+=n,A(),!0}if("\\"===g[d]){s=g.charAt(d+1);if(void 0!==H[s])n+=g.slice(d,d+2),d+=2;else if("u"===s){let t=2;for(;t<6&&/^[0-9A-Fa-f]$/.test(g[d+t]);)t++;if(6===t)n+=g.slice(d,d+6),d+=6;else{if(!(d+t>=g.length))throw a=void 0,a=g.slice(d,d+6),new y('Invalid unicode character "'.concat(a,'"'),d);d=g.length}}else n+=s,d+=2}else{var h,c=g.charAt(d);if('"'===c&&"\\"!==g[d-1])n+="\\".concat(c);else if("\n"===(h=c)||"\r"===h||"\t"===h||"\b"===h||"\f"===h)n+=G[c];else{if(!(" "<=c))throw h=void 0,h=c,new y("Invalid character ".concat(JSON.stringify(h)),d);n+=c}d++}}i&&p("\\")}}return!1}function A(){let t=!1;for(v();"+"===g[d];){t=!0,d++,v();var n=(b=B(b,'"',!0)).length,e=w();b=e?(e=b,n=n,r=1,e.substring(0,n)+e.substring(n+r)):D(b,'"')}var r;t}function e(t,n){return g.slice(d,d+t.length)===t&&(b+=n,d+=t.length,!0)}function l(t){var n=d;if(k(g[d])){for(;d<g.length&&C(g[d]);)d++;let t=d;for(;T(g,t);)t++;if("("===g[t])return d=t+1,f(),")"===g[d]&&(d++,";"===g[d])&&d++,!0}for(;d<g.length&&!E(g[d])&&!_(g[d])&&(!t||":"!==g[d]);)d++;if(":"===g[d-1]&&m.test(g.substring(n,d+2)))for(;d<g.length&&z.test(g[d]);)d++;if(d>n){for(;T(g,d-1)&&0<d;)d--;n=g.slice(n,d);return b+="undefined"===n?"null":JSON.stringify(n),'"'===g[d]&&d++,!0}}function x(t){let n=t;for(;0<n&&T(g,n);)n--;return n}function i(){return d>=g.length||j(g[d])||T(g,d)}function c(t){b+="".concat(g.slice(t,d),"0")}function s(){throw new y("Colon expected",d)}}});
},{}],100:[function(require,module,exports){
"use strict";

/*!
 * @license :jsstore - V4.9.0 - 16/12/2024
 * https://github.com/ujjwalguptaofficial/JsStore
 * Copyright (c) 2024 @Ujjwal Gupta; Licensed MIT
 */
/******/
(function () {
  // webpackBootstrap
  /******/
  "use strict";

  /******/ // The require scope
  /******/
  var __webpack_require__ = {};
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/define property getters */
  /******/
  (function () {
    /******/ // define getter functions for harmony exports
    /******/__webpack_require__.d = function (exports, definition) {
      /******/for (var key in definition) {
        /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          /******/Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/
  (function () {
    /******/__webpack_require__.o = function (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/
  (function () {
    /******/ // define __esModule on exports
    /******/__webpack_require__.r = function (exports) {
      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};
  // ESM COMPAT FLAG
  __webpack_require__.r(__webpack_exports__);

  // EXPORTS
  __webpack_require__.d(__webpack_exports__, {
    API: function API() {
      return /* reexport */_API;
    },
    CONNECTION_STATUS: function CONNECTION_STATUS() {
      return /* reexport */_CONNECTION_STATUS;
    },
    Connection: function Connection() {
      return /* reexport */_Connection;
    },
    DATA_TYPE: function DATA_TYPE() {
      return /* reexport */_DATA_TYPE;
    },
    ERROR_TYPE: function ERROR_TYPE() {
      return /* reexport */_ERROR_TYPE;
    },
    EVENT: function EVENT() {
      return /* reexport */_EVENT;
    },
    IDB_MODE: function IDB_MODE() {
      return /* reexport */_IDB_MODE;
    },
    OCCURENCE: function OCCURENCE() {
      return /* reexport */_OCCURENCE;
    },
    QUERY_OPTION: function QUERY_OPTION() {
      return /* reexport */_QUERY_OPTION;
    },
    WORKER_STATUS: function WORKER_STATUS() {
      return /* reexport */_WORKER_STATUS;
    },
    forObj: function forObj() {
      return /* reexport */_forObj;
    },
    promise: function promise() {
      return /* reexport */_promise;
    },
    promiseAll: function promiseAll() {
      return /* reexport */_promiseAll;
    },
    promiseResolve: function promiseResolve() {
      return /* reexport */_promiseResolve;
    }
  });
  ; // ./src/main/log_helper.ts
  var LogHelper = /** @class */function () {
    function LogHelper(type, info) {
      this.type = type;
      this._info = info;
      this.message = this.getMsg();
    }
    LogHelper.prototype["throw"] = function () {
      throw this;
    };
    LogHelper.prototype.log = function (msg) {
      if (this.status) {
        console.log(msg);
      }
    };
    LogHelper.prototype.logError = function () {
      console.error(this.get());
    };
    LogHelper.prototype.logWarning = function () {
      console.warn(this.get());
    };
    LogHelper.prototype.get = function () {
      return {
        message: this.message,
        type: this.type
      };
    };
    LogHelper.prototype.getMsg = function () {
      var errMsg;
      switch (this.type) {
        default:
          errMsg = this.message;
          break;
      }
      return errMsg;
    };
    return LogHelper;
  }();
  ; // ./src/common/enums.ts
  var _ERROR_TYPE = {
    InvalidUpdateColumn: "invalid_update_column",
    UndefinedColumn: "undefined_column",
    UndefinedValue: "undefined_value",
    UndefinedColumnName: "undefined_column_name",
    UndefinedDbName: "undefined_database_name",
    UndefinedColumnValue: "undefined_column_value",
    NotArray: "not_array",
    NoValueSupplied: "no_value_supplied",
    ColumnNotExist: "column_not_exist",
    NoIndexFound: "no_index_found",
    InvalidOp: "invalid_operator",
    NullValue: "null_value",
    WrongDataType: "wrong_data_type",
    TableNotExist: "table_not_exist",
    DbNotExist: "db_not_exist",
    ConnectionAborted: "connection_aborted",
    ConnectionClosed: "connection_closed",
    NotObject: "not_object",
    InvalidConfig: "invalid_config",
    DbBlocked: "Db_blocked",
    IndexedDbNotSupported: "indexeddb_not_supported",
    NullValueInWhere: "null_value_in_where",
    InvalidJoinQuery: 'invalid_join_query',
    InvalidQuery: 'invalid_query',
    ImportScriptsFailed: 'import_scripts_failed',
    MethodNotExist: 'method_not_exist',
    Unknown: "unknown",
    InvalidMiddleware: "invalid_middleware",
    InvalidOrderQuery: 'invalid_order_query',
    InvalidGroupQuery: 'invalid_group_query',
    NoPrimaryKey: 'no_primary_key'
  };
  var _WORKER_STATUS;
  (function (WORKER_STATUS) {
    WORKER_STATUS["Registered"] = "registerd";
    WORKER_STATUS["Failed"] = "failed";
    WORKER_STATUS["NotStarted"] = "not_started";
  })(_WORKER_STATUS || (_WORKER_STATUS = {}));
  var _DATA_TYPE;
  (function (DATA_TYPE) {
    DATA_TYPE["String"] = "string";
    DATA_TYPE["Object"] = "object";
    DATA_TYPE["Array"] = "array";
    DATA_TYPE["Number"] = "number";
    DATA_TYPE["Boolean"] = "boolean";
    DATA_TYPE["Null"] = "null";
    DATA_TYPE["DateTime"] = "date_time";
  })(_DATA_TYPE || (_DATA_TYPE = {}));
  var _API;
  (function (API) {
    API["InitDb"] = "init_db";
    API["MapGet"] = "map_get";
    API["MapSet"] = "map_set";
    API["MapHas"] = "map_has";
    API["MapDelete"] = "map_delete";
    API["Select"] = "select";
    API["Insert"] = "insert";
    API["Update"] = "update";
    API["Remove"] = "remove";
    API["OpenDb"] = "open_db";
    API["Clear"] = "clear";
    API["DropDb"] = "drop_db";
    API["Count"] = "count";
    API["ChangeLogStatus"] = "change_log_status";
    API["Terminate"] = "terminate";
    API["Transaction"] = "transaction";
    API["CloseDb"] = "close_db";
    API["Union"] = "union";
    API["Intersect"] = "intersect";
    API["ImportScripts"] = "import_scripts";
    API["Middleware"] = "middleware";
  })(_API || (_API = {}));
  var _EVENT;
  (function (EVENT) {
    EVENT["RequestQueueEmpty"] = "requestQueueEmpty";
    EVENT["RequestQueueFilled"] = "requestQueueFilled";
    EVENT["Upgrade"] = "upgrade";
    EVENT["Create"] = "create";
    EVENT["Open"] = "open";
  })(_EVENT || (_EVENT = {}));
  var _QUERY_OPTION;
  (function (QUERY_OPTION) {
    QUERY_OPTION["Where"] = "where";
    QUERY_OPTION["Like"] = "like";
    QUERY_OPTION["Regex"] = "regex";
    QUERY_OPTION["In"] = "in";
    QUERY_OPTION["Equal"] = "=";
    QUERY_OPTION["Between"] = "-";
    QUERY_OPTION["GreaterThan"] = ">";
    QUERY_OPTION["LessThan"] = "<";
    QUERY_OPTION["GreaterThanEqualTo"] = ">=";
    QUERY_OPTION["LessThanEqualTo"] = "<=";
    QUERY_OPTION["NotEqualTo"] = "!=";
    QUERY_OPTION["Aggregate"] = "aggregate";
    QUERY_OPTION["Max"] = "max";
    QUERY_OPTION["Min"] = "min";
    QUERY_OPTION["Avg"] = "avg";
    QUERY_OPTION["Count"] = "count";
    QUERY_OPTION["Sum"] = "sum";
    QUERY_OPTION["List"] = "list";
    QUERY_OPTION["Or"] = "or";
    QUERY_OPTION["Skip"] = "skip";
    QUERY_OPTION["Limit"] = "limit";
    QUERY_OPTION["And"] = "and";
    QUERY_OPTION["IgnoreCase"] = "ignoreCase";
    QUERY_OPTION["Then"] = "then";
  })(_QUERY_OPTION || (_QUERY_OPTION = {}));
  var _IDB_MODE;
  (function (IDB_MODE) {
    IDB_MODE["ReadOnly"] = "readonly";
    IDB_MODE["ReadWrite"] = "readwrite";
  })(_IDB_MODE || (_IDB_MODE = {}));
  var _OCCURENCE;
  (function (OCCURENCE) {
    OCCURENCE["First"] = "f";
    OCCURENCE["Last"] = "l";
    OCCURENCE["Any"] = "a";
  })(_OCCURENCE || (_OCCURENCE = {}));
  var _CONNECTION_STATUS;
  (function (CONNECTION_STATUS) {
    CONNECTION_STATUS["Connected"] = "connected";
    CONNECTION_STATUS["Closed"] = "closed";
    CONNECTION_STATUS["NotStarted"] = "not_started";
    CONNECTION_STATUS["UnableToStart"] = "unable_to_start";
    CONNECTION_STATUS["ClosedByJsStore"] = "closed_by_jsstore";
  })(_CONNECTION_STATUS || (_CONNECTION_STATUS = {}));
  ; // ./src/common/utils/promise.ts
  var _promise = function _promise(cb) {
    return new Promise(cb);
  };
  ; // ./src/common/utils/promise_resolve.ts
  var _promiseResolve = function _promiseResolve(value) {
    return Promise.resolve(value);
  };
  ; // ./src/main/event_bus.ts
  var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var EventBus = /** @class */function () {
    function EventBus(ctx) {
      this._events = {};
      this._ctx = ctx;
    }
    EventBus.prototype.on = function (event, cb) {
      if (this._events[event] == null) {
        this._events[event] = [];
      }
      this._events[event].push(cb);
      return this;
    };
    EventBus.prototype.off = function (event, cb) {
      if (this._events[event]) {
        if (cb) {
          var index = this._events[event].indexOf(cb);
          this._events[event].splice(index, 1);
        } else {
          this._events[event] = [];
        }
      }
    };
    EventBus.prototype.emit = function (event) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[event] || [];
      var index = 0;
      var length = events.length;
      var results = [];
      var callMethod = function callMethod() {
        var eventCb = events[index++];
        if (eventCb) {
          var result = eventCb.call.apply(eventCb, __spreadArray([_this._ctx], args, false));
          return result && result.then ? result : Promise.resolve(result);
        }
      };
      return new Promise(function (res) {
        var _checkAndCall = function checkAndCall() {
          if (index < length) {
            callMethod().then(function (result) {
              results.push(result);
              _checkAndCall();
            });
          } else {
            res(results);
          }
        };
        _checkAndCall();
      });
    };
    EventBus.prototype.destroy = function () {
      this._events = null;
      this._ctx = null;
    };
    return EventBus;
  }();
  ; // ./src/main/connection_helper.ts

  var ConnectionHelper = /** @class */function () {
    function ConnectionHelper(worker) {
      this.isConOpened_ = false;
      this.isDbIdle_ = true;
      this.requestQueue_ = [];
      this.isCodeExecuting_ = false;
      this.inactivityTimer_ = -1000;
      this.middlewares = [];
      this.eventBus_ = new EventBus(this);
      // these apis have special permissions. These apis dont wait for database open.
      this.whiteListApi_ = [_API.InitDb, _API.OpenDb, _API.MapGet, _API.MapSet, _API.MapHas, _API.MapDelete, _API.ChangeLogStatus, _API.Terminate, _API.DropDb];
      this.isWorker = true;
      this.logger = new LogHelper(null);
      if (worker) {
        this.worker_ = worker;
        this.worker_.onmessage = this.onMessageFromWorker_.bind(this);
      } else {
        this.isWorker = false;
        this.initQueryManager_();
      }
    }
    Object.defineProperty(ConnectionHelper.prototype, "jsstoreWorker", {
      get: function get() {
        return this.$worker || self['JsStoreWorker'];
      },
      enumerable: false,
      configurable: true
    });
    ConnectionHelper.prototype.initQueryManager_ = function () {
      var workerRef = this.jsstoreWorker;
      if (workerRef) {
        this.queryManager = new workerRef.QueryManager(this.processFinishedQuery_.bind(this));
      }
    };
    ConnectionHelper.prototype.onMessageFromWorker_ = function (msg) {
      this.processFinishedQuery_(msg.data);
    };
    ConnectionHelper.prototype.processFinishedQuery_ = function (message) {
      var finishedRequest = this.requestQueue_.shift();
      if (finishedRequest) {
        this.logger.log("request ".concat(finishedRequest.name, " finished"));
        if (message.error) {
          finishedRequest.onError(message.error);
        } else {
          switch (finishedRequest.name) {
            case _API.OpenDb:
            case _API.InitDb:
              this.isConOpened_ = true;
              break;
            case _API.Terminate:
              this.isConOpened_ = false;
              if (this.isWorker === true) {
                this.worker_.terminate();
              }
            case _API.DropDb:
              this.isConOpened_ = false;
              this.requestQueue_ = [];
              this.isDbIdle_ = true;
              break;
            case _API.CloseDb:
              this.isDbIdle_ = true;
              this.eventBus_.emit(_EVENT.RequestQueueEmpty, []);
              if (this.requestQueue_.length > 0) {
                this.openDb_(false);
              }
              break;
          }
          finishedRequest.onSuccess(message.result);
        }
        this.isCodeExecuting_ = false;
        this.executeQry_();
      }
    };
    ConnectionHelper.prototype.openDb_ = function (execute) {
      if (execute === void 0) {
        execute = true;
      }
      var request = {
        name: _API.OpenDb,
        query: {
          name: this.database.name,
          version: this.database.version
        },
        onSuccess: function onSuccess() {},
        onError: function onError(err) {
          console.error(err);
        }
      };
      if (execute) {
        this.prcoessExecutionOfQry_(request, 0);
      } else {
        this.requestQueue_.splice(0, 0, request);
      }
    };
    ConnectionHelper.prototype.executeMiddleware_ = function (input) {
      var _this = this;
      return _promise(function (res) {
        var index = 0;
        var lastIndex = _this.middlewares.length - 1;
        var _callNextMiddleware = function callNextMiddleware() {
          if (index <= lastIndex) {
            var promiseResult = _this.middlewares[index++](input);
            if (!promiseResult || !promiseResult.then) {
              promiseResult = _promiseResolve(promiseResult);
            }
            promiseResult.then(function (_) {
              _callNextMiddleware();
            });
          } else {
            res();
          }
        };
        _callNextMiddleware();
      });
    };
    ConnectionHelper.prototype.callResultMiddleware = function (middlewares, result) {
      return _promise(function (res) {
        var index = 0;
        var lastIndex = middlewares.length - 1;
        var _callNextMiddleware2 = function callNextMiddleware() {
          if (index <= lastIndex) {
            var promiseResult = middlewares[index++](result);
            if (!promiseResult.then) {
              promiseResult = _promiseResolve(promiseResult);
            }
            promiseResult.then(function (modifiedResult) {
              result = modifiedResult;
              _callNextMiddleware2();
            });
          } else {
            res(result);
          }
        };
        _callNextMiddleware2();
      });
    };
    ConnectionHelper.prototype.pushApi = function (request) {
      var _this = this;
      if (true && !this.jsstoreWorker && !this.worker_) {
        throw new Error("JsStoreWorker not found. Either pass web worker or inject JsStore Worker.");
      }
      return new Promise(function (resolve, reject) {
        var middlewares = [];
        request.onResult = function (cb) {
          middlewares.push(function (result) {
            return cb(result);
          });
        };
        _this.executeMiddleware_(request).then(function () {
          request.onSuccess = function (result) {
            _this.callResultMiddleware(middlewares, result).then(function (modifiedResult) {
              resolve(modifiedResult);
            })["catch"](function (err) {
              request.onError(err);
            });
          };
          request.onError = function (err) {
            middlewares = [];
            reject(err);
          };
          if (_this.requestQueue_.length === 0) {
            _this.eventBus_.emit(_EVENT.RequestQueueFilled, []);
            if (_this.isDbIdle_ && _this.isConOpened_) {
              var isConnectionApi = [_API.InitDb, _API.CloseDb, _API.DropDb, _API.OpenDb, _API.Terminate].indexOf(request.name) >= 0;
              if (!isConnectionApi) {
                _this.openDb_();
              }
            }
            clearTimeout(_this.inactivityTimer_);
          }
          _this.prcoessExecutionOfQry_(request);
        })["catch"](reject);
      });
    };
    ConnectionHelper.prototype.prcoessExecutionOfQry_ = function (request, index) {
      this.isDbIdle_ = false;
      if (index != null) {
        this.requestQueue_.splice(index, 0, request);
      } else {
        this.requestQueue_.push(request);
      }
      this.logger.log("request pushed: " + request.name);
      this.executeQry_();
    };
    ConnectionHelper.prototype.executeQry_ = function () {
      var _this = this;
      var requestQueueLength = this.requestQueue_.length;
      if (!this.isCodeExecuting_ && requestQueueLength > 0) {
        if (this.isConOpened_ === true) {
          this.sendRequestToWorker_(this.requestQueue_[0]);
          return;
        }
        var allowedQueryIndex = this.requestQueue_.findIndex(function (item) {
          return _this.whiteListApi_.indexOf(item.name) >= 0;
        });
        // shift allowed query to zeroth index
        if (allowedQueryIndex >= 0) {
          this.requestQueue_.splice(0, 0, this.requestQueue_.splice(allowedQueryIndex, 1)[0]);
          this.sendRequestToWorker_(this.requestQueue_[0]);
        }
      } else if (requestQueueLength === 0 && this.isDbIdle_ === false && this.isConOpened_) {
        this.inactivityTimer_ = setTimeout(function () {
          _this.prcoessExecutionOfQry_({
            name: _API.CloseDb,
            onSuccess: function onSuccess() {},
            onError: function onError(err) {
              console.error(err);
            }
          });
        }, 100);
      }
    };
    ConnectionHelper.prototype.sendRequestToWorker_ = function (request) {
      this.isCodeExecuting_ = true;
      this.logger.log("request executing: " + request.name);
      var requestForWorker = {
        name: request.name,
        query: request.query
      };
      if (this.isWorker === true) {
        this.worker_.postMessage(requestForWorker);
      } else {
        this.queryManager.run(requestForWorker);
      }
    };
    return ConnectionHelper;
  }();
  ; // ./src/main/map.ts

  var JsStoreMap = /** @class */function () {
    function JsStoreMap(con) {
      this.con = con;
    }
    /**
     * Returns the value associated to the passed key, or undefined if there is none.
     *
     * @template T
     * @param {string} key
     * @return {*}
     * @memberof JsStoreMap
     */
    JsStoreMap.prototype.get = function (key) {
      return this.con['pushApi']({
        name: _API.MapGet,
        query: key
      });
    };
    /**
     * Returns a boolean indicating whether a value has been associated with the passed key in the MapStore or not.
     *
     * @param {string} key
     * @return {*}
     * @memberof JsStoreMap
     */
    JsStoreMap.prototype.has = function (key) {
      return this.con['pushApi']({
        name: _API.MapHas,
        query: key
      });
    };
    /**
     * Sets the value for the passed key in the map store
     *
     * @param {string} key
     * @param {*} value
     * @return {*}
     * @memberof JsStoreMap
     */
    JsStoreMap.prototype.set = function (key, value) {
      return this.con['pushApi']({
        name: _API.MapSet,
        query: {
          key: key,
          value: value
        }
      });
    };
    /**
     * delete the value by key in the map store
     *
     * @param {string} key
     * @return {*}
     * @memberof JsStoreMap
     */
    JsStoreMap.prototype["delete"] = function (key) {
      return this.con['pushApi']({
        name: _API.MapDelete,
        query: key
      });
    };
    return JsStoreMap;
  }();
  ; // ./src/main/connection.ts
  var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };
      return _extendStatics(d, b);
    };
    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      _extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var _Connection = /** @class */function (_super) {
    __extends(Connection, _super);
    function Connection(worker) {
      var _this = _super.call(this, worker) || this;
      /**
       * stores data in the key value format
       *
       * @memberof Connection
       */
      // tslint:disable-next-line
      _this.Map = new JsStoreMap(_this);
      return _this;
    }
    /**
     * initiate DataBase
     *
     * @param {IDataBase} dataBase
     * @returns
     * @memberof Connection
     */
    Connection.prototype.initDb = function (dataBase) {
      var _this = this;
      this.database = dataBase;
      return this.pushApi({
        name: _API.InitDb,
        query: dataBase
      }).then(function (result) {
        var promiseObj;
        var db = result.database;
        // db.tables = db.tables.filter(table => table.name !== 'JsStore_Meta');
        if (result.isCreated) {
          if (result.oldVersion) {
            promiseObj = _this.eventBus_.emit(_EVENT.Upgrade, db, result.oldVersion, result.newVersion);
          } else {
            promiseObj = _this.eventBus_.emit(_EVENT.Create, db);
          }
        }
        return (promiseObj || _promiseResolve()).then(function (_) {
          return _this.eventBus_.emit(_EVENT.Open, db);
        }).then(function (_) {
          return result.isCreated;
        });
      });
    };
    /**
     * drop dataBase
     *
     * @returns
     * @memberof Connection
     */
    Connection.prototype.dropDb = function () {
      return this.pushApi({
        name: _API.DropDb
      });
    };
    /**
     * select data from table
     *
     * @template T
     * @param {ISelectQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.select = function (query) {
      return this.pushApi({
        name: _API.Select,
        query: query
      });
    };
    /**
     * get no of record from table
     *
     * @param {ICountQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.count = function (query) {
      return this.pushApi({
        name: _API.Count,
        query: query
      });
    };
    /**
     * insert data into table
     *
     * @template T
     * @param {IInsertQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.insert = function (query) {
      return this.pushApi({
        name: _API.Insert,
        query: query
      });
    };
    /**
     * update data into table
     *
     * @param {IUpdateQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.update = function (query) {
      return this.pushApi({
        name: _API.Update,
        query: query
      });
    };
    /**
     * remove data from table
     *
     * @param {IRemoveQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.remove = function (query) {
      return this.pushApi({
        name: _API.Remove,
        query: query
      });
    };
    /**
     * delete all data from table
     *
     * @param {string} tableName
     * @returns
     * @memberof Connection
     */
    Connection.prototype.clear = function (tableName) {
      return this.pushApi({
        name: _API.Clear,
        query: tableName
      });
    };
    Object.defineProperty(Connection.prototype, "logStatus", {
      /**
       * set log status
       *
       * @param {boolean} status
       * @memberof Connection
       */
      set: function set(status) {
        this.logger.status = status;
        this.pushApi({
          name: _API.ChangeLogStatus,
          query: status
        });
      },
      enumerable: false,
      configurable: true
    });
    /**
     * open database
     *
     * @param {string} dbName
     * @returns
     * @memberof Connection
     */
    Connection.prototype.openDb = function (dbName, version) {
      var _this = this;
      return this.pushApi({
        name: _API.OpenDb,
        query: {
          version: version,
          name: dbName
        }
      }).then(function (dataBase) {
        _this.database = dataBase;
        return dataBase;
      });
    };
    /**
     * returns list of database created
     *
     * @returns
     * @memberof Connection
     */
    Connection.prototype.getDbList = function () {
      console.warn("Api getDbList is recommended to use for debugging only. Do not use in code.");
      return indexedDB.databases();
    };
    /**
     * get the value from keystore table
     *
     * @template T
     * @param {string} key
     * @returns
     * @memberof Connection
     */
    Connection.prototype.get = function (key) {
      console.warn("This API is obsolete, please use Map");
      return this.Map.get(key);
    };
    /**
     * set the value in keystore table
     *
     * @param {string} key
     * @param {*} value
     * @returns
     * @memberof Connection
     */
    Connection.prototype.set = function (key, value) {
      console.warn("This API is obsolete, please use Map");
      return this.Map.set(key, value);
    };
    /**
     * terminate the connection
     *
     * @returns
     * @memberof Connection
     */
    Connection.prototype.terminate = function () {
      return this.pushApi({
        name: _API.Terminate
      });
    };
    /**
     * execute transaction
     *
     * @template T
     * @param {ITransactionQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.transaction = function (query) {
      return this.pushApi({
        name: _API.Transaction,
        query: query
      });
    };
    Connection.prototype.on = function (event, eventCallBack) {
      this.eventBus_.on(event, eventCallBack);
    };
    Connection.prototype.off = function (event, eventCallBack) {
      this.eventBus_.off(event, eventCallBack);
    };
    Connection.prototype.union = function (query) {
      return this.pushApi({
        name: _API.Union,
        query: query
      });
    };
    Connection.prototype.intersect = function (query) {
      return this.pushApi({
        name: _API.Intersect,
        query: query
      });
    };
    Connection.prototype.addPlugin = function (plugin, params) {
      return plugin.setup(this, params);
    };
    Connection.prototype.addMiddleware = function (middleware, forWorker) {
      if (forWorker) {
        return this.pushApi({
          name: _API.Middleware,
          query: middleware
        });
      }
      this.middlewares.push(middleware);
      return Promise.resolve();
    };
    /**
     * import scripts in jsstore web worker.
     * Scripts method can be called using transaction api.
     *
     * @param {...string[]} urls
     * @returns
     * @memberof Connection
     */
    Connection.prototype.importScripts = function () {
      var urls = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        urls[_i] = arguments[_i];
      }
      return this.pushApi({
        name: _API.ImportScripts,
        query: urls
      });
    };
    return Connection;
  }(ConnectionHelper);
  ; // ./src/common/utils/promise_all.ts
  var _promiseAll = function _promiseAll(promises) {
    return Promise.all(promises);
  };
  ; // ./src/common/utils/for_obj.ts
  var _forObj = function _forObj(obj, cb) {
    for (var key in obj) {
      cb(key, obj[key]);
    }
  };
  ; // ./src/common/utils/index.ts

  ; // ./src/common/index.ts

  ; // ./src/main/index.ts

  module.exports = __webpack_exports__;
  /******/
})();

},{}],101:[function(require,module,exports){
/*! For license information please see jsstore.commonjs2.min.js.LICENSE.txt */
(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{API:()=>o,CONNECTION_STATUS:()=>p,Connection:()=>b,DATA_TYPE:()=>r,ERROR_TYPE:()=>l,EVENT:()=>i,IDB_MODE:()=>u,OCCURENCE:()=>a,QUERY_OPTION:()=>s,WORKER_STATUS:()=>n,forObj:()=>q,promise:()=>d,promiseAll:()=>v,promiseResolve:()=>f});var n,r,o,i,s,u,a,p,c=function(){function e(e,t){this.type=e,this._info=t,this.message=this.getMsg()}return e.prototype.throw=function(){throw this},e.prototype.log=function(e){this.status&&console.log(e)},e.prototype.logError=function(){console.error(this.get())},e.prototype.logWarning=function(){console.warn(this.get())},e.prototype.get=function(){return{message:this.message,type:this.type}},e.prototype.getMsg=function(){return this.type,this.message},e}(),l={InvalidUpdateColumn:"invalid_update_column",UndefinedColumn:"undefined_column",UndefinedValue:"undefined_value",UndefinedColumnName:"undefined_column_name",UndefinedDbName:"undefined_database_name",UndefinedColumnValue:"undefined_column_value",NotArray:"not_array",NoValueSupplied:"no_value_supplied",ColumnNotExist:"column_not_exist",NoIndexFound:"no_index_found",InvalidOp:"invalid_operator",NullValue:"null_value",WrongDataType:"wrong_data_type",TableNotExist:"table_not_exist",DbNotExist:"db_not_exist",ConnectionAborted:"connection_aborted",ConnectionClosed:"connection_closed",NotObject:"not_object",InvalidConfig:"invalid_config",DbBlocked:"Db_blocked",IndexedDbNotSupported:"indexeddb_not_supported",NullValueInWhere:"null_value_in_where",InvalidJoinQuery:"invalid_join_query",InvalidQuery:"invalid_query",ImportScriptsFailed:"import_scripts_failed",MethodNotExist:"method_not_exist",Unknown:"unknown",InvalidMiddleware:"invalid_middleware",InvalidOrderQuery:"invalid_order_query",InvalidGroupQuery:"invalid_group_query",NoPrimaryKey:"no_primary_key"};!function(e){e.Registered="registerd",e.Failed="failed",e.NotStarted="not_started"}(n||(n={})),function(e){e.String="string",e.Object="object",e.Array="array",e.Number="number",e.Boolean="boolean",e.Null="null",e.DateTime="date_time"}(r||(r={})),function(e){e.InitDb="init_db",e.MapGet="map_get",e.MapSet="map_set",e.MapHas="map_has",e.MapDelete="map_delete",e.Select="select",e.Insert="insert",e.Update="update",e.Remove="remove",e.OpenDb="open_db",e.Clear="clear",e.DropDb="drop_db",e.Count="count",e.ChangeLogStatus="change_log_status",e.Terminate="terminate",e.Transaction="transaction",e.CloseDb="close_db",e.Union="union",e.Intersect="intersect",e.ImportScripts="import_scripts",e.Middleware="middleware"}(o||(o={})),function(e){e.RequestQueueEmpty="requestQueueEmpty",e.RequestQueueFilled="requestQueueFilled",e.Upgrade="upgrade",e.Create="create",e.Open="open"}(i||(i={})),function(e){e.Where="where",e.Like="like",e.Regex="regex",e.In="in",e.Equal="=",e.Between="-",e.GreaterThan=">",e.LessThan="<",e.GreaterThanEqualTo=">=",e.LessThanEqualTo="<=",e.NotEqualTo="!=",e.Aggregate="aggregate",e.Max="max",e.Min="min",e.Avg="avg",e.Count="count",e.Sum="sum",e.List="list",e.Or="or",e.Skip="skip",e.Limit="limit",e.And="and",e.IgnoreCase="ignoreCase",e.Then="then"}(s||(s={})),function(e){e.ReadOnly="readonly",e.ReadWrite="readwrite"}(u||(u={})),function(e){e.First="f",e.Last="l",e.Any="a"}(a||(a={})),function(e){e.Connected="connected",e.Closed="closed",e.NotStarted="not_started",e.UnableToStart="unable_to_start",e.ClosedByJsStore="closed_by_jsstore"}(p||(p={}));var h,d=function(e){return new Promise(e)},f=function(e){return Promise.resolve(e)},_=function(){function e(e){this._events={},this._ctx=e}return e.prototype.on=function(e,t){return null==this._events[e]&&(this._events[e]=[]),this._events[e].push(t),this},e.prototype.off=function(e,t){if(this._events[e])if(t){var n=this._events[e].indexOf(t);this._events[e].splice(n,1)}else this._events[e]=[]},e.prototype.emit=function(e){for(var t=this,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];var o=this._events[e]||[],i=0,s=o.length,u=[];return new Promise((function(e){var r=function(){i<s?function(){var e=o[i++];if(e){var r=e.call.apply(e,function(e,t,n){if(n||2===arguments.length)for(var r,o=0,i=t.length;o<i;o++)!r&&o in t||(r||(r=Array.prototype.slice.call(t,0,o)),r[o]=t[o]);return e.concat(r||Array.prototype.slice.call(t))}([t._ctx],n,!1));return r&&r.then?r:Promise.resolve(r)}}().then((function(e){u.push(e),r()})):e(u)};r()}))},e.prototype.destroy=function(){this._events=null,this._ctx=null},e}(),y=function(){function e(e){this.isConOpened_=!1,this.isDbIdle_=!0,this.requestQueue_=[],this.isCodeExecuting_=!1,this.inactivityTimer_=-1e3,this.middlewares=[],this.eventBus_=new _(this),this.whiteListApi_=[o.InitDb,o.OpenDb,o.MapGet,o.MapSet,o.MapHas,o.MapDelete,o.ChangeLogStatus,o.Terminate,o.DropDb],this.isWorker=!0,this.logger=new c(null),e?(this.worker_=e,this.worker_.onmessage=this.onMessageFromWorker_.bind(this)):(this.isWorker=!1,this.initQueryManager_())}return Object.defineProperty(e.prototype,"jsstoreWorker",{get:function(){return this.$worker||self.JsStoreWorker},enumerable:!1,configurable:!0}),e.prototype.initQueryManager_=function(){var e=this.jsstoreWorker;e&&(this.queryManager=new e.QueryManager(this.processFinishedQuery_.bind(this)))},e.prototype.onMessageFromWorker_=function(e){this.processFinishedQuery_(e.data)},e.prototype.processFinishedQuery_=function(e){var t=this.requestQueue_.shift();if(t){if(this.logger.log("request ".concat(t.name," finished")),e.error)t.onError(e.error);else{switch(t.name){case o.OpenDb:case o.InitDb:this.isConOpened_=!0;break;case o.Terminate:this.isConOpened_=!1,!0===this.isWorker&&this.worker_.terminate();case o.DropDb:this.isConOpened_=!1,this.requestQueue_=[],this.isDbIdle_=!0;break;case o.CloseDb:this.isDbIdle_=!0,this.eventBus_.emit(i.RequestQueueEmpty,[]),this.requestQueue_.length>0&&this.openDb_(!1)}t.onSuccess(e.result)}this.isCodeExecuting_=!1,this.executeQry_()}},e.prototype.openDb_=function(e){void 0===e&&(e=!0);var t={name:o.OpenDb,query:{name:this.database.name,version:this.database.version},onSuccess:function(){},onError:function(e){console.error(e)}};e?this.prcoessExecutionOfQry_(t,0):this.requestQueue_.splice(0,0,t)},e.prototype.executeMiddleware_=function(e){var t=this;return d((function(n){var r=0,o=t.middlewares.length-1,i=function(){if(r<=o){var s=t.middlewares[r++](e);s&&s.then||(s=f(s)),s.then((function(e){i()}))}else n()};i()}))},e.prototype.callResultMiddleware=function(e,t){return d((function(n){var r=0,o=e.length-1,i=function(){if(r<=o){var s=e[r++](t);s.then||(s=f(s)),s.then((function(e){t=e,i()}))}else n(t)};i()}))},e.prototype.pushApi=function(e){var t=this;return new Promise((function(n,r){var s=[];e.onResult=function(e){s.push((function(t){return e(t)}))},t.executeMiddleware_(e).then((function(){e.onSuccess=function(r){t.callResultMiddleware(s,r).then((function(e){n(e)})).catch((function(t){e.onError(t)}))},e.onError=function(e){s=[],r(e)},0===t.requestQueue_.length&&(t.eventBus_.emit(i.RequestQueueFilled,[]),t.isDbIdle_&&t.isConOpened_&&([o.InitDb,o.CloseDb,o.DropDb,o.OpenDb,o.Terminate].indexOf(e.name)>=0||t.openDb_()),clearTimeout(t.inactivityTimer_)),t.prcoessExecutionOfQry_(e)})).catch(r)}))},e.prototype.prcoessExecutionOfQry_=function(e,t){this.isDbIdle_=!1,null!=t?this.requestQueue_.splice(t,0,e):this.requestQueue_.push(e),this.logger.log("request pushed: "+e.name),this.executeQry_()},e.prototype.executeQry_=function(){var e=this,t=this.requestQueue_.length;if(!this.isCodeExecuting_&&t>0){if(!0===this.isConOpened_)return void this.sendRequestToWorker_(this.requestQueue_[0]);var n=this.requestQueue_.findIndex((function(t){return e.whiteListApi_.indexOf(t.name)>=0}));n>=0&&(this.requestQueue_.splice(0,0,this.requestQueue_.splice(n,1)[0]),this.sendRequestToWorker_(this.requestQueue_[0]))}else 0===t&&!1===this.isDbIdle_&&this.isConOpened_&&(this.inactivityTimer_=setTimeout((function(){e.prcoessExecutionOfQry_({name:o.CloseDb,onSuccess:function(){},onError:function(e){console.error(e)}})}),100))},e.prototype.sendRequestToWorker_=function(e){this.isCodeExecuting_=!0,this.logger.log("request executing: "+e.name);var t={name:e.name,query:e.query};!0===this.isWorker?this.worker_.postMessage(t):this.queryManager.run(t)},e}(),m=function(){function e(e){this.con=e}return e.prototype.get=function(e){return this.con.pushApi({name:o.MapGet,query:e})},e.prototype.has=function(e){return this.con.pushApi({name:o.MapHas,query:e})},e.prototype.set=function(e,t){return this.con.pushApi({name:o.MapSet,query:{key:e,value:t}})},e.prototype.delete=function(e){return this.con.pushApi({name:o.MapDelete,query:e})},e}(),g=(h=function(e,t){return h=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},h(e,t)},function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}h(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}),b=function(e){function t(t){var n=e.call(this,t)||this;return n.Map=new m(n),n}return g(t,e),t.prototype.initDb=function(e){var t=this;return this.database=e,this.pushApi({name:o.InitDb,query:e}).then((function(e){var n,r=e.database;return e.isCreated&&(n=e.oldVersion?t.eventBus_.emit(i.Upgrade,r,e.oldVersion,e.newVersion):t.eventBus_.emit(i.Create,r)),(n||f()).then((function(e){return t.eventBus_.emit(i.Open,r)})).then((function(t){return e.isCreated}))}))},t.prototype.dropDb=function(){return this.pushApi({name:o.DropDb})},t.prototype.select=function(e){return this.pushApi({name:o.Select,query:e})},t.prototype.count=function(e){return this.pushApi({name:o.Count,query:e})},t.prototype.insert=function(e){return this.pushApi({name:o.Insert,query:e})},t.prototype.update=function(e){return this.pushApi({name:o.Update,query:e})},t.prototype.remove=function(e){return this.pushApi({name:o.Remove,query:e})},t.prototype.clear=function(e){return this.pushApi({name:o.Clear,query:e})},Object.defineProperty(t.prototype,"logStatus",{set:function(e){this.logger.status=e,this.pushApi({name:o.ChangeLogStatus,query:e})},enumerable:!1,configurable:!0}),t.prototype.openDb=function(e,t){var n=this;return this.pushApi({name:o.OpenDb,query:{version:t,name:e}}).then((function(e){return n.database=e,e}))},t.prototype.getDbList=function(){return console.warn("Api getDbList is recommended to use for debugging only. Do not use in code."),indexedDB.databases()},t.prototype.get=function(e){return console.warn("This API is obsolete, please use Map"),this.Map.get(e)},t.prototype.set=function(e,t){return console.warn("This API is obsolete, please use Map"),this.Map.set(e,t)},t.prototype.terminate=function(){return this.pushApi({name:o.Terminate})},t.prototype.transaction=function(e){return this.pushApi({name:o.Transaction,query:e})},t.prototype.on=function(e,t){this.eventBus_.on(e,t)},t.prototype.off=function(e,t){this.eventBus_.off(e,t)},t.prototype.union=function(e){return this.pushApi({name:o.Union,query:e})},t.prototype.intersect=function(e){return this.pushApi({name:o.Intersect,query:e})},t.prototype.addPlugin=function(e,t){return e.setup(this,t)},t.prototype.addMiddleware=function(e,t){return t?this.pushApi({name:o.Middleware,query:e}):(this.middlewares.push(e),Promise.resolve())},t.prototype.importScripts=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return this.pushApi({name:o.ImportScripts,query:e})},t}(y),v=function(e){return Promise.all(e)},q=function(e,t){for(var n in e)t(n,e[n])};module.exports=t})();

},{}],102:[function(require,module,exports){
(function (process){(function (){
"production"===process.env.NODE_ENV?module.exports=require("./jsstore.commonjs2.min.js"):module.exports=require("./jsstore.commonjs2.js");
}).call(this)}).call(this,require('_process'))
},{"./jsstore.commonjs2.js":100,"./jsstore.commonjs2.min.js":101,"_process":111}],103:[function(require,module,exports){
/**
 * marked v16.1.1 - a markdown parser
 * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */
(function(g,f){if(typeof exports=="object"&&typeof module<"u"){module.exports=f()}else if("function"==typeof define && define.amd){define("marked",f)}else {g["marked"]=f()}}(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this,function(){var exports={};var __exports=exports;var module={exports};
"use strict";var H=Object.defineProperty;var be=Object.getOwnPropertyDescriptor;var Re=Object.getOwnPropertyNames;var Oe=Object.prototype.hasOwnProperty;var Te=(a,e)=>{for(var t in e)H(a,t,{get:e[t],enumerable:!0})},we=(a,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Re(e))!Oe.call(a,r)&&r!==t&&H(a,r,{get:()=>e[r],enumerable:!(n=be(e,r))||n.enumerable});return a};var ye=a=>we(H({},"__esModule",{value:!0}),a);var dt={};Te(dt,{Hooks:()=>$,Lexer:()=>x,Marked:()=>A,Parser:()=>b,Renderer:()=>P,TextRenderer:()=>S,Tokenizer:()=>y,defaults:()=>O,getDefaults:()=>_,lexer:()=>ht,marked:()=>d,options:()=>it,parse:()=>pt,parseInline:()=>ut,parser:()=>ct,setOptions:()=>ot,use:()=>at,walkTokens:()=>lt});module.exports=ye(dt);function _(){return{async:!1,breaks:!1,extensions:null,gfm:!0,hooks:null,pedantic:!1,renderer:null,silent:!1,tokenizer:null,walkTokens:null}}var O=_();function N(a){O=a}var C={exec:()=>null};function h(a,e=""){let t=typeof a=="string"?a:a.source,n={replace:(r,i)=>{let s=typeof i=="string"?i:i.source;return s=s.replace(m.caret,"$1"),t=t.replace(r,s),n},getRegex:()=>new RegExp(t,e)};return n}var m={codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm,outputLinkReplace:/\\([\[\]])/g,indentCodeCompensation:/^(\s+)(?:```)/,beginningSpace:/^\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\n/g,tabCharGlobal:/\t/g,multipleSpaceGlobal:/\s+/g,blankLine:/^[ \t]*$/,doubleBlankLine:/\n[ \t]*\n[ \t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm,listReplaceTabs:/^\t+/,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\[[ xX]\] /,listReplaceTask:/^\[[ xX]\] +/,anyLine:/\n.*\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\||\| *$/g,tableRowBlankLine:/\n[ \t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i,endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/,unicodeAlphaNumeric:/[\p{L}\p{N}]/u,escapeTest:/[&<>"']/,escapeReplace:/[&<>"']/g,escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,caret:/(^|[^\[])\^/g,percentDecode:/%25/g,findPipe:/\|/g,splitPipe:/ \|/,slashPipe:/\\\|/g,carriageReturn:/\r\n|\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\S*/,endingNewline:/\n$/,listItemRegex:a=>new RegExp(`^( {0,3}${a})((?:[	 ][^\\n]*)?(?:\\n|$))`),nextBulletRegex:a=>new RegExp(`^ {0,${Math.min(3,a-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),hrRegex:a=>new RegExp(`^ {0,${Math.min(3,a-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),fencesBeginRegex:a=>new RegExp(`^ {0,${Math.min(3,a-1)}}(?:\`\`\`|~~~)`),headingBeginRegex:a=>new RegExp(`^ {0,${Math.min(3,a-1)}}#`),htmlBeginRegex:a=>new RegExp(`^ {0,${Math.min(3,a-1)}}<(?:[a-z].*>|!--)`,"i")},Pe=/^(?:[ \t]*(?:\n|$))+/,Se=/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,$e=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,I=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,_e=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,F=/(?:[*+-]|\d{1,9}[.)])/,ie=/^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,oe=h(ie).replace(/bull/g,F).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/\|table/g,"").getRegex(),Le=h(ie).replace(/bull/g,F).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/table/g,/ {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(),Q=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,Me=/^[^\n]+/,U=/(?!\s*\])(?:\\.|[^\[\]\\])+/,ze=h(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label",U).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),Ae=h(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,F).getRegex(),v="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",K=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,Ee=h("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))","i").replace("comment",K).replace("tag",v).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),ae=h(Q).replace("hr",I).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",v).getRegex(),Ce=h(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",ae).getRegex(),X={blockquote:Ce,code:Se,def:ze,fences:$e,heading:_e,hr:I,html:Ee,lheading:oe,list:Ae,newline:Pe,paragraph:ae,table:C,text:Me},se=h("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",I).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code","(?: {4}| {0,3}	)[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",v).getRegex(),Ie={...X,lheading:Le,table:se,paragraph:h(Q).replace("hr",I).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",se).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",v).getRegex()},Be={...X,html:h(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",K).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:C,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:h(Q).replace("hr",I).replace("heading",` *#{1,6} *[^
]`).replace("lheading",oe).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},qe=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,ve=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,le=/^( {2,}|\\)\n(?!\s*$)/,De=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,D=/[\p{P}\p{S}]/u,W=/[\s\p{P}\p{S}]/u,ue=/[^\s\p{P}\p{S}]/u,Ze=h(/^((?![*_])punctSpace)/,"u").replace(/punctSpace/g,W).getRegex(),pe=/(?!~)[\p{P}\p{S}]/u,Ge=/(?!~)[\s\p{P}\p{S}]/u,He=/(?:[^\s\p{P}\p{S}]|~)/u,Ne=/\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g,ce=/^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,je=h(ce,"u").replace(/punct/g,D).getRegex(),Fe=h(ce,"u").replace(/punct/g,pe).getRegex(),he="^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",Qe=h(he,"gu").replace(/notPunctSpace/g,ue).replace(/punctSpace/g,W).replace(/punct/g,D).getRegex(),Ue=h(he,"gu").replace(/notPunctSpace/g,He).replace(/punctSpace/g,Ge).replace(/punct/g,pe).getRegex(),Ke=h("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)","gu").replace(/notPunctSpace/g,ue).replace(/punctSpace/g,W).replace(/punct/g,D).getRegex(),Xe=h(/\\(punct)/,"gu").replace(/punct/g,D).getRegex(),We=h(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),Je=h(K).replace("(?:-->|$)","-->").getRegex(),Ve=h("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",Je).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),q=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,Ye=h(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label",q).replace("href",/<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),de=h(/^!?\[(label)\]\[(ref)\]/).replace("label",q).replace("ref",U).getRegex(),ke=h(/^!?\[(ref)\](?:\[\])?/).replace("ref",U).getRegex(),et=h("reflink|nolink(?!\\()","g").replace("reflink",de).replace("nolink",ke).getRegex(),J={_backpedal:C,anyPunctuation:Xe,autolink:We,blockSkip:Ne,br:le,code:ve,del:C,emStrongLDelim:je,emStrongRDelimAst:Qe,emStrongRDelimUnd:Ke,escape:qe,link:Ye,nolink:ke,punctuation:Ze,reflink:de,reflinkSearch:et,tag:Ve,text:De,url:C},tt={...J,link:h(/^!?\[(label)\]\((.*?)\)/).replace("label",q).getRegex(),reflink:h(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",q).getRegex()},j={...J,emStrongRDelimAst:Ue,emStrongLDelim:Fe,url:h(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,"i").replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/},nt={...j,br:h(le).replace("{2,}","*").getRegex(),text:h(j.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},B={normal:X,gfm:Ie,pedantic:Be},M={normal:J,gfm:j,breaks:nt,pedantic:tt};var rt={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},ge=a=>rt[a];function w(a,e){if(e){if(m.escapeTest.test(a))return a.replace(m.escapeReplace,ge)}else if(m.escapeTestNoEncode.test(a))return a.replace(m.escapeReplaceNoEncode,ge);return a}function V(a){try{a=encodeURI(a).replace(m.percentDecode,"%")}catch{return null}return a}function Y(a,e){let t=a.replace(m.findPipe,(i,s,o)=>{let l=!1,u=s;for(;--u>=0&&o[u]==="\\";)l=!l;return l?"|":" |"}),n=t.split(m.splitPipe),r=0;if(n[0].trim()||n.shift(),n.length>0&&!n.at(-1)?.trim()&&n.pop(),e)if(n.length>e)n.splice(e);else for(;n.length<e;)n.push("");for(;r<n.length;r++)n[r]=n[r].trim().replace(m.slashPipe,"|");return n}function z(a,e,t){let n=a.length;if(n===0)return"";let r=0;for(;r<n;){let i=a.charAt(n-r-1);if(i===e&&!t)r++;else if(i!==e&&t)r++;else break}return a.slice(0,n-r)}function fe(a,e){if(a.indexOf(e[1])===-1)return-1;let t=0;for(let n=0;n<a.length;n++)if(a[n]==="\\")n++;else if(a[n]===e[0])t++;else if(a[n]===e[1]&&(t--,t<0))return n;return t>0?-2:-1}function me(a,e,t,n,r){let i=e.href,s=e.title||null,o=a[1].replace(r.other.outputLinkReplace,"$1");n.state.inLink=!0;let l={type:a[0].charAt(0)==="!"?"image":"link",raw:t,href:i,title:s,text:o,tokens:n.inlineTokens(o)};return n.state.inLink=!1,l}function st(a,e,t){let n=a.match(t.other.indentCodeCompensation);if(n===null)return e;let r=n[1];return e.split(`
`).map(i=>{let s=i.match(t.other.beginningSpace);if(s===null)return i;let[o]=s;return o.length>=r.length?i.slice(r.length):i}).join(`
`)}var y=class{options;rules;lexer;constructor(e){this.options=e||O}space(e){let t=this.rules.block.newline.exec(e);if(t&&t[0].length>0)return{type:"space",raw:t[0]}}code(e){let t=this.rules.block.code.exec(e);if(t){let n=t[0].replace(this.rules.other.codeRemoveIndent,"");return{type:"code",raw:t[0],codeBlockStyle:"indented",text:this.options.pedantic?n:z(n,`
`)}}}fences(e){let t=this.rules.block.fences.exec(e);if(t){let n=t[0],r=st(n,t[3]||"",this.rules);return{type:"code",raw:n,lang:t[2]?t[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):t[2],text:r}}}heading(e){let t=this.rules.block.heading.exec(e);if(t){let n=t[2].trim();if(this.rules.other.endingHash.test(n)){let r=z(n,"#");(this.options.pedantic||!r||this.rules.other.endingSpaceChar.test(r))&&(n=r.trim())}return{type:"heading",raw:t[0],depth:t[1].length,text:n,tokens:this.lexer.inline(n)}}}hr(e){let t=this.rules.block.hr.exec(e);if(t)return{type:"hr",raw:z(t[0],`
`)}}blockquote(e){let t=this.rules.block.blockquote.exec(e);if(t){let n=z(t[0],`
`).split(`
`),r="",i="",s=[];for(;n.length>0;){let o=!1,l=[],u;for(u=0;u<n.length;u++)if(this.rules.other.blockquoteStart.test(n[u]))l.push(n[u]),o=!0;else if(!o)l.push(n[u]);else break;n=n.slice(u);let p=l.join(`
`),c=p.replace(this.rules.other.blockquoteSetextReplace,`
    $1`).replace(this.rules.other.blockquoteSetextReplace2,"");r=r?`${r}
${p}`:p,i=i?`${i}
${c}`:c;let f=this.lexer.state.top;if(this.lexer.state.top=!0,this.lexer.blockTokens(c,s,!0),this.lexer.state.top=f,n.length===0)break;let k=s.at(-1);if(k?.type==="code")break;if(k?.type==="blockquote"){let R=k,g=R.raw+`
`+n.join(`
`),T=this.blockquote(g);s[s.length-1]=T,r=r.substring(0,r.length-R.raw.length)+T.raw,i=i.substring(0,i.length-R.text.length)+T.text;break}else if(k?.type==="list"){let R=k,g=R.raw+`
`+n.join(`
`),T=this.list(g);s[s.length-1]=T,r=r.substring(0,r.length-k.raw.length)+T.raw,i=i.substring(0,i.length-R.raw.length)+T.raw,n=g.substring(s.at(-1).raw.length).split(`
`);continue}}return{type:"blockquote",raw:r,tokens:s,text:i}}}list(e){let t=this.rules.block.list.exec(e);if(t){let n=t[1].trim(),r=n.length>1,i={type:"list",raw:"",ordered:r,start:r?+n.slice(0,-1):"",loose:!1,items:[]};n=r?`\\d{1,9}\\${n.slice(-1)}`:`\\${n}`,this.options.pedantic&&(n=r?n:"[*+-]");let s=this.rules.other.listItemRegex(n),o=!1;for(;e;){let u=!1,p="",c="";if(!(t=s.exec(e))||this.rules.block.hr.test(e))break;p=t[0],e=e.substring(p.length);let f=t[2].split(`
`,1)[0].replace(this.rules.other.listReplaceTabs,Z=>" ".repeat(3*Z.length)),k=e.split(`
`,1)[0],R=!f.trim(),g=0;if(this.options.pedantic?(g=2,c=f.trimStart()):R?g=t[1].length+1:(g=t[2].search(this.rules.other.nonSpaceChar),g=g>4?1:g,c=f.slice(g),g+=t[1].length),R&&this.rules.other.blankLine.test(k)&&(p+=k+`
`,e=e.substring(k.length+1),u=!0),!u){let Z=this.rules.other.nextBulletRegex(g),te=this.rules.other.hrRegex(g),ne=this.rules.other.fencesBeginRegex(g),re=this.rules.other.headingBeginRegex(g),xe=this.rules.other.htmlBeginRegex(g);for(;e;){let G=e.split(`
`,1)[0],E;if(k=G,this.options.pedantic?(k=k.replace(this.rules.other.listReplaceNesting,"  "),E=k):E=k.replace(this.rules.other.tabCharGlobal,"    "),ne.test(k)||re.test(k)||xe.test(k)||Z.test(k)||te.test(k))break;if(E.search(this.rules.other.nonSpaceChar)>=g||!k.trim())c+=`
`+E.slice(g);else{if(R||f.replace(this.rules.other.tabCharGlobal,"    ").search(this.rules.other.nonSpaceChar)>=4||ne.test(f)||re.test(f)||te.test(f))break;c+=`
`+k}!R&&!k.trim()&&(R=!0),p+=G+`
`,e=e.substring(G.length+1),f=E.slice(g)}}i.loose||(o?i.loose=!0:this.rules.other.doubleBlankLine.test(p)&&(o=!0));let T=null,ee;this.options.gfm&&(T=this.rules.other.listIsTask.exec(c),T&&(ee=T[0]!=="[ ] ",c=c.replace(this.rules.other.listReplaceTask,""))),i.items.push({type:"list_item",raw:p,task:!!T,checked:ee,loose:!1,text:c,tokens:[]}),i.raw+=p}let l=i.items.at(-1);if(l)l.raw=l.raw.trimEnd(),l.text=l.text.trimEnd();else return;i.raw=i.raw.trimEnd();for(let u=0;u<i.items.length;u++)if(this.lexer.state.top=!1,i.items[u].tokens=this.lexer.blockTokens(i.items[u].text,[]),!i.loose){let p=i.items[u].tokens.filter(f=>f.type==="space"),c=p.length>0&&p.some(f=>this.rules.other.anyLine.test(f.raw));i.loose=c}if(i.loose)for(let u=0;u<i.items.length;u++)i.items[u].loose=!0;return i}}html(e){let t=this.rules.block.html.exec(e);if(t)return{type:"html",block:!0,raw:t[0],pre:t[1]==="pre"||t[1]==="script"||t[1]==="style",text:t[0]}}def(e){let t=this.rules.block.def.exec(e);if(t){let n=t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal," "),r=t[2]?t[2].replace(this.rules.other.hrefBrackets,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",i=t[3]?t[3].substring(1,t[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):t[3];return{type:"def",tag:n,raw:t[0],href:r,title:i}}}table(e){let t=this.rules.block.table.exec(e);if(!t||!this.rules.other.tableDelimiter.test(t[2]))return;let n=Y(t[1]),r=t[2].replace(this.rules.other.tableAlignChars,"").split("|"),i=t[3]?.trim()?t[3].replace(this.rules.other.tableRowBlankLine,"").split(`
`):[],s={type:"table",raw:t[0],header:[],align:[],rows:[]};if(n.length===r.length){for(let o of r)this.rules.other.tableAlignRight.test(o)?s.align.push("right"):this.rules.other.tableAlignCenter.test(o)?s.align.push("center"):this.rules.other.tableAlignLeft.test(o)?s.align.push("left"):s.align.push(null);for(let o=0;o<n.length;o++)s.header.push({text:n[o],tokens:this.lexer.inline(n[o]),header:!0,align:s.align[o]});for(let o of i)s.rows.push(Y(o,s.header.length).map((l,u)=>({text:l,tokens:this.lexer.inline(l),header:!1,align:s.align[u]})));return s}}lheading(e){let t=this.rules.block.lheading.exec(e);if(t)return{type:"heading",raw:t[0],depth:t[2].charAt(0)==="="?1:2,text:t[1],tokens:this.lexer.inline(t[1])}}paragraph(e){let t=this.rules.block.paragraph.exec(e);if(t){let n=t[1].charAt(t[1].length-1)===`
`?t[1].slice(0,-1):t[1];return{type:"paragraph",raw:t[0],text:n,tokens:this.lexer.inline(n)}}}text(e){let t=this.rules.block.text.exec(e);if(t)return{type:"text",raw:t[0],text:t[0],tokens:this.lexer.inline(t[0])}}escape(e){let t=this.rules.inline.escape.exec(e);if(t)return{type:"escape",raw:t[0],text:t[1]}}tag(e){let t=this.rules.inline.tag.exec(e);if(t)return!this.lexer.state.inLink&&this.rules.other.startATag.test(t[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&this.rules.other.endATag.test(t[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(t[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(t[0])&&(this.lexer.state.inRawBlock=!1),{type:"html",raw:t[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:!1,text:t[0]}}link(e){let t=this.rules.inline.link.exec(e);if(t){let n=t[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(n)){if(!this.rules.other.endAngleBracket.test(n))return;let s=z(n.slice(0,-1),"\\");if((n.length-s.length)%2===0)return}else{let s=fe(t[2],"()");if(s===-2)return;if(s>-1){let l=(t[0].indexOf("!")===0?5:4)+t[1].length+s;t[2]=t[2].substring(0,s),t[0]=t[0].substring(0,l).trim(),t[3]=""}}let r=t[2],i="";if(this.options.pedantic){let s=this.rules.other.pedanticHrefTitle.exec(r);s&&(r=s[1],i=s[3])}else i=t[3]?t[3].slice(1,-1):"";return r=r.trim(),this.rules.other.startAngleBracket.test(r)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(n)?r=r.slice(1):r=r.slice(1,-1)),me(t,{href:r&&r.replace(this.rules.inline.anyPunctuation,"$1"),title:i&&i.replace(this.rules.inline.anyPunctuation,"$1")},t[0],this.lexer,this.rules)}}reflink(e,t){let n;if((n=this.rules.inline.reflink.exec(e))||(n=this.rules.inline.nolink.exec(e))){let r=(n[2]||n[1]).replace(this.rules.other.multipleSpaceGlobal," "),i=t[r.toLowerCase()];if(!i){let s=n[0].charAt(0);return{type:"text",raw:s,text:s}}return me(n,i,n[0],this.lexer,this.rules)}}emStrong(e,t,n=""){let r=this.rules.inline.emStrongLDelim.exec(e);if(!r||r[3]&&n.match(this.rules.other.unicodeAlphaNumeric))return;if(!(r[1]||r[2]||"")||!n||this.rules.inline.punctuation.exec(n)){let s=[...r[0]].length-1,o,l,u=s,p=0,c=r[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(c.lastIndex=0,t=t.slice(-1*e.length+s);(r=c.exec(t))!=null;){if(o=r[1]||r[2]||r[3]||r[4]||r[5]||r[6],!o)continue;if(l=[...o].length,r[3]||r[4]){u+=l;continue}else if((r[5]||r[6])&&s%3&&!((s+l)%3)){p+=l;continue}if(u-=l,u>0)continue;l=Math.min(l,l+u+p);let f=[...r[0]][0].length,k=e.slice(0,s+r.index+f+l);if(Math.min(s,l)%2){let g=k.slice(1,-1);return{type:"em",raw:k,text:g,tokens:this.lexer.inlineTokens(g)}}let R=k.slice(2,-2);return{type:"strong",raw:k,text:R,tokens:this.lexer.inlineTokens(R)}}}}codespan(e){let t=this.rules.inline.code.exec(e);if(t){let n=t[2].replace(this.rules.other.newLineCharGlobal," "),r=this.rules.other.nonSpaceChar.test(n),i=this.rules.other.startingSpaceChar.test(n)&&this.rules.other.endingSpaceChar.test(n);return r&&i&&(n=n.substring(1,n.length-1)),{type:"codespan",raw:t[0],text:n}}}br(e){let t=this.rules.inline.br.exec(e);if(t)return{type:"br",raw:t[0]}}del(e){let t=this.rules.inline.del.exec(e);if(t)return{type:"del",raw:t[0],text:t[2],tokens:this.lexer.inlineTokens(t[2])}}autolink(e){let t=this.rules.inline.autolink.exec(e);if(t){let n,r;return t[2]==="@"?(n=t[1],r="mailto:"+n):(n=t[1],r=n),{type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}url(e){let t;if(t=this.rules.inline.url.exec(e)){let n,r;if(t[2]==="@")n=t[0],r="mailto:"+n;else{let i;do i=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])?.[0]??"";while(i!==t[0]);n=t[0],t[1]==="www."?r="http://"+t[0]:r=t[0]}return{type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}inlineText(e){let t=this.rules.inline.text.exec(e);if(t){let n=this.lexer.state.inRawBlock;return{type:"text",raw:t[0],text:t[0],escaped:n}}}};var x=class a{tokens;options;state;tokenizer;inlineQueue;constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||O,this.options.tokenizer=this.options.tokenizer||new y,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};let t={other:m,block:B.normal,inline:M.normal};this.options.pedantic?(t.block=B.pedantic,t.inline=M.pedantic):this.options.gfm&&(t.block=B.gfm,this.options.breaks?t.inline=M.breaks:t.inline=M.gfm),this.tokenizer.rules=t}static get rules(){return{block:B,inline:M}}static lex(e,t){return new a(t).lex(e)}static lexInline(e,t){return new a(t).inlineTokens(e)}lex(e){e=e.replace(m.carriageReturn,`
`),this.blockTokens(e,this.tokens);for(let t=0;t<this.inlineQueue.length;t++){let n=this.inlineQueue[t];this.inlineTokens(n.src,n.tokens)}return this.inlineQueue=[],this.tokens}blockTokens(e,t=[],n=!1){for(this.options.pedantic&&(e=e.replace(m.tabCharGlobal,"    ").replace(m.spaceLine,""));e;){let r;if(this.options.extensions?.block?.some(s=>(r=s.call({lexer:this},e,t))?(e=e.substring(r.raw.length),t.push(r),!0):!1))continue;if(r=this.tokenizer.space(e)){e=e.substring(r.raw.length);let s=t.at(-1);r.raw.length===1&&s!==void 0?s.raw+=`
`:t.push(r);continue}if(r=this.tokenizer.code(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=`
`+r.raw,s.text+=`
`+r.text,this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(r=this.tokenizer.fences(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.heading(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.hr(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.blockquote(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.list(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.html(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.def(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=`
`+r.raw,s.text+=`
`+r.raw,this.inlineQueue.at(-1).src=s.text):this.tokens.links[r.tag]||(this.tokens.links[r.tag]={href:r.href,title:r.title});continue}if(r=this.tokenizer.table(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.lheading(e)){e=e.substring(r.raw.length),t.push(r);continue}let i=e;if(this.options.extensions?.startBlock){let s=1/0,o=e.slice(1),l;this.options.extensions.startBlock.forEach(u=>{l=u.call({lexer:this},o),typeof l=="number"&&l>=0&&(s=Math.min(s,l))}),s<1/0&&s>=0&&(i=e.substring(0,s+1))}if(this.state.top&&(r=this.tokenizer.paragraph(i))){let s=t.at(-1);n&&s?.type==="paragraph"?(s.raw+=`
`+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r),n=i.length!==e.length,e=e.substring(r.raw.length);continue}if(r=this.tokenizer.text(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="text"?(s.raw+=`
`+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(e){let s="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(s);break}else throw new Error(s)}}return this.state.top=!0,t}inline(e,t=[]){return this.inlineQueue.push({src:e,tokens:t}),t}inlineTokens(e,t=[]){let n=e,r=null;if(this.tokens.links){let o=Object.keys(this.tokens.links);if(o.length>0)for(;(r=this.tokenizer.rules.inline.reflinkSearch.exec(n))!=null;)o.includes(r[0].slice(r[0].lastIndexOf("[")+1,-1))&&(n=n.slice(0,r.index)+"["+"a".repeat(r[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(r=this.tokenizer.rules.inline.anyPunctuation.exec(n))!=null;)n=n.slice(0,r.index)+"++"+n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);for(;(r=this.tokenizer.rules.inline.blockSkip.exec(n))!=null;)n=n.slice(0,r.index)+"["+"a".repeat(r[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);let i=!1,s="";for(;e;){i||(s=""),i=!1;let o;if(this.options.extensions?.inline?.some(u=>(o=u.call({lexer:this},e,t))?(e=e.substring(o.raw.length),t.push(o),!0):!1))continue;if(o=this.tokenizer.escape(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.tag(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.link(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(o.raw.length);let u=t.at(-1);o.type==="text"&&u?.type==="text"?(u.raw+=o.raw,u.text+=o.text):t.push(o);continue}if(o=this.tokenizer.emStrong(e,n,s)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.codespan(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.br(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.del(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.autolink(e)){e=e.substring(o.raw.length),t.push(o);continue}if(!this.state.inLink&&(o=this.tokenizer.url(e))){e=e.substring(o.raw.length),t.push(o);continue}let l=e;if(this.options.extensions?.startInline){let u=1/0,p=e.slice(1),c;this.options.extensions.startInline.forEach(f=>{c=f.call({lexer:this},p),typeof c=="number"&&c>=0&&(u=Math.min(u,c))}),u<1/0&&u>=0&&(l=e.substring(0,u+1))}if(o=this.tokenizer.inlineText(l)){e=e.substring(o.raw.length),o.raw.slice(-1)!=="_"&&(s=o.raw.slice(-1)),i=!0;let u=t.at(-1);u?.type==="text"?(u.raw+=o.raw,u.text+=o.text):t.push(o);continue}if(e){let u="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(u);break}else throw new Error(u)}}return t}};var P=class{options;parser;constructor(e){this.options=e||O}space(e){return""}code({text:e,lang:t,escaped:n}){let r=(t||"").match(m.notSpaceStart)?.[0],i=e.replace(m.endingNewline,"")+`
`;return r?'<pre><code class="language-'+w(r)+'">'+(n?i:w(i,!0))+`</code></pre>
`:"<pre><code>"+(n?i:w(i,!0))+`</code></pre>
`}blockquote({tokens:e}){return`<blockquote>
${this.parser.parse(e)}</blockquote>
`}html({text:e}){return e}heading({tokens:e,depth:t}){return`<h${t}>${this.parser.parseInline(e)}</h${t}>
`}hr(e){return`<hr>
`}list(e){let t=e.ordered,n=e.start,r="";for(let o=0;o<e.items.length;o++){let l=e.items[o];r+=this.listitem(l)}let i=t?"ol":"ul",s=t&&n!==1?' start="'+n+'"':"";return"<"+i+s+`>
`+r+"</"+i+`>
`}listitem(e){let t="";if(e.task){let n=this.checkbox({checked:!!e.checked});e.loose?e.tokens[0]?.type==="paragraph"?(e.tokens[0].text=n+" "+e.tokens[0].text,e.tokens[0].tokens&&e.tokens[0].tokens.length>0&&e.tokens[0].tokens[0].type==="text"&&(e.tokens[0].tokens[0].text=n+" "+w(e.tokens[0].tokens[0].text),e.tokens[0].tokens[0].escaped=!0)):e.tokens.unshift({type:"text",raw:n+" ",text:n+" ",escaped:!0}):t+=n+" "}return t+=this.parser.parse(e.tokens,!!e.loose),`<li>${t}</li>
`}checkbox({checked:e}){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox">'}paragraph({tokens:e}){return`<p>${this.parser.parseInline(e)}</p>
`}table(e){let t="",n="";for(let i=0;i<e.header.length;i++)n+=this.tablecell(e.header[i]);t+=this.tablerow({text:n});let r="";for(let i=0;i<e.rows.length;i++){let s=e.rows[i];n="";for(let o=0;o<s.length;o++)n+=this.tablecell(s[o]);r+=this.tablerow({text:n})}return r&&(r=`<tbody>${r}</tbody>`),`<table>
<thead>
`+t+`</thead>
`+r+`</table>
`}tablerow({text:e}){return`<tr>
${e}</tr>
`}tablecell(e){let t=this.parser.parseInline(e.tokens),n=e.header?"th":"td";return(e.align?`<${n} align="${e.align}">`:`<${n}>`)+t+`</${n}>
`}strong({tokens:e}){return`<strong>${this.parser.parseInline(e)}</strong>`}em({tokens:e}){return`<em>${this.parser.parseInline(e)}</em>`}codespan({text:e}){return`<code>${w(e,!0)}</code>`}br(e){return"<br>"}del({tokens:e}){return`<del>${this.parser.parseInline(e)}</del>`}link({href:e,title:t,tokens:n}){let r=this.parser.parseInline(n),i=V(e);if(i===null)return r;e=i;let s='<a href="'+e+'"';return t&&(s+=' title="'+w(t)+'"'),s+=">"+r+"</a>",s}image({href:e,title:t,text:n,tokens:r}){r&&(n=this.parser.parseInline(r,this.parser.textRenderer));let i=V(e);if(i===null)return w(n);e=i;let s=`<img src="${e}" alt="${n}"`;return t&&(s+=` title="${w(t)}"`),s+=">",s}text(e){return"tokens"in e&&e.tokens?this.parser.parseInline(e.tokens):"escaped"in e&&e.escaped?e.text:w(e.text)}};var S=class{strong({text:e}){return e}em({text:e}){return e}codespan({text:e}){return e}del({text:e}){return e}html({text:e}){return e}text({text:e}){return e}link({text:e}){return""+e}image({text:e}){return""+e}br(){return""}};var b=class a{options;renderer;textRenderer;constructor(e){this.options=e||O,this.options.renderer=this.options.renderer||new P,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new S}static parse(e,t){return new a(t).parse(e)}static parseInline(e,t){return new a(t).parseInline(e)}parse(e,t=!0){let n="";for(let r=0;r<e.length;r++){let i=e[r];if(this.options.extensions?.renderers?.[i.type]){let o=i,l=this.options.extensions.renderers[o.type].call({parser:this},o);if(l!==!1||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(o.type)){n+=l||"";continue}}let s=i;switch(s.type){case"space":{n+=this.renderer.space(s);continue}case"hr":{n+=this.renderer.hr(s);continue}case"heading":{n+=this.renderer.heading(s);continue}case"code":{n+=this.renderer.code(s);continue}case"table":{n+=this.renderer.table(s);continue}case"blockquote":{n+=this.renderer.blockquote(s);continue}case"list":{n+=this.renderer.list(s);continue}case"html":{n+=this.renderer.html(s);continue}case"paragraph":{n+=this.renderer.paragraph(s);continue}case"text":{let o=s,l=this.renderer.text(o);for(;r+1<e.length&&e[r+1].type==="text";)o=e[++r],l+=`
`+this.renderer.text(o);t?n+=this.renderer.paragraph({type:"paragraph",raw:l,text:l,tokens:[{type:"text",raw:l,text:l,escaped:!0}]}):n+=l;continue}default:{let o='Token with "'+s.type+'" type was not found.';if(this.options.silent)return console.error(o),"";throw new Error(o)}}}return n}parseInline(e,t=this.renderer){let n="";for(let r=0;r<e.length;r++){let i=e[r];if(this.options.extensions?.renderers?.[i.type]){let o=this.options.extensions.renderers[i.type].call({parser:this},i);if(o!==!1||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(i.type)){n+=o||"";continue}}let s=i;switch(s.type){case"escape":{n+=t.text(s);break}case"html":{n+=t.html(s);break}case"link":{n+=t.link(s);break}case"image":{n+=t.image(s);break}case"strong":{n+=t.strong(s);break}case"em":{n+=t.em(s);break}case"codespan":{n+=t.codespan(s);break}case"br":{n+=t.br(s);break}case"del":{n+=t.del(s);break}case"text":{n+=t.text(s);break}default:{let o='Token with "'+s.type+'" type was not found.';if(this.options.silent)return console.error(o),"";throw new Error(o)}}}return n}};var $=class{options;block;constructor(e){this.options=e||O}static passThroughHooks=new Set(["preprocess","postprocess","processAllTokens"]);preprocess(e){return e}postprocess(e){return e}processAllTokens(e){return e}provideLexer(){return this.block?x.lex:x.lexInline}provideParser(){return this.block?b.parse:b.parseInline}};var A=class{defaults=_();options=this.setOptions;parse=this.parseMarkdown(!0);parseInline=this.parseMarkdown(!1);Parser=b;Renderer=P;TextRenderer=S;Lexer=x;Tokenizer=y;Hooks=$;constructor(...e){this.use(...e)}walkTokens(e,t){let n=[];for(let r of e)switch(n=n.concat(t.call(this,r)),r.type){case"table":{let i=r;for(let s of i.header)n=n.concat(this.walkTokens(s.tokens,t));for(let s of i.rows)for(let o of s)n=n.concat(this.walkTokens(o.tokens,t));break}case"list":{let i=r;n=n.concat(this.walkTokens(i.items,t));break}default:{let i=r;this.defaults.extensions?.childTokens?.[i.type]?this.defaults.extensions.childTokens[i.type].forEach(s=>{let o=i[s].flat(1/0);n=n.concat(this.walkTokens(o,t))}):i.tokens&&(n=n.concat(this.walkTokens(i.tokens,t)))}}return n}use(...e){let t=this.defaults.extensions||{renderers:{},childTokens:{}};return e.forEach(n=>{let r={...n};if(r.async=this.defaults.async||r.async||!1,n.extensions&&(n.extensions.forEach(i=>{if(!i.name)throw new Error("extension name required");if("renderer"in i){let s=t.renderers[i.name];s?t.renderers[i.name]=function(...o){let l=i.renderer.apply(this,o);return l===!1&&(l=s.apply(this,o)),l}:t.renderers[i.name]=i.renderer}if("tokenizer"in i){if(!i.level||i.level!=="block"&&i.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");let s=t[i.level];s?s.unshift(i.tokenizer):t[i.level]=[i.tokenizer],i.start&&(i.level==="block"?t.startBlock?t.startBlock.push(i.start):t.startBlock=[i.start]:i.level==="inline"&&(t.startInline?t.startInline.push(i.start):t.startInline=[i.start]))}"childTokens"in i&&i.childTokens&&(t.childTokens[i.name]=i.childTokens)}),r.extensions=t),n.renderer){let i=this.defaults.renderer||new P(this.defaults);for(let s in n.renderer){if(!(s in i))throw new Error(`renderer '${s}' does not exist`);if(["options","parser"].includes(s))continue;let o=s,l=n.renderer[o],u=i[o];i[o]=(...p)=>{let c=l.apply(i,p);return c===!1&&(c=u.apply(i,p)),c||""}}r.renderer=i}if(n.tokenizer){let i=this.defaults.tokenizer||new y(this.defaults);for(let s in n.tokenizer){if(!(s in i))throw new Error(`tokenizer '${s}' does not exist`);if(["options","rules","lexer"].includes(s))continue;let o=s,l=n.tokenizer[o],u=i[o];i[o]=(...p)=>{let c=l.apply(i,p);return c===!1&&(c=u.apply(i,p)),c}}r.tokenizer=i}if(n.hooks){let i=this.defaults.hooks||new $;for(let s in n.hooks){if(!(s in i))throw new Error(`hook '${s}' does not exist`);if(["options","block"].includes(s))continue;let o=s,l=n.hooks[o],u=i[o];$.passThroughHooks.has(s)?i[o]=p=>{if(this.defaults.async)return Promise.resolve(l.call(i,p)).then(f=>u.call(i,f));let c=l.call(i,p);return u.call(i,c)}:i[o]=(...p)=>{let c=l.apply(i,p);return c===!1&&(c=u.apply(i,p)),c}}r.hooks=i}if(n.walkTokens){let i=this.defaults.walkTokens,s=n.walkTokens;r.walkTokens=function(o){let l=[];return l.push(s.call(this,o)),i&&(l=l.concat(i.call(this,o))),l}}this.defaults={...this.defaults,...r}}),this}setOptions(e){return this.defaults={...this.defaults,...e},this}lexer(e,t){return x.lex(e,t??this.defaults)}parser(e,t){return b.parse(e,t??this.defaults)}parseMarkdown(e){return(n,r)=>{let i={...r},s={...this.defaults,...i},o=this.onError(!!s.silent,!!s.async);if(this.defaults.async===!0&&i.async===!1)return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));if(typeof n>"u"||n===null)return o(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return o(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));s.hooks&&(s.hooks.options=s,s.hooks.block=e);let l=s.hooks?s.hooks.provideLexer():e?x.lex:x.lexInline,u=s.hooks?s.hooks.provideParser():e?b.parse:b.parseInline;if(s.async)return Promise.resolve(s.hooks?s.hooks.preprocess(n):n).then(p=>l(p,s)).then(p=>s.hooks?s.hooks.processAllTokens(p):p).then(p=>s.walkTokens?Promise.all(this.walkTokens(p,s.walkTokens)).then(()=>p):p).then(p=>u(p,s)).then(p=>s.hooks?s.hooks.postprocess(p):p).catch(o);try{s.hooks&&(n=s.hooks.preprocess(n));let p=l(n,s);s.hooks&&(p=s.hooks.processAllTokens(p)),s.walkTokens&&this.walkTokens(p,s.walkTokens);let c=u(p,s);return s.hooks&&(c=s.hooks.postprocess(c)),c}catch(p){return o(p)}}}onError(e,t){return n=>{if(n.message+=`
Please report this to https://github.com/markedjs/marked.`,e){let r="<p>An error occurred:</p><pre>"+w(n.message+"",!0)+"</pre>";return t?Promise.resolve(r):r}if(t)return Promise.reject(n);throw n}}};var L=new A;function d(a,e){return L.parse(a,e)}d.options=d.setOptions=function(a){return L.setOptions(a),d.defaults=L.defaults,N(d.defaults),d};d.getDefaults=_;d.defaults=O;d.use=function(...a){return L.use(...a),d.defaults=L.defaults,N(d.defaults),d};d.walkTokens=function(a,e){return L.walkTokens(a,e)};d.parseInline=L.parseInline;d.Parser=b;d.parser=b.parse;d.Renderer=P;d.TextRenderer=S;d.Lexer=x;d.lexer=x.lex;d.Tokenizer=y;d.Hooks=$;d.parse=d;var it=d.options,ot=d.setOptions,at=d.use,lt=d.walkTokens,ut=d.parseInline,pt=d,ct=b.parse,ht=x.lex;

if(__exports != exports)module.exports = exports;return module.exports}));


},{}],104:[function(require,module,exports){
//! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i,
            arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        var flags = null,
            parsedParts = false,
            isNowValid = m._d && !isNaN(m._d.getTime());
        if (isNowValid) {
            flags = getParsingFlags(m);
            parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            isNowValid =
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidEra &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));
            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        } else {
            return isNowValid;
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key,
                    argLen = arguments.length;
                for (i = 0; i < argLen; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {
        D: 'date',
        dates: 'date',
        date: 'date',
        d: 'day',
        days: 'day',
        day: 'day',
        e: 'weekday',
        weekdays: 'weekday',
        weekday: 'weekday',
        E: 'isoWeekday',
        isoweekdays: 'isoWeekday',
        isoweekday: 'isoWeekday',
        DDD: 'dayOfYear',
        dayofyears: 'dayOfYear',
        dayofyear: 'dayOfYear',
        h: 'hour',
        hours: 'hour',
        hour: 'hour',
        ms: 'millisecond',
        milliseconds: 'millisecond',
        millisecond: 'millisecond',
        m: 'minute',
        minutes: 'minute',
        minute: 'minute',
        M: 'month',
        months: 'month',
        month: 'month',
        Q: 'quarter',
        quarters: 'quarter',
        quarter: 'quarter',
        s: 'second',
        seconds: 'second',
        second: 'second',
        gg: 'weekYear',
        weekyears: 'weekYear',
        weekyear: 'weekYear',
        GG: 'isoWeekYear',
        isoweekyears: 'isoWeekYear',
        isoweekyear: 'isoWeekYear',
        w: 'week',
        weeks: 'week',
        week: 'week',
        W: 'isoWeek',
        isoweeks: 'isoWeek',
        isoweek: 'isoWeek',
        y: 'year',
        years: 'year',
        year: 'year',
    };

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1,
    };

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        match1to2NoLeadingZero = /^[1-9]\d?/, //         1-99
        match1to2HasZero = /^([1-9]\d|\d)/, //           0-99
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(
                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                    function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }
                )
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback,
            tokenLen;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        tokenLen = token.length;
        for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        if (!mom.isValid()) {
            return NaN;
        }

        var d = mom._d,
            isUTC = mom._isUTC;

        switch (unit) {
            case 'Milliseconds':
                return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
            case 'Seconds':
                return isUTC ? d.getUTCSeconds() : d.getSeconds();
            case 'Minutes':
                return isUTC ? d.getUTCMinutes() : d.getMinutes();
            case 'Hours':
                return isUTC ? d.getUTCHours() : d.getHours();
            case 'Date':
                return isUTC ? d.getUTCDate() : d.getDate();
            case 'Day':
                return isUTC ? d.getUTCDay() : d.getDay();
            case 'Month':
                return isUTC ? d.getUTCMonth() : d.getMonth();
            case 'FullYear':
                return isUTC ? d.getUTCFullYear() : d.getFullYear();
            default:
                return NaN; // Just in case
        }
    }

    function set$1(mom, unit, value) {
        var d, isUTC, year, month, date;

        if (!mom.isValid() || isNaN(value)) {
            return;
        }

        d = mom._d;
        isUTC = mom._isUTC;

        switch (unit) {
            case 'Milliseconds':
                return void (isUTC
                    ? d.setUTCMilliseconds(value)
                    : d.setMilliseconds(value));
            case 'Seconds':
                return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
            case 'Minutes':
                return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
            case 'Hours':
                return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
            case 'Date':
                return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
            // case 'Day': // Not real
            //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
            // case 'Month': // Not used because we need to pass two variables
            //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
            case 'FullYear':
                break; // See below ...
            default:
                return; // Just in case
        }

        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC
            ? d.setUTCFullYear(year, month, date)
            : d.setFullYear(year, month, date));
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i,
                prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // PARSING

    addRegexToken('M', match1to2, match1to2NoLeadingZero);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
        defaultLocaleMonthsShort =
            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        var month = value,
            date = mom.date();

        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC
            ? mom._d.setUTCMonth(month, date)
            : mom._d.setMonth(month, date));
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            shortP,
            longP;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortP = regexEscape(this.monthsShort(mom, ''));
            longP = regexEscape(this.months(mom, ''));
            shortPieces.push(shortP);
            longPieces.push(longP);
            mixedPieces.push(longP);
            mixedPieces.push(shortP);
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // PARSING

    addRegexToken('w', match1to2, match1to2NoLeadingZero);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2, match1to2NoLeadingZero);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(
        ['w', 'ww', 'W', 'WW'],
        function (input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input);
        }
    );

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
              ? weekdays[m.day()]
              : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        var day = get(this, 'Day');
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2, match1to2HasZero);
    addRegexToken('h', match1to2, match1to2NoLeadingZero);
    addRegexToken('k', match1to2, match1to2NoLeadingZero);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function isLocaleNameSane(name) {
        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
        // Ensure name is available and function returns boolean
        return !!(name && name.match('^[^/\\\\]*$'));
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            typeof module !== 'undefined' &&
            module &&
            module.exports &&
            isLocaleNameSane(name)
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                      ? DATE
                      : a[HOUR] < 0 ||
                          a[HOUR] > 24 ||
                          (a[HOUR] === 24 &&
                              (a[MINUTE] !== 0 ||
                                  a[SECOND] !== 0 ||
                                  a[MILLISECOND] !== 0))
                        ? HOUR
                        : a[MINUTE] < 0 || a[MINUTE] > 59
                          ? MINUTE
                          : a[SECOND] < 0 || a[SECOND] > 59
                            ? SECOND
                            : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                              ? MILLISECOND
                              : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 =
            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^()]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;

        if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property,
            propertyLen = properties.length;

        for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
              ? 'lastWeek'
              : diff < 0
                ? 'lastDay'
                : diff < 1
                  ? 'sameDay'
                  : diff < 2
                    ? 'nextDay'
                    : diff < 7
                      ? 'nextWeek'
                      : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(
        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
        function (input, array, config, token) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        }
    );

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            erasName,
            erasAbbr,
            erasNarrow,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            erasName = regexEscape(eras[i].name);
            erasAbbr = regexEscape(eras[i].abbr);
            erasNarrow = regexEscape(eras[i].narrow);

            namePieces.push(erasName);
            abbrPieces.push(erasAbbr);
            narrowPieces.push(erasNarrow);
            mixedPieces.push(erasName);
            mixedPieces.push(erasAbbr);
            mixedPieces.push(erasNarrow);
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(
        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
        function (input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input);
        }
    );

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday() + this.localeData()._week.dow,
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // PARSING

    addRegexToken('D', match1to2, match1to2NoLeadingZero);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // PARSING

    addRegexToken('m', match1to2, match1to2HasZero);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // PARSING

    addRegexToken('s', match1to2, match1to2HasZero);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                          ? 'st'
                          : b === 2
                            ? 'nd'
                            : b === 3
                              ? 'rd'
                              : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y'),
        valueOf$1 = asMilliseconds;

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.30.1';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));

},{}],105:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],106:[function(require,module,exports){
(function (global){(function (){
!function(e){var t;"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):("undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.objectHash=e())}(function(){return function r(o,i,u){function s(n,e){if(!i[n]){if(!o[n]){var t="function"==typeof require&&require;if(!e&&t)return t(n,!0);if(a)return a(n,!0);throw new Error("Cannot find module '"+n+"'")}e=i[n]={exports:{}};o[n][0].call(e.exports,function(e){var t=o[n][1][e];return s(t||e)},e,e.exports,r,o,i,u)}return i[n].exports}for(var a="function"==typeof require&&require,e=0;e<u.length;e++)s(u[e]);return s}({1:[function(w,b,m){!function(e,n,s,c,d,h,p,g,y){"use strict";var r=w("crypto");function t(e,t){t=u(e,t);var n;return void 0===(n="passthrough"!==t.algorithm?r.createHash(t.algorithm):new l).write&&(n.write=n.update,n.end=n.update),f(t,n).dispatch(e),n.update||n.end(""),n.digest?n.digest("buffer"===t.encoding?void 0:t.encoding):(e=n.read(),"buffer"!==t.encoding?e.toString(t.encoding):e)}(m=b.exports=t).sha1=function(e){return t(e)},m.keys=function(e){return t(e,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},m.MD5=function(e){return t(e,{algorithm:"md5",encoding:"hex"})},m.keysMD5=function(e){return t(e,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var o=r.getHashes?r.getHashes().slice():["sha1","md5"],i=(o.push("passthrough"),["buffer","hex","binary","base64"]);function u(e,t){var n={};if(n.algorithm=(t=t||{}).algorithm||"sha1",n.encoding=t.encoding||"hex",n.excludeValues=!!t.excludeValues,n.algorithm=n.algorithm.toLowerCase(),n.encoding=n.encoding.toLowerCase(),n.ignoreUnknown=!0===t.ignoreUnknown,n.respectType=!1!==t.respectType,n.respectFunctionNames=!1!==t.respectFunctionNames,n.respectFunctionProperties=!1!==t.respectFunctionProperties,n.unorderedArrays=!0===t.unorderedArrays,n.unorderedSets=!1!==t.unorderedSets,n.unorderedObjects=!1!==t.unorderedObjects,n.replacer=t.replacer||void 0,n.excludeKeys=t.excludeKeys||void 0,void 0===e)throw new Error("Object argument required.");for(var r=0;r<o.length;++r)o[r].toLowerCase()===n.algorithm.toLowerCase()&&(n.algorithm=o[r]);if(-1===o.indexOf(n.algorithm))throw new Error('Algorithm "'+n.algorithm+'"  not supported. supported values: '+o.join(", "));if(-1===i.indexOf(n.encoding)&&"passthrough"!==n.algorithm)throw new Error('Encoding "'+n.encoding+'"  not supported. supported values: '+i.join(", "));return n}function a(e){if("function"==typeof e)return null!=/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e))}function f(o,t,i){i=i||[];function u(e){return t.update?t.update(e,"utf8"):t.write(e,"utf8")}return{dispatch:function(e){return this["_"+(null===(e=o.replacer?o.replacer(e):e)?"null":typeof e)](e)},_object:function(t){var n,e=Object.prototype.toString.call(t),r=/\[object (.*)\]/i.exec(e);r=(r=r?r[1]:"unknown:["+e+"]").toLowerCase();if(0<=(e=i.indexOf(t)))return this.dispatch("[CIRCULAR:"+e+"]");if(i.push(t),void 0!==s&&s.isBuffer&&s.isBuffer(t))return u("buffer:"),u(t);if("object"===r||"function"===r||"asyncfunction"===r)return e=Object.keys(t),o.unorderedObjects&&(e=e.sort()),!1===o.respectType||a(t)||e.splice(0,0,"prototype","__proto__","constructor"),o.excludeKeys&&(e=e.filter(function(e){return!o.excludeKeys(e)})),u("object:"+e.length+":"),n=this,e.forEach(function(e){n.dispatch(e),u(":"),o.excludeValues||n.dispatch(t[e]),u(",")});if(!this["_"+r]){if(o.ignoreUnknown)return u("["+r+"]");throw new Error('Unknown object type "'+r+'"')}this["_"+r](t)},_array:function(e,t){t=void 0!==t?t:!1!==o.unorderedArrays;var n=this;if(u("array:"+e.length+":"),!t||e.length<=1)return e.forEach(function(e){return n.dispatch(e)});var r=[],t=e.map(function(e){var t=new l,n=i.slice();return f(o,t,n).dispatch(e),r=r.concat(n.slice(i.length)),t.read().toString()});return i=i.concat(r),t.sort(),this._array(t,!1)},_date:function(e){return u("date:"+e.toJSON())},_symbol:function(e){return u("symbol:"+e.toString())},_error:function(e){return u("error:"+e.toString())},_boolean:function(e){return u("bool:"+e.toString())},_string:function(e){u("string:"+e.length+":"),u(e.toString())},_function:function(e){u("fn:"),a(e)?this.dispatch("[native]"):this.dispatch(e.toString()),!1!==o.respectFunctionNames&&this.dispatch("function-name:"+String(e.name)),o.respectFunctionProperties&&this._object(e)},_number:function(e){return u("number:"+e.toString())},_xml:function(e){return u("xml:"+e.toString())},_null:function(){return u("Null")},_undefined:function(){return u("Undefined")},_regexp:function(e){return u("regex:"+e.toString())},_uint8array:function(e){return u("uint8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint8clampedarray:function(e){return u("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(e))},_int8array:function(e){return u("int8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint16array:function(e){return u("uint16array:"),this.dispatch(Array.prototype.slice.call(e))},_int16array:function(e){return u("int16array:"),this.dispatch(Array.prototype.slice.call(e))},_uint32array:function(e){return u("uint32array:"),this.dispatch(Array.prototype.slice.call(e))},_int32array:function(e){return u("int32array:"),this.dispatch(Array.prototype.slice.call(e))},_float32array:function(e){return u("float32array:"),this.dispatch(Array.prototype.slice.call(e))},_float64array:function(e){return u("float64array:"),this.dispatch(Array.prototype.slice.call(e))},_arraybuffer:function(e){return u("arraybuffer:"),this.dispatch(new Uint8Array(e))},_url:function(e){return u("url:"+e.toString())},_map:function(e){u("map:");e=Array.from(e);return this._array(e,!1!==o.unorderedSets)},_set:function(e){u("set:");e=Array.from(e);return this._array(e,!1!==o.unorderedSets)},_file:function(e){return u("file:"),this.dispatch([e.name,e.size,e.type,e.lastModfied])},_blob:function(){if(o.ignoreUnknown)return u("[blob]");throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')},_domwindow:function(){return u("domwindow")},_bigint:function(e){return u("bigint:"+e.toString())},_process:function(){return u("process")},_timer:function(){return u("timer")},_pipe:function(){return u("pipe")},_tcp:function(){return u("tcp")},_udp:function(){return u("udp")},_tty:function(){return u("tty")},_statwatcher:function(){return u("statwatcher")},_securecontext:function(){return u("securecontext")},_connection:function(){return u("connection")},_zlib:function(){return u("zlib")},_context:function(){return u("context")},_nodescript:function(){return u("nodescript")},_httpparser:function(){return u("httpparser")},_dataview:function(){return u("dataview")},_signal:function(){return u("signal")},_fsevent:function(){return u("fsevent")},_tlswrap:function(){return u("tlswrap")}}}function l(){return{buf:"",write:function(e){this.buf+=e},end:function(e){this.buf+=e},read:function(){return this.buf}}}m.writeToStream=function(e,t,n){return void 0===n&&(n=t,t={}),f(t=u(e,t),n).dispatch(e)}}.call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_9a5aa49d.js","/")},{buffer:3,crypto:5,lYpoI2:11}],2:[function(e,t,f){!function(e,t,n,r,o,i,u,s,a){!function(e){"use strict";var a="undefined"!=typeof Uint8Array?Uint8Array:Array,t="+".charCodeAt(0),n="/".charCodeAt(0),r="0".charCodeAt(0),o="a".charCodeAt(0),i="A".charCodeAt(0),u="-".charCodeAt(0),s="_".charCodeAt(0);function f(e){e=e.charCodeAt(0);return e===t||e===u?62:e===n||e===s?63:e<r?-1:e<r+10?e-r+26+26:e<i+26?e-i:e<o+26?e-o+26:void 0}e.toByteArray=function(e){var t,n;if(0<e.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.length,r="="===e.charAt(r-2)?2:"="===e.charAt(r-1)?1:0,o=new a(3*e.length/4-r),i=0<r?e.length-4:e.length,u=0;function s(e){o[u++]=e}for(t=0;t<i;t+=4,0)s((16711680&(n=f(e.charAt(t))<<18|f(e.charAt(t+1))<<12|f(e.charAt(t+2))<<6|f(e.charAt(t+3))))>>16),s((65280&n)>>8),s(255&n);return 2==r?s(255&(n=f(e.charAt(t))<<2|f(e.charAt(t+1))>>4)):1==r&&(s((n=f(e.charAt(t))<<10|f(e.charAt(t+1))<<4|f(e.charAt(t+2))>>2)>>8&255),s(255&n)),o},e.fromByteArray=function(e){var t,n,r,o,i=e.length%3,u="";function s(e){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e)}for(t=0,r=e.length-i;t<r;t+=3)n=(e[t]<<16)+(e[t+1]<<8)+e[t+2],u+=s((o=n)>>18&63)+s(o>>12&63)+s(o>>6&63)+s(63&o);switch(i){case 1:u=(u+=s((n=e[e.length-1])>>2))+s(n<<4&63)+"==";break;case 2:u=(u=(u+=s((n=(e[e.length-2]<<8)+e[e.length-1])>>10))+s(n>>4&63))+s(n<<2&63)+"="}return u}}(void 0===f?this.base64js={}:f)}.call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/base64-js/lib")},{buffer:3,lYpoI2:11}],3:[function(O,e,H){!function(e,n,f,r,h,p,g,y,w){var a=O("base64-js"),i=O("ieee754");function f(e,t,n){if(!(this instanceof f))return new f(e,t,n);var r,o,i,u,s=typeof e;if("base64"===t&&"string"==s)for(e=(u=e).trim?u.trim():u.replace(/^\s+|\s+$/g,"");e.length%4!=0;)e+="=";if("number"==s)r=j(e);else if("string"==s)r=f.byteLength(e,t);else{if("object"!=s)throw new Error("First argument needs to be a number, array or string.");r=j(e.length)}if(f._useTypedArrays?o=f._augment(new Uint8Array(r)):((o=this).length=r,o._isBuffer=!0),f._useTypedArrays&&"number"==typeof e.byteLength)o._set(e);else if(C(u=e)||f.isBuffer(u)||u&&"object"==typeof u&&"number"==typeof u.length)for(i=0;i<r;i++)f.isBuffer(e)?o[i]=e.readUInt8(i):o[i]=e[i];else if("string"==s)o.write(e,0,t);else if("number"==s&&!f._useTypedArrays&&!n)for(i=0;i<r;i++)o[i]=0;return o}function b(e,t,n,r){return f._charsWritten=c(function(e){for(var t=[],n=0;n<e.length;n++)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function m(e,t,n,r){return f._charsWritten=c(function(e){for(var t,n,r=[],o=0;o<e.length;o++)n=e.charCodeAt(o),t=n>>8,n=n%256,r.push(n),r.push(t);return r}(t),e,n,r)}function v(e,t,n){var r="";n=Math.min(e.length,n);for(var o=t;o<n;o++)r+=String.fromCharCode(e[o]);return r}function o(e,t,n,r){r||(d("boolean"==typeof n,"missing or invalid endian"),d(null!=t,"missing offset"),d(t+1<e.length,"Trying to read beyond buffer length"));var o,r=e.length;if(!(r<=t))return n?(o=e[t],t+1<r&&(o|=e[t+1]<<8)):(o=e[t]<<8,t+1<r&&(o|=e[t+1])),o}function u(e,t,n,r){r||(d("boolean"==typeof n,"missing or invalid endian"),d(null!=t,"missing offset"),d(t+3<e.length,"Trying to read beyond buffer length"));var o,r=e.length;if(!(r<=t))return n?(t+2<r&&(o=e[t+2]<<16),t+1<r&&(o|=e[t+1]<<8),o|=e[t],t+3<r&&(o+=e[t+3]<<24>>>0)):(t+1<r&&(o=e[t+1]<<16),t+2<r&&(o|=e[t+2]<<8),t+3<r&&(o|=e[t+3]),o+=e[t]<<24>>>0),o}function _(e,t,n,r){if(r||(d("boolean"==typeof n,"missing or invalid endian"),d(null!=t,"missing offset"),d(t+1<e.length,"Trying to read beyond buffer length")),!(e.length<=t))return r=o(e,t,n,!0),32768&r?-1*(65535-r+1):r}function E(e,t,n,r){if(r||(d("boolean"==typeof n,"missing or invalid endian"),d(null!=t,"missing offset"),d(t+3<e.length,"Trying to read beyond buffer length")),!(e.length<=t))return r=u(e,t,n,!0),2147483648&r?-1*(4294967295-r+1):r}function I(e,t,n,r){return r||(d("boolean"==typeof n,"missing or invalid endian"),d(t+3<e.length,"Trying to read beyond buffer length")),i.read(e,t,n,23,4)}function A(e,t,n,r){return r||(d("boolean"==typeof n,"missing or invalid endian"),d(t+7<e.length,"Trying to read beyond buffer length")),i.read(e,t,n,52,8)}function s(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+1<e.length,"trying to write beyond buffer length"),Y(t,65535));o=e.length;if(!(o<=n))for(var i=0,u=Math.min(o-n,2);i<u;i++)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function l(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+3<e.length,"trying to write beyond buffer length"),Y(t,4294967295));o=e.length;if(!(o<=n))for(var i=0,u=Math.min(o-n,4);i<u;i++)e[n+i]=t>>>8*(r?i:3-i)&255}function B(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+1<e.length,"Trying to write beyond buffer length"),F(t,32767,-32768)),e.length<=n||s(e,0<=t?t:65535+t+1,n,r,o)}function L(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+3<e.length,"Trying to write beyond buffer length"),F(t,2147483647,-2147483648)),e.length<=n||l(e,0<=t?t:4294967295+t+1,n,r,o)}function U(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+3<e.length,"Trying to write beyond buffer length"),D(t,34028234663852886e22,-34028234663852886e22)),e.length<=n||i.write(e,t,n,r,23,4)}function x(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+7<e.length,"Trying to write beyond buffer length"),D(t,17976931348623157e292,-17976931348623157e292)),e.length<=n||i.write(e,t,n,r,52,8)}H.Buffer=f,H.SlowBuffer=f,H.INSPECT_MAX_BYTES=50,f.poolSize=8192,f._useTypedArrays=function(){try{var e=new ArrayBuffer(0),t=new Uint8Array(e);return t.foo=function(){return 42},42===t.foo()&&"function"==typeof t.subarray}catch(e){return!1}}(),f.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},f.isBuffer=function(e){return!(null==e||!e._isBuffer)},f.byteLength=function(e,t){var n;switch(e+="",t||"utf8"){case"hex":n=e.length/2;break;case"utf8":case"utf-8":n=T(e).length;break;case"ascii":case"binary":case"raw":n=e.length;break;case"base64":n=M(e).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":n=2*e.length;break;default:throw new Error("Unknown encoding")}return n},f.concat=function(e,t){if(d(C(e),"Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."),0===e.length)return new f(0);if(1===e.length)return e[0];if("number"!=typeof t)for(o=t=0;o<e.length;o++)t+=e[o].length;for(var n=new f(t),r=0,o=0;o<e.length;o++){var i=e[o];i.copy(n,r),r+=i.length}return n},f.prototype.write=function(e,t,n,r){isFinite(t)?isFinite(n)||(r=n,n=void 0):(a=r,r=t,t=n,n=a),t=Number(t)||0;var o,i,u,s,a=this.length-t;switch((!n||a<(n=Number(n)))&&(n=a),r=String(r||"utf8").toLowerCase()){case"hex":o=function(e,t,n,r){n=Number(n)||0;var o=e.length-n;(!r||o<(r=Number(r)))&&(r=o),d((o=t.length)%2==0,"Invalid hex string"),o/2<r&&(r=o/2);for(var i=0;i<r;i++){var u=parseInt(t.substr(2*i,2),16);d(!isNaN(u),"Invalid hex string"),e[n+i]=u}return f._charsWritten=2*i,i}(this,e,t,n);break;case"utf8":case"utf-8":i=this,u=t,s=n,o=f._charsWritten=c(T(e),i,u,s);break;case"ascii":case"binary":o=b(this,e,t,n);break;case"base64":i=this,u=t,s=n,o=f._charsWritten=c(M(e),i,u,s);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":o=m(this,e,t,n);break;default:throw new Error("Unknown encoding")}return o},f.prototype.toString=function(e,t,n){var r,o,i,u,s=this;if(e=String(e||"utf8").toLowerCase(),t=Number(t)||0,(n=void 0!==n?Number(n):s.length)===t)return"";switch(e){case"hex":r=function(e,t,n){var r=e.length;(!t||t<0)&&(t=0);(!n||n<0||r<n)&&(n=r);for(var o="",i=t;i<n;i++)o+=k(e[i]);return o}(s,t,n);break;case"utf8":case"utf-8":r=function(e,t,n){var r="",o="";n=Math.min(e.length,n);for(var i=t;i<n;i++)e[i]<=127?(r+=N(o)+String.fromCharCode(e[i]),o=""):o+="%"+e[i].toString(16);return r+N(o)}(s,t,n);break;case"ascii":case"binary":r=v(s,t,n);break;case"base64":o=s,u=n,r=0===(i=t)&&u===o.length?a.fromByteArray(o):a.fromByteArray(o.slice(i,u));break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":r=function(e,t,n){for(var r=e.slice(t,n),o="",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}(s,t,n);break;default:throw new Error("Unknown encoding")}return r},f.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},f.prototype.copy=function(e,t,n,r){if(t=t||0,(r=r||0===r?r:this.length)!==(n=n||0)&&0!==e.length&&0!==this.length){d(n<=r,"sourceEnd < sourceStart"),d(0<=t&&t<e.length,"targetStart out of bounds"),d(0<=n&&n<this.length,"sourceStart out of bounds"),d(0<=r&&r<=this.length,"sourceEnd out of bounds"),r>this.length&&(r=this.length);var o=(r=e.length-t<r-n?e.length-t+n:r)-n;if(o<100||!f._useTypedArrays)for(var i=0;i<o;i++)e[i+t]=this[i+n];else e._set(this.subarray(n,n+o),t)}},f.prototype.slice=function(e,t){var n=this.length;if(e=S(e,n,0),t=S(t,n,n),f._useTypedArrays)return f._augment(this.subarray(e,t));for(var r=t-e,o=new f(r,void 0,!0),i=0;i<r;i++)o[i]=this[i+e];return o},f.prototype.get=function(e){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(e)},f.prototype.set=function(e,t){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(e,t)},f.prototype.readUInt8=function(e,t){if(t||(d(null!=e,"missing offset"),d(e<this.length,"Trying to read beyond buffer length")),!(e>=this.length))return this[e]},f.prototype.readUInt16LE=function(e,t){return o(this,e,!0,t)},f.prototype.readUInt16BE=function(e,t){return o(this,e,!1,t)},f.prototype.readUInt32LE=function(e,t){return u(this,e,!0,t)},f.prototype.readUInt32BE=function(e,t){return u(this,e,!1,t)},f.prototype.readInt8=function(e,t){if(t||(d(null!=e,"missing offset"),d(e<this.length,"Trying to read beyond buffer length")),!(e>=this.length))return 128&this[e]?-1*(255-this[e]+1):this[e]},f.prototype.readInt16LE=function(e,t){return _(this,e,!0,t)},f.prototype.readInt16BE=function(e,t){return _(this,e,!1,t)},f.prototype.readInt32LE=function(e,t){return E(this,e,!0,t)},f.prototype.readInt32BE=function(e,t){return E(this,e,!1,t)},f.prototype.readFloatLE=function(e,t){return I(this,e,!0,t)},f.prototype.readFloatBE=function(e,t){return I(this,e,!1,t)},f.prototype.readDoubleLE=function(e,t){return A(this,e,!0,t)},f.prototype.readDoubleBE=function(e,t){return A(this,e,!1,t)},f.prototype.writeUInt8=function(e,t,n){n||(d(null!=e,"missing value"),d(null!=t,"missing offset"),d(t<this.length,"trying to write beyond buffer length"),Y(e,255)),t>=this.length||(this[t]=e)},f.prototype.writeUInt16LE=function(e,t,n){s(this,e,t,!0,n)},f.prototype.writeUInt16BE=function(e,t,n){s(this,e,t,!1,n)},f.prototype.writeUInt32LE=function(e,t,n){l(this,e,t,!0,n)},f.prototype.writeUInt32BE=function(e,t,n){l(this,e,t,!1,n)},f.prototype.writeInt8=function(e,t,n){n||(d(null!=e,"missing value"),d(null!=t,"missing offset"),d(t<this.length,"Trying to write beyond buffer length"),F(e,127,-128)),t>=this.length||(0<=e?this.writeUInt8(e,t,n):this.writeUInt8(255+e+1,t,n))},f.prototype.writeInt16LE=function(e,t,n){B(this,e,t,!0,n)},f.prototype.writeInt16BE=function(e,t,n){B(this,e,t,!1,n)},f.prototype.writeInt32LE=function(e,t,n){L(this,e,t,!0,n)},f.prototype.writeInt32BE=function(e,t,n){L(this,e,t,!1,n)},f.prototype.writeFloatLE=function(e,t,n){U(this,e,t,!0,n)},f.prototype.writeFloatBE=function(e,t,n){U(this,e,t,!1,n)},f.prototype.writeDoubleLE=function(e,t,n){x(this,e,t,!0,n)},f.prototype.writeDoubleBE=function(e,t,n){x(this,e,t,!1,n)},f.prototype.fill=function(e,t,n){if(t=t||0,n=n||this.length,d("number"==typeof(e="string"==typeof(e=e||0)?e.charCodeAt(0):e)&&!isNaN(e),"value is not a number"),d(t<=n,"end < start"),n!==t&&0!==this.length){d(0<=t&&t<this.length,"start out of bounds"),d(0<=n&&n<=this.length,"end out of bounds");for(var r=t;r<n;r++)this[r]=e}},f.prototype.inspect=function(){for(var e=[],t=this.length,n=0;n<t;n++)if(e[n]=k(this[n]),n===H.INSPECT_MAX_BYTES){e[n+1]="...";break}return"<Buffer "+e.join(" ")+">"},f.prototype.toArrayBuffer=function(){if("undefined"==typeof Uint8Array)throw new Error("Buffer.toArrayBuffer not supported in this browser");if(f._useTypedArrays)return new f(this).buffer;for(var e=new Uint8Array(this.length),t=0,n=e.length;t<n;t+=1)e[t]=this[t];return e.buffer};var t=f.prototype;function S(e,t,n){return"number"!=typeof e?n:t<=(e=~~e)?t:0<=e||0<=(e+=t)?e:0}function j(e){return(e=~~Math.ceil(+e))<0?0:e}function C(e){return(Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)})(e)}function k(e){return e<16?"0"+e.toString(16):e.toString(16)}function T(e){for(var t=[],n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<=127)t.push(e.charCodeAt(n));else for(var o=n,i=(55296<=r&&r<=57343&&n++,encodeURIComponent(e.slice(o,n+1)).substr(1).split("%")),u=0;u<i.length;u++)t.push(parseInt(i[u],16))}return t}function M(e){return a.toByteArray(e)}function c(e,t,n,r){for(var o=0;o<r&&!(o+n>=t.length||o>=e.length);o++)t[o+n]=e[o];return o}function N(e){try{return decodeURIComponent(e)}catch(e){return String.fromCharCode(65533)}}function Y(e,t){d("number"==typeof e,"cannot write a non-number as a number"),d(0<=e,"specified a negative value for writing an unsigned value"),d(e<=t,"value is larger than maximum value for type"),d(Math.floor(e)===e,"value has a fractional component")}function F(e,t,n){d("number"==typeof e,"cannot write a non-number as a number"),d(e<=t,"value larger than maximum allowed value"),d(n<=e,"value smaller than minimum allowed value"),d(Math.floor(e)===e,"value has a fractional component")}function D(e,t,n){d("number"==typeof e,"cannot write a non-number as a number"),d(e<=t,"value larger than maximum allowed value"),d(n<=e,"value smaller than minimum allowed value")}function d(e,t){if(!e)throw new Error(t||"Failed assertion")}f._augment=function(e){return e._isBuffer=!0,e._get=e.get,e._set=e.set,e.get=t.get,e.set=t.set,e.write=t.write,e.toString=t.toString,e.toLocaleString=t.toString,e.toJSON=t.toJSON,e.copy=t.copy,e.slice=t.slice,e.readUInt8=t.readUInt8,e.readUInt16LE=t.readUInt16LE,e.readUInt16BE=t.readUInt16BE,e.readUInt32LE=t.readUInt32LE,e.readUInt32BE=t.readUInt32BE,e.readInt8=t.readInt8,e.readInt16LE=t.readInt16LE,e.readInt16BE=t.readInt16BE,e.readInt32LE=t.readInt32LE,e.readInt32BE=t.readInt32BE,e.readFloatLE=t.readFloatLE,e.readFloatBE=t.readFloatBE,e.readDoubleLE=t.readDoubleLE,e.readDoubleBE=t.readDoubleBE,e.writeUInt8=t.writeUInt8,e.writeUInt16LE=t.writeUInt16LE,e.writeUInt16BE=t.writeUInt16BE,e.writeUInt32LE=t.writeUInt32LE,e.writeUInt32BE=t.writeUInt32BE,e.writeInt8=t.writeInt8,e.writeInt16LE=t.writeInt16LE,e.writeInt16BE=t.writeInt16BE,e.writeInt32LE=t.writeInt32LE,e.writeInt32BE=t.writeInt32BE,e.writeFloatLE=t.writeFloatLE,e.writeFloatBE=t.writeFloatBE,e.writeDoubleLE=t.writeDoubleLE,e.writeDoubleBE=t.writeDoubleBE,e.fill=t.fill,e.inspect=t.inspect,e.toArrayBuffer=t.toArrayBuffer,e}}.call(this,O("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},O("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/buffer")},{"base64-js":2,buffer:3,ieee754:10,lYpoI2:11}],4:[function(c,d,e){!function(e,t,a,n,r,o,i,u,s){var a=c("buffer").Buffer,f=4,l=new a(f);l.fill(0);d.exports={hash:function(e,t,n,r){for(var o=t(function(e,t){e.length%f!=0&&(n=e.length+(f-e.length%f),e=a.concat([e,l],n));for(var n,r=[],o=t?e.readInt32BE:e.readInt32LE,i=0;i<e.length;i+=f)r.push(o.call(e,i));return r}(e=a.isBuffer(e)?e:new a(e),r),8*e.length),t=r,i=new a(n),u=t?i.writeInt32BE:i.writeInt32LE,s=0;s<o.length;s++)u.call(i,o[s],4*s,!0);return i}}}.call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],5:[function(v,e,_){!function(l,c,u,d,h,p,g,y,w){var u=v("buffer").Buffer,e=v("./sha"),t=v("./sha256"),n=v("./rng"),b={sha1:e,sha256:t,md5:v("./md5")},s=64,a=new u(s);function r(e,n){var r=b[e=e||"sha1"],o=[];return r||i("algorithm:",e,"is not yet supported"),{update:function(e){return u.isBuffer(e)||(e=new u(e)),o.push(e),e.length,this},digest:function(e){var t=u.concat(o),t=n?function(e,t,n){u.isBuffer(t)||(t=new u(t)),u.isBuffer(n)||(n=new u(n)),t.length>s?t=e(t):t.length<s&&(t=u.concat([t,a],s));for(var r=new u(s),o=new u(s),i=0;i<s;i++)r[i]=54^t[i],o[i]=92^t[i];return n=e(u.concat([r,n])),e(u.concat([o,n]))}(r,n,t):r(t);return o=null,e?t.toString(e):t}}}function i(){var e=[].slice.call(arguments).join(" ");throw new Error([e,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join("\n"))}a.fill(0),_.createHash=function(e){return r(e)},_.createHmac=r,_.randomBytes=function(e,t){if(!t||!t.call)return new u(n(e));try{t.call(this,void 0,new u(n(e)))}catch(e){t(e)}};var o,f=["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],m=function(e){_[e]=function(){i("sorry,",e,"is not implemented yet")}};for(o in f)m(f[o],o)}.call(this,v("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},v("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,buffer:3,lYpoI2:11}],6:[function(w,b,e){!function(e,r,o,i,u,a,f,l,y){var t=w("./helpers");function n(e,t){e[t>>5]|=128<<t%32,e[14+(t+64>>>9<<4)]=t;for(var n=1732584193,r=-271733879,o=-1732584194,i=271733878,u=0;u<e.length;u+=16){var s=n,a=r,f=o,l=i,n=c(n,r,o,i,e[u+0],7,-680876936),i=c(i,n,r,o,e[u+1],12,-389564586),o=c(o,i,n,r,e[u+2],17,606105819),r=c(r,o,i,n,e[u+3],22,-1044525330);n=c(n,r,o,i,e[u+4],7,-176418897),i=c(i,n,r,o,e[u+5],12,1200080426),o=c(o,i,n,r,e[u+6],17,-1473231341),r=c(r,o,i,n,e[u+7],22,-45705983),n=c(n,r,o,i,e[u+8],7,1770035416),i=c(i,n,r,o,e[u+9],12,-1958414417),o=c(o,i,n,r,e[u+10],17,-42063),r=c(r,o,i,n,e[u+11],22,-1990404162),n=c(n,r,o,i,e[u+12],7,1804603682),i=c(i,n,r,o,e[u+13],12,-40341101),o=c(o,i,n,r,e[u+14],17,-1502002290),n=d(n,r=c(r,o,i,n,e[u+15],22,1236535329),o,i,e[u+1],5,-165796510),i=d(i,n,r,o,e[u+6],9,-1069501632),o=d(o,i,n,r,e[u+11],14,643717713),r=d(r,o,i,n,e[u+0],20,-373897302),n=d(n,r,o,i,e[u+5],5,-701558691),i=d(i,n,r,o,e[u+10],9,38016083),o=d(o,i,n,r,e[u+15],14,-660478335),r=d(r,o,i,n,e[u+4],20,-405537848),n=d(n,r,o,i,e[u+9],5,568446438),i=d(i,n,r,o,e[u+14],9,-1019803690),o=d(o,i,n,r,e[u+3],14,-187363961),r=d(r,o,i,n,e[u+8],20,1163531501),n=d(n,r,o,i,e[u+13],5,-1444681467),i=d(i,n,r,o,e[u+2],9,-51403784),o=d(o,i,n,r,e[u+7],14,1735328473),n=h(n,r=d(r,o,i,n,e[u+12],20,-1926607734),o,i,e[u+5],4,-378558),i=h(i,n,r,o,e[u+8],11,-2022574463),o=h(o,i,n,r,e[u+11],16,1839030562),r=h(r,o,i,n,e[u+14],23,-35309556),n=h(n,r,o,i,e[u+1],4,-1530992060),i=h(i,n,r,o,e[u+4],11,1272893353),o=h(o,i,n,r,e[u+7],16,-155497632),r=h(r,o,i,n,e[u+10],23,-1094730640),n=h(n,r,o,i,e[u+13],4,681279174),i=h(i,n,r,o,e[u+0],11,-358537222),o=h(o,i,n,r,e[u+3],16,-722521979),r=h(r,o,i,n,e[u+6],23,76029189),n=h(n,r,o,i,e[u+9],4,-640364487),i=h(i,n,r,o,e[u+12],11,-421815835),o=h(o,i,n,r,e[u+15],16,530742520),n=p(n,r=h(r,o,i,n,e[u+2],23,-995338651),o,i,e[u+0],6,-198630844),i=p(i,n,r,o,e[u+7],10,1126891415),o=p(o,i,n,r,e[u+14],15,-1416354905),r=p(r,o,i,n,e[u+5],21,-57434055),n=p(n,r,o,i,e[u+12],6,1700485571),i=p(i,n,r,o,e[u+3],10,-1894986606),o=p(o,i,n,r,e[u+10],15,-1051523),r=p(r,o,i,n,e[u+1],21,-2054922799),n=p(n,r,o,i,e[u+8],6,1873313359),i=p(i,n,r,o,e[u+15],10,-30611744),o=p(o,i,n,r,e[u+6],15,-1560198380),r=p(r,o,i,n,e[u+13],21,1309151649),n=p(n,r,o,i,e[u+4],6,-145523070),i=p(i,n,r,o,e[u+11],10,-1120210379),o=p(o,i,n,r,e[u+2],15,718787259),r=p(r,o,i,n,e[u+9],21,-343485551),n=g(n,s),r=g(r,a),o=g(o,f),i=g(i,l)}return Array(n,r,o,i)}function s(e,t,n,r,o,i){return g((t=g(g(t,e),g(r,i)))<<o|t>>>32-o,n)}function c(e,t,n,r,o,i,u){return s(t&n|~t&r,e,t,o,i,u)}function d(e,t,n,r,o,i,u){return s(t&r|n&~r,e,t,o,i,u)}function h(e,t,n,r,o,i,u){return s(t^n^r,e,t,o,i,u)}function p(e,t,n,r,o,i,u){return s(n^(t|~r),e,t,o,i,u)}function g(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}b.exports=function(e){return t.hash(e,n,16)}}.call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],7:[function(e,l,t){!function(e,t,n,r,o,i,u,s,f){var a;l.exports=a||function(e){for(var t,n=new Array(e),r=0;r<e;r++)0==(3&r)&&(t=4294967296*Math.random()),n[r]=t>>>((3&r)<<3)&255;return n}}.call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],8:[function(c,d,e){!function(e,t,n,r,o,s,a,f,l){var i=c("./helpers");function u(l,c){l[c>>5]|=128<<24-c%32,l[15+(c+64>>9<<4)]=c;for(var e,t,n,r=Array(80),o=1732584193,i=-271733879,u=-1732584194,s=271733878,d=-1009589776,h=0;h<l.length;h+=16){for(var p=o,g=i,y=u,w=s,b=d,a=0;a<80;a++){r[a]=a<16?l[h+a]:v(r[a-3]^r[a-8]^r[a-14]^r[a-16],1);var f=m(m(v(o,5),(f=i,t=u,n=s,(e=a)<20?f&t|~f&n:!(e<40)&&e<60?f&t|f&n|t&n:f^t^n)),m(m(d,r[a]),(e=a)<20?1518500249:e<40?1859775393:e<60?-1894007588:-899497514)),d=s,s=u,u=v(i,30),i=o,o=f}o=m(o,p),i=m(i,g),u=m(u,y),s=m(s,w),d=m(d,b)}return Array(o,i,u,s,d)}function m(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function v(e,t){return e<<t|e>>>32-t}d.exports=function(e){return i.hash(e,u,20,!0)}}.call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],9:[function(c,d,e){!function(e,t,n,r,u,s,a,f,l){function b(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function o(e,l){var c,d=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),t=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),n=new Array(64);e[l>>5]|=128<<24-l%32,e[15+(l+64>>9<<4)]=l;for(var r,o,h=0;h<e.length;h+=16){for(var i=t[0],u=t[1],s=t[2],p=t[3],a=t[4],g=t[5],y=t[6],w=t[7],f=0;f<64;f++)n[f]=f<16?e[f+h]:b(b(b((o=n[f-2],m(o,17)^m(o,19)^v(o,10)),n[f-7]),(o=n[f-15],m(o,7)^m(o,18)^v(o,3))),n[f-16]),c=b(b(b(b(w,m(o=a,6)^m(o,11)^m(o,25)),a&g^~a&y),d[f]),n[f]),r=b(m(r=i,2)^m(r,13)^m(r,22),i&u^i&s^u&s),w=y,y=g,g=a,a=b(p,c),p=s,s=u,u=i,i=b(c,r);t[0]=b(i,t[0]),t[1]=b(u,t[1]),t[2]=b(s,t[2]),t[3]=b(p,t[3]),t[4]=b(a,t[4]),t[5]=b(g,t[5]),t[6]=b(y,t[6]),t[7]=b(w,t[7])}return t}var i=c("./helpers"),m=function(e,t){return e>>>t|e<<32-t},v=function(e,t){return e>>>t};d.exports=function(e){return i.hash(e,o,32,!0)}}.call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],10:[function(e,t,f){!function(e,t,n,r,o,i,u,s,a){f.read=function(e,t,n,r,o){var i,u,l=8*o-r-1,c=(1<<l)-1,d=c>>1,s=-7,a=n?o-1:0,f=n?-1:1,o=e[t+a];for(a+=f,i=o&(1<<-s)-1,o>>=-s,s+=l;0<s;i=256*i+e[t+a],a+=f,s-=8);for(u=i&(1<<-s)-1,i>>=-s,s+=r;0<s;u=256*u+e[t+a],a+=f,s-=8);if(0===i)i=1-d;else{if(i===c)return u?NaN:1/0*(o?-1:1);u+=Math.pow(2,r),i-=d}return(o?-1:1)*u*Math.pow(2,i-r)},f.write=function(e,t,l,n,r,c){var o,i,u=8*c-r-1,s=(1<<u)-1,a=s>>1,d=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:c-1,h=n?1:-1,c=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(i=isNaN(t)?1:0,o=s):(o=Math.floor(Math.log(t)/Math.LN2),t*(n=Math.pow(2,-o))<1&&(o--,n*=2),2<=(t+=1<=o+a?d/n:d*Math.pow(2,1-a))*n&&(o++,n/=2),s<=o+a?(i=0,o=s):1<=o+a?(i=(t*n-1)*Math.pow(2,r),o+=a):(i=t*Math.pow(2,a-1)*Math.pow(2,r),o=0));8<=r;e[l+f]=255&i,f+=h,i/=256,r-=8);for(o=o<<r|i,u+=r;0<u;e[l+f]=255&o,f+=h,o/=256,u-=8);e[l+f-h]|=128*c}}.call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/ieee754/index.js","/node_modules/gulp-browserify/node_modules/ieee754")},{buffer:3,lYpoI2:11}],11:[function(e,h,t){!function(e,t,n,r,o,f,l,c,d){var i,u,s;function a(){}(e=h.exports={}).nextTick=(u="undefined"!=typeof window&&window.setImmediate,s="undefined"!=typeof window&&window.postMessage&&window.addEventListener,u?function(e){return window.setImmediate(e)}:s?(i=[],window.addEventListener("message",function(e){var t=e.source;t!==window&&null!==t||"process-tick"!==e.data||(e.stopPropagation(),0<i.length&&i.shift()())},!0),function(e){i.push(e),window.postMessage("process-tick","*")}):function(e){setTimeout(e,0)}),e.title="browser",e.browser=!0,e.env={},e.argv=[],e.on=a,e.addListener=a,e.once=a,e.off=a,e.removeListener=a,e.removeAllListeners=a,e.emit=a,e.binding=function(e){throw new Error("process.binding is not supported")},e.cwd=function(){return"/"},e.chdir=function(e){throw new Error("process.chdir is not supported")}}.call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/process")},{buffer:3,lYpoI2:11}]},{},[1])(1)});
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = function (collection) {
  var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var numItems = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;

  if (!Array.isArray(collection)) {
    throw "Expect array and got " + (typeof collection === "undefined" ? "undefined" : _typeof(collection));
  }
  var currentPage = parseInt(page);
  var perPage = parseInt(numItems);
  var offset = (page - 1) * perPage;
  var paginatedItems = collection.slice(offset, offset + perPage);

  return {
    currentPage: currentPage,
    perPage: perPage,
    total: collection.length,
    totalPages: Math.ceil(collection.length / perPage),
    data: paginatedItems
  };
};

module.exports = exports["default"];
},{}],108:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":111}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*!
  * PhotoSwipe 5.4.4 - https://photoswipe.com
  * (c) 2024 Dmytro Semenov
  */
/** @typedef {import('../photoswipe.js').Point} Point */

/**
 * @template {keyof HTMLElementTagNameMap} T
 * @param {string} className
 * @param {T} tagName
 * @param {Node} [appendToEl]
 * @returns {HTMLElementTagNameMap[T]}
 */
function createElement(className, tagName, appendToEl) {
  var el = document.createElement(tagName);
  if (className) {
    el.className = className;
  }
  if (appendToEl) {
    appendToEl.appendChild(el);
  }
  return el;
}
/**
 * @param {Point} p1
 * @param {Point} p2
 * @returns {Point}
 */

function equalizePoints(p1, p2) {
  p1.x = p2.x;
  p1.y = p2.y;
  if (p2.id !== undefined) {
    p1.id = p2.id;
  }
  return p1;
}
/**
 * @param {Point} p
 */

function roundPoint(p) {
  p.x = Math.round(p.x);
  p.y = Math.round(p.y);
}
/**
 * Returns distance between two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 * @returns {number}
 */

function getDistanceBetween(p1, p2) {
  var x = Math.abs(p1.x - p2.x);
  var y = Math.abs(p1.y - p2.y);
  return Math.sqrt(x * x + y * y);
}
/**
 * Whether X and Y positions of points are equal
 *
 * @param {Point} p1
 * @param {Point} p2
 * @returns {boolean}
 */

function pointsEqual(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
/**
 * The float result between the min and max values.
 *
 * @param {number} val
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */

function clamp(val, min, max) {
  return Math.min(Math.max(val, min), max);
}
/**
 * Get transform string
 *
 * @param {number} x
 * @param {number} [y]
 * @param {number} [scale]
 * @returns {string}
 */

function toTransformString(x, y, scale) {
  var propValue = "translate3d(".concat(x, "px,").concat(y || 0, "px,0)");
  if (scale !== undefined) {
    propValue += " scale3d(".concat(scale, ",").concat(scale, ",1)");
  }
  return propValue;
}
/**
 * Apply transform:translate(x, y) scale(scale) to element
 *
 * @param {HTMLElement} el
 * @param {number} x
 * @param {number} [y]
 * @param {number} [scale]
 */

function setTransform(el, x, y, scale) {
  el.style.transform = toTransformString(x, y, scale);
}
var defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';
/**
 * Apply CSS transition to element
 *
 * @param {HTMLElement} el
 * @param {string} [prop] CSS property to animate
 * @param {number} [duration] in ms
 * @param {string} [ease] CSS easing function
 */

function setTransitionStyle(el, prop, duration, ease) {
  // inOut: 'cubic-bezier(.4, 0, .22, 1)', // for "toggle state" transitions
  // out: 'cubic-bezier(0, 0, .22, 1)', // for "show" transitions
  // in: 'cubic-bezier(.4, 0, 1, 1)'// for "hide" transitions
  el.style.transition = prop ? "".concat(prop, " ").concat(duration, "ms ").concat(ease || defaultCSSEasing) : 'none';
}
/**
 * Apply width and height CSS properties to element
 *
 * @param {HTMLElement} el
 * @param {string | number} w
 * @param {string | number} h
 */

function setWidthHeight(el, w, h) {
  el.style.width = typeof w === 'number' ? "".concat(w, "px") : w;
  el.style.height = typeof h === 'number' ? "".concat(h, "px") : h;
}
/**
 * @param {HTMLElement} el
 */

function removeTransitionStyle(el) {
  setTransitionStyle(el);
}
/**
 * @param {HTMLImageElement} img
 * @returns {Promise<HTMLImageElement | void>}
 */

function decodeImage(img) {
  if ('decode' in img) {
    return img.decode()["catch"](function () {});
  }
  if (img.complete) {
    return Promise.resolve(img);
  }
  return new Promise(function (resolve, reject) {
    img.onload = function () {
      return resolve(img);
    };
    img.onerror = reject;
  });
}
/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */

/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */

var LOAD_STATE = {
  IDLE: 'idle',
  LOADING: 'loading',
  LOADED: 'loaded',
  ERROR: 'error'
};
/**
 * Check if click or keydown event was dispatched
 * with a special key or via mouse wheel.
 *
 * @param {MouseEvent | KeyboardEvent} e
 * @returns {boolean}
 */

function specialKeyUsed(e) {
  return 'button' in e && e.button === 1 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;
}
/**
 * Parse `gallery` or `children` options.
 *
 * @param {import('../photoswipe.js').ElementProvider} [option]
 * @param {string} [legacySelector]
 * @param {HTMLElement | Document} [parent]
 * @returns HTMLElement[]
 */

function getElementsFromOption(option, legacySelector) {
  var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
  /** @type {HTMLElement[]} */
  var elements = [];
  if (option instanceof Element) {
    elements = [option];
  } else if (option instanceof NodeList || Array.isArray(option)) {
    elements = Array.from(option);
  } else {
    var selector = typeof option === 'string' ? option : legacySelector;
    if (selector) {
      elements = Array.from(parent.querySelectorAll(selector));
    }
  }
  return elements;
}
/**
 * Check if browser is Safari
 *
 * @returns {boolean}
 */

function isSafari() {
  return !!(navigator.vendor && navigator.vendor.match(/apple/i));
}

// Detect passive event listener support
var supportsPassive = false;
/* eslint-disable */

try {
  /* @ts-ignore */
  window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
    get: function get() {
      supportsPassive = true;
    }
  }));
} catch (e) {}
/* eslint-enable */

/**
 * @typedef {Object} PoolItem
 * @prop {HTMLElement | Window | Document | undefined | null} target
 * @prop {string} type
 * @prop {EventListenerOrEventListenerObject} listener
 * @prop {boolean} [passive]
 */
var DOMEvents = /*#__PURE__*/function () {
  function DOMEvents() {
    _classCallCheck(this, DOMEvents);
    /**
     * @type {PoolItem[]}
     * @private
     */
    this._pool = [];
  }
  /**
   * Adds event listeners
   *
   * @param {PoolItem['target']} target
   * @param {PoolItem['type']} type Can be multiple, separated by space.
   * @param {PoolItem['listener']} listener
   * @param {PoolItem['passive']} [passive]
   */
  return _createClass(DOMEvents, [{
    key: "add",
    value: function add(target, type, listener, passive) {
      this._toggleListener(target, type, listener, passive);
    }
    /**
     * Removes event listeners
     *
     * @param {PoolItem['target']} target
     * @param {PoolItem['type']} type
     * @param {PoolItem['listener']} listener
     * @param {PoolItem['passive']} [passive]
     */
  }, {
    key: "remove",
    value: function remove(target, type, listener, passive) {
      this._toggleListener(target, type, listener, passive, true);
    }
    /**
     * Removes all bound events
     */
  }, {
    key: "removeAll",
    value: function removeAll() {
      var _this = this;
      this._pool.forEach(function (poolItem) {
        _this._toggleListener(poolItem.target, poolItem.type, poolItem.listener, poolItem.passive, true, true);
      });
      this._pool = [];
    }
    /**
     * Adds or removes event
     *
     * @private
     * @param {PoolItem['target']} target
     * @param {PoolItem['type']} type
     * @param {PoolItem['listener']} listener
     * @param {PoolItem['passive']} [passive]
     * @param {boolean} [unbind] Whether the event should be added or removed
     * @param {boolean} [skipPool] Whether events pool should be skipped
     */
  }, {
    key: "_toggleListener",
    value: function _toggleListener(target, type, listener, passive, unbind, skipPool) {
      var _this2 = this;
      if (!target) {
        return;
      }
      var methodName = unbind ? 'removeEventListener' : 'addEventListener';
      var types = type.split(' ');
      types.forEach(function (eType) {
        if (eType) {
          // Events pool is used to easily unbind all events when PhotoSwipe is closed,
          // so developer doesn't need to do this manually
          if (!skipPool) {
            if (unbind) {
              // Remove from the events pool
              _this2._pool = _this2._pool.filter(function (poolItem) {
                return poolItem.type !== eType || poolItem.listener !== listener || poolItem.target !== target;
              });
            } else {
              // Add to the events pool
              _this2._pool.push({
                target: target,
                type: eType,
                listener: listener,
                passive: passive
              });
            }
          } // most PhotoSwipe events call preventDefault,
          // and we do not need browser to scroll the page

          var eventOptions = supportsPassive ? {
            passive: passive || false
          } : false;
          target[methodName](eType, listener, eventOptions);
        }
      });
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('../slide/slide.js').SlideData} SlideData */
/**
 * @param {PhotoSwipeOptions} options
 * @param {PhotoSwipeBase} pswp
 * @returns {Point}
 */
function getViewportSize(options, pswp) {
  if (options.getViewportSizeFn) {
    var newViewportSize = options.getViewportSizeFn(options, pswp);
    if (newViewportSize) {
      return newViewportSize;
    }
  }
  return {
    x: document.documentElement.clientWidth,
    // TODO: height on mobile is very incosistent due to toolbar
    // find a way to improve this
    //
    // document.documentElement.clientHeight - doesn't seem to work well
    y: window.innerHeight
  };
}
/**
 * Parses padding option.
 * Supported formats:
 *
 * // Object
 * padding: {
 *  top: 0,
 *  bottom: 0,
 *  left: 0,
 *  right: 0
 * }
 *
 * // A function that returns the object
 * paddingFn: (viewportSize, itemData, index) => {
 *  return {
 *    top: 0,
 *    bottom: 0,
 *    left: 0,
 *    right: 0
 *  };
 * }
 *
 * // Legacy variant
 * paddingLeft: 0,
 * paddingRight: 0,
 * paddingTop: 0,
 * paddingBottom: 0,
 *
 * @param {'left' | 'top' | 'bottom' | 'right'} prop
 * @param {PhotoSwipeOptions} options PhotoSwipe options
 * @param {Point} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }
 * @param {SlideData} itemData Data about the slide
 * @param {number} index Slide index
 * @returns {number}
 */

function parsePaddingOption(prop, options, viewportSize, itemData, index) {
  var paddingValue = 0;
  if (options.paddingFn) {
    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];
  } else if (options.padding) {
    paddingValue = options.padding[prop];
  } else {
    var legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1); // @ts-expect-error

    if (options[legacyPropName]) {
      // @ts-expect-error
      paddingValue = options[legacyPropName];
    }
  }
  return Number(paddingValue) || 0;
}
/**
 * @param {PhotoSwipeOptions} options
 * @param {Point} viewportSize
 * @param {SlideData} itemData
 * @param {number} index
 * @returns {Point}
 */

function getPanAreaSize(options, viewportSize, itemData, index) {
  return {
    x: viewportSize.x - parsePaddingOption('left', options, viewportSize, itemData, index) - parsePaddingOption('right', options, viewportSize, itemData, index),
    y: viewportSize.y - parsePaddingOption('top', options, viewportSize, itemData, index) - parsePaddingOption('bottom', options, viewportSize, itemData, index)
  };
}

/** @typedef {import('./slide.js').default} Slide */

/** @typedef {Record<Axis, number>} Point */

/** @typedef {'x' | 'y'} Axis */

/**
 * Calculates minimum, maximum and initial (center) bounds of a slide
 */
var PanBounds = /*#__PURE__*/function () {
  /**
   * @param {Slide} slide
   */
  function PanBounds(slide) {
    _classCallCheck(this, PanBounds);
    this.slide = slide;
    this.currZoomLevel = 1;
    this.center = /** @type {Point} */
    {
      x: 0,
      y: 0
    };
    this.max = /** @type {Point} */
    {
      x: 0,
      y: 0
    };
    this.min = /** @type {Point} */
    {
      x: 0,
      y: 0
    };
  }
  /**
   * _getItemBounds
   *
   * @param {number} currZoomLevel
   */
  return _createClass(PanBounds, [{
    key: "update",
    value: function update(currZoomLevel) {
      this.currZoomLevel = currZoomLevel;
      if (!this.slide.width) {
        this.reset();
      } else {
        this._updateAxis('x');
        this._updateAxis('y');
        this.slide.pswp.dispatch('calcBounds', {
          slide: this.slide
        });
      }
    }
    /**
     * _calculateItemBoundsForAxis
     *
     * @param {Axis} axis
     */
  }, {
    key: "_updateAxis",
    value: function _updateAxis(axis) {
      var pswp = this.slide.pswp;
      var elSize = this.slide[axis === 'x' ? 'width' : 'height'] * this.currZoomLevel;
      var paddingProp = axis === 'x' ? 'left' : 'top';
      var padding = parsePaddingOption(paddingProp, pswp.options, pswp.viewportSize, this.slide.data, this.slide.index);
      var panAreaSize = this.slide.panAreaSize[axis]; // Default position of element.
      // By default, it is center of viewport:

      this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding; // maximum pan position

      this.max[axis] = elSize > panAreaSize ? Math.round(panAreaSize - elSize) + padding : this.center[axis]; // minimum pan position

      this.min[axis] = elSize > panAreaSize ? padding : this.center[axis];
    } // _getZeroBounds
  }, {
    key: "reset",
    value: function reset() {
      this.center.x = 0;
      this.center.y = 0;
      this.max.x = 0;
      this.max.y = 0;
      this.min.x = 0;
      this.min.y = 0;
    }
    /**
     * Correct pan position if it's beyond the bounds
     *
     * @param {Axis} axis x or y
     * @param {number} panOffset
     * @returns {number}
     */
  }, {
    key: "correctPan",
    value: function correctPan(axis, panOffset) {
      // checkPanBounds
      return clamp(panOffset, this.max[axis], this.min[axis]);
    }
  }]);
}();
var MAX_IMAGE_WIDTH = 4000;
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */

/** @typedef {import('../photoswipe.js').Point} Point */

/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */

/**
 * Calculates zoom levels for specific slide.
 * Depends on viewport size and image size.
 */
var ZoomLevel = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipeOptions} options PhotoSwipe options
   * @param {SlideData} itemData Slide data
   * @param {number} index Slide index
   * @param {PhotoSwipe} [pswp] PhotoSwipe instance, can be undefined if not initialized yet
   */
  function ZoomLevel(options, itemData, index, pswp) {
    _classCallCheck(this, ZoomLevel);
    this.pswp = pswp;
    this.options = options;
    this.itemData = itemData;
    this.index = index;
    /** @type { Point | null } */

    this.panAreaSize = null;
    /** @type { Point | null } */

    this.elementSize = null;
    this.fit = 1;
    this.fill = 1;
    this.vFill = 1;
    this.initial = 1;
    this.secondary = 1;
    this.max = 1;
    this.min = 1;
  }
  /**
   * Calculate initial, secondary and maximum zoom level for the specified slide.
   *
   * It should be called when either image or viewport size changes.
   *
   * @param {number} maxWidth
   * @param {number} maxHeight
   * @param {Point} panAreaSize
   */
  return _createClass(ZoomLevel, [{
    key: "update",
    value: function update(maxWidth, maxHeight, panAreaSize) {
      /** @type {Point} */
      var elementSize = {
        x: maxWidth,
        y: maxHeight
      };
      this.elementSize = elementSize;
      this.panAreaSize = panAreaSize;
      var hRatio = panAreaSize.x / elementSize.x;
      var vRatio = panAreaSize.y / elementSize.y;
      this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);
      this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio); // zoom.vFill defines zoom level of the image
      // when it has 100% of viewport vertical space (height)

      this.vFill = Math.min(1, vRatio);
      this.initial = this._getInitial();
      this.secondary = this._getSecondary();
      this.max = Math.max(this.initial, this.secondary, this._getMax());
      this.min = Math.min(this.fit, this.initial, this.secondary);
      if (this.pswp) {
        this.pswp.dispatch('zoomLevelsUpdate', {
          zoomLevels: this,
          slideData: this.itemData
        });
      }
    }
    /**
     * Parses user-defined zoom option.
     *
     * @private
     * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)
     * @returns { number | undefined }
     */
  }, {
    key: "_parseZoomLevelOption",
    value: function _parseZoomLevelOption(optionPrefix) {
      var optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */
      optionPrefix + 'ZoomLevel';
      var optionValue = this.options[optionName];
      if (!optionValue) {
        return;
      }
      if (typeof optionValue === 'function') {
        return optionValue(this);
      }
      if (optionValue === 'fill') {
        return this.fill;
      }
      if (optionValue === 'fit') {
        return this.fit;
      }
      return Number(optionValue);
    }
    /**
     * Get zoom level to which image will be zoomed after double-tap gesture,
     * or when user clicks on zoom icon,
     * or mouse-click on image itself.
     * If you return 1 image will be zoomed to its original size.
     *
     * @private
     * @return {number}
     */
  }, {
    key: "_getSecondary",
    value: function _getSecondary() {
      var currZoomLevel = this._parseZoomLevelOption('secondary');
      if (currZoomLevel) {
        return currZoomLevel;
      } // 3x of "fit" state, but not larger than original

      currZoomLevel = Math.min(1, this.fit * 3);
      if (this.elementSize && currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {
        currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;
      }
      return currZoomLevel;
    }
    /**
     * Get initial image zoom level.
     *
     * @private
     * @return {number}
     */
  }, {
    key: "_getInitial",
    value: function _getInitial() {
      return this._parseZoomLevelOption('initial') || this.fit;
    }
    /**
     * Maximum zoom level when user zooms
     * via zoom/pinch gesture,
     * via cmd/ctrl-wheel or via trackpad.
     *
     * @private
     * @return {number}
     */
  }, {
    key: "_getMax",
    value: function _getMax() {
      // max zoom level is x4 from "fit state",
      // used for zoom gesture and ctrl/trackpad zoom
      return this._parseZoomLevelOption('max') || Math.max(1, this.fit * 4);
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/**
 * Renders and allows to control a single slide
 */
var Slide = /*#__PURE__*/function () {
  /**
   * @param {SlideData} data
   * @param {number} index
   * @param {PhotoSwipe} pswp
   */
  function Slide(data, index, pswp) {
    _classCallCheck(this, Slide);
    this.data = data;
    this.index = index;
    this.pswp = pswp;
    this.isActive = index === pswp.currIndex;
    this.currentResolution = 0;
    /** @type {Point} */

    this.panAreaSize = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.pan = {
      x: 0,
      y: 0
    };
    this.isFirstSlide = this.isActive && !pswp.opener.isOpen;
    this.zoomLevels = new ZoomLevel(pswp.options, data, index, pswp);
    this.pswp.dispatch('gettingData', {
      slide: this,
      data: this.data,
      index: index
    });
    this.content = this.pswp.contentLoader.getContentBySlide(this);
    this.container = createElement('pswp__zoom-wrap', 'div');
    /** @type {HTMLElement | null} */

    this.holderElement = null;
    this.currZoomLevel = 1;
    /** @type {number} */

    this.width = this.content.width;
    /** @type {number} */

    this.height = this.content.height;
    this.heavyAppended = false;
    this.bounds = new PanBounds(this);
    this.prevDisplayedWidth = -1;
    this.prevDisplayedHeight = -1;
    this.pswp.dispatch('slideInit', {
      slide: this
    });
  }
  /**
   * If this slide is active/current/visible
   *
   * @param {boolean} isActive
   */
  return _createClass(Slide, [{
    key: "setIsActive",
    value: function setIsActive(isActive) {
      if (isActive && !this.isActive) {
        // slide just became active
        this.activate();
      } else if (!isActive && this.isActive) {
        // slide just became non-active
        this.deactivate();
      }
    }
    /**
     * Appends slide content to DOM
     *
     * @param {HTMLElement} holderElement
     */
  }, {
    key: "append",
    value: function append(holderElement) {
      this.holderElement = holderElement;
      this.container.style.transformOrigin = '0 0'; // Slide appended to DOM

      if (!this.data) {
        return;
      }
      this.calculateSize();
      this.load();
      this.updateContentSize();
      this.appendHeavy();
      this.holderElement.appendChild(this.container);
      this.zoomAndPanToInitial();
      this.pswp.dispatch('firstZoomPan', {
        slide: this
      });
      this.applyCurrentZoomPan();
      this.pswp.dispatch('afterSetContent', {
        slide: this
      });
      if (this.isActive) {
        this.activate();
      }
    }
  }, {
    key: "load",
    value: function load() {
      this.content.load(false);
      this.pswp.dispatch('slideLoad', {
        slide: this
      });
    }
    /**
     * Append "heavy" DOM elements
     *
     * This may depend on a type of slide,
     * but generally these are large images.
     */
  }, {
    key: "appendHeavy",
    value: function appendHeavy() {
      var pswp = this.pswp;
      var appendHeavyNearby = true; // todo
      // Avoid appending heavy elements during animations

      if (this.heavyAppended || !pswp.opener.isOpen || pswp.mainScroll.isShifted() || !this.isActive && !appendHeavyNearby) {
        return;
      }
      if (this.pswp.dispatch('appendHeavy', {
        slide: this
      }).defaultPrevented) {
        return;
      }
      this.heavyAppended = true;
      this.content.append();
      this.pswp.dispatch('appendHeavyContent', {
        slide: this
      });
    }
    /**
     * Triggered when this slide is active (selected).
     *
     * If it's part of opening/closing transition -
     * activate() will trigger after the transition is ended.
     */
  }, {
    key: "activate",
    value: function activate() {
      this.isActive = true;
      this.appendHeavy();
      this.content.activate();
      this.pswp.dispatch('slideActivate', {
        slide: this
      });
    }
    /**
     * Triggered when this slide becomes inactive.
     *
     * Slide can become inactive only after it was active.
     */
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.isActive = false;
      this.content.deactivate();
      if (this.currZoomLevel !== this.zoomLevels.initial) {
        // allow filtering
        this.calculateSize();
      } // reset zoom level

      this.currentResolution = 0;
      this.zoomAndPanToInitial();
      this.applyCurrentZoomPan();
      this.updateContentSize();
      this.pswp.dispatch('slideDeactivate', {
        slide: this
      });
    }
    /**
     * The slide should destroy itself, it will never be used again.
     * (unbind all events and destroy internal components)
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.content.hasSlide = false;
      this.content.remove();
      this.container.remove();
      this.pswp.dispatch('slideDestroy', {
        slide: this
      });
    }
  }, {
    key: "resize",
    value: function resize() {
      if (this.currZoomLevel === this.zoomLevels.initial || !this.isActive) {
        // Keep initial zoom level if it was before the resize,
        // as well as when this slide is not active
        // Reset position and scale to original state
        this.calculateSize();
        this.currentResolution = 0;
        this.zoomAndPanToInitial();
        this.applyCurrentZoomPan();
        this.updateContentSize();
      } else {
        // readjust pan position if it's beyond the bounds
        this.calculateSize();
        this.bounds.update(this.currZoomLevel);
        this.panTo(this.pan.x, this.pan.y);
      }
    }
    /**
     * Apply size to current slide content,
     * based on the current resolution and scale.
     *
     * @param {boolean} [force] if size should be updated even if dimensions weren't changed
     */
  }, {
    key: "updateContentSize",
    value: function updateContentSize(force) {
      // Use initial zoom level
      // if resolution is not defined (user didn't zoom yet)
      var scaleMultiplier = this.currentResolution || this.zoomLevels.initial;
      if (!scaleMultiplier) {
        return;
      }
      var width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x;
      var height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;
      if (!this.sizeChanged(width, height) && !force) {
        return;
      }
      this.content.setDisplayedSize(width, height);
    }
    /**
     * @param {number} width
     * @param {number} height
     */
  }, {
    key: "sizeChanged",
    value: function sizeChanged(width, height) {
      if (width !== this.prevDisplayedWidth || height !== this.prevDisplayedHeight) {
        this.prevDisplayedWidth = width;
        this.prevDisplayedHeight = height;
        return true;
      }
      return false;
    }
    /** @returns {HTMLImageElement | HTMLDivElement | null | undefined} */
  }, {
    key: "getPlaceholderElement",
    value: function getPlaceholderElement() {
      var _this$content$placeho;
      return (_this$content$placeho = this.content.placeholder) === null || _this$content$placeho === void 0 ? void 0 : _this$content$placeho.element;
    }
    /**
     * Zoom current slide image to...
     *
     * @param {number} destZoomLevel Destination zoom level.
     * @param {Point} [centerPoint]
     * Transform origin center point, or false if viewport center should be used.
     * @param {number | false} [transitionDuration] Transition duration, may be set to 0.
     * @param {boolean} [ignoreBounds] Minimum and maximum zoom levels will be ignored.
     */
  }, {
    key: "zoomTo",
    value: function zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {
      var _this3 = this;
      var pswp = this.pswp;
      if (!this.isZoomable() || pswp.mainScroll.isShifted()) {
        return;
      }
      pswp.dispatch('beforeZoomTo', {
        destZoomLevel: destZoomLevel,
        centerPoint: centerPoint,
        transitionDuration: transitionDuration
      }); // stop all pan and zoom transitions

      pswp.animations.stopAllPan(); // if (!centerPoint) {
      //   centerPoint = pswp.getViewportCenterPoint();
      // }

      var prevZoomLevel = this.currZoomLevel;
      if (!ignoreBounds) {
        destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max);
      } // if (transitionDuration === undefined) {
      //   transitionDuration = this.pswp.options.zoomAnimationDuration;
      // }

      this.setZoomLevel(destZoomLevel);
      this.pan.x = this.calculateZoomToPanOffset('x', centerPoint, prevZoomLevel);
      this.pan.y = this.calculateZoomToPanOffset('y', centerPoint, prevZoomLevel);
      roundPoint(this.pan);
      var finishTransition = function finishTransition() {
        _this3._setResolution(destZoomLevel);
        _this3.applyCurrentZoomPan();
      };
      if (!transitionDuration) {
        finishTransition();
      } else {
        pswp.animations.startTransition({
          isPan: true,
          name: 'zoomTo',
          target: this.container,
          transform: this.getCurrentTransform(),
          onComplete: finishTransition,
          duration: transitionDuration,
          easing: pswp.options.easing
        });
      }
    }
    /**
     * @param {Point} [centerPoint]
     */
  }, {
    key: "toggleZoom",
    value: function toggleZoom(centerPoint) {
      this.zoomTo(this.currZoomLevel === this.zoomLevels.initial ? this.zoomLevels.secondary : this.zoomLevels.initial, centerPoint, this.pswp.options.zoomAnimationDuration);
    }
    /**
     * Updates zoom level property and recalculates new pan bounds,
     * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)
     *
     * @param {number} currZoomLevel
     */
  }, {
    key: "setZoomLevel",
    value: function setZoomLevel(currZoomLevel) {
      this.currZoomLevel = currZoomLevel;
      this.bounds.update(this.currZoomLevel);
    }
    /**
     * Get pan position after zoom at a given `point`.
     *
     * Always call setZoomLevel(newZoomLevel) beforehand to recalculate
     * pan bounds according to the new zoom level.
     *
     * @param {'x' | 'y'} axis
     * @param {Point} [point]
     * point based on which zoom is performed, usually refers to the current mouse position,
     * if false - viewport center will be used.
     * @param {number} [prevZoomLevel] Zoom level before new zoom was applied.
     * @returns {number}
     */
  }, {
    key: "calculateZoomToPanOffset",
    value: function calculateZoomToPanOffset(axis, point, prevZoomLevel) {
      var totalPanDistance = this.bounds.max[axis] - this.bounds.min[axis];
      if (totalPanDistance === 0) {
        return this.bounds.center[axis];
      }
      if (!point) {
        point = this.pswp.getViewportCenterPoint();
      }
      if (!prevZoomLevel) {
        prevZoomLevel = this.zoomLevels.initial;
      }
      var zoomFactor = this.currZoomLevel / prevZoomLevel;
      return this.bounds.correctPan(axis, (this.pan[axis] - point[axis]) * zoomFactor + point[axis]);
    }
    /**
     * Apply pan and keep it within bounds.
     *
     * @param {number} panX
     * @param {number} panY
     */
  }, {
    key: "panTo",
    value: function panTo(panX, panY) {
      this.pan.x = this.bounds.correctPan('x', panX);
      this.pan.y = this.bounds.correctPan('y', panY);
      this.applyCurrentZoomPan();
    }
    /**
     * If the slide in the current state can be panned by the user
     * @returns {boolean}
     */
  }, {
    key: "isPannable",
    value: function isPannable() {
      return Boolean(this.width) && this.currZoomLevel > this.zoomLevels.fit;
    }
    /**
     * If the slide can be zoomed
     * @returns {boolean}
     */
  }, {
    key: "isZoomable",
    value: function isZoomable() {
      return Boolean(this.width) && this.content.isZoomable();
    }
    /**
     * Apply transform and scale based on
     * the current pan position (this.pan) and zoom level (this.currZoomLevel)
     */
  }, {
    key: "applyCurrentZoomPan",
    value: function applyCurrentZoomPan() {
      this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel);
      if (this === this.pswp.currSlide) {
        this.pswp.dispatch('zoomPanUpdate', {
          slide: this
        });
      }
    }
  }, {
    key: "zoomAndPanToInitial",
    value: function zoomAndPanToInitial() {
      this.currZoomLevel = this.zoomLevels.initial; // pan according to the zoom level

      this.bounds.update(this.currZoomLevel);
      equalizePoints(this.pan, this.bounds.center);
      this.pswp.dispatch('initialZoomPan', {
        slide: this
      });
    }
    /**
     * Set translate and scale based on current resolution
     *
     * @param {number} x
     * @param {number} y
     * @param {number} zoom
     * @private
     */
  }, {
    key: "_applyZoomTransform",
    value: function _applyZoomTransform(x, y, zoom) {
      zoom /= this.currentResolution || this.zoomLevels.initial;
      setTransform(this.container, x, y, zoom);
    }
  }, {
    key: "calculateSize",
    value: function calculateSize() {
      var pswp = this.pswp;
      equalizePoints(this.panAreaSize, getPanAreaSize(pswp.options, pswp.viewportSize, this.data, this.index));
      this.zoomLevels.update(this.width, this.height, this.panAreaSize);
      pswp.dispatch('calcSlideSize', {
        slide: this
      });
    }
    /** @returns {string} */
  }, {
    key: "getCurrentTransform",
    value: function getCurrentTransform() {
      var scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);
      return toTransformString(this.pan.x, this.pan.y, scale);
    }
    /**
     * Set resolution and re-render the image.
     *
     * For example, if the real image size is 2000x1500,
     * and resolution is 0.5 - it will be rendered as 1000x750.
     *
     * Image with zoom level 2 and resolution 0.5 is
     * the same as image with zoom level 1 and resolution 1.
     *
     * Used to optimize animations and make
     * sure that browser renders image in the highest quality.
     * Also used by responsive images to load the correct one.
     *
     * @param {number} newResolution
     */
  }, {
    key: "_setResolution",
    value: function _setResolution(newResolution) {
      if (newResolution === this.currentResolution) {
        return;
      }
      this.currentResolution = newResolution;
      this.updateContentSize();
      this.pswp.dispatch('resolutionChanged');
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('./gestures.js').default} Gestures */
var PAN_END_FRICTION = 0.35;
var VERTICAL_DRAG_FRICTION = 0.6; // 1 corresponds to the third of viewport height

var MIN_RATIO_TO_CLOSE = 0.4; // Minimum speed required to navigate
// to next or previous slide

var MIN_NEXT_SLIDE_SPEED = 0.5;
/**
 * @param {number} initialVelocity
 * @param {number} decelerationRate
 * @returns {number}
 */

function project(initialVelocity, decelerationRate) {
  return initialVelocity * decelerationRate / (1 - decelerationRate);
}
/**
 * Handles single pointer dragging
 */
var DragHandler = /*#__PURE__*/function () {
  /**
   * @param {Gestures} gestures
   */
  function DragHandler(gestures) {
    _classCallCheck(this, DragHandler);
    this.gestures = gestures;
    this.pswp = gestures.pswp;
    /** @type {Point} */

    this.startPan = {
      x: 0,
      y: 0
    };
  }
  return _createClass(DragHandler, [{
    key: "start",
    value: function start() {
      if (this.pswp.currSlide) {
        equalizePoints(this.startPan, this.pswp.currSlide.pan);
      }
      this.pswp.animations.stopAll();
    }
  }, {
    key: "change",
    value: function change() {
      var _this$gestures = this.gestures,
        p1 = _this$gestures.p1,
        prevP1 = _this$gestures.prevP1,
        dragAxis = _this$gestures.dragAxis;
      var currSlide = this.pswp.currSlide;
      if (dragAxis === 'y' && this.pswp.options.closeOnVerticalDrag && currSlide && currSlide.currZoomLevel <= currSlide.zoomLevels.fit && !this.gestures.isMultitouch) {
        // Handle vertical drag to close
        var panY = currSlide.pan.y + (p1.y - prevP1.y);
        if (!this.pswp.dispatch('verticalDrag', {
          panY: panY
        }).defaultPrevented) {
          this._setPanWithFriction('y', panY, VERTICAL_DRAG_FRICTION);
          var bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));
          this.pswp.applyBgOpacity(bgOpacity);
          currSlide.applyCurrentZoomPan();
        }
      } else {
        var mainScrollChanged = this._panOrMoveMainScroll('x');
        if (!mainScrollChanged) {
          this._panOrMoveMainScroll('y');
          if (currSlide) {
            roundPoint(currSlide.pan);
            currSlide.applyCurrentZoomPan();
          }
        }
      }
    }
  }, {
    key: "end",
    value: function end() {
      var velocity = this.gestures.velocity;
      var _this$pswp4 = this.pswp,
        mainScroll = _this$pswp4.mainScroll,
        currSlide = _this$pswp4.currSlide;
      var indexDiff = 0;
      this.pswp.animations.stopAll(); // Handle main scroll if it's shifted

      if (mainScroll.isShifted()) {
        // Position of the main scroll relative to the viewport
        var mainScrollShiftDiff = mainScroll.x - mainScroll.getCurrSlideX(); // Ratio between 0 and 1:
        // 0 - slide is not visible at all,
        // 0.5 - half of the slide is visible
        // 1 - slide is fully visible

        var currentSlideVisibilityRatio = mainScrollShiftDiff / this.pswp.viewportSize.x; // Go next slide.
        //
        // - if velocity and its direction is matched,
        //   and we see at least tiny part of the next slide
        //
        // - or if we see less than 50% of the current slide
        //   and velocity is close to 0
        //

        if (velocity.x < -MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio < 0 || velocity.x < 0.1 && currentSlideVisibilityRatio < -0.5) {
          // Go to next slide
          indexDiff = 1;
          velocity.x = Math.min(velocity.x, 0);
        } else if (velocity.x > MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio > 0 || velocity.x > -0.1 && currentSlideVisibilityRatio > 0.5) {
          // Go to prev slide
          indexDiff = -1;
          velocity.x = Math.max(velocity.x, 0);
        }
        mainScroll.moveIndexBy(indexDiff, true, velocity.x);
      } // Restore zoom level

      if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.max || this.gestures.isMultitouch) {
        this.gestures.zoomLevels.correctZoomPan(true);
      } else {
        // we run two animations instead of one,
        // as each axis has own pan boundaries and thus different spring function
        // (correctZoomPan does not have this functionality,
        //  it animates all properties with single timing function)
        this._finishPanGestureForAxis('x');
        this._finishPanGestureForAxis('y');
      }
    }
    /**
     * @private
     * @param {'x' | 'y'} axis
     */
  }, {
    key: "_finishPanGestureForAxis",
    value: function _finishPanGestureForAxis(axis) {
      var _this4 = this;
      var velocity = this.gestures.velocity;
      var currSlide = this.pswp.currSlide;
      if (!currSlide) {
        return;
      }
      var pan = currSlide.pan,
        bounds = currSlide.bounds;
      var panPos = pan[axis];
      var restoreBgOpacity = this.pswp.bgOpacity < 1 && axis === 'y'; // 0.995 means - scroll view loses 0.5% of its velocity per millisecond
      // Increasing this number will reduce travel distance

      var decelerationRate = 0.995; // 0.99
      // Pan position if there is no bounds

      var projectedPosition = panPos + project(velocity[axis], decelerationRate);
      if (restoreBgOpacity) {
        var vDragRatio = this._getVerticalDragRatio(panPos);
        var projectedVDragRatio = this._getVerticalDragRatio(projectedPosition); // If we are above and moving upwards,
        // or if we are below and moving downwards

        if (vDragRatio < 0 && projectedVDragRatio < -MIN_RATIO_TO_CLOSE || vDragRatio > 0 && projectedVDragRatio > MIN_RATIO_TO_CLOSE) {
          this.pswp.close();
          return;
        }
      } // Pan position with corrected bounds

      var correctedPanPosition = bounds.correctPan(axis, projectedPosition); // Exit if pan position should not be changed
      // or if speed it too low

      if (panPos === correctedPanPosition) {
        return;
      } // Overshoot if the final position is out of pan bounds

      var dampingRatio = correctedPanPosition === projectedPosition ? 1 : 0.82;
      var initialBgOpacity = this.pswp.bgOpacity;
      var totalPanDist = correctedPanPosition - panPos;
      this.pswp.animations.startSpring({
        name: 'panGesture' + axis,
        isPan: true,
        start: panPos,
        end: correctedPanPosition,
        velocity: velocity[axis],
        dampingRatio: dampingRatio,
        onUpdate: function onUpdate(pos) {
          // Animate opacity of background relative to Y pan position of an image
          if (restoreBgOpacity && _this4.pswp.bgOpacity < 1) {
            // 0 - start of animation, 1 - end of animation
            var animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist; // We clamp opacity to keep it between 0 and 1.
            // As progress ratio can be larger than 1 due to overshoot,
            // and we do not want to bounce opacity.

            _this4.pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio, 0, 1));
          }
          pan[axis] = Math.floor(pos);
          currSlide.applyCurrentZoomPan();
        }
      });
    }
    /**
     * Update position of the main scroll,
     * or/and update pan position of the current slide.
     *
     * Should return true if it changes (or can change) main scroll.
     *
     * @private
     * @param {'x' | 'y'} axis
     * @returns {boolean}
     */
  }, {
    key: "_panOrMoveMainScroll",
    value: function _panOrMoveMainScroll(axis) {
      var _this$gestures2 = this.gestures,
        p1 = _this$gestures2.p1,
        dragAxis = _this$gestures2.dragAxis,
        prevP1 = _this$gestures2.prevP1,
        isMultitouch = _this$gestures2.isMultitouch;
      var _this$pswp5 = this.pswp,
        currSlide = _this$pswp5.currSlide,
        mainScroll = _this$pswp5.mainScroll;
      var delta = p1[axis] - prevP1[axis];
      var newMainScrollX = mainScroll.x + delta;
      if (!delta || !currSlide) {
        return false;
      } // Always move main scroll if image can not be panned

      if (axis === 'x' && !currSlide.isPannable() && !isMultitouch) {
        mainScroll.moveTo(newMainScrollX, true);
        return true; // changed main scroll
      }
      var bounds = currSlide.bounds;
      var newPan = currSlide.pan[axis] + delta;
      if (this.pswp.options.allowPanToNext && dragAxis === 'x' && axis === 'x' && !isMultitouch) {
        var currSlideMainScrollX = mainScroll.getCurrSlideX(); // Position of the main scroll relative to the viewport

        var mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX;
        var isLeftToRight = delta > 0;
        var isRightToLeft = !isLeftToRight;
        if (newPan > bounds.min[axis] && isLeftToRight) {
          // Panning from left to right, beyond the left edge
          // Wether the image was at minimum pan position (or less)
          // when this drag gesture started.
          // Minimum pan position refers to the left edge of the image.
          var wasAtMinPanPosition = bounds.min[axis] <= this.startPan[axis];
          if (wasAtMinPanPosition) {
            mainScroll.moveTo(newMainScrollX, true);
            return true;
          } else {
            this._setPanWithFriction(axis, newPan); //currSlide.pan[axis] = newPan;
          }
        } else if (newPan < bounds.max[axis] && isRightToLeft) {
          // Paning from right to left, beyond the right edge
          // Maximum pan position refers to the right edge of the image.
          var wasAtMaxPanPosition = this.startPan[axis] <= bounds.max[axis];
          if (wasAtMaxPanPosition) {
            mainScroll.moveTo(newMainScrollX, true);
            return true;
          } else {
            this._setPanWithFriction(axis, newPan); //currSlide.pan[axis] = newPan;
          }
        } else {
          // If main scroll is shifted
          if (mainScrollShiftDiff !== 0) {
            // If main scroll is shifted right
            if (mainScrollShiftDiff > 0
            /*&& isRightToLeft*/) {
              mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), true);
              return true;
            } else if (mainScrollShiftDiff < 0
            /*&& isLeftToRight*/) {
              // Main scroll is shifted left (Position is less than 0 comparing to the viewport 0)
              mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), true);
              return true;
            }
          } else {
            // We are within pan bounds, so just pan
            this._setPanWithFriction(axis, newPan);
          }
        }
      } else {
        if (axis === 'y') {
          // Do not pan vertically if main scroll is shifted o
          if (!mainScroll.isShifted() && bounds.min.y !== bounds.max.y) {
            this._setPanWithFriction(axis, newPan);
          }
        } else {
          this._setPanWithFriction(axis, newPan);
        }
      }
      return false;
    } // If we move above - the ratio is negative
    // If we move below the ratio is positive

    /**
     * Relation between pan Y position and third of viewport height.
     *
     * When we are at initial position (center bounds) - the ratio is 0,
     * if position is shifted upwards - the ratio is negative,
     * if position is shifted downwards - the ratio is positive.
     *
     * @private
     * @param {number} panY The current pan Y position.
     * @returns {number}
     */
  }, {
    key: "_getVerticalDragRatio",
    value: function _getVerticalDragRatio(panY) {
      var _this$pswp$currSlide$, _this$pswp$currSlide;
      return (panY - ((_this$pswp$currSlide$ = (_this$pswp$currSlide = this.pswp.currSlide) === null || _this$pswp$currSlide === void 0 ? void 0 : _this$pswp$currSlide.bounds.center.y) !== null && _this$pswp$currSlide$ !== void 0 ? _this$pswp$currSlide$ : 0)) / (this.pswp.viewportSize.y / 3);
    }
    /**
     * Set pan position of the current slide.
     * Apply friction if the position is beyond the pan bounds,
     * or if custom friction is defined.
     *
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} potentialPan
     * @param {number} [customFriction] (0.1 - 1)
     */
  }, {
    key: "_setPanWithFriction",
    value: function _setPanWithFriction(axis, potentialPan, customFriction) {
      var currSlide = this.pswp.currSlide;
      if (!currSlide) {
        return;
      }
      var pan = currSlide.pan,
        bounds = currSlide.bounds;
      var correctedPan = bounds.correctPan(axis, potentialPan); // If we are out of pan bounds

      if (correctedPan !== potentialPan || customFriction) {
        var delta = Math.round(potentialPan - pan[axis]);
        pan[axis] += delta * (customFriction || PAN_END_FRICTION);
      } else {
        pan[axis] = potentialPan;
      }
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('./gestures.js').default} Gestures */
var UPPER_ZOOM_FRICTION = 0.05;
var LOWER_ZOOM_FRICTION = 0.15;
/**
 * Get center point between two points
 *
 * @param {Point} p
 * @param {Point} p1
 * @param {Point} p2
 * @returns {Point}
 */

function getZoomPointsCenter(p, p1, p2) {
  p.x = (p1.x + p2.x) / 2;
  p.y = (p1.y + p2.y) / 2;
  return p;
}
var ZoomHandler = /*#__PURE__*/function () {
  /**
   * @param {Gestures} gestures
   */
  function ZoomHandler(gestures) {
    _classCallCheck(this, ZoomHandler);
    this.gestures = gestures;
    /**
     * @private
     * @type {Point}
     */

    this._startPan = {
      x: 0,
      y: 0
    };
    /**
     * @private
     * @type {Point}
     */

    this._startZoomPoint = {
      x: 0,
      y: 0
    };
    /**
     * @private
     * @type {Point}
     */

    this._zoomPoint = {
      x: 0,
      y: 0
    };
    /** @private */

    this._wasOverFitZoomLevel = false;
    /** @private */

    this._startZoomLevel = 1;
  }
  return _createClass(ZoomHandler, [{
    key: "start",
    value: function start() {
      var currSlide = this.gestures.pswp.currSlide;
      if (currSlide) {
        this._startZoomLevel = currSlide.currZoomLevel;
        equalizePoints(this._startPan, currSlide.pan);
      }
      this.gestures.pswp.animations.stopAllPan();
      this._wasOverFitZoomLevel = false;
    }
  }, {
    key: "change",
    value: function change() {
      var _this$gestures3 = this.gestures,
        p1 = _this$gestures3.p1,
        startP1 = _this$gestures3.startP1,
        p2 = _this$gestures3.p2,
        startP2 = _this$gestures3.startP2,
        pswp = _this$gestures3.pswp;
      var currSlide = pswp.currSlide;
      if (!currSlide) {
        return;
      }
      var minZoomLevel = currSlide.zoomLevels.min;
      var maxZoomLevel = currSlide.zoomLevels.max;
      if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) {
        return;
      }
      getZoomPointsCenter(this._startZoomPoint, startP1, startP2);
      getZoomPointsCenter(this._zoomPoint, p1, p2);
      var currZoomLevel = 1 / getDistanceBetween(startP1, startP2) * getDistanceBetween(p1, p2) * this._startZoomLevel; // slightly over the zoom.fit

      if (currZoomLevel > currSlide.zoomLevels.initial + currSlide.zoomLevels.initial / 15) {
        this._wasOverFitZoomLevel = true;
      }
      if (currZoomLevel < minZoomLevel) {
        if (pswp.options.pinchToClose && !this._wasOverFitZoomLevel && this._startZoomLevel <= currSlide.zoomLevels.initial) {
          // fade out background if zooming out
          var bgOpacity = 1 - (minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2);
          if (!pswp.dispatch('pinchClose', {
            bgOpacity: bgOpacity
          }).defaultPrevented) {
            pswp.applyBgOpacity(bgOpacity);
          }
        } else {
          // Apply the friction if zoom level is below the min
          currZoomLevel = minZoomLevel - (minZoomLevel - currZoomLevel) * LOWER_ZOOM_FRICTION;
        }
      } else if (currZoomLevel > maxZoomLevel) {
        // Apply the friction if zoom level is above the max
        currZoomLevel = maxZoomLevel + (currZoomLevel - maxZoomLevel) * UPPER_ZOOM_FRICTION;
      }
      currSlide.pan.x = this._calculatePanForZoomLevel('x', currZoomLevel);
      currSlide.pan.y = this._calculatePanForZoomLevel('y', currZoomLevel);
      currSlide.setZoomLevel(currZoomLevel);
      currSlide.applyCurrentZoomPan();
    }
  }, {
    key: "end",
    value: function end() {
      var pswp = this.gestures.pswp;
      var currSlide = pswp.currSlide;
      if ((!currSlide || currSlide.currZoomLevel < currSlide.zoomLevels.initial) && !this._wasOverFitZoomLevel && pswp.options.pinchToClose) {
        pswp.close();
      } else {
        this.correctZoomPan();
      }
    }
    /**
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} currZoomLevel
     * @returns {number}
     */
  }, {
    key: "_calculatePanForZoomLevel",
    value: function _calculatePanForZoomLevel(axis, currZoomLevel) {
      var zoomFactor = currZoomLevel / this._startZoomLevel;
      return this._zoomPoint[axis] - (this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor;
    }
    /**
     * Correct currZoomLevel and pan if they are
     * beyond minimum or maximum values.
     * With animation.
     *
     * @param {boolean} [ignoreGesture]
     * Wether gesture coordinates should be ignored when calculating destination pan position.
     */
  }, {
    key: "correctZoomPan",
    value: function correctZoomPan(ignoreGesture) {
      var pswp = this.gestures.pswp;
      var currSlide = pswp.currSlide;
      if (!(currSlide !== null && currSlide !== void 0 && currSlide.isZoomable())) {
        return;
      }
      if (this._zoomPoint.x === 0) {
        ignoreGesture = true;
      }
      var prevZoomLevel = currSlide.currZoomLevel;
      /** @type {number} */

      var destinationZoomLevel;
      var currZoomLevelNeedsChange = true;
      if (prevZoomLevel < currSlide.zoomLevels.initial) {
        destinationZoomLevel = currSlide.zoomLevels.initial; // zoom to min
      } else if (prevZoomLevel > currSlide.zoomLevels.max) {
        destinationZoomLevel = currSlide.zoomLevels.max; // zoom to max
      } else {
        currZoomLevelNeedsChange = false;
        destinationZoomLevel = prevZoomLevel;
      }
      var initialBgOpacity = pswp.bgOpacity;
      var restoreBgOpacity = pswp.bgOpacity < 1;
      var initialPan = equalizePoints({
        x: 0,
        y: 0
      }, currSlide.pan);
      var destinationPan = equalizePoints({
        x: 0,
        y: 0
      }, initialPan);
      if (ignoreGesture) {
        this._zoomPoint.x = 0;
        this._zoomPoint.y = 0;
        this._startZoomPoint.x = 0;
        this._startZoomPoint.y = 0;
        this._startZoomLevel = prevZoomLevel;
        equalizePoints(this._startPan, initialPan);
      }
      if (currZoomLevelNeedsChange) {
        destinationPan = {
          x: this._calculatePanForZoomLevel('x', destinationZoomLevel),
          y: this._calculatePanForZoomLevel('y', destinationZoomLevel)
        };
      } // set zoom level, so pan bounds are updated according to it

      currSlide.setZoomLevel(destinationZoomLevel);
      destinationPan = {
        x: currSlide.bounds.correctPan('x', destinationPan.x),
        y: currSlide.bounds.correctPan('y', destinationPan.y)
      }; // return zoom level and its bounds to initial

      currSlide.setZoomLevel(prevZoomLevel);
      var panNeedsChange = !pointsEqual(destinationPan, initialPan);
      if (!panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) {
        // update resolution after gesture
        currSlide._setResolution(destinationZoomLevel);
        currSlide.applyCurrentZoomPan(); // nothing to animate

        return;
      }
      pswp.animations.stopAllPan();
      pswp.animations.startSpring({
        isPan: true,
        start: 0,
        end: 1000,
        velocity: 0,
        dampingRatio: 1,
        naturalFrequency: 40,
        onUpdate: function onUpdate(now) {
          now /= 1000; // 0 - start, 1 - end

          if (panNeedsChange || currZoomLevelNeedsChange) {
            if (panNeedsChange) {
              currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now;
              currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now;
            }
            if (currZoomLevelNeedsChange) {
              var newZoomLevel = prevZoomLevel + (destinationZoomLevel - prevZoomLevel) * now;
              currSlide.setZoomLevel(newZoomLevel);
            }
            currSlide.applyCurrentZoomPan();
          } // Restore background opacity

          if (restoreBgOpacity && pswp.bgOpacity < 1) {
            // We clamp opacity to keep it between 0 and 1.
            // As progress ratio can be larger than 1 due to overshoot,
            // and we do not want to bounce opacity.
            pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1));
          }
        },
        onComplete: function onComplete() {
          // update resolution after transition ends
          currSlide._setResolution(destinationZoomLevel);
          currSlide.applyCurrentZoomPan();
        }
      });
    }
  }]);
}();
/**
 * @template {string} T
 * @template {string} P
 * @typedef {import('../types.js').AddPostfix<T, P>} AddPostfix<T, P>
 */
/** @typedef {import('./gestures.js').default} Gestures */
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {'imageClick' | 'bgClick' | 'tap' | 'doubleTap'} Actions */
/**
 * Whether the tap was performed on the main slide
 * (rather than controls or caption).
 *
 * @param {PointerEvent} event
 * @returns {boolean}
 */
function didTapOnMainContent(event) {
  return !! /** @type {HTMLElement} */
  event.target.closest('.pswp__container');
}
/**
 * Tap, double-tap handler.
 */
var TapHandler = /*#__PURE__*/function () {
  /**
   * @param {Gestures} gestures
   */
  function TapHandler(gestures) {
    _classCallCheck(this, TapHandler);
    this.gestures = gestures;
  }
  /**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  return _createClass(TapHandler, [{
    key: "click",
    value: function click(point, originalEvent) {
      var targetClassList = /** @type {HTMLElement} */
      originalEvent.target.classList;
      var isImageClick = targetClassList.contains('pswp__img');
      var isBackgroundClick = targetClassList.contains('pswp__item') || targetClassList.contains('pswp__zoom-wrap');
      if (isImageClick) {
        this._doClickOrTapAction('imageClick', point, originalEvent);
      } else if (isBackgroundClick) {
        this._doClickOrTapAction('bgClick', point, originalEvent);
      }
    }
    /**
     * @param {Point} point
     * @param {PointerEvent} originalEvent
     */
  }, {
    key: "tap",
    value: function tap(point, originalEvent) {
      if (didTapOnMainContent(originalEvent)) {
        this._doClickOrTapAction('tap', point, originalEvent);
      }
    }
    /**
     * @param {Point} point
     * @param {PointerEvent} originalEvent
     */
  }, {
    key: "doubleTap",
    value: function doubleTap(point, originalEvent) {
      if (didTapOnMainContent(originalEvent)) {
        this._doClickOrTapAction('doubleTap', point, originalEvent);
      }
    }
    /**
     * @private
     * @param {Actions} actionName
     * @param {Point} point
     * @param {PointerEvent} originalEvent
     */
  }, {
    key: "_doClickOrTapAction",
    value: function _doClickOrTapAction(actionName, point, originalEvent) {
      var _this$gestures$pswp$e;
      var pswp = this.gestures.pswp;
      var currSlide = pswp.currSlide;
      var actionFullName = /** @type {AddPostfix<Actions, 'Action'>} */
      actionName + 'Action';
      var optionValue = pswp.options[actionFullName];
      if (pswp.dispatch(actionFullName, {
        point: point,
        originalEvent: originalEvent
      }).defaultPrevented) {
        return;
      }
      if (typeof optionValue === 'function') {
        optionValue.call(pswp, point, originalEvent);
        return;
      }
      switch (optionValue) {
        case 'close':
        case 'next':
          pswp[optionValue]();
          break;
        case 'zoom':
          currSlide === null || currSlide === void 0 || currSlide.toggleZoom(point);
          break;
        case 'zoom-or-close':
          // by default click zooms current image,
          // if it can not be zoomed - gallery will be closed
          if (currSlide !== null && currSlide !== void 0 && currSlide.isZoomable() && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial) {
            currSlide.toggleZoom(point);
          } else if (pswp.options.clickToCloseNonZoomable) {
            pswp.close();
          }
          break;
        case 'toggle-controls':
          (_this$gestures$pswp$e = this.gestures.pswp.element) === null || _this$gestures$pswp$e === void 0 || _this$gestures$pswp$e.classList.toggle('pswp--ui-visible'); // if (_controlsVisible) {
          //   _ui.hideControls();
          // } else {
          //   _ui.showControls();
          // }

          break;
      }
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../photoswipe.js').Point} Point */
// How far should user should drag
// until we can determine that the gesture is swipe and its direction
var AXIS_SWIPE_HYSTERISIS = 10; //const PAN_END_FRICTION = 0.35;

var DOUBLE_TAP_DELAY = 300; // ms

var MIN_TAP_DISTANCE = 25; // px

/**
 * Gestures class bind touch, pointer or mouse events
 * and emits drag to drag-handler and zoom events zoom-handler.
 *
 * Drag and zoom events are emited in requestAnimationFrame,
 * and only when one of pointers was actually changed.
 */
var Gestures = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function Gestures(pswp) {
    var _this5 = this;
    _classCallCheck(this, Gestures);
    this.pswp = pswp;
    /** @type {'x' | 'y' | null} */

    this.dragAxis = null; // point objects are defined once and reused
    // PhotoSwipe keeps track only of two pointers, others are ignored

    /** @type {Point} */

    this.p1 = {
      x: 0,
      y: 0
    }; // the first pressed pointer

    /** @type {Point} */

    this.p2 = {
      x: 0,
      y: 0
    }; // the second pressed pointer

    /** @type {Point} */

    this.prevP1 = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.prevP2 = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.startP1 = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.startP2 = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.velocity = {
      x: 0,
      y: 0
    };
    /** @type {Point}
     * @private
     */

    this._lastStartP1 = {
      x: 0,
      y: 0
    };
    /** @type {Point}
     * @private
     */

    this._intervalP1 = {
      x: 0,
      y: 0
    };
    /** @private */

    this._numActivePoints = 0;
    /** @type {Point[]}
     * @private
     */

    this._ongoingPointers = [];
    /** @private */

    this._touchEventEnabled = 'ontouchstart' in window;
    /** @private */

    this._pointerEventEnabled = !!window.PointerEvent;
    this.supportsTouch = this._touchEventEnabled || this._pointerEventEnabled && navigator.maxTouchPoints > 1;
    /** @private */

    this._numActivePoints = 0;
    /** @private */

    this._intervalTime = 0;
    /** @private */

    this._velocityCalculated = false;
    this.isMultitouch = false;
    this.isDragging = false;
    this.isZooming = false;
    /** @type {number | null} */

    this.raf = null;
    /** @type {NodeJS.Timeout | null}
     * @private
     */

    this._tapTimer = null;
    if (!this.supportsTouch) {
      // disable pan to next slide for non-touch devices
      pswp.options.allowPanToNext = false;
    }
    this.drag = new DragHandler(this);
    this.zoomLevels = new ZoomHandler(this);
    this.tapHandler = new TapHandler(this);
    pswp.on('bindEvents', function () {
      pswp.events.add(pswp.scrollWrap, 'click', /** @type EventListener */
      _this5._onClick.bind(_this5));
      if (_this5._pointerEventEnabled) {
        _this5._bindEvents('pointer', 'down', 'up', 'cancel');
      } else if (_this5._touchEventEnabled) {
        _this5._bindEvents('touch', 'start', 'end', 'cancel'); // In previous versions we also bound mouse event here,
        // in case device supports both touch and mouse events,
        // but newer versions of browsers now support PointerEvent.
        // on iOS10 if you bind touchmove/end after touchstart,
        // and you don't preventDefault touchstart (which PhotoSwipe does),
        // preventDefault will have no effect on touchmove and touchend.
        // Unless you bind it previously.

        if (pswp.scrollWrap) {
          pswp.scrollWrap.ontouchmove = function () {};
          pswp.scrollWrap.ontouchend = function () {};
        }
      } else {
        _this5._bindEvents('mouse', 'down', 'up');
      }
    });
  }
  /**
   * @private
   * @param {'mouse' | 'touch' | 'pointer'} pref
   * @param {'down' | 'start'} down
   * @param {'up' | 'end'} up
   * @param {'cancel'} [cancel]
   */
  return _createClass(Gestures, [{
    key: "_bindEvents",
    value: function _bindEvents(pref, down, up, cancel) {
      var pswp = this.pswp;
      var events = pswp.events;
      var cancelEvent = cancel ? pref + cancel : '';
      events.add(pswp.scrollWrap, pref + down, /** @type EventListener */
      this.onPointerDown.bind(this));
      events.add(window, pref + 'move', /** @type EventListener */
      this.onPointerMove.bind(this));
      events.add(window, pref + up, /** @type EventListener */
      this.onPointerUp.bind(this));
      if (cancelEvent) {
        events.add(pswp.scrollWrap, cancelEvent, /** @type EventListener */
        this.onPointerUp.bind(this));
      }
    }
    /**
     * @param {PointerEvent} e
     */
  }, {
    key: "onPointerDown",
    value: function onPointerDown(e) {
      // We do not call preventDefault for touch events
      // to allow browser to show native dialog on longpress
      // (the one that allows to save image or open it in new tab).
      //
      // Desktop Safari allows to drag images when preventDefault isn't called on mousedown,
      // even though preventDefault IS called on mousemove. That's why we preventDefault mousedown.
      var isMousePointer = e.type === 'mousedown' || e.pointerType === 'mouse'; // Allow dragging only via left mouse button.
      // http://www.quirksmode.org/js/events_properties.html
      // https://developer.mozilla.org/en-US/docs/Web/API/event.button

      if (isMousePointer && e.button > 0) {
        return;
      }
      var pswp = this.pswp; // if PhotoSwipe is opening or closing

      if (!pswp.opener.isOpen) {
        e.preventDefault();
        return;
      }
      if (pswp.dispatch('pointerDown', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (isMousePointer) {
        pswp.mouseDetected(); // preventDefault mouse event to prevent
        // browser image drag feature

        this._preventPointerEventBehaviour(e, 'down');
      }
      pswp.animations.stopAll();
      this._updatePoints(e, 'down');
      if (this._numActivePoints === 1) {
        this.dragAxis = null; // we need to store initial point to determine the main axis,
        // drag is activated only after the axis is determined

        equalizePoints(this.startP1, this.p1);
      }
      if (this._numActivePoints > 1) {
        // Tap or double tap should not trigger if more than one pointer
        this._clearTapTimer();
        this.isMultitouch = true;
      } else {
        this.isMultitouch = false;
      }
    }
    /**
     * @param {PointerEvent} e
     */
  }, {
    key: "onPointerMove",
    value: function onPointerMove(e) {
      this._preventPointerEventBehaviour(e, 'move');
      if (!this._numActivePoints) {
        return;
      }
      this._updatePoints(e, 'move');
      if (this.pswp.dispatch('pointerMove', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (this._numActivePoints === 1 && !this.isDragging) {
        if (!this.dragAxis) {
          this._calculateDragDirection();
        } // Drag axis was detected, emit drag.start

        if (this.dragAxis && !this.isDragging) {
          if (this.isZooming) {
            this.isZooming = false;
            this.zoomLevels.end();
          }
          this.isDragging = true;
          this._clearTapTimer(); // Tap can not trigger after drag
          // Adjust starting point

          this._updateStartPoints();
          this._intervalTime = Date.now(); //this._startTime = this._intervalTime;

          this._velocityCalculated = false;
          equalizePoints(this._intervalP1, this.p1);
          this.velocity.x = 0;
          this.velocity.y = 0;
          this.drag.start();
          this._rafStopLoop();
          this._rafRenderLoop();
        }
      } else if (this._numActivePoints > 1 && !this.isZooming) {
        this._finishDrag();
        this.isZooming = true; // Adjust starting points

        this._updateStartPoints();
        this.zoomLevels.start();
        this._rafStopLoop();
        this._rafRenderLoop();
      }
    }
    /**
     * @private
     */
  }, {
    key: "_finishDrag",
    value: function _finishDrag() {
      if (this.isDragging) {
        this.isDragging = false; // Try to calculate velocity,
        // if it wasn't calculated yet in drag.change

        if (!this._velocityCalculated) {
          this._updateVelocity(true);
        }
        this.drag.end();
        this.dragAxis = null;
      }
    }
    /**
     * @param {PointerEvent} e
     */
  }, {
    key: "onPointerUp",
    value: function onPointerUp(e) {
      if (!this._numActivePoints) {
        return;
      }
      this._updatePoints(e, 'up');
      if (this.pswp.dispatch('pointerUp', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (this._numActivePoints === 0) {
        this._rafStopLoop();
        if (this.isDragging) {
          this._finishDrag();
        } else if (!this.isZooming && !this.isMultitouch) {
          //this.zoomLevels.correctZoomPan();
          this._finishTap(e);
        }
      }
      if (this._numActivePoints < 2 && this.isZooming) {
        this.isZooming = false;
        this.zoomLevels.end();
        if (this._numActivePoints === 1) {
          // Since we have 1 point left, we need to reinitiate drag
          this.dragAxis = null;
          this._updateStartPoints();
        }
      }
    }
    /**
     * @private
     */
  }, {
    key: "_rafRenderLoop",
    value: function _rafRenderLoop() {
      if (this.isDragging || this.isZooming) {
        this._updateVelocity();
        if (this.isDragging) {
          // make sure that pointer moved since the last update
          if (!pointsEqual(this.p1, this.prevP1)) {
            this.drag.change();
          }
        } else /* if (this.isZooming) */
          {
            if (!pointsEqual(this.p1, this.prevP1) || !pointsEqual(this.p2, this.prevP2)) {
              this.zoomLevels.change();
            }
          }
        this._updatePrevPoints();
        this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this));
      }
    }
    /**
     * Update velocity at 50ms interval
     *
     * @private
     * @param {boolean} [force]
     */
  }, {
    key: "_updateVelocity",
    value: function _updateVelocity(force) {
      var time = Date.now();
      var duration = time - this._intervalTime;
      if (duration < 50 && !force) {
        return;
      }
      this.velocity.x = this._getVelocity('x', duration);
      this.velocity.y = this._getVelocity('y', duration);
      this._intervalTime = time;
      equalizePoints(this._intervalP1, this.p1);
      this._velocityCalculated = true;
    }
    /**
     * @private
     * @param {PointerEvent} e
     */
  }, {
    key: "_finishTap",
    value: function _finishTap(e) {
      var _this6 = this;
      var mainScroll = this.pswp.mainScroll; // Do not trigger tap events if main scroll is shifted

      if (mainScroll.isShifted()) {
        // restore main scroll position
        // (usually happens if stopped in the middle of animation)
        mainScroll.moveIndexBy(0, true);
        return;
      } // Do not trigger tap for touchcancel or pointercancel

      if (e.type.indexOf('cancel') > 0) {
        return;
      } // Trigger click instead of tap for mouse events

      if (e.type === 'mouseup' || e.pointerType === 'mouse') {
        this.tapHandler.click(this.startP1, e);
        return;
      } // Disable delay if there is no doubleTapAction

      var tapDelay = this.pswp.options.doubleTapAction ? DOUBLE_TAP_DELAY : 0; // If tapTimer is defined - we tapped recently,
      // check if the current tap is close to the previous one,
      // if yes - trigger double tap

      if (this._tapTimer) {
        this._clearTapTimer(); // Check if two taps were more or less on the same place

        if (getDistanceBetween(this._lastStartP1, this.startP1) < MIN_TAP_DISTANCE) {
          this.tapHandler.doubleTap(this.startP1, e);
        }
      } else {
        equalizePoints(this._lastStartP1, this.startP1);
        this._tapTimer = setTimeout(function () {
          _this6.tapHandler.tap(_this6.startP1, e);
          _this6._clearTapTimer();
        }, tapDelay);
      }
    }
    /**
     * @private
     */
  }, {
    key: "_clearTapTimer",
    value: function _clearTapTimer() {
      if (this._tapTimer) {
        clearTimeout(this._tapTimer);
        this._tapTimer = null;
      }
    }
    /**
     * Get velocity for axis
     *
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} duration
     * @returns {number}
     */
  }, {
    key: "_getVelocity",
    value: function _getVelocity(axis, duration) {
      // displacement is like distance, but can be negative.
      var displacement = this.p1[axis] - this._intervalP1[axis];
      if (Math.abs(displacement) > 1 && duration > 5) {
        return displacement / duration;
      }
      return 0;
    }
    /**
     * @private
     */
  }, {
    key: "_rafStopLoop",
    value: function _rafStopLoop() {
      if (this.raf) {
        cancelAnimationFrame(this.raf);
        this.raf = null;
      }
    }
    /**
     * @private
     * @param {PointerEvent} e
     * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
     */
  }, {
    key: "_preventPointerEventBehaviour",
    value: function _preventPointerEventBehaviour(e, pointerType) {
      var preventPointerEvent = this.pswp.applyFilters('preventPointerEvent', true, e, pointerType);
      if (preventPointerEvent) {
        e.preventDefault();
      }
    }
    /**
     * Parses and normalizes points from the touch, mouse or pointer event.
     * Updates p1 and p2.
     *
     * @private
     * @param {PointerEvent | TouchEvent} e
     * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
     */
  }, {
    key: "_updatePoints",
    value: function _updatePoints(e, pointerType) {
      if (this._pointerEventEnabled) {
        var pointerEvent = /** @type {PointerEvent} */
        e; // Try to find the current pointer in ongoing pointers by its ID

        var pointerIndex = this._ongoingPointers.findIndex(function (ongoingPointer) {
          return ongoingPointer.id === pointerEvent.pointerId;
        });
        if (pointerType === 'up' && pointerIndex > -1) {
          // release the pointer - remove it from ongoing
          this._ongoingPointers.splice(pointerIndex, 1);
        } else if (pointerType === 'down' && pointerIndex === -1) {
          // add new pointer
          this._ongoingPointers.push(this._convertEventPosToPoint(pointerEvent, {
            x: 0,
            y: 0
          }));
        } else if (pointerIndex > -1) {
          // update existing pointer
          this._convertEventPosToPoint(pointerEvent, this._ongoingPointers[pointerIndex]);
        }
        this._numActivePoints = this._ongoingPointers.length; // update points that PhotoSwipe uses
        // to calculate position and scale

        if (this._numActivePoints > 0) {
          equalizePoints(this.p1, this._ongoingPointers[0]);
        }
        if (this._numActivePoints > 1) {
          equalizePoints(this.p2, this._ongoingPointers[1]);
        }
      } else {
        var touchEvent = /** @type {TouchEvent} */
        e;
        this._numActivePoints = 0;
        if (touchEvent.type.indexOf('touch') > -1) {
          // Touch Event
          // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
          if (touchEvent.touches && touchEvent.touches.length > 0) {
            this._convertEventPosToPoint(touchEvent.touches[0], this.p1);
            this._numActivePoints++;
            if (touchEvent.touches.length > 1) {
              this._convertEventPosToPoint(touchEvent.touches[1], this.p2);
              this._numActivePoints++;
            }
          }
        } else {
          // Mouse Event
          this._convertEventPosToPoint(/** @type {PointerEvent} */
          e, this.p1);
          if (pointerType === 'up') {
            // clear all points on mouseup
            this._numActivePoints = 0;
          } else {
            this._numActivePoints++;
          }
        }
      }
    }
    /** update points that were used during previous rAF tick
     * @private
     */
  }, {
    key: "_updatePrevPoints",
    value: function _updatePrevPoints() {
      equalizePoints(this.prevP1, this.p1);
      equalizePoints(this.prevP2, this.p2);
    }
    /** update points at the start of gesture
     * @private
     */
  }, {
    key: "_updateStartPoints",
    value: function _updateStartPoints() {
      equalizePoints(this.startP1, this.p1);
      equalizePoints(this.startP2, this.p2);
      this._updatePrevPoints();
    }
    /** @private */
  }, {
    key: "_calculateDragDirection",
    value: function _calculateDragDirection() {
      if (this.pswp.mainScroll.isShifted()) {
        // if main scroll position is shifted â direction is always horizontal
        this.dragAxis = 'x';
      } else {
        // calculate delta of the last touchmove tick
        var diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);
        if (diff !== 0) {
          // check if pointer was shifted horizontally or vertically
          var axisToCheck = diff > 0 ? 'x' : 'y';
          if (Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= AXIS_SWIPE_HYSTERISIS) {
            this.dragAxis = axisToCheck;
          }
        }
      }
    }
    /**
     * Converts touch, pointer or mouse event
     * to PhotoSwipe point.
     *
     * @private
     * @param {Touch | PointerEvent} e
     * @param {Point} p
     * @returns {Point}
     */
  }, {
    key: "_convertEventPosToPoint",
    value: function _convertEventPosToPoint(e, p) {
      p.x = e.pageX - this.pswp.offset.x;
      p.y = e.pageY - this.pswp.offset.y;
      if ('pointerId' in e) {
        p.id = e.pointerId;
      } else if (e.identifier !== undefined) {
        p.id = e.identifier;
      }
      return p;
    }
    /**
     * @private
     * @param {PointerEvent} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      // Do not allow click event to pass through after drag
      if (this.pswp.mainScroll.isShifted()) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }]);
}();
/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./slide/slide.js').default} Slide */
/** @typedef {{ el: HTMLDivElement; slide?: Slide }} ItemHolder */
var MAIN_SCROLL_END_FRICTION = 0.35; // const MIN_SWIPE_TRANSITION_DURATION = 250;
// const MAX_SWIPE_TRABSITION_DURATION = 500;
// const DEFAULT_SWIPE_TRANSITION_DURATION = 333;

/**
 * Handles movement of the main scrolling container
 * (for example, it repositions when user swipes left or right).
 *
 * Also stores its state.
 */
var MainScroll = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function MainScroll(pswp) {
    _classCallCheck(this, MainScroll);
    this.pswp = pswp;
    this.x = 0;
    this.slideWidth = 0;
    /** @private */

    this._currPositionIndex = 0;
    /** @private */

    this._prevPositionIndex = 0;
    /** @private */

    this._containerShiftIndex = -1;
    /** @type {ItemHolder[]} */

    this.itemHolders = [];
  }
  /**
   * Position the scroller and slide containers
   * according to viewport size.
   *
   * @param {boolean} [resizeSlides] Whether slides content should resized
   */
  return _createClass(MainScroll, [{
    key: "resize",
    value: function resize(resizeSlides) {
      var _this7 = this;
      var pswp = this.pswp;
      var newSlideWidth = Math.round(pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing); // Mobile browsers might trigger a resize event during a gesture.
      // (due to toolbar appearing or hiding).
      // Avoid re-adjusting main scroll position if width wasn't changed

      var slideWidthChanged = newSlideWidth !== this.slideWidth;
      if (slideWidthChanged) {
        this.slideWidth = newSlideWidth;
        this.moveTo(this.getCurrSlideX());
      }
      this.itemHolders.forEach(function (itemHolder, index) {
        if (slideWidthChanged) {
          setTransform(itemHolder.el, (index + _this7._containerShiftIndex) * _this7.slideWidth);
        }
        if (resizeSlides && itemHolder.slide) {
          itemHolder.slide.resize();
        }
      });
    }
    /**
     * Reset X position of the main scroller to zero
     */
  }, {
    key: "resetPosition",
    value: function resetPosition() {
      // Position on the main scroller (offset)
      // it is independent from slide index
      this._currPositionIndex = 0;
      this._prevPositionIndex = 0; // This will force recalculation of size on next resize()

      this.slideWidth = 0; // _containerShiftIndex*viewportSize will give you amount of transform of the current slide

      this._containerShiftIndex = -1;
    }
    /**
     * Create and append array of three items
     * that hold data about slides in DOM
     */
  }, {
    key: "appendHolders",
    value: function appendHolders() {
      this.itemHolders = []; // append our three slide holders -
      // previous, current, and next

      for (var i = 0; i < 3; i++) {
        var el = createElement('pswp__item', 'div', this.pswp.container);
        el.setAttribute('role', 'group');
        el.setAttribute('aria-roledescription', 'slide');
        el.setAttribute('aria-hidden', 'true'); // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)

        el.style.display = i === 1 ? 'block' : 'none';
        this.itemHolders.push({
          el: el //index: -1
        });
      }
    }
    /**
     * Whether the main scroll can be horizontally swiped to the next or previous slide.
     * @returns {boolean}
     */
  }, {
    key: "canBeSwiped",
    value: function canBeSwiped() {
      return this.pswp.getNumItems() > 1;
    }
    /**
     * Move main scroll by X amount of slides.
     * For example:
     *   `-1` will move to the previous slide,
     *    `0` will reset the scroll position of the current slide,
     *    `3` will move three slides forward
     *
     * If loop option is enabled - index will be automatically looped too,
     * (for example `-1` will move to the last slide of the gallery).
     *
     * @param {number} diff
     * @param {boolean} [animate]
     * @param {number} [velocityX]
     * @returns {boolean} whether index was changed or not
     */
  }, {
    key: "moveIndexBy",
    value: function moveIndexBy(diff, animate, velocityX) {
      var _this8 = this;
      var pswp = this.pswp;
      var newIndex = pswp.potentialIndex + diff;
      var numSlides = pswp.getNumItems();
      if (pswp.canLoop()) {
        newIndex = pswp.getLoopedIndex(newIndex);
        var distance = (diff + numSlides) % numSlides;
        if (distance <= numSlides / 2) {
          // go forward
          diff = distance;
        } else {
          // go backwards
          diff = distance - numSlides;
        }
      } else {
        if (newIndex < 0) {
          newIndex = 0;
        } else if (newIndex >= numSlides) {
          newIndex = numSlides - 1;
        }
        diff = newIndex - pswp.potentialIndex;
      }
      pswp.potentialIndex = newIndex;
      this._currPositionIndex -= diff;
      pswp.animations.stopMainScroll();
      var destinationX = this.getCurrSlideX();
      if (!animate) {
        this.moveTo(destinationX);
        this.updateCurrItem();
      } else {
        pswp.animations.startSpring({
          isMainScroll: true,
          start: this.x,
          end: destinationX,
          velocity: velocityX || 0,
          naturalFrequency: 30,
          dampingRatio: 1,
          //0.7,
          onUpdate: function onUpdate(x) {
            _this8.moveTo(x);
          },
          onComplete: function onComplete() {
            _this8.updateCurrItem();
            pswp.appendHeavy();
          }
        });
        var currDiff = pswp.potentialIndex - pswp.currIndex;
        if (pswp.canLoop()) {
          var currDistance = (currDiff + numSlides) % numSlides;
          if (currDistance <= numSlides / 2) {
            // go forward
            currDiff = currDistance;
          } else {
            // go backwards
            currDiff = currDistance - numSlides;
          }
        } // Force-append new slides during transition
        // if difference between slides is more than 1

        if (Math.abs(currDiff) > 1) {
          this.updateCurrItem();
        }
      }
      return Boolean(diff);
    }
    /**
     * X position of the main scroll for the current slide
     * (ignores position during dragging)
     * @returns {number}
     */
  }, {
    key: "getCurrSlideX",
    value: function getCurrSlideX() {
      return this.slideWidth * this._currPositionIndex;
    }
    /**
     * Whether scroll position is shifted.
     * For example, it will return true if the scroll is being dragged or animated.
     * @returns {boolean}
     */
  }, {
    key: "isShifted",
    value: function isShifted() {
      return this.x !== this.getCurrSlideX();
    }
    /**
     * Update slides X positions and set their content
     */
  }, {
    key: "updateCurrItem",
    value: function updateCurrItem() {
      var _this$itemHolders$;
      var pswp = this.pswp;
      var positionDifference = this._prevPositionIndex - this._currPositionIndex;
      if (!positionDifference) {
        return;
      }
      this._prevPositionIndex = this._currPositionIndex;
      pswp.currIndex = pswp.potentialIndex;
      var diffAbs = Math.abs(positionDifference);
      /** @type {ItemHolder | undefined} */

      var tempHolder;
      if (diffAbs >= 3) {
        this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3);
        diffAbs = 3; // If slides are changed by 3 screens or more - clean up previous slides

        this.itemHolders.forEach(function (itemHolder) {
          var _itemHolder$slide;
          (_itemHolder$slide = itemHolder.slide) === null || _itemHolder$slide === void 0 || _itemHolder$slide.destroy();
          itemHolder.slide = undefined;
        });
      }
      for (var i = 0; i < diffAbs; i++) {
        if (positionDifference > 0) {
          tempHolder = this.itemHolders.shift();
          if (tempHolder) {
            this.itemHolders[2] = tempHolder; // move first to last

            this._containerShiftIndex++;
            setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth);
            pswp.setContent(tempHolder, pswp.currIndex - diffAbs + i + 2);
          }
        } else {
          tempHolder = this.itemHolders.pop();
          if (tempHolder) {
            this.itemHolders.unshift(tempHolder); // move last to first

            this._containerShiftIndex--;
            setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth);
            pswp.setContent(tempHolder, pswp.currIndex + diffAbs - i - 2);
          }
        }
      } // Reset transfrom every 50ish navigations in one direction.
      //
      // Otherwise transform will keep growing indefinitely,
      // which might cause issues as browsers have a maximum transform limit.
      // I wasn't able to reach it, but just to be safe.
      // This should not cause noticable lag.

      if (Math.abs(this._containerShiftIndex) > 50 && !this.isShifted()) {
        this.resetPosition();
        this.resize();
      } // Pan transition might be running (and consntantly updating pan position)

      pswp.animations.stopAllPan();
      this.itemHolders.forEach(function (itemHolder, i) {
        if (itemHolder.slide) {
          // Slide in the 2nd holder is always active
          itemHolder.slide.setIsActive(i === 1);
        }
      });
      pswp.currSlide = (_this$itemHolders$ = this.itemHolders[1]) === null || _this$itemHolders$ === void 0 ? void 0 : _this$itemHolders$.slide;
      pswp.contentLoader.updateLazy(positionDifference);
      if (pswp.currSlide) {
        pswp.currSlide.applyCurrentZoomPan();
      }
      pswp.dispatch('change');
    }
    /**
     * Move the X position of the main scroll container
     *
     * @param {number} x
     * @param {boolean} [dragging]
     */
  }, {
    key: "moveTo",
    value: function moveTo(x, dragging) {
      if (!this.pswp.canLoop() && dragging) {
        // Apply friction
        var newSlideIndexOffset = (this.slideWidth * this._currPositionIndex - x) / this.slideWidth;
        newSlideIndexOffset += this.pswp.currIndex;
        var delta = Math.round(x - this.x);
        if (newSlideIndexOffset < 0 && delta > 0 || newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0) {
          x = this.x + delta * MAIN_SCROLL_END_FRICTION;
        }
      }
      this.x = x;
      if (this.pswp.container) {
        setTransform(this.pswp.container, x);
      }
      this.pswp.dispatch('moveMainScroll', {
        x: x,
        dragging: dragging !== null && dragging !== void 0 ? dragging : false
      });
    }
  }]);
}();
/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/**
 * @template T
 * @typedef {import('./types.js').Methods<T>} Methods<T>
 */
var KeyboardKeyCodesMap = {
  Escape: 27,
  z: 90,
  ArrowLeft: 37,
  ArrowUp: 38,
  ArrowRight: 39,
  ArrowDown: 40,
  Tab: 9
};
/**
 * @template {keyof KeyboardKeyCodesMap} T
 * @param {T} key
 * @param {boolean} isKeySupported
 * @returns {T | number | undefined}
 */

var getKeyboardEventKey = function getKeyboardEventKey(key, isKeySupported) {
  return isKeySupported ? key : KeyboardKeyCodesMap[key];
};
/**
 * - Manages keyboard shortcuts.
 * - Helps trap focus within photoswipe.
 */
var Keyboard = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function Keyboard(pswp) {
    var _this9 = this;
    _classCallCheck(this, Keyboard);
    this.pswp = pswp;
    /** @private */

    this._wasFocused = false;
    pswp.on('bindEvents', function () {
      if (pswp.options.trapFocus) {
        // Dialog was likely opened by keyboard if initial point is not defined
        if (!pswp.options.initialPointerPos) {
          // focus causes layout,
          // which causes lag during the animation,
          // that's why we delay it until the opener transition ends
          _this9._focusRoot();
        }
        pswp.events.add(document, 'focusin', /** @type EventListener */
        _this9._onFocusIn.bind(_this9));
      }
      pswp.events.add(document, 'keydown', /** @type EventListener */
      _this9._onKeyDown.bind(_this9));
    });
    var lastActiveElement = /** @type {HTMLElement} */
    document.activeElement;
    pswp.on('destroy', function () {
      if (pswp.options.returnFocus && lastActiveElement && _this9._wasFocused) {
        lastActiveElement.focus();
      }
    });
  }
  /** @private */
  return _createClass(Keyboard, [{
    key: "_focusRoot",
    value: function _focusRoot() {
      if (!this._wasFocused && this.pswp.element) {
        this.pswp.element.focus();
        this._wasFocused = true;
      }
    }
    /**
     * @private
     * @param {KeyboardEvent} e
     */
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(e) {
      var pswp = this.pswp;
      if (pswp.dispatch('keydown', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (specialKeyUsed(e)) {
        // don't do anything if special key pressed
        // to prevent from overriding default browser actions
        // for example, in Chrome on Mac cmd+arrow-left returns to previous page
        return;
      }
      /** @type {Methods<PhotoSwipe> | undefined} */

      var keydownAction;
      /** @type {'x' | 'y' | undefined} */

      var axis;
      var isForward = false;
      var isKeySupported = 'key' in e;
      switch (isKeySupported ? e.key : e.keyCode) {
        case getKeyboardEventKey('Escape', isKeySupported):
          if (pswp.options.escKey) {
            keydownAction = 'close';
          }
          break;
        case getKeyboardEventKey('z', isKeySupported):
          keydownAction = 'toggleZoom';
          break;
        case getKeyboardEventKey('ArrowLeft', isKeySupported):
          axis = 'x';
          break;
        case getKeyboardEventKey('ArrowUp', isKeySupported):
          axis = 'y';
          break;
        case getKeyboardEventKey('ArrowRight', isKeySupported):
          axis = 'x';
          isForward = true;
          break;
        case getKeyboardEventKey('ArrowDown', isKeySupported):
          isForward = true;
          axis = 'y';
          break;
        case getKeyboardEventKey('Tab', isKeySupported):
          this._focusRoot();
          break;
      } // if left/right/top/bottom key

      if (axis) {
        // prevent page scroll
        e.preventDefault();
        var currSlide = pswp.currSlide;
        if (pswp.options.arrowKeys && axis === 'x' && pswp.getNumItems() > 1) {
          keydownAction = isForward ? 'next' : 'prev';
        } else if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit) {
          // up/down arrow keys pan the image vertically
          // left/right arrow keys pan horizontally.
          // Unless there is only one image,
          // or arrowKeys option is disabled
          currSlide.pan[axis] += isForward ? -80 : 80;
          currSlide.panTo(currSlide.pan.x, currSlide.pan.y);
        }
      }
      if (keydownAction) {
        e.preventDefault(); // @ts-ignore

        pswp[keydownAction]();
      }
    }
    /**
     * Trap focus inside photoswipe
     *
     * @private
     * @param {FocusEvent} e
     */
  }, {
    key: "_onFocusIn",
    value: function _onFocusIn(e) {
      var template = this.pswp.template;
      if (template && document !== e.target && template !== e.target && !template.contains(/** @type {Node} */
      e.target)) {
        // focus root element
        template.focus();
      }
    }
  }]);
}();
var DEFAULT_EASING = 'cubic-bezier(.4,0,.22,1)';
/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */

/** @typedef {Object} DefaultCssAnimationProps
 *
 * @prop {HTMLElement} target
 * @prop {number} [duration]
 * @prop {string} [easing]
 * @prop {string} [transform]
 * @prop {string} [opacity]
 * */

/** @typedef {SharedAnimationProps & DefaultCssAnimationProps} CssAnimationProps */

/**
 * Runs CSS transition.
 */
var CSSAnimation = /*#__PURE__*/function () {
  /**
   * onComplete can be unpredictable, be careful about current state
   *
   * @param {CssAnimationProps} props
   */
  function CSSAnimation(props) {
    var _this0 = this;
    _classCallCheck(this, CSSAnimation);
    var _props$prop;
    this.props = props;
    var target = props.target,
      onComplete = props.onComplete,
      transform = props.transform,
      _props$onFinish = props.onFinish,
      onFinish = _props$onFinish === void 0 ? function () {} : _props$onFinish,
      _props$duration = props.duration,
      duration = _props$duration === void 0 ? 333 : _props$duration,
      _props$easing = props.easing,
      easing = _props$easing === void 0 ? DEFAULT_EASING : _props$easing;
    this.onFinish = onFinish; // support only transform and opacity

    var prop = transform ? 'transform' : 'opacity';
    var propValue = (_props$prop = props[prop]) !== null && _props$prop !== void 0 ? _props$prop : '';
    /** @private */

    this._target = target;
    /** @private */

    this._onComplete = onComplete;
    /** @private */

    this._finished = false;
    /** @private */

    this._onTransitionEnd = this._onTransitionEnd.bind(this); // Using timeout hack to make sure that animation
    // starts even if the animated property was changed recently,
    // otherwise transitionend might not fire or transition won't start.
    // https://drafts.csswg.org/css-transitions/#starting
    //
    // Â¯\_(ã)_/Â¯

    /** @private */

    this._helperTimeout = setTimeout(function () {
      setTransitionStyle(target, prop, duration, easing);
      _this0._helperTimeout = setTimeout(function () {
        target.addEventListener('transitionend', _this0._onTransitionEnd, false);
        target.addEventListener('transitioncancel', _this0._onTransitionEnd, false); // Safari occasionally does not emit transitionend event
        // if element property was modified during the transition,
        // which may be caused by resize or third party component,
        // using timeout as a safety fallback

        _this0._helperTimeout = setTimeout(function () {
          _this0._finalizeAnimation();
        }, duration + 500);
        target.style[prop] = propValue;
      }, 30); // Do not reduce this number
    }, 0);
  }
  /**
   * @private
   * @param {TransitionEvent} e
   */
  return _createClass(CSSAnimation, [{
    key: "_onTransitionEnd",
    value: function _onTransitionEnd(e) {
      if (e.target === this._target) {
        this._finalizeAnimation();
      }
    }
    /**
     * @private
     */
  }, {
    key: "_finalizeAnimation",
    value: function _finalizeAnimation() {
      if (!this._finished) {
        this._finished = true;
        this.onFinish();
        if (this._onComplete) {
          this._onComplete();
        }
      }
    } // Destroy is called automatically onFinish
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._helperTimeout) {
        clearTimeout(this._helperTimeout);
      }
      removeTransitionStyle(this._target);
      this._target.removeEventListener('transitionend', this._onTransitionEnd, false);
      this._target.removeEventListener('transitioncancel', this._onTransitionEnd, false);
      if (!this._finished) {
        this._finalizeAnimation();
      }
    }
  }]);
}();
var DEFAULT_NATURAL_FREQUENCY = 12;
var DEFAULT_DAMPING_RATIO = 0.75;
/**
 * Spring easing helper
 */
var SpringEaser = /*#__PURE__*/function () {
  /**
   * @param {number} initialVelocity Initial velocity, px per ms.
   *
   * @param {number} [dampingRatio]
   * Determines how bouncy animation will be.
   * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.
   * "overshoot" refers to part of animation that
   * goes beyond the final value.
   *
   * @param {number} [naturalFrequency]
   * Determines how fast animation will slow down.
   * The higher value - the stiffer the transition will be,
   * and the faster it will slow down.
   * Recommended value from 10 to 50
   */
  function SpringEaser(initialVelocity, dampingRatio, naturalFrequency) {
    _classCallCheck(this, SpringEaser);
    this.velocity = initialVelocity * 1000; // convert to "pixels per second"
    // https://en.wikipedia.org/wiki/Damping_ratio

    this._dampingRatio = dampingRatio || DEFAULT_DAMPING_RATIO; // https://en.wikipedia.org/wiki/Natural_frequency

    this._naturalFrequency = naturalFrequency || DEFAULT_NATURAL_FREQUENCY;
    this._dampedFrequency = this._naturalFrequency;
    if (this._dampingRatio < 1) {
      this._dampedFrequency *= Math.sqrt(1 - this._dampingRatio * this._dampingRatio);
    }
  }
  /**
   * @param {number} deltaPosition Difference between current and end position of the animation
   * @param {number} deltaTime Frame duration in milliseconds
   *
   * @returns {number} Displacement, relative to the end position.
   */
  return _createClass(SpringEaser, [{
    key: "easeFrame",
    value: function easeFrame(deltaPosition, deltaTime) {
      // Inspired by Apple Webkit and Android spring function implementation
      // https://en.wikipedia.org/wiki/Oscillation
      // https://en.wikipedia.org/wiki/Damping_ratio
      // we ignore mass (assume that it's 1kg)
      var displacement = 0;
      var coeff;
      deltaTime /= 1000;
      var naturalDumpingPow = Math.pow(Math.E, -this._dampingRatio * this._naturalFrequency * deltaTime);
      if (this._dampingRatio === 1) {
        coeff = this.velocity + this._naturalFrequency * deltaPosition;
        displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow;
        this.velocity = displacement * -this._naturalFrequency + coeff * naturalDumpingPow;
      } else if (this._dampingRatio < 1) {
        coeff = 1 / this._dampedFrequency * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);
        var dumpedFCos = Math.cos(this._dampedFrequency * deltaTime);
        var dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);
        displacement = naturalDumpingPow * (deltaPosition * dumpedFCos + coeff * dumpedFSin);
        this.velocity = displacement * -this._naturalFrequency * this._dampingRatio + naturalDumpingPow * (-this._dampedFrequency * deltaPosition * dumpedFSin + this._dampedFrequency * coeff * dumpedFCos);
      } // Overdamped (>1) damping ratio is not supported

      return displacement;
    }
  }]);
}();
/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */
/**
 * @typedef {Object} DefaultSpringAnimationProps
 *
 * @prop {number} start
 * @prop {number} end
 * @prop {number} velocity
 * @prop {number} [dampingRatio]
 * @prop {number} [naturalFrequency]
 * @prop {(end: number) => void} onUpdate
 */
/** @typedef {SharedAnimationProps & DefaultSpringAnimationProps} SpringAnimationProps */
var SpringAnimation = /*#__PURE__*/function () {
  /**
   * @param {SpringAnimationProps} props
   */
  function SpringAnimation(props) {
    var _this1 = this;
    _classCallCheck(this, SpringAnimation);
    this.props = props;
    this._raf = 0;
    var start = props.start,
      end = props.end,
      velocity = props.velocity,
      onUpdate = props.onUpdate,
      onComplete = props.onComplete,
      _props$onFinish2 = props.onFinish,
      onFinish = _props$onFinish2 === void 0 ? function () {} : _props$onFinish2,
      dampingRatio = props.dampingRatio,
      naturalFrequency = props.naturalFrequency;
    this.onFinish = onFinish;
    var easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);
    var prevTime = Date.now();
    var deltaPosition = start - end;
    var _animationLoop = function animationLoop() {
      if (_this1._raf) {
        deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime); // Stop the animation if velocity is low and position is close to end

        if (Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50) {
          // Finalize the animation
          onUpdate(end);
          if (onComplete) {
            onComplete();
          }
          _this1.onFinish();
        } else {
          prevTime = Date.now();
          onUpdate(deltaPosition + end);
          _this1._raf = requestAnimationFrame(_animationLoop);
        }
      }
    };
    this._raf = requestAnimationFrame(_animationLoop);
  } // Destroy is called automatically onFinish
  return _createClass(SpringAnimation, [{
    key: "destroy",
    value: function destroy() {
      if (this._raf >= 0) {
        cancelAnimationFrame(this._raf);
      }
      this._raf = 0;
    }
  }]);
}();
/** @typedef {import('./css-animation.js').CssAnimationProps} CssAnimationProps */
/** @typedef {import('./spring-animation.js').SpringAnimationProps} SpringAnimationProps */
/** @typedef {Object} SharedAnimationProps
 * @prop {string} [name]
 * @prop {boolean} [isPan]
 * @prop {boolean} [isMainScroll]
 * @prop {VoidFunction} [onComplete]
 * @prop {VoidFunction} [onFinish]
 */
/** @typedef {SpringAnimation | CSSAnimation} Animation */
/** @typedef {SpringAnimationProps | CssAnimationProps} AnimationProps */
/**
 * Manages animations
 */
var Animations = /*#__PURE__*/function () {
  function Animations() {
    _classCallCheck(this, Animations);
    /** @type {Animation[]} */
    this.activeAnimations = [];
  }
  /**
   * @param {SpringAnimationProps} props
   */
  return _createClass(Animations, [{
    key: "startSpring",
    value: function startSpring(props) {
      this._start(props, true);
    }
    /**
     * @param {CssAnimationProps} props
     */
  }, {
    key: "startTransition",
    value: function startTransition(props) {
      this._start(props);
    }
    /**
     * @private
     * @param {AnimationProps} props
     * @param {boolean} [isSpring]
     * @returns {Animation}
     */
  }, {
    key: "_start",
    value: function _start(props, isSpring) {
      var _this10 = this;
      var animation = isSpring ? new SpringAnimation(/** @type SpringAnimationProps */
      props) : new CSSAnimation(/** @type CssAnimationProps */
      props);
      this.activeAnimations.push(animation);
      animation.onFinish = function () {
        return _this10.stop(animation);
      };
      return animation;
    }
    /**
     * @param {Animation} animation
     */
  }, {
    key: "stop",
    value: function stop(animation) {
      animation.destroy();
      var index = this.activeAnimations.indexOf(animation);
      if (index > -1) {
        this.activeAnimations.splice(index, 1);
      }
    }
  }, {
    key: "stopAll",
    value: function stopAll() {
      // _stopAllAnimations
      this.activeAnimations.forEach(function (animation) {
        animation.destroy();
      });
      this.activeAnimations = [];
    }
    /**
     * Stop all pan or zoom transitions
     */
  }, {
    key: "stopAllPan",
    value: function stopAllPan() {
      this.activeAnimations = this.activeAnimations.filter(function (animation) {
        if (animation.props.isPan) {
          animation.destroy();
          return false;
        }
        return true;
      });
    }
  }, {
    key: "stopMainScroll",
    value: function stopMainScroll() {
      this.activeAnimations = this.activeAnimations.filter(function (animation) {
        if (animation.props.isMainScroll) {
          animation.destroy();
          return false;
        }
        return true;
      });
    }
    /**
     * Returns true if main scroll transition is running
     */
    // isMainScrollRunning() {
    //   return this.activeAnimations.some((animation) => {
    //     return animation.props.isMainScroll;
    //   });
    // }

    /**
     * Returns true if any pan or zoom transition is running
     */
  }, {
    key: "isPanRunning",
    value: function isPanRunning() {
      return this.activeAnimations.some(function (animation) {
        return animation.props.isPan;
      });
    }
  }]);
}();
/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/**
 * Handles scroll wheel.
 * Can pan and zoom current slide image.
 */
var ScrollWheel = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function ScrollWheel(pswp) {
    _classCallCheck(this, ScrollWheel);
    this.pswp = pswp;
    pswp.events.add(pswp.element, 'wheel', /** @type EventListener */
    this._onWheel.bind(this));
  }
  /**
   * @private
   * @param {WheelEvent} e
   */
  return _createClass(ScrollWheel, [{
    key: "_onWheel",
    value: function _onWheel(e) {
      e.preventDefault();
      var currSlide = this.pswp.currSlide;
      var deltaX = e.deltaX,
        deltaY = e.deltaY;
      if (!currSlide) {
        return;
      }
      if (this.pswp.dispatch('wheel', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (e.ctrlKey || this.pswp.options.wheelToZoom) {
        // zoom
        if (currSlide.isZoomable()) {
          var zoomFactor = -deltaY;
          if (e.deltaMode === 1
          /* DOM_DELTA_LINE */) {
            zoomFactor *= 0.05;
          } else {
            zoomFactor *= e.deltaMode ? 1 : 0.002;
          }
          zoomFactor = Math.pow(2, zoomFactor);
          var destZoomLevel = currSlide.currZoomLevel * zoomFactor;
          currSlide.zoomTo(destZoomLevel, {
            x: e.clientX,
            y: e.clientY
          });
        }
      } else {
        // pan
        if (currSlide.isPannable()) {
          if (e.deltaMode === 1
          /* DOM_DELTA_LINE */) {
            // 18 - average line height
            deltaX *= 18;
            deltaY *= 18;
          }
          currSlide.panTo(currSlide.pan.x - deltaX, currSlide.pan.y - deltaY);
        }
      }
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/**
 * @template T
 * @typedef {import('../types.js').Methods<T>} Methods<T>
 */
/**
 * @typedef {Object} UIElementMarkupProps
 * @prop {boolean} [isCustomSVG]
 * @prop {string} inner
 * @prop {string} [outlineID]
 * @prop {number | string} [size]
 */
/**
 * @typedef {Object} UIElementData
 * @prop {DefaultUIElements | string} [name]
 * @prop {string} [className]
 * @prop {UIElementMarkup} [html]
 * @prop {boolean} [isButton]
 * @prop {keyof HTMLElementTagNameMap} [tagName]
 * @prop {string} [title]
 * @prop {string} [ariaLabel]
 * @prop {(element: HTMLElement, pswp: PhotoSwipe) => void} [onInit]
 * @prop {Methods<PhotoSwipe> | ((e: MouseEvent, element: HTMLElement, pswp: PhotoSwipe) => void)} [onClick]
 * @prop {'bar' | 'wrapper' | 'root'} [appendTo]
 * @prop {number} [order]
 */
/** @typedef {'arrowPrev' | 'arrowNext' | 'close' | 'zoom' | 'counter'} DefaultUIElements */
/** @typedef {string | UIElementMarkupProps} UIElementMarkup */
/**
 * @param {UIElementMarkup} [htmlData]
 * @returns {string}
 */
function addElementHTML(htmlData) {
  if (typeof htmlData === 'string') {
    // Allow developers to provide full svg,
    // For example:
    // <svg viewBox="0 0 32 32" width="32" height="32" aria-hidden="true" class="pswp__icn">
    //   <path d="..." />
    //   <circle ... />
    // </svg>
    // Can also be any HTML string.
    return htmlData;
  }
  if (!htmlData || !htmlData.isCustomSVG) {
    return '';
  }
  var svgData = htmlData;
  var out = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">'; // replace all %d with size

  out = out.split('%d').join(/** @type {string} */
  svgData.size || 32); // Icons may contain outline/shadow,
  // to make it we "clone" base icon shape and add border to it.
  // Icon itself and border are styled via CSS.
  //
  // Property shadowID defines ID of element that should be cloned.

  if (svgData.outlineID) {
    out += '<use class="pswp__icn-shadow" xlink:href="#' + svgData.outlineID + '"/>';
  }
  out += svgData.inner;
  out += '</svg>';
  return out;
}
var UIElement = /*#__PURE__*/_createClass(
/**
 * @param {PhotoSwipe} pswp
 * @param {UIElementData} data
 */
function UIElement(pswp, data) {
  _classCallCheck(this, UIElement);
  var _container;
  var name = data.name || data.className;
  var elementHTML = data.html; // @ts-expect-error lookup only by `data.name` maybe?

  if (pswp.options[name] === false) {
    // exit if element is disabled from options
    return;
  } // Allow to override SVG icons from options
  // @ts-expect-error lookup only by `data.name` maybe?

  if (typeof pswp.options[name + 'SVG'] === 'string') {
    // arrowPrevSVG
    // arrowNextSVG
    // closeSVG
    // zoomSVG
    // @ts-expect-error lookup only by `data.name` maybe?
    elementHTML = pswp.options[name + 'SVG'];
  }
  pswp.dispatch('uiElementCreate', {
    data: data
  });
  var className = '';
  if (data.isButton) {
    className += 'pswp__button ';
    className += data.className || "pswp__button--".concat(data.name);
  } else {
    className += data.className || "pswp__".concat(data.name);
  }
  var tagName = data.isButton ? data.tagName || 'button' : data.tagName || 'div';
  tagName = /** @type {keyof HTMLElementTagNameMap} */
  tagName.toLowerCase();
  /** @type {HTMLElement} */

  var element = createElement(className, tagName);
  if (data.isButton) {
    if (tagName === 'button') {
      /** @type {HTMLButtonElement} */
      element.type = 'button';
    }
    var title = data.title;
    var ariaLabel = data.ariaLabel; // @ts-expect-error lookup only by `data.name` maybe?

    if (typeof pswp.options[name + 'Title'] === 'string') {
      // @ts-expect-error lookup only by `data.name` maybe?
      title = pswp.options[name + 'Title'];
    }
    if (title) {
      element.title = title;
    }
    var ariaText = ariaLabel || title;
    if (ariaText) {
      element.setAttribute('aria-label', ariaText);
    }
  }
  element.innerHTML = addElementHTML(elementHTML);
  if (data.onInit) {
    data.onInit(element, pswp);
  }
  if (data.onClick) {
    element.onclick = function (e) {
      if (typeof data.onClick === 'string') {
        // @ts-ignore
        pswp[data.onClick]();
      } else if (typeof data.onClick === 'function') {
        data.onClick(e, element, pswp);
      }
    };
  } // Top bar is default position

  var appendTo = data.appendTo || 'bar';
  /** @type {HTMLElement | undefined} root element by default */

  var container = pswp.element;
  if (appendTo === 'bar') {
    if (!pswp.topBar) {
      pswp.topBar = createElement('pswp__top-bar pswp__hide-on-close', 'div', pswp.scrollWrap);
    }
    container = pswp.topBar;
  } else {
    // element outside of top bar gets a secondary class
    // that makes element fade out on close
    element.classList.add('pswp__hide-on-close');
    if (appendTo === 'wrapper') {
      container = pswp.scrollWrap;
    }
  }
  (_container = container) === null || _container === void 0 || _container.appendChild(pswp.applyFilters('uiElement', element, data));
});
/*
  Backward and forward arrow buttons
 */
/** @typedef {import('./ui-element.js').UIElementData} UIElementData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/**
 *
 * @param {HTMLElement} element
 * @param {PhotoSwipe} pswp
 * @param {boolean} [isNextButton]
 */
function initArrowButton(element, pswp, isNextButton) {
  element.classList.add('pswp__button--arrow'); // TODO: this should point to a unique id for this instance

  element.setAttribute('aria-controls', 'pswp__items');
  pswp.on('change', function () {
    if (!pswp.options.loop) {
      if (isNextButton) {
        /** @type {HTMLButtonElement} */
        element.disabled = !(pswp.currIndex < pswp.getNumItems() - 1);
      } else {
        /** @type {HTMLButtonElement} */
        element.disabled = !(pswp.currIndex > 0);
      }
    }
  });
}
/** @type {UIElementData} */

var arrowPrev = {
  name: 'arrowPrev',
  className: 'pswp__button--arrow--prev',
  title: 'Previous',
  order: 10,
  isButton: true,
  appendTo: 'wrapper',
  html: {
    isCustomSVG: true,
    size: 60,
    inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
    outlineID: 'pswp__icn-arrow'
  },
  onClick: 'prev',
  onInit: initArrowButton
};
/** @type {UIElementData} */

var arrowNext = {
  name: 'arrowNext',
  className: 'pswp__button--arrow--next',
  title: 'Next',
  order: 11,
  isButton: true,
  appendTo: 'wrapper',
  html: {
    isCustomSVG: true,
    size: 60,
    inner: '<use xlink:href="#pswp__icn-arrow"/>',
    outlineID: 'pswp__icn-arrow'
  },
  onClick: 'next',
  onInit: function onInit(el, pswp) {
    initArrowButton(el, pswp, true);
  }
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
var closeButton = {
  name: 'close',
  title: 'Close',
  order: 20,
  isButton: true,
  html: {
    isCustomSVG: true,
    inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
    outlineID: 'pswp__icn-close'
  },
  onClick: 'close'
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
var zoomButton = {
  name: 'zoom',
  title: 'Zoom',
  order: 10,
  isButton: true,
  html: {
    isCustomSVG: true,
    // eslint-disable-next-line max-len
    inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/>' + '<path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/>' + '<path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
    outlineID: 'pswp__icn-zoom'
  },
  onClick: 'toggleZoom'
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
var loadingIndicator = {
  name: 'preloader',
  appendTo: 'bar',
  order: 7,
  html: {
    isCustomSVG: true,
    // eslint-disable-next-line max-len
    inner: '<path fill-rule="evenodd" clip-rule="evenodd" d="M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z" id="pswp__icn-loading"/>',
    outlineID: 'pswp__icn-loading'
  },
  onInit: function onInit(indicatorElement, pswp) {
    /** @type {boolean | undefined} */
    var isVisible;
    /** @type {NodeJS.Timeout | null} */

    var delayTimeout = null;
    /**
     * @param {string} className
     * @param {boolean} add
     */

    var toggleIndicatorClass = function toggleIndicatorClass(className, add) {
      indicatorElement.classList.toggle('pswp__preloader--' + className, add);
    };
    /**
     * @param {boolean} visible
     */

    var setIndicatorVisibility = function setIndicatorVisibility(visible) {
      if (isVisible !== visible) {
        isVisible = visible;
        toggleIndicatorClass('active', visible);
      }
    };
    var updatePreloaderVisibility = function updatePreloaderVisibility() {
      var _pswp$currSlide;
      if (!((_pswp$currSlide = pswp.currSlide) !== null && _pswp$currSlide !== void 0 && _pswp$currSlide.content.isLoading())) {
        setIndicatorVisibility(false);
        if (delayTimeout) {
          clearTimeout(delayTimeout);
          delayTimeout = null;
        }
        return;
      }
      if (!delayTimeout) {
        // display loading indicator with delay
        delayTimeout = setTimeout(function () {
          var _pswp$currSlide2;
          setIndicatorVisibility(Boolean((_pswp$currSlide2 = pswp.currSlide) === null || _pswp$currSlide2 === void 0 ? void 0 : _pswp$currSlide2.content.isLoading()));
          delayTimeout = null;
        }, pswp.options.preloaderDelay);
      }
    };
    pswp.on('change', updatePreloaderVisibility);
    pswp.on('loadComplete', function (e) {
      if (pswp.currSlide === e.slide) {
        updatePreloaderVisibility();
      }
    }); // expose the method

    if (pswp.ui) {
      pswp.ui.updatePreloaderVisibility = updatePreloaderVisibility;
    }
  }
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
var counterIndicator = {
  name: 'counter',
  order: 5,
  onInit: function onInit(counterElement, pswp) {
    pswp.on('change', function () {
      counterElement.innerText = pswp.currIndex + 1 + pswp.options.indexIndicatorSep + pswp.getNumItems();
    });
  }
};

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {import('./ui-element.js').UIElementData} UIElementData */

/**
 * Set special class on element when image is zoomed.
 *
 * By default, it is used to adjust
 * zoom icon and zoom cursor via CSS.
 *
 * @param {HTMLElement} el
 * @param {boolean} isZoomedIn
 */

function setZoomedIn(el, isZoomedIn) {
  el.classList.toggle('pswp--zoomed-in', isZoomedIn);
}
var UI = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function UI(pswp) {
    _classCallCheck(this, UI);
    this.pswp = pswp;
    this.isRegistered = false;
    /** @type {UIElementData[]} */

    this.uiElementsData = [];
    /** @type {(UIElement | UIElementData)[]} */

    this.items = [];
    /** @type {() => void} */

    this.updatePreloaderVisibility = function () {};
    /**
     * @private
     * @type {number | undefined}
     */

    this._lastUpdatedZoomLevel = undefined;
  }
  return _createClass(UI, [{
    key: "init",
    value: function init() {
      var _this11 = this;
      var pswp = this.pswp;
      this.isRegistered = false;
      this.uiElementsData = [closeButton, arrowPrev, arrowNext, zoomButton, loadingIndicator, counterIndicator];
      pswp.dispatch('uiRegister'); // sort by order

      this.uiElementsData.sort(function (a, b) {
        // default order is 0
        return (a.order || 0) - (b.order || 0);
      });
      this.items = [];
      this.isRegistered = true;
      this.uiElementsData.forEach(function (uiElementData) {
        _this11.registerElement(uiElementData);
      });
      pswp.on('change', function () {
        var _pswp$element;
        (_pswp$element = pswp.element) === null || _pswp$element === void 0 || _pswp$element.classList.toggle('pswp--one-slide', pswp.getNumItems() === 1);
      });
      pswp.on('zoomPanUpdate', function () {
        return _this11._onZoomPanUpdate();
      });
    }
    /**
     * @param {UIElementData} elementData
     */
  }, {
    key: "registerElement",
    value: function registerElement(elementData) {
      if (this.isRegistered) {
        this.items.push(new UIElement(this.pswp, elementData));
      } else {
        this.uiElementsData.push(elementData);
      }
    }
    /**
     * Fired each time zoom or pan position is changed.
     * Update classes that control visibility of zoom button and cursor icon.
     *
     * @private
     */
  }, {
    key: "_onZoomPanUpdate",
    value: function _onZoomPanUpdate() {
      var _this$pswp6 = this.pswp,
        template = _this$pswp6.template,
        currSlide = _this$pswp6.currSlide,
        options = _this$pswp6.options;
      if (this.pswp.opener.isClosing || !template || !currSlide) {
        return;
      }
      var currZoomLevel = currSlide.currZoomLevel; // if not open yet - check against initial zoom level

      if (!this.pswp.opener.isOpen) {
        currZoomLevel = currSlide.zoomLevels.initial;
      }
      if (currZoomLevel === this._lastUpdatedZoomLevel) {
        return;
      }
      this._lastUpdatedZoomLevel = currZoomLevel;
      var currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary; // Initial and secondary zoom levels are almost equal

      if (Math.abs(currZoomLevelDiff) < 0.01 || !currSlide.isZoomable()) {
        // disable zoom
        setZoomedIn(template, false);
        template.classList.remove('pswp--zoom-allowed');
        return;
      }
      template.classList.add('pswp--zoom-allowed');
      var potentialZoomLevel = currZoomLevel === currSlide.zoomLevels.initial ? currSlide.zoomLevels.secondary : currSlide.zoomLevels.initial;
      setZoomedIn(template, potentialZoomLevel <= currZoomLevel);
      if (options.imageClickAction === 'zoom' || options.imageClickAction === 'zoom-or-close') {
        template.classList.add('pswp--click-to-zoom');
      }
    }
  }]);
}();
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {{ x: number; y: number; w: number; innerRect?: { w: number; h: number; x: number; y: number } }} Bounds */
/**
 * @param {HTMLElement} el
 * @returns Bounds
 */
function getBoundsByElement(el) {
  var thumbAreaRect = el.getBoundingClientRect();
  return {
    x: thumbAreaRect.left,
    y: thumbAreaRect.top,
    w: thumbAreaRect.width
  };
}
/**
 * @param {HTMLElement} el
 * @param {number} imageWidth
 * @param {number} imageHeight
 * @returns Bounds
 */

function getCroppedBoundsByElement(el, imageWidth, imageHeight) {
  var thumbAreaRect = el.getBoundingClientRect(); // fill image into the area
  // (do they same as object-fit:cover does to retrieve coordinates)

  var hRatio = thumbAreaRect.width / imageWidth;
  var vRatio = thumbAreaRect.height / imageHeight;
  var fillZoomLevel = hRatio > vRatio ? hRatio : vRatio;
  var offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2;
  var offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2;
  /**
   * Coordinates of the image,
   * as if it was not cropped,
   * height is calculated automatically
   *
   * @type {Bounds}
   */

  var bounds = {
    x: thumbAreaRect.left + offsetX,
    y: thumbAreaRect.top + offsetY,
    w: imageWidth * fillZoomLevel
  }; // Coordinates of inner crop area
  // relative to the image

  bounds.innerRect = {
    w: thumbAreaRect.width,
    h: thumbAreaRect.height,
    x: offsetX,
    y: offsetY
  };
  return bounds;
}
/**
 * Get dimensions of thumbnail image
 * (click on which opens photoswipe or closes photoswipe to)
 *
 * @param {number} index
 * @param {SlideData} itemData
 * @param {PhotoSwipe} instance PhotoSwipe instance
 * @returns {Bounds | undefined}
 */

function _getThumbBounds(index, itemData, instance) {
  // legacy event, before filters were introduced
  var event = instance.dispatch('thumbBounds', {
    index: index,
    itemData: itemData,
    instance: instance
  }); // @ts-expect-error

  if (event.thumbBounds) {
    // @ts-expect-error
    return event.thumbBounds;
  }
  var element = itemData.element;
  /** @type {Bounds | undefined} */

  var thumbBounds;
  /** @type {HTMLElement | null | undefined} */

  var thumbnail;
  if (element && instance.options.thumbSelector !== false) {
    var thumbSelector = instance.options.thumbSelector || 'img';
    thumbnail = element.matches(thumbSelector) ? element : /** @type {HTMLElement | null} */
    element.querySelector(thumbSelector);
  }
  thumbnail = instance.applyFilters('thumbEl', thumbnail, itemData, index);
  if (thumbnail) {
    if (!itemData.thumbCropped) {
      thumbBounds = getBoundsByElement(thumbnail);
    } else {
      thumbBounds = getCroppedBoundsByElement(thumbnail, itemData.width || itemData.w || 0, itemData.height || itemData.h || 0);
    }
  }
  return instance.applyFilters('thumbBounds', thumbBounds, itemData, index);
}

/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */

/** @typedef {import('../photoswipe.js').DataSource} DataSource */

/** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */

/** @typedef {import('../slide/content.js').default} ContentDefault */

/** @typedef {import('../slide/slide.js').default} Slide */

/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */

/** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */

/**
 * Allow adding an arbitrary props to the Content
 * https://photoswipe.com/custom-content/#using-webp-image-format
 * @typedef {ContentDefault & Record<string, any>} Content
 */

/** @typedef {{ x?: number; y?: number }} Point */

/**
 * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/
 *
 *
 * https://photoswipe.com/adding-ui-elements/
 *
 * @prop {undefined} uiRegister
 * @prop {{ data: UIElementData }} uiElementCreate
 *
 *
 * https://photoswipe.com/events/#initialization-events
 *
 * @prop {undefined} beforeOpen
 * @prop {undefined} firstUpdate
 * @prop {undefined} initialLayout
 * @prop {undefined} change
 * @prop {undefined} afterInit
 * @prop {undefined} bindEvents
 *
 *
 * https://photoswipe.com/events/#opening-or-closing-transition-events
 *
 * @prop {undefined} openingAnimationStart
 * @prop {undefined} openingAnimationEnd
 * @prop {undefined} closingAnimationStart
 * @prop {undefined} closingAnimationEnd
 *
 *
 * https://photoswipe.com/events/#closing-events
 *
 * @prop {undefined} close
 * @prop {undefined} destroy
 *
 *
 * https://photoswipe.com/events/#pointer-and-gesture-events
 *
 * @prop {{ originalEvent: PointerEvent }} pointerDown
 * @prop {{ originalEvent: PointerEvent }} pointerMove
 * @prop {{ originalEvent: PointerEvent }} pointerUp
 * @prop {{ bgOpacity: number }} pinchClose can be default prevented
 * @prop {{ panY: number }} verticalDrag can be default prevented
 *
 *
 * https://photoswipe.com/events/#slide-content-events
 *
 * @prop {{ content: Content }} contentInit
 * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented
 * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented
 * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete
 * @prop {{ content: Content; slide: Slide }} loadError
 * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented
 * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange
 * @prop {{ content: Content }} contentLazyLoad can be default prevented
 * @prop {{ content: Content }} contentAppend can be default prevented
 * @prop {{ content: Content }} contentActivate can be default prevented
 * @prop {{ content: Content }} contentDeactivate can be default prevented
 * @prop {{ content: Content }} contentRemove can be default prevented
 * @prop {{ content: Content }} contentDestroy can be default prevented
 *
 *
 * undocumented
 *
 * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented
 *
 * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented
 * @prop {{ x: number; dragging: boolean }} moveMainScroll
 * @prop {{ slide: Slide }} firstZoomPan
 * @prop {{ slide: Slide | undefined, data: SlideData, index: number }} gettingData
 * @prop {undefined} beforeResize
 * @prop {undefined} resize
 * @prop {undefined} viewportSize
 * @prop {undefined} updateScrollOffset
 * @prop {{ slide: Slide }} slideInit
 * @prop {{ slide: Slide }} afterSetContent
 * @prop {{ slide: Slide }} slideLoad
 * @prop {{ slide: Slide }} appendHeavy can be default prevented
 * @prop {{ slide: Slide }} appendHeavyContent
 * @prop {{ slide: Slide }} slideActivate
 * @prop {{ slide: Slide }} slideDeactivate
 * @prop {{ slide: Slide }} slideDestroy
 * @prop {{ destZoomLevel: number, centerPoint: Point | undefined, transitionDuration: number | false | undefined }} beforeZoomTo
 * @prop {{ slide: Slide }} zoomPanUpdate
 * @prop {{ slide: Slide }} initialZoomPan
 * @prop {{ slide: Slide }} calcSlideSize
 * @prop {undefined} resolutionChanged
 * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented
 * @prop {{ content: Content }} contentAppendImage can be default prevented
 * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented
 * @prop {undefined} lazyLoad
 * @prop {{ slide: Slide }} calcBounds
 * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate
 *
 *
 * legacy
 *
 * @prop {undefined} init
 * @prop {undefined} initialZoomIn
 * @prop {undefined} initialZoomOut
 * @prop {undefined} initialZoomInEnd
 * @prop {undefined} initialZoomOutEnd
 * @prop {{ dataSource: DataSource | undefined, numItems: number }} numItems
 * @prop {{ itemData: SlideData; index: number }} itemData
 * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds
 */

/**
 * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/
 *
 * @prop {(numItems: number, dataSource: DataSource | undefined) => number} numItems
 * Modify the total amount of slides. Example on Data sources page.
 * https://photoswipe.com/filters/#numitems
 *
 * @prop {(itemData: SlideData, index: number) => SlideData} itemData
 * Modify slide item data. Example on Data sources page.
 * https://photoswipe.com/filters/#itemdata
 *
 * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData
 * Modify item data when it's parsed from DOM element. Example on Data sources page.
 * https://photoswipe.com/filters/#domitemdata
 *
 * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex
 * Modify clicked gallery item index.
 * https://photoswipe.com/filters/#clickedindex
 *
 * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc
 * Modify placeholder image source.
 * https://photoswipe.com/filters/#placeholdersrc
 *
 * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading
 * Modify if the content is currently loading.
 * https://photoswipe.com/filters/#iscontentloading
 *
 * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable
 * Modify if the content can be zoomed.
 * https://photoswipe.com/filters/#iscontentzoomable
 *
 * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder
 * Modify if the placeholder should be used for the content.
 * https://photoswipe.com/filters/#usecontentplaceholder
 *
 * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder
 * Modify if the placeholder should be kept after the content is loaded.
 * https://photoswipe.com/filters/#iskeepingplaceholder
 *
 *
 * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement
 * Modify an element when the content has error state (for example, if image cannot be loaded).
 * https://photoswipe.com/filters/#contenterrorelement
 *
 * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement
 * Modify a UI element that's being created.
 * https://photoswipe.com/filters/#uielement
 *
 * @prop {(thumbnail: HTMLElement | null | undefined, itemData: SlideData, index: number) => HTMLElement} thumbEl
 * Modify the thumbnail element from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbel
 *
 * @prop {(thumbBounds: Bounds | undefined, itemData: SlideData, index: number) => Bounds} thumbBounds
 * Modify the thumbnail bounds from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbbounds
 *
 * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth
 *
 * @prop {(preventPointerEvent: boolean, event: PointerEvent, pointerType: string) => boolean} preventPointerEvent
 *
 */

/**
 * @template {keyof PhotoSwipeFiltersMap} T
 * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {(event: AugmentedEvent<T>) => void} EventCallback
 */

/**
 * Base PhotoSwipe event object
 *
 * @template {keyof PhotoSwipeEventsMap} T
 */
var PhotoSwipeEvent = /*#__PURE__*/function () {
  /**
   * @param {T} type
   * @param {PhotoSwipeEventsMap[T]} [details]
   */
  function PhotoSwipeEvent(type, details) {
    _classCallCheck(this, PhotoSwipeEvent);
    this.type = type;
    this.defaultPrevented = false;
    if (details) {
      Object.assign(this, details);
    }
  }
  return _createClass(PhotoSwipeEvent, [{
    key: "preventDefault",
    value: function preventDefault() {
      this.defaultPrevented = true;
    }
  }]);
}();
/**
 * PhotoSwipe base class that can listen and dispatch for events.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js
 */
var Eventable = /*#__PURE__*/function () {
  function Eventable() {
    _classCallCheck(this, Eventable);
    /**
     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}
     */
    this._listeners = {};
    /**
     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}
     */

    this._filters = {};
    /** @type {PhotoSwipe | undefined} */

    this.pswp = undefined;
    /** @type {PhotoSwipeOptions | undefined} */

    this.options = undefined;
  }
  /**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {PhotoSwipeFiltersMap[T]} fn
   * @param {number} priority
   */
  return _createClass(Eventable, [{
    key: "addFilter",
    value: function addFilter(name, fn) {
      var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
      var _this$_filters$name, _this$_filters$name2, _this$pswp;
      if (!this._filters[name]) {
        this._filters[name] = [];
      }
      (_this$_filters$name = this._filters[name]) === null || _this$_filters$name === void 0 || _this$_filters$name.push({
        fn: fn,
        priority: priority
      });
      (_this$_filters$name2 = this._filters[name]) === null || _this$_filters$name2 === void 0 || _this$_filters$name2.sort(function (f1, f2) {
        return f1.priority - f2.priority;
      });
      (_this$pswp = this.pswp) === null || _this$pswp === void 0 || _this$pswp.addFilter(name, fn, priority);
    }
    /**
     * @template {keyof PhotoSwipeFiltersMap} T
     * @param {T} name
     * @param {PhotoSwipeFiltersMap[T]} fn
     */
  }, {
    key: "removeFilter",
    value: function removeFilter(name, fn) {
      if (this._filters[name]) {
        // @ts-expect-error
        this._filters[name] = this._filters[name].filter(function (filter) {
          return filter.fn !== fn;
        });
      }
      if (this.pswp) {
        this.pswp.removeFilter(name, fn);
      }
    }
    /**
     * @template {keyof PhotoSwipeFiltersMap} T
     * @param {T} name
     * @param {Parameters<PhotoSwipeFiltersMap[T]>} args
     * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}
     */
  }, {
    key: "applyFilters",
    value: function applyFilters(name) {
      var _this12 = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var _this$_filters$name3;
      (_this$_filters$name3 = this._filters[name]) === null || _this$_filters$name3 === void 0 || _this$_filters$name3.forEach(function (filter) {
        // @ts-expect-error
        args[0] = filter.fn.apply(_this12, args);
      });
      return args[0];
    }
    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @param {T} name
     * @param {EventCallback<T>} fn
     */
  }, {
    key: "on",
    value: function on(name, fn) {
      var _this$_listeners$name, _this$pswp2;
      if (!this._listeners[name]) {
        this._listeners[name] = [];
      }
      (_this$_listeners$name = this._listeners[name]) === null || _this$_listeners$name === void 0 || _this$_listeners$name.push(fn); // When binding events to lightbox,
      // also bind events to PhotoSwipe Core,
      // if it's open.

      (_this$pswp2 = this.pswp) === null || _this$pswp2 === void 0 || _this$pswp2.on(name, fn);
    }
    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @param {T} name
     * @param {EventCallback<T>} fn
     */
  }, {
    key: "off",
    value: function off(name, fn) {
      var _this$pswp3;
      if (this._listeners[name]) {
        // @ts-expect-error
        this._listeners[name] = this._listeners[name].filter(function (listener) {
          return fn !== listener;
        });
      }
      (_this$pswp3 = this.pswp) === null || _this$pswp3 === void 0 || _this$pswp3.off(name, fn);
    }
    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @param {T} name
     * @param {PhotoSwipeEventsMap[T]} [details]
     * @returns {AugmentedEvent<T>}
     */
  }, {
    key: "dispatch",
    value: function dispatch(name, details) {
      var _this13 = this;
      var _this$_listeners$name2;
      if (this.pswp) {
        return this.pswp.dispatch(name, details);
      }
      var event = /** @type {AugmentedEvent<T>} */
      new PhotoSwipeEvent(name, details);
      (_this$_listeners$name2 = this._listeners[name]) === null || _this$_listeners$name2 === void 0 || _this$_listeners$name2.forEach(function (listener) {
        listener.call(_this13, event);
      });
      return event;
    }
  }]);
}();
var Placeholder = /*#__PURE__*/function () {
  /**
   * @param {string | false} imageSrc
   * @param {HTMLElement} container
   */
  function Placeholder(imageSrc, container) {
    _classCallCheck(this, Placeholder);
    // Create placeholder
    // (stretched thumbnail or simple div behind the main image)

    /** @type {HTMLImageElement | HTMLDivElement | null} */
    this.element = createElement('pswp__img pswp__img--placeholder', imageSrc ? 'img' : 'div', container);
    if (imageSrc) {
      var imgEl = /** @type {HTMLImageElement} */
      this.element;
      imgEl.decoding = 'async';
      imgEl.alt = '';
      imgEl.src = imageSrc;
      imgEl.setAttribute('role', 'presentation');
    }
    this.element.setAttribute('aria-hidden', 'true');
  }
  /**
   * @param {number} width
   * @param {number} height
   */
  return _createClass(Placeholder, [{
    key: "setDisplayedSize",
    value: function setDisplayedSize(width, height) {
      if (!this.element) {
        return;
      }
      if (this.element.tagName === 'IMG') {
        // Use transform scale() to modify img placeholder size
        // (instead of changing width/height directly).
        // This helps with performance, specifically in iOS15 Safari.
        setWidthHeight(this.element, 250, 'auto');
        this.element.style.transformOrigin = '0 0';
        this.element.style.transform = toTransformString(0, 0, width / 250);
      } else {
        setWidthHeight(this.element, width, height);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$element;
      if ((_this$element = this.element) !== null && _this$element !== void 0 && _this$element.parentNode) {
        this.element.remove();
      }
      this.element = null;
    }
  }]);
}();
/** @typedef {import('./slide.js').default} Slide */
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../util/util.js').LoadState} LoadState */
var Content = /*#__PURE__*/function () {
  /**
   * @param {SlideData} itemData Slide data
   * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance
   * @param {number} index
   */
  function Content(itemData, instance, index) {
    _classCallCheck(this, Content);
    this.instance = instance;
    this.data = itemData;
    this.index = index;
    /** @type {HTMLImageElement | HTMLDivElement | undefined} */

    this.element = undefined;
    /** @type {Placeholder | undefined} */

    this.placeholder = undefined;
    /** @type {Slide | undefined} */

    this.slide = undefined;
    this.displayedImageWidth = 0;
    this.displayedImageHeight = 0;
    this.width = Number(this.data.w) || Number(this.data.width) || 0;
    this.height = Number(this.data.h) || Number(this.data.height) || 0;
    this.isAttached = false;
    this.hasSlide = false;
    this.isDecoding = false;
    /** @type {LoadState} */

    this.state = LOAD_STATE.IDLE;
    if (this.data.type) {
      this.type = this.data.type;
    } else if (this.data.src) {
      this.type = 'image';
    } else {
      this.type = 'html';
    }
    this.instance.dispatch('contentInit', {
      content: this
    });
  }
  return _createClass(Content, [{
    key: "removePlaceholder",
    value: function removePlaceholder() {
      var _this14 = this;
      if (this.placeholder && !this.keepPlaceholder()) {
        // With delay, as image might be loaded, but not rendered
        setTimeout(function () {
          if (_this14.placeholder) {
            _this14.placeholder.destroy();
            _this14.placeholder = undefined;
          }
        }, 1000);
      }
    }
    /**
     * Preload content
     *
     * @param {boolean} isLazy
     * @param {boolean} [reload]
     */
  }, {
    key: "load",
    value: function load(isLazy, reload) {
      if (this.slide && this.usePlaceholder()) {
        if (!this.placeholder) {
          var placeholderSrc = this.instance.applyFilters('placeholderSrc',
          // use  image-based placeholder only for the first slide,
          // as rendering (even small stretched thumbnail) is an expensive operation
          this.data.msrc && this.slide.isFirstSlide ? this.data.msrc : false, this);
          this.placeholder = new Placeholder(placeholderSrc, this.slide.container);
        } else {
          var placeholderEl = this.placeholder.element; // Add placeholder to DOM if it was already created

          if (placeholderEl && !placeholderEl.parentElement) {
            this.slide.container.prepend(placeholderEl);
          }
        }
      }
      if (this.element && !reload) {
        return;
      }
      if (this.instance.dispatch('contentLoad', {
        content: this,
        isLazy: isLazy
      }).defaultPrevented) {
        return;
      }
      if (this.isImageContent()) {
        this.element = createElement('pswp__img', 'img'); // Start loading only after width is defined, as sizes might depend on it.
        // Due to Safari feature, we must define sizes before srcset.

        if (this.displayedImageWidth) {
          this.loadImage(isLazy);
        }
      } else {
        this.element = createElement('pswp__content', 'div');
        this.element.innerHTML = this.data.html || '';
      }
      if (reload && this.slide) {
        this.slide.updateContentSize(true);
      }
    }
    /**
     * Preload image
     *
     * @param {boolean} isLazy
     */
  }, {
    key: "loadImage",
    value: function loadImage(isLazy) {
      var _this15 = this;
      var _this$data$src, _this$data$alt;
      if (!this.isImageContent() || !this.element || this.instance.dispatch('contentLoadImage', {
        content: this,
        isLazy: isLazy
      }).defaultPrevented) {
        return;
      }
      var imageElement = /** @type HTMLImageElement */
      this.element;
      this.updateSrcsetSizes();
      if (this.data.srcset) {
        imageElement.srcset = this.data.srcset;
      }
      imageElement.src = (_this$data$src = this.data.src) !== null && _this$data$src !== void 0 ? _this$data$src : '';
      imageElement.alt = (_this$data$alt = this.data.alt) !== null && _this$data$alt !== void 0 ? _this$data$alt : '';
      this.state = LOAD_STATE.LOADING;
      if (imageElement.complete) {
        this.onLoaded();
      } else {
        imageElement.onload = function () {
          _this15.onLoaded();
        };
        imageElement.onerror = function () {
          _this15.onError();
        };
      }
    }
    /**
     * Assign slide to content
     *
     * @param {Slide} slide
     */
  }, {
    key: "setSlide",
    value: function setSlide(slide) {
      this.slide = slide;
      this.hasSlide = true;
      this.instance = slide.pswp; // todo: do we need to unset slide?
    }
    /**
     * Content load success handler
     */
  }, {
    key: "onLoaded",
    value: function onLoaded() {
      this.state = LOAD_STATE.LOADED;
      if (this.slide && this.element) {
        this.instance.dispatch('loadComplete', {
          slide: this.slide,
          content: this
        }); // if content is reloaded

        if (this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode) {
          this.append();
          this.slide.updateContentSize(true);
        }
        if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
          this.removePlaceholder();
        }
      }
    }
    /**
     * Content load error handler
     */
  }, {
    key: "onError",
    value: function onError() {
      this.state = LOAD_STATE.ERROR;
      if (this.slide) {
        this.displayError();
        this.instance.dispatch('loadComplete', {
          slide: this.slide,
          isError: true,
          content: this
        });
        this.instance.dispatch('loadError', {
          slide: this.slide,
          content: this
        });
      }
    }
    /**
     * @returns {Boolean} If the content is currently loading
     */
  }, {
    key: "isLoading",
    value: function isLoading() {
      return this.instance.applyFilters('isContentLoading', this.state === LOAD_STATE.LOADING, this);
    }
    /**
     * @returns {Boolean} If the content is in error state
     */
  }, {
    key: "isError",
    value: function isError() {
      return this.state === LOAD_STATE.ERROR;
    }
    /**
     * @returns {boolean} If the content is image
     */
  }, {
    key: "isImageContent",
    value: function isImageContent() {
      return this.type === 'image';
    }
    /**
     * Update content size
     *
     * @param {Number} width
     * @param {Number} height
     */
  }, {
    key: "setDisplayedSize",
    value: function setDisplayedSize(width, height) {
      if (!this.element) {
        return;
      }
      if (this.placeholder) {
        this.placeholder.setDisplayedSize(width, height);
      }
      if (this.instance.dispatch('contentResize', {
        content: this,
        width: width,
        height: height
      }).defaultPrevented) {
        return;
      }
      setWidthHeight(this.element, width, height);
      if (this.isImageContent() && !this.isError()) {
        var isInitialSizeUpdate = !this.displayedImageWidth && width;
        this.displayedImageWidth = width;
        this.displayedImageHeight = height;
        if (isInitialSizeUpdate) {
          this.loadImage(false);
        } else {
          this.updateSrcsetSizes();
        }
        if (this.slide) {
          this.instance.dispatch('imageSizeChange', {
            slide: this.slide,
            width: width,
            height: height,
            content: this
          });
        }
      }
    }
    /**
     * @returns {boolean} If the content can be zoomed
     */
  }, {
    key: "isZoomable",
    value: function isZoomable() {
      return this.instance.applyFilters('isContentZoomable', this.isImageContent() && this.state !== LOAD_STATE.ERROR, this);
    }
    /**
     * Update image srcset sizes attribute based on width and height
     */
  }, {
    key: "updateSrcsetSizes",
    value: function updateSrcsetSizes() {
      // Handle srcset sizes attribute.
      //
      // Never lower quality, if it was increased previously.
      // Chrome does this automatically, Firefox and Safari do not,
      // so we store largest used size in dataset.
      if (!this.isImageContent() || !this.element || !this.data.srcset) {
        return;
      }
      var image = /** @type HTMLImageElement */
      this.element;
      var sizesWidth = this.instance.applyFilters('srcsetSizesWidth', this.displayedImageWidth, this);
      if (!image.dataset.largestUsedSize || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)) {
        image.sizes = sizesWidth + 'px';
        image.dataset.largestUsedSize = String(sizesWidth);
      }
    }
    /**
     * @returns {boolean} If content should use a placeholder (from msrc by default)
     */
  }, {
    key: "usePlaceholder",
    value: function usePlaceholder() {
      return this.instance.applyFilters('useContentPlaceholder', this.isImageContent(), this);
    }
    /**
     * Preload content with lazy-loading param
     */
  }, {
    key: "lazyLoad",
    value: function lazyLoad() {
      if (this.instance.dispatch('contentLazyLoad', {
        content: this
      }).defaultPrevented) {
        return;
      }
      this.load(true);
    }
    /**
     * @returns {boolean} If placeholder should be kept after content is loaded
     */
  }, {
    key: "keepPlaceholder",
    value: function keepPlaceholder() {
      return this.instance.applyFilters('isKeepingPlaceholder', this.isLoading(), this);
    }
    /**
     * Destroy the content
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.hasSlide = false;
      this.slide = undefined;
      if (this.instance.dispatch('contentDestroy', {
        content: this
      }).defaultPrevented) {
        return;
      }
      this.remove();
      if (this.placeholder) {
        this.placeholder.destroy();
        this.placeholder = undefined;
      }
      if (this.isImageContent() && this.element) {
        this.element.onload = null;
        this.element.onerror = null;
        this.element = undefined;
      }
    }
    /**
     * Display error message
     */
  }, {
    key: "displayError",
    value: function displayError() {
      if (this.slide) {
        var _this$instance$option, _this$instance$option2;
        var errorMsgEl = createElement('pswp__error-msg', 'div');
        errorMsgEl.innerText = (_this$instance$option = (_this$instance$option2 = this.instance.options) === null || _this$instance$option2 === void 0 ? void 0 : _this$instance$option2.errorMsg) !== null && _this$instance$option !== void 0 ? _this$instance$option : '';
        errorMsgEl = /** @type {HTMLDivElement} */
        this.instance.applyFilters('contentErrorElement', errorMsgEl, this);
        this.element = createElement('pswp__content pswp__error-msg-container', 'div');
        this.element.appendChild(errorMsgEl);
        this.slide.container.innerText = '';
        this.slide.container.appendChild(this.element);
        this.slide.updateContentSize(true);
        this.removePlaceholder();
      }
    }
    /**
     * Append the content
     */
  }, {
    key: "append",
    value: function append() {
      var _this16 = this;
      if (this.isAttached || !this.element) {
        return;
      }
      this.isAttached = true;
      if (this.state === LOAD_STATE.ERROR) {
        this.displayError();
        return;
      }
      if (this.instance.dispatch('contentAppend', {
        content: this
      }).defaultPrevented) {
        return;
      }
      var supportsDecode = 'decode' in this.element;
      if (this.isImageContent()) {
        // Use decode() on nearby slides
        //
        // Nearby slide images are in DOM and not hidden via display:none.
        // However, they are placed offscreen (to the left and right side).
        //
        // Some browsers do not composite the image until it's actually visible,
        // using decode() helps.
        //
        // You might ask "why dont you just decode() and then append all images",
        // that's because I want to show image before it's fully loaded,
        // as browser can render parts of image while it is loading.
        // We do not do this in Safari due to partial loading bug.
        if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {
          this.isDecoding = true; // purposefully using finally instead of then,
          // as if srcset sizes changes dynamically - it may cause decode error

          /** @type {HTMLImageElement} */

          this.element.decode()["catch"](function () {})["finally"](function () {
            _this16.isDecoding = false;
            _this16.appendImage();
          });
        } else {
          this.appendImage();
        }
      } else if (this.slide && !this.element.parentNode) {
        this.slide.container.appendChild(this.element);
      }
    }
    /**
     * Activate the slide,
     * active slide is generally the current one,
     * meaning the user can see it.
     */
  }, {
    key: "activate",
    value: function activate() {
      if (this.instance.dispatch('contentActivate', {
        content: this
      }).defaultPrevented || !this.slide) {
        return;
      }
      if (this.isImageContent() && this.isDecoding && !isSafari()) {
        // add image to slide when it becomes active,
        // even if it's not finished decoding
        this.appendImage();
      } else if (this.isError()) {
        this.load(false, true); // try to reload
      }
      if (this.slide.holderElement) {
        this.slide.holderElement.setAttribute('aria-hidden', 'false');
      }
    }
    /**
     * Deactivate the content
     */
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.instance.dispatch('contentDeactivate', {
        content: this
      });
      if (this.slide && this.slide.holderElement) {
        this.slide.holderElement.setAttribute('aria-hidden', 'true');
      }
    }
    /**
     * Remove the content from DOM
     */
  }, {
    key: "remove",
    value: function remove() {
      this.isAttached = false;
      if (this.instance.dispatch('contentRemove', {
        content: this
      }).defaultPrevented) {
        return;
      }
      if (this.element && this.element.parentNode) {
        this.element.remove();
      }
      if (this.placeholder && this.placeholder.element) {
        this.placeholder.element.remove();
      }
    }
    /**
     * Append the image content to slide container
     */
  }, {
    key: "appendImage",
    value: function appendImage() {
      if (!this.isAttached) {
        return;
      }
      if (this.instance.dispatch('contentAppendImage', {
        content: this
      }).defaultPrevented) {
        return;
      } // ensure that element exists and is not already appended

      if (this.slide && this.element && !this.element.parentNode) {
        this.slide.container.appendChild(this.element);
      }
      if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
        this.removePlaceholder();
      }
    }
  }]);
}();
/** @typedef {import('./content.js').default} Content */
/** @typedef {import('./slide.js').default} Slide */
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
var MIN_SLIDES_TO_CACHE = 5;
/**
 * Lazy-load an image
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * @param {SlideData} itemData Data about the slide
 * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance
 * @param {number} index
 * @returns {Content} Image that is being decoded or false.
 */

function _lazyLoadData(itemData, instance, index) {
  var content = instance.createContentFromData(itemData, index);
  /** @type {ZoomLevel | undefined} */

  var zoomLevel;
  var options = instance.options; // We need to know dimensions of the image to preload it,
  // as it might use srcset, and we need to define sizes

  if (options) {
    zoomLevel = new ZoomLevel(options, itemData, -1);
    var viewportSize;
    if (instance.pswp) {
      viewportSize = instance.pswp.viewportSize;
    } else {
      viewportSize = getViewportSize(options, instance);
    }
    var panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);
    zoomLevel.update(content.width, content.height, panAreaSize);
  }
  content.lazyLoad();
  if (zoomLevel) {
    content.setDisplayedSize(Math.ceil(content.width * zoomLevel.initial), Math.ceil(content.height * zoomLevel.initial));
  }
  return content;
}
/**
 * Lazy-loads specific slide.
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * By default, it loads image based on viewport size and initial zoom level.
 *
 * @param {number} index Slide index
 * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox eventable instance
 * @returns {Content | undefined}
 */

function lazyLoadSlide(index, instance) {
  var itemData = instance.getItemData(index);
  if (instance.dispatch('lazyLoadSlide', {
    index: index,
    itemData: itemData
  }).defaultPrevented) {
    return;
  }
  return _lazyLoadData(itemData, instance, index);
}
var ContentLoader = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function ContentLoader(pswp) {
    _classCallCheck(this, ContentLoader);
    this.pswp = pswp; // Total amount of cached images

    this.limit = Math.max(pswp.options.preload[0] + pswp.options.preload[1] + 1, MIN_SLIDES_TO_CACHE);
    /** @type {Content[]} */

    this._cachedItems = [];
  }
  /**
   * Lazy load nearby slides based on `preload` option.
   *
   * @param {number} [diff] Difference between slide indexes that was changed recently, or 0.
   */
  return _createClass(ContentLoader, [{
    key: "updateLazy",
    value: function updateLazy(diff) {
      var pswp = this.pswp;
      if (pswp.dispatch('lazyLoad').defaultPrevented) {
        return;
      }
      var preload = pswp.options.preload;
      var isForward = diff === undefined ? true : diff >= 0;
      var i; // preload[1] - num items to preload in forward direction

      for (i = 0; i <= preload[1]; i++) {
        this.loadSlideByIndex(pswp.currIndex + (isForward ? i : -i));
      } // preload[0] - num items to preload in backward direction

      for (i = 1; i <= preload[0]; i++) {
        this.loadSlideByIndex(pswp.currIndex + (isForward ? -i : i));
      }
    }
    /**
     * @param {number} initialIndex
     */
  }, {
    key: "loadSlideByIndex",
    value: function loadSlideByIndex(initialIndex) {
      var index = this.pswp.getLoopedIndex(initialIndex); // try to get cached content

      var content = this.getContentByIndex(index);
      if (!content) {
        // no cached content, so try to load from scratch:
        content = lazyLoadSlide(index, this.pswp); // if content can be loaded, add it to cache:

        if (content) {
          this.addToCache(content);
        }
      }
    }
    /**
     * @param {Slide} slide
     * @returns {Content}
     */
  }, {
    key: "getContentBySlide",
    value: function getContentBySlide(slide) {
      var content = this.getContentByIndex(slide.index);
      if (!content) {
        // create content if not found in cache
        content = this.pswp.createContentFromData(slide.data, slide.index);
        this.addToCache(content);
      } // assign slide to content

      content.setSlide(slide);
      return content;
    }
    /**
     * @param {Content} content
     */
  }, {
    key: "addToCache",
    value: function addToCache(content) {
      // move to the end of array
      this.removeByIndex(content.index);
      this._cachedItems.push(content);
      if (this._cachedItems.length > this.limit) {
        // Destroy the first content that's not attached
        var indexToRemove = this._cachedItems.findIndex(function (item) {
          return !item.isAttached && !item.hasSlide;
        });
        if (indexToRemove !== -1) {
          var removedItem = this._cachedItems.splice(indexToRemove, 1)[0];
          removedItem.destroy();
        }
      }
    }
    /**
     * Removes an image from cache, does not destroy() it, just removes.
     *
     * @param {number} index
     */
  }, {
    key: "removeByIndex",
    value: function removeByIndex(index) {
      var indexToRemove = this._cachedItems.findIndex(function (item) {
        return item.index === index;
      });
      if (indexToRemove !== -1) {
        this._cachedItems.splice(indexToRemove, 1);
      }
    }
    /**
     * @param {number} index
     * @returns {Content | undefined}
     */
  }, {
    key: "getContentByIndex",
    value: function getContentByIndex(index) {
      return this._cachedItems.find(function (content) {
        return content.index === index;
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._cachedItems.forEach(function (content) {
        return content.destroy();
      });
      this._cachedItems = [];
    }
  }]);
}();
/** @typedef {import("../photoswipe.js").default} PhotoSwipe */
/** @typedef {import("../slide/slide.js").SlideData} SlideData */
/**
 * PhotoSwipe base class that can retrieve data about every slide.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox
 */
var PhotoSwipeBase = /*#__PURE__*/function (_Eventable) {
  function PhotoSwipeBase() {
    _classCallCheck(this, PhotoSwipeBase);
    return _callSuper(this, PhotoSwipeBase, arguments);
  }
  _inherits(PhotoSwipeBase, _Eventable);
  return _createClass(PhotoSwipeBase, [{
    key: "getNumItems",
    value:
    /**
     * Get total number of slides
     *
     * @returns {number}
     */
    function getNumItems() {
      var _this$options;
      var numItems = 0;
      var dataSource = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.dataSource;
      if (dataSource && 'length' in dataSource) {
        // may be an array or just object with length property
        numItems = dataSource.length;
      } else if (dataSource && 'gallery' in dataSource) {
        // query DOM elements
        if (!dataSource.items) {
          dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
        }
        if (dataSource.items) {
          numItems = dataSource.items.length;
        }
      } // legacy event, before filters were introduced

      var event = this.dispatch('numItems', {
        dataSource: dataSource,
        numItems: numItems
      });
      return this.applyFilters('numItems', event.numItems, dataSource);
    }
    /**
     * @param {SlideData} slideData
     * @param {number} index
     * @returns {Content}
     */
  }, {
    key: "createContentFromData",
    value: function createContentFromData(slideData, index) {
      return new Content(slideData, this, index);
    }
    /**
     * Get item data by index.
     *
     * "item data" should contain normalized information that PhotoSwipe needs to generate a slide.
     * For example, it may contain properties like
     * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.
     *
     * @param {number} index
     * @returns {SlideData}
     */
  }, {
    key: "getItemData",
    value: function getItemData(index) {
      var _this$options2;
      var dataSource = (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.dataSource;
      /** @type {SlideData | HTMLElement} */

      var dataSourceItem = {};
      if (Array.isArray(dataSource)) {
        // Datasource is an array of elements
        dataSourceItem = dataSource[index];
      } else if (dataSource && 'gallery' in dataSource) {
        // dataSource has gallery property,
        // thus it was created by Lightbox, based on
        // gallery and children options
        // query DOM elements
        if (!dataSource.items) {
          dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
        }
        dataSourceItem = dataSource.items[index];
      }
      var itemData = dataSourceItem;
      if (itemData instanceof Element) {
        itemData = this._domElementToItemData(itemData);
      } // Dispatching the itemData event,
      // it's a legacy verion before filters were introduced

      var event = this.dispatch('itemData', {
        itemData: itemData || {},
        index: index
      });
      return this.applyFilters('itemData', event.itemData, index);
    }
    /**
     * Get array of gallery DOM elements,
     * based on childSelector and gallery element.
     *
     * @param {HTMLElement} galleryElement
     * @returns {HTMLElement[]}
     */
  }, {
    key: "_getGalleryDOMElements",
    value: function _getGalleryDOMElements(galleryElement) {
      var _this$options3, _this$options4;
      if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.children || (_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.childSelector) {
        return getElementsFromOption(this.options.children, this.options.childSelector, galleryElement) || [];
      }
      return [galleryElement];
    }
    /**
     * Converts DOM element to item data object.
     *
     * @param {HTMLElement} element DOM element
     * @returns {SlideData}
     */
  }, {
    key: "_domElementToItemData",
    value: function _domElementToItemData(element) {
      /** @type {SlideData} */
      var itemData = {
        element: element
      };
      var linkEl = /** @type {HTMLAnchorElement} */
      element.tagName === 'A' ? element : element.querySelector('a');
      if (linkEl) {
        // src comes from data-pswp-src attribute,
        // if it's empty link href is used
        itemData.src = linkEl.dataset.pswpSrc || linkEl.href;
        if (linkEl.dataset.pswpSrcset) {
          itemData.srcset = linkEl.dataset.pswpSrcset;
        }
        itemData.width = linkEl.dataset.pswpWidth ? parseInt(linkEl.dataset.pswpWidth, 10) : 0;
        itemData.height = linkEl.dataset.pswpHeight ? parseInt(linkEl.dataset.pswpHeight, 10) : 0; // support legacy w & h properties

        itemData.w = itemData.width;
        itemData.h = itemData.height;
        if (linkEl.dataset.pswpType) {
          itemData.type = linkEl.dataset.pswpType;
        }
        var thumbnailEl = element.querySelector('img');
        if (thumbnailEl) {
          var _thumbnailEl$getAttri;

          // msrc is URL to placeholder image that's displayed before large image is loaded
          // by default it's displayed only for the first slide
          itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;
          itemData.alt = (_thumbnailEl$getAttri = thumbnailEl.getAttribute('alt')) !== null && _thumbnailEl$getAttri !== void 0 ? _thumbnailEl$getAttri : '';
        }
        if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {
          itemData.thumbCropped = true;
        }
      }
      return this.applyFilters('domItemData', itemData, element, linkEl);
    }
    /**
     * Lazy-load by slide data
     *
     * @param {SlideData} itemData Data about the slide
     * @param {number} index
     * @returns {Content} Image that is being decoded or false.
     */
  }, {
    key: "lazyLoadData",
    value: function lazyLoadData(itemData, index) {
      return _lazyLoadData(itemData, this, index);
    }
  }]);
}(Eventable);
/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./slide/get-thumb-bounds.js').Bounds} Bounds */
/** @typedef {import('./util/animations.js').AnimationProps} AnimationProps */
// some browsers do not paint
// elements which opacity is set to 0,
// since we need to pre-render elements for the animation -
// we set it to the minimum amount
var MIN_OPACITY = 0.003;
/**
 * Manages opening and closing transitions of the PhotoSwipe.
 *
 * It can perform zoom, fade or no transition.
 */
var Opener = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function Opener(pswp) {
    _classCallCheck(this, Opener);
    this.pswp = pswp;
    this.isClosed = true;
    this.isOpen = false;
    this.isClosing = false;
    this.isOpening = false;
    /**
     * @private
     * @type {number | false | undefined}
     */

    this._duration = undefined;
    /** @private */

    this._useAnimation = false;
    /** @private */

    this._croppedZoom = false;
    /** @private */

    this._animateRootOpacity = false;
    /** @private */

    this._animateBgOpacity = false;
    /**
     * @private
     * @type { HTMLDivElement | HTMLImageElement | null | undefined }
     */

    this._placeholder = undefined;
    /**
     * @private
     * @type { HTMLDivElement | undefined }
     */

    this._opacityElement = undefined;
    /**
     * @private
     * @type { HTMLDivElement | undefined }
     */

    this._cropContainer1 = undefined;
    /**
     * @private
     * @type { HTMLElement | null | undefined }
     */

    this._cropContainer2 = undefined;
    /**
     * @private
     * @type {Bounds | undefined}
     */

    this._thumbBounds = undefined;
    this._prepareOpen = this._prepareOpen.bind(this); // Override initial zoom and pan position

    pswp.on('firstZoomPan', this._prepareOpen);
  }
  return _createClass(Opener, [{
    key: "open",
    value: function open() {
      this._prepareOpen();
      this._start();
    }
  }, {
    key: "close",
    value: function close() {
      var _this17 = this;
      if (this.isClosed || this.isClosing || this.isOpening) {
        // if we close during opening animation
        // for now do nothing,
        // browsers aren't good at changing the direction of the CSS transition
        return;
      }
      var slide = this.pswp.currSlide;
      this.isOpen = false;
      this.isOpening = false;
      this.isClosing = true;
      this._duration = this.pswp.options.hideAnimationDuration;
      if (slide && slide.currZoomLevel * slide.width >= this.pswp.options.maxWidthToAnimate) {
        this._duration = 0;
      }
      this._applyStartProps();
      setTimeout(function () {
        _this17._start();
      }, this._croppedZoom ? 30 : 0);
    }
    /** @private */
  }, {
    key: "_prepareOpen",
    value: function _prepareOpen() {
      this.pswp.off('firstZoomPan', this._prepareOpen);
      if (!this.isOpening) {
        var slide = this.pswp.currSlide;
        this.isOpening = true;
        this.isClosing = false;
        this._duration = this.pswp.options.showAnimationDuration;
        if (slide && slide.zoomLevels.initial * slide.width >= this.pswp.options.maxWidthToAnimate) {
          this._duration = 0;
        }
        this._applyStartProps();
      }
    }
    /** @private */
  }, {
    key: "_applyStartProps",
    value: function _applyStartProps() {
      var pswp = this.pswp;
      var slide = this.pswp.currSlide;
      var options = pswp.options;
      if (options.showHideAnimationType === 'fade') {
        options.showHideOpacity = true;
        this._thumbBounds = undefined;
      } else if (options.showHideAnimationType === 'none') {
        options.showHideOpacity = false;
        this._duration = 0;
        this._thumbBounds = undefined;
      } else if (this.isOpening && pswp._initialThumbBounds) {
        // Use initial bounds if defined
        this._thumbBounds = pswp._initialThumbBounds;
      } else {
        this._thumbBounds = this.pswp.getThumbBounds();
      }
      this._placeholder = slide === null || slide === void 0 ? void 0 : slide.getPlaceholderElement();
      pswp.animations.stopAll(); // Discard animations when duration is less than 50ms

      this._useAnimation = Boolean(this._duration && this._duration > 50);
      this._animateZoom = Boolean(this._thumbBounds) && (slide === null || slide === void 0 ? void 0 : slide.content.usePlaceholder()) && (!this.isClosing || !pswp.mainScroll.isShifted());
      if (!this._animateZoom) {
        this._animateRootOpacity = true;
        if (this.isOpening && slide) {
          slide.zoomAndPanToInitial();
          slide.applyCurrentZoomPan();
        }
      } else {
        var _options$showHideOpac;
        this._animateRootOpacity = (_options$showHideOpac = options.showHideOpacity) !== null && _options$showHideOpac !== void 0 ? _options$showHideOpac : false;
      }
      this._animateBgOpacity = !this._animateRootOpacity && this.pswp.options.bgOpacity > MIN_OPACITY;
      this._opacityElement = this._animateRootOpacity ? pswp.element : pswp.bg;
      if (!this._useAnimation) {
        this._duration = 0;
        this._animateZoom = false;
        this._animateBgOpacity = false;
        this._animateRootOpacity = true;
        if (this.isOpening) {
          if (pswp.element) {
            pswp.element.style.opacity = String(MIN_OPACITY);
          }
          pswp.applyBgOpacity(1);
        }
        return;
      }
      if (this._animateZoom && this._thumbBounds && this._thumbBounds.innerRect) {
        var _this$pswp$currSlide;

        // Properties are used when animation from cropped thumbnail
        this._croppedZoom = true;
        this._cropContainer1 = this.pswp.container;
        this._cropContainer2 = (_this$pswp$currSlide = this.pswp.currSlide) === null || _this$pswp$currSlide === void 0 ? void 0 : _this$pswp$currSlide.holderElement;
        if (pswp.container) {
          pswp.container.style.overflow = 'hidden';
          pswp.container.style.width = pswp.viewportSize.x + 'px';
        }
      } else {
        this._croppedZoom = false;
      }
      if (this.isOpening) {
        // Apply styles before opening transition
        if (this._animateRootOpacity) {
          if (pswp.element) {
            pswp.element.style.opacity = String(MIN_OPACITY);
          }
          pswp.applyBgOpacity(1);
        } else {
          if (this._animateBgOpacity && pswp.bg) {
            pswp.bg.style.opacity = String(MIN_OPACITY);
          }
          if (pswp.element) {
            pswp.element.style.opacity = '1';
          }
        }
        if (this._animateZoom) {
          this._setClosedStateZoomPan();
          if (this._placeholder) {
            // tell browser that we plan to animate the placeholder
            this._placeholder.style.willChange = 'transform'; // hide placeholder to allow hiding of
            // elements that overlap it (such as icons over the thumbnail)

            this._placeholder.style.opacity = String(MIN_OPACITY);
          }
        }
      } else if (this.isClosing) {
        // hide nearby slides to make sure that
        // they are not painted during the transition
        if (pswp.mainScroll.itemHolders[0]) {
          pswp.mainScroll.itemHolders[0].el.style.display = 'none';
        }
        if (pswp.mainScroll.itemHolders[2]) {
          pswp.mainScroll.itemHolders[2].el.style.display = 'none';
        }
        if (this._croppedZoom) {
          if (pswp.mainScroll.x !== 0) {
            // shift the main scroller to zero position
            pswp.mainScroll.resetPosition();
            pswp.mainScroll.resize();
          }
        }
      }
    }
    /** @private */
  }, {
    key: "_start",
    value: function _start() {
      var _this18 = this;
      if (this.isOpening && this._useAnimation && this._placeholder && this._placeholder.tagName === 'IMG') {
        // To ensure smooth animation
        // we wait till the current slide image placeholder is decoded,
        // but no longer than 250ms,
        // and no shorter than 50ms
        // (just using requestanimationframe is not enough in Firefox,
        // for some reason)
        new Promise(function (resolve) {
          var decoded = false;
          var isDelaying = true;
          decodeImage(/** @type {HTMLImageElement} */
          _this18._placeholder)["finally"](function () {
            decoded = true;
            if (!isDelaying) {
              resolve(true);
            }
          });
          setTimeout(function () {
            isDelaying = false;
            if (decoded) {
              resolve(true);
            }
          }, 50);
          setTimeout(resolve, 250);
        })["finally"](function () {
          return _this18._initiate();
        });
      } else {
        this._initiate();
      }
    }
    /** @private */
  }, {
    key: "_initiate",
    value: function _initiate() {
      var _this$pswp$element, _this$pswp$element2;
      (_this$pswp$element = this.pswp.element) === null || _this$pswp$element === void 0 || _this$pswp$element.style.setProperty('--pswp-transition-duration', this._duration + 'ms');
      this.pswp.dispatch(this.isOpening ? 'openingAnimationStart' : 'closingAnimationStart'); // legacy event

      this.pswp.dispatch(/** @type {'initialZoomIn' | 'initialZoomOut'} */
      'initialZoom' + (this.isOpening ? 'In' : 'Out'));
      (_this$pswp$element2 = this.pswp.element) === null || _this$pswp$element2 === void 0 || _this$pswp$element2.classList.toggle('pswp--ui-visible', this.isOpening);
      if (this.isOpening) {
        if (this._placeholder) {
          // unhide the placeholder
          this._placeholder.style.opacity = '1';
        }
        this._animateToOpenState();
      } else if (this.isClosing) {
        this._animateToClosedState();
      }
      if (!this._useAnimation) {
        this._onAnimationComplete();
      }
    }
    /** @private */
  }, {
    key: "_onAnimationComplete",
    value: function _onAnimationComplete() {
      var pswp = this.pswp;
      this.isOpen = this.isOpening;
      this.isClosed = this.isClosing;
      this.isOpening = false;
      this.isClosing = false;
      pswp.dispatch(this.isOpen ? 'openingAnimationEnd' : 'closingAnimationEnd'); // legacy event

      pswp.dispatch(/** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */
      'initialZoom' + (this.isOpen ? 'InEnd' : 'OutEnd'));
      if (this.isClosed) {
        pswp.destroy();
      } else if (this.isOpen) {
        var _pswp$currSlide;
        if (this._animateZoom && pswp.container) {
          pswp.container.style.overflow = 'visible';
          pswp.container.style.width = '100%';
        }
        (_pswp$currSlide = pswp.currSlide) === null || _pswp$currSlide === void 0 || _pswp$currSlide.applyCurrentZoomPan();
      }
    }
    /** @private */
  }, {
    key: "_animateToOpenState",
    value: function _animateToOpenState() {
      var pswp = this.pswp;
      if (this._animateZoom) {
        if (this._croppedZoom && this._cropContainer1 && this._cropContainer2) {
          this._animateTo(this._cropContainer1, 'transform', 'translate3d(0,0,0)');
          this._animateTo(this._cropContainer2, 'transform', 'none');
        }
        if (pswp.currSlide) {
          pswp.currSlide.zoomAndPanToInitial();
          this._animateTo(pswp.currSlide.container, 'transform', pswp.currSlide.getCurrentTransform());
        }
      }
      if (this._animateBgOpacity && pswp.bg) {
        this._animateTo(pswp.bg, 'opacity', String(pswp.options.bgOpacity));
      }
      if (this._animateRootOpacity && pswp.element) {
        this._animateTo(pswp.element, 'opacity', '1');
      }
    }
    /** @private */
  }, {
    key: "_animateToClosedState",
    value: function _animateToClosedState() {
      var pswp = this.pswp;
      if (this._animateZoom) {
        this._setClosedStateZoomPan(true);
      } // do not animate opacity if it's already at 0

      if (this._animateBgOpacity && pswp.bgOpacity > 0.01 && pswp.bg) {
        this._animateTo(pswp.bg, 'opacity', '0');
      }
      if (this._animateRootOpacity && pswp.element) {
        this._animateTo(pswp.element, 'opacity', '0');
      }
    }
    /**
     * @private
     * @param {boolean} [animate]
     */
  }, {
    key: "_setClosedStateZoomPan",
    value: function _setClosedStateZoomPan(animate) {
      if (!this._thumbBounds) return;
      var pswp = this.pswp;
      var innerRect = this._thumbBounds.innerRect;
      var currSlide = pswp.currSlide,
        viewportSize = pswp.viewportSize;
      if (this._croppedZoom && innerRect && this._cropContainer1 && this._cropContainer2) {
        var containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w;
        var containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h;
        var containerTwoPanX = viewportSize.x - innerRect.w;
        var containerTwoPanY = viewportSize.y - innerRect.h;
        if (animate) {
          this._animateTo(this._cropContainer1, 'transform', toTransformString(containerOnePanX, containerOnePanY));
          this._animateTo(this._cropContainer2, 'transform', toTransformString(containerTwoPanX, containerTwoPanY));
        } else {
          setTransform(this._cropContainer1, containerOnePanX, containerOnePanY);
          setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY);
        }
      }
      if (currSlide) {
        equalizePoints(currSlide.pan, innerRect || this._thumbBounds);
        currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width;
        if (animate) {
          this._animateTo(currSlide.container, 'transform', currSlide.getCurrentTransform());
        } else {
          currSlide.applyCurrentZoomPan();
        }
      }
    }
    /**
     * @private
     * @param {HTMLElement} target
     * @param {'transform' | 'opacity'} prop
     * @param {string} propValue
     */
  }, {
    key: "_animateTo",
    value: function _animateTo(target, prop, propValue) {
      var _this19 = this;
      if (!this._duration) {
        target.style[prop] = propValue;
        return;
      }
      var animations = this.pswp.animations;
      /** @type {AnimationProps} */

      var animProps = {
        duration: this._duration,
        easing: this.pswp.options.easing,
        onComplete: function onComplete() {
          if (!animations.activeAnimations.length) {
            _this19._onAnimationComplete();
          }
        },
        target: target
      };
      animProps[prop] = propValue;
      animations.startTransition(animProps);
    }
  }]);
}();
/**
 * @template T
 * @typedef {import('./types.js').Type<T>} Type<T>
 */
/** @typedef {import('./slide/slide.js').SlideData} SlideData */
/** @typedef {import('./slide/zoom-level.js').ZoomLevelOption} ZoomLevelOption */
/** @typedef {import('./ui/ui-element.js').UIElementData} UIElementData */
/** @typedef {import('./main-scroll.js').ItemHolder} ItemHolder */
/** @typedef {import('./core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */
/** @typedef {import('./core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */
/** @typedef {import('./slide/get-thumb-bounds').Bounds} Bounds */
/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {import('./core/eventable.js').EventCallback<T>} EventCallback<T>
 */
/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {import('./core/eventable.js').AugmentedEvent<T>} AugmentedEvent<T>
 */
/** @typedef {{ x: number; y: number; id?: string | number }} Point */
/** @typedef {{ top: number; bottom: number; left: number; right: number }} Padding */
/** @typedef {SlideData[]} DataSourceArray */
/** @typedef {{ gallery: HTMLElement; items?: HTMLElement[] }} DataSourceObject */
/** @typedef {DataSourceArray | DataSourceObject} DataSource */
/** @typedef {(point: Point, originalEvent: PointerEvent) => void} ActionFn */
/** @typedef {'close' | 'next' | 'zoom' | 'zoom-or-close' | 'toggle-controls'} ActionType */
/** @typedef {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} PhotoSwipeModule */
/** @typedef {PhotoSwipeModule | Promise<PhotoSwipeModule> | (() => Promise<PhotoSwipeModule>)} PhotoSwipeModuleOption */
/**
 * @typedef {string | NodeListOf<HTMLElement> | HTMLElement[] | HTMLElement} ElementProvider
 */
/** @typedef {Partial<PreparedPhotoSwipeOptions>} PhotoSwipeOptions https://photoswipe.com/options/ */
/**
 * @typedef {Object} PreparedPhotoSwipeOptions
 *
 * @prop {DataSource} [dataSource]
 * Pass an array of any items via dataSource option. Its length will determine amount of slides
 * (which may be modified further from numItems event).
 *
 * Each item should contain data that you need to generate slide
 * (for image slide it would be src (image URL), width (image width), height, srcset, alt).
 *
 * If these properties are not present in your initial array, you may "pre-parse" each item from itemData filter.
 *
 * @prop {number} bgOpacity
 * Background backdrop opacity, always define it via this option and not via CSS rgba color.
 *
 * @prop {number} spacing
 * Spacing between slides. Defined as ratio relative to the viewport width (0.1 = 10% of viewport).
 *
 * @prop {boolean} allowPanToNext
 * Allow swipe navigation to the next slide when the current slide is zoomed. Does not apply to mouse events.
 *
 * @prop {boolean} loop
 * If set to true you'll be able to swipe from the last to the first image.
 * Option is always false when there are less than 3 slides.
 *
 * @prop {boolean} [wheelToZoom]
 * By default PhotoSwipe zooms image with ctrl-wheel, if you enable this option - image will zoom just via wheel.
 *
 * @prop {boolean} pinchToClose
 * Pinch touch gesture to close the gallery.
 *
 * @prop {boolean} closeOnVerticalDrag
 * Vertical drag gesture to close the PhotoSwipe.
 *
 * @prop {Padding} [padding]
 * Slide area padding (in pixels).
 *
 * @prop {(viewportSize: Point, itemData: SlideData, index: number) => Padding} [paddingFn]
 * The option is checked frequently, so make sure it's performant. Overrides padding option if defined. For example:
 *
 * @prop {number | false} hideAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {number | false} showAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {number | false} zoomAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {string} easing
 * String, 'cubic-bezier(.4,0,.22,1)'. CSS easing function for open/close/zoom transitions.
 *
 * @prop {boolean} escKey
 * Esc key to close.
 *
 * @prop {boolean} arrowKeys
 * Left/right arrow keys for navigation.
 *
 * @prop {boolean} trapFocus
 * Trap focus within PhotoSwipe element while it's open.
 *
 * @prop {boolean} returnFocus
 * Restore focus the last active element after PhotoSwipe is closed.
 *
 * @prop {boolean} clickToCloseNonZoomable
 * If image is not zoomable (for example, smaller than viewport) it can be closed by clicking on it.
 *
 * @prop {ActionType | ActionFn | false} imageClickAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} bgClickAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} tapAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} doubleTapAction
 * Refer to click and tap actions page.
 *
 * @prop {number} preloaderDelay
 * Delay before the loading indicator will be displayed,
 * if image is loaded during it - the indicator will not be displayed at all. Can be zero.
 *
 * @prop {string} indexIndicatorSep
 * Used for slide count indicator ("1 of 10 ").
 *
 * @prop {(options: PhotoSwipeOptions, pswp: PhotoSwipeBase) => Point} [getViewportSizeFn]
 * A function that should return slide viewport width and height, in format {x: 100, y: 100}.
 *
 * @prop {string} errorMsg
 * Message to display when the image wasn't able to load. If you need to display HTML - use contentErrorElement filter.
 *
 * @prop {[number, number]} preload
 * Lazy loading of nearby slides based on direction of movement. Should be an array with two integers,
 * first one - number of items to preload before the current image, second one - after the current image.
 * Two nearby images are always loaded.
 *
 * @prop {string} [mainClass]
 * Class that will be added to the root element of PhotoSwipe, may contain multiple separated by space.
 * Example on Styling page.
 *
 * @prop {HTMLElement} [appendToEl]
 * Element to which PhotoSwipe dialog will be appended when it opens.
 *
 * @prop {number} maxWidthToAnimate
 * Maximum width of image to animate, if initial rendered image width
 * is larger than this value - the opening/closing transition will be automatically disabled.
 *
 * @prop {string} [closeTitle]
 * Translating
 *
 * @prop {string} [zoomTitle]
 * Translating
 *
 * @prop {string} [arrowPrevTitle]
 * Translating
 *
 * @prop {string} [arrowNextTitle]
 * Translating
 *
 * @prop {'zoom' | 'fade' | 'none'} [showHideAnimationType]
 * To adjust opening or closing transition type use lightbox option `showHideAnimationType` (`String`).
 * It supports three values - `zoom` (default), `fade` (default if there is no thumbnail) and `none`.
 *
 * Animations are automatically disabled if user `(prefers-reduced-motion: reduce)`.
 *
 * @prop {number} index
 * Defines start slide index.
 *
 * @prop {(e: MouseEvent) => number} [getClickedIndexFn]
 *
 * @prop {boolean} [arrowPrev]
 * @prop {boolean} [arrowNext]
 * @prop {boolean} [zoom]
 * @prop {boolean} [close]
 * @prop {boolean} [counter]
 *
 * @prop {string} [arrowPrevSVG]
 * @prop {string} [arrowNextSVG]
 * @prop {string} [zoomSVG]
 * @prop {string} [closeSVG]
 * @prop {string} [counterSVG]
 *
 * @prop {string} [arrowPrevTitle]
 * @prop {string} [arrowNextTitle]
 * @prop {string} [zoomTitle]
 * @prop {string} [closeTitle]
 * @prop {string} [counterTitle]
 *
 * @prop {ZoomLevelOption} [initialZoomLevel]
 * @prop {ZoomLevelOption} [secondaryZoomLevel]
 * @prop {ZoomLevelOption} [maxZoomLevel]
 *
 * @prop {boolean} [mouseMovePan]
 * @prop {Point | null} [initialPointerPos]
 * @prop {boolean} [showHideOpacity]
 *
 * @prop {PhotoSwipeModuleOption} [pswpModule]
 * @prop {() => Promise<any>} [openPromise]
 * @prop {boolean} [preloadFirstSlide]
 * @prop {ElementProvider} [gallery]
 * @prop {string} [gallerySelector]
 * @prop {ElementProvider} [children]
 * @prop {string} [childSelector]
 * @prop {string | false} [thumbSelector]
 */
/** @type {PreparedPhotoSwipeOptions} */
var defaultOptions = {
  allowPanToNext: true,
  spacing: 0.1,
  loop: true,
  pinchToClose: true,
  closeOnVerticalDrag: true,
  hideAnimationDuration: 333,
  showAnimationDuration: 333,
  zoomAnimationDuration: 333,
  escKey: true,
  arrowKeys: true,
  trapFocus: true,
  returnFocus: true,
  maxWidthToAnimate: 4000,
  clickToCloseNonZoomable: true,
  imageClickAction: 'zoom-or-close',
  bgClickAction: 'close',
  tapAction: 'toggle-controls',
  doubleTapAction: 'zoom',
  indexIndicatorSep: ' / ',
  preloaderDelay: 2000,
  bgOpacity: 0.8,
  index: 0,
  errorMsg: 'The image cannot be loaded',
  preload: [1, 2],
  easing: 'cubic-bezier(.4,0,.22,1)'
};
/**
 * PhotoSwipe Core
 */
var PhotoSwipe = exports["default"] = /*#__PURE__*/function (_PhotoSwipeBase) {
  /**
   * @param {PhotoSwipeOptions} [options]
   */
  function PhotoSwipe(options) {
    var _this20;
    _classCallCheck(this, PhotoSwipe);
    _this20 = _callSuper(this, PhotoSwipe);
    _this20.options = _this20._prepareOptions(options || {});
    /**
     * offset of viewport relative to document
     *
     * @type {Point}
     */

    _this20.offset = {
      x: 0,
      y: 0
    };
    /**
     * @type {Point}
     * @private
     */

    _this20._prevViewportSize = {
      x: 0,
      y: 0
    };
    /**
     * Size of scrollable PhotoSwipe viewport
     *
     * @type {Point}
     */

    _this20.viewportSize = {
      x: 0,
      y: 0
    };
    /**
     * background (backdrop) opacity
     */

    _this20.bgOpacity = 1;
    _this20.currIndex = 0;
    _this20.potentialIndex = 0;
    _this20.isOpen = false;
    _this20.isDestroying = false;
    _this20.hasMouse = false;
    /**
     * @private
     * @type {SlideData}
     */

    _this20._initialItemData = {};
    /** @type {Bounds | undefined} */

    _this20._initialThumbBounds = undefined;
    /** @type {HTMLDivElement | undefined} */

    _this20.topBar = undefined;
    /** @type {HTMLDivElement | undefined} */

    _this20.element = undefined;
    /** @type {HTMLDivElement | undefined} */

    _this20.template = undefined;
    /** @type {HTMLDivElement | undefined} */

    _this20.container = undefined;
    /** @type {HTMLElement | undefined} */

    _this20.scrollWrap = undefined;
    /** @type {Slide | undefined} */

    _this20.currSlide = undefined;
    _this20.events = new DOMEvents();
    _this20.animations = new Animations();
    _this20.mainScroll = new MainScroll(_this20);
    _this20.gestures = new Gestures(_this20);
    _this20.opener = new Opener(_this20);
    _this20.keyboard = new Keyboard(_this20);
    _this20.contentLoader = new ContentLoader(_this20);
    return _this20;
  }
  /** @returns {boolean} */
  _inherits(PhotoSwipe, _PhotoSwipeBase);
  return _createClass(PhotoSwipe, [{
    key: "init",
    value: function init() {
      var _this21 = this;
      if (this.isOpen || this.isDestroying) {
        return false;
      }
      this.isOpen = true;
      this.dispatch('init'); // legacy

      this.dispatch('beforeOpen');
      this._createMainStructure(); // add classes to the root element of PhotoSwipe

      var rootClasses = 'pswp--open';
      if (this.gestures.supportsTouch) {
        rootClasses += ' pswp--touch';
      }
      if (this.options.mainClass) {
        rootClasses += ' ' + this.options.mainClass;
      }
      if (this.element) {
        this.element.className += ' ' + rootClasses;
      }
      this.currIndex = this.options.index || 0;
      this.potentialIndex = this.currIndex;
      this.dispatch('firstUpdate'); // starting index can be modified here
      // initialize scroll wheel handler to block the scroll

      this.scrollWheel = new ScrollWheel(this); // sanitize index

      if (Number.isNaN(this.currIndex) || this.currIndex < 0 || this.currIndex >= this.getNumItems()) {
        this.currIndex = 0;
      }
      if (!this.gestures.supportsTouch) {
        // enable mouse features if no touch support detected
        this.mouseDetected();
      } // causes forced synchronous layout

      this.updateSize();
      this.offset.y = window.pageYOffset;
      this._initialItemData = this.getItemData(this.currIndex);
      this.dispatch('gettingData', {
        index: this.currIndex,
        data: this._initialItemData,
        slide: undefined
      }); // *Layout* - calculate size and position of elements here

      this._initialThumbBounds = this.getThumbBounds();
      this.dispatch('initialLayout');
      this.on('openingAnimationEnd', function () {
        var itemHolders = _this21.mainScroll.itemHolders; // Add content to the previous and next slide

        if (itemHolders[0]) {
          itemHolders[0].el.style.display = 'block';
          _this21.setContent(itemHolders[0], _this21.currIndex - 1);
        }
        if (itemHolders[2]) {
          itemHolders[2].el.style.display = 'block';
          _this21.setContent(itemHolders[2], _this21.currIndex + 1);
        }
        _this21.appendHeavy();
        _this21.contentLoader.updateLazy();
        _this21.events.add(window, 'resize', _this21._handlePageResize.bind(_this21));
        _this21.events.add(window, 'scroll', _this21._updatePageScrollOffset.bind(_this21));
        _this21.dispatch('bindEvents');
      }); // set content for center slide (first time)

      if (this.mainScroll.itemHolders[1]) {
        this.setContent(this.mainScroll.itemHolders[1], this.currIndex);
      }
      this.dispatch('change');
      this.opener.open();
      this.dispatch('afterInit');
      return true;
    }
    /**
     * Get looped slide index
     * (for example, -1 will return the last slide)
     *
     * @param {number} index
     * @returns {number}
     */
  }, {
    key: "getLoopedIndex",
    value: function getLoopedIndex(index) {
      var numSlides = this.getNumItems();
      if (this.options.loop) {
        if (index > numSlides - 1) {
          index -= numSlides;
        }
        if (index < 0) {
          index += numSlides;
        }
      }
      return clamp(index, 0, numSlides - 1);
    }
  }, {
    key: "appendHeavy",
    value: function appendHeavy() {
      this.mainScroll.itemHolders.forEach(function (itemHolder) {
        var _itemHolder$slide;
        (_itemHolder$slide = itemHolder.slide) === null || _itemHolder$slide === void 0 || _itemHolder$slide.appendHeavy();
      });
    }
    /**
     * Change the slide
     * @param {number} index New index
     */
  }, {
    key: "goTo",
    value: function goTo(index) {
      this.mainScroll.moveIndexBy(this.getLoopedIndex(index) - this.potentialIndex);
    }
    /**
     * Go to the next slide.
     */
  }, {
    key: "next",
    value: function next() {
      this.goTo(this.potentialIndex + 1);
    }
    /**
     * Go to the previous slide.
     */
  }, {
    key: "prev",
    value: function prev() {
      this.goTo(this.potentialIndex - 1);
    }
    /**
     * @see slide/slide.js zoomTo
     *
     * @param {Parameters<Slide['zoomTo']>} args
     */
  }, {
    key: "zoomTo",
    value: function zoomTo() {
      var _this$currSlide4;
      var _this$currSlide;
      (_this$currSlide = this.currSlide) === null || _this$currSlide === void 0 || (_this$currSlide4 = _this$currSlide).zoomTo.apply(_this$currSlide4, arguments);
    }
    /**
     * @see slide/slide.js toggleZoom
     */
  }, {
    key: "toggleZoom",
    value: function toggleZoom() {
      var _this$currSlide2;
      (_this$currSlide2 = this.currSlide) === null || _this$currSlide2 === void 0 || _this$currSlide2.toggleZoom();
    }
    /**
     * Close the gallery.
     * After closing transition ends - destroy it
     */
  }, {
    key: "close",
    value: function close() {
      if (!this.opener.isOpen || this.isDestroying) {
        return;
      }
      this.isDestroying = true;
      this.dispatch('close');
      this.events.removeAll();
      this.opener.close();
    }
    /**
     * Destroys the gallery:
     * - instantly closes the gallery
     * - unbinds events,
     * - cleans intervals and timeouts
     * - removes elements from DOM
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$element;
      if (!this.isDestroying) {
        this.options.showHideAnimationType = 'none';
        this.close();
        return;
      }
      this.dispatch('destroy');
      this._listeners = {};
      if (this.scrollWrap) {
        this.scrollWrap.ontouchmove = null;
        this.scrollWrap.ontouchend = null;
      }
      (_this$element = this.element) === null || _this$element === void 0 || _this$element.remove();
      this.mainScroll.itemHolders.forEach(function (itemHolder) {
        var _itemHolder$slide2;
        (_itemHolder$slide2 = itemHolder.slide) === null || _itemHolder$slide2 === void 0 || _itemHolder$slide2.destroy();
      });
      this.contentLoader.destroy();
      this.events.removeAll();
    }
    /**
     * Refresh/reload content of a slide by its index
     *
     * @param {number} slideIndex
     */
  }, {
    key: "refreshSlideContent",
    value: function refreshSlideContent(slideIndex) {
      var _this22 = this;
      this.contentLoader.removeByIndex(slideIndex);
      this.mainScroll.itemHolders.forEach(function (itemHolder, i) {
        var _this$currSlide$index, _this$currSlide3;
        var potentialHolderIndex = ((_this$currSlide$index = (_this$currSlide3 = _this22.currSlide) === null || _this$currSlide3 === void 0 ? void 0 : _this$currSlide3.index) !== null && _this$currSlide$index !== void 0 ? _this$currSlide$index : 0) - 1 + i;
        if (_this22.canLoop()) {
          potentialHolderIndex = _this22.getLoopedIndex(potentialHolderIndex);
        }
        if (potentialHolderIndex === slideIndex) {
          // set the new slide content
          _this22.setContent(itemHolder, slideIndex, true); // activate the new slide if it's current

          if (i === 1) {
            var _itemHolder$slide3;
            _this22.currSlide = itemHolder.slide;
            (_itemHolder$slide3 = itemHolder.slide) === null || _itemHolder$slide3 === void 0 || _itemHolder$slide3.setIsActive(true);
          }
        }
      });
      this.dispatch('change');
    }
    /**
     * Set slide content
     *
     * @param {ItemHolder} holder mainScroll.itemHolders array item
     * @param {number} index Slide index
     * @param {boolean} [force] If content should be set even if index wasn't changed
     */
  }, {
    key: "setContent",
    value: function setContent(holder, index, force) {
      if (this.canLoop()) {
        index = this.getLoopedIndex(index);
      }
      if (holder.slide) {
        if (holder.slide.index === index && !force) {
          // exit if holder already contains this slide
          // this could be common when just three slides are used
          return;
        } // destroy previous slide

        holder.slide.destroy();
        holder.slide = undefined;
      } // exit if no loop and index is out of bounds

      if (!this.canLoop() && (index < 0 || index >= this.getNumItems())) {
        return;
      }
      var itemData = this.getItemData(index);
      holder.slide = new Slide(itemData, index, this); // set current slide

      if (index === this.currIndex) {
        this.currSlide = holder.slide;
      }
      holder.slide.append(holder.el);
    }
    /** @returns {Point} */
  }, {
    key: "getViewportCenterPoint",
    value: function getViewportCenterPoint() {
      return {
        x: this.viewportSize.x / 2,
        y: this.viewportSize.y / 2
      };
    }
    /**
     * Update size of all elements.
     * Executed on init and on page resize.
     *
     * @param {boolean} [force] Update size even if size of viewport was not changed.
     */
  }, {
    key: "updateSize",
    value: function updateSize(force) {
      // let item;
      // let itemIndex;
      if (this.isDestroying) {
        // exit if PhotoSwipe is closed or closing
        // (to avoid errors, as resize event might be delayed)
        return;
      } //const newWidth = this.scrollWrap.clientWidth;
      //const newHeight = this.scrollWrap.clientHeight;

      var newViewportSize = getViewportSize(this.options, this);
      if (!force && pointsEqual(newViewportSize, this._prevViewportSize)) {
        // Exit if dimensions were not changed
        return;
      } //this._prevViewportSize.x = newWidth;
      //this._prevViewportSize.y = newHeight;

      equalizePoints(this._prevViewportSize, newViewportSize);
      this.dispatch('beforeResize');
      equalizePoints(this.viewportSize, this._prevViewportSize);
      this._updatePageScrollOffset();
      this.dispatch('viewportSize'); // Resize slides only after opener animation is finished
      // and don't re-calculate size on inital size update

      this.mainScroll.resize(this.opener.isOpen);
      if (!this.hasMouse && window.matchMedia('(any-hover: hover)').matches) {
        this.mouseDetected();
      }
      this.dispatch('resize');
    }
    /**
     * @param {number} opacity
     */
  }, {
    key: "applyBgOpacity",
    value: function applyBgOpacity(opacity) {
      this.bgOpacity = Math.max(opacity, 0);
      if (this.bg) {
        this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity);
      }
    }
    /**
     * Whether mouse is detected
     */
  }, {
    key: "mouseDetected",
    value: function mouseDetected() {
      if (!this.hasMouse) {
        var _this$element2;
        this.hasMouse = true;
        (_this$element2 = this.element) === null || _this$element2 === void 0 || _this$element2.classList.add('pswp--has_mouse');
      }
    }
    /**
     * Page resize event handler
     *
     * @private
     */
  }, {
    key: "_handlePageResize",
    value: function _handlePageResize() {
      var _this23 = this;
      this.updateSize(); // In iOS webview, if element size depends on document size,
      // it'll be measured incorrectly in resize event
      //
      // https://bugs.webkit.org/show_bug.cgi?id=170595
      // https://hackernoon.com/onresize-event-broken-in-mobile-safari-d8469027bf4d

      if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {
        setTimeout(function () {
          _this23.updateSize();
        }, 500);
      }
    }
    /**
     * Page scroll offset is used
     * to get correct coordinates
     * relative to PhotoSwipe viewport.
     *
     * @private
     */
  }, {
    key: "_updatePageScrollOffset",
    value: function _updatePageScrollOffset() {
      this.setScrollOffset(0, window.pageYOffset);
    }
    /**
     * @param {number} x
     * @param {number} y
     */
  }, {
    key: "setScrollOffset",
    value: function setScrollOffset(x, y) {
      this.offset.x = x;
      this.offset.y = y;
      this.dispatch('updateScrollOffset');
    }
    /**
     * Create main HTML structure of PhotoSwipe,
     * and add it to DOM
     *
     * @private
     */
  }, {
    key: "_createMainStructure",
    value: function _createMainStructure() {
      // root DOM element of PhotoSwipe (.pswp)
      this.element = createElement('pswp', 'div');
      this.element.setAttribute('tabindex', '-1');
      this.element.setAttribute('role', 'dialog'); // template is legacy prop

      this.template = this.element; // Background is added as a separate element,
      // as animating opacity is faster than animating rgba()

      this.bg = createElement('pswp__bg', 'div', this.element);
      this.scrollWrap = createElement('pswp__scroll-wrap', 'section', this.element);
      this.container = createElement('pswp__container', 'div', this.scrollWrap); // aria pattern: carousel

      this.scrollWrap.setAttribute('aria-roledescription', 'carousel');
      this.container.setAttribute('aria-live', 'off');
      this.container.setAttribute('id', 'pswp__items');
      this.mainScroll.appendHolders();
      this.ui = new UI(this);
      this.ui.init(); // append to DOM

      (this.options.appendToEl || document.body).appendChild(this.element);
    }
    /**
     * Get position and dimensions of small thumbnail
     *   {x:,y:,w:}
     *
     * Height is optional (calculated based on the large image)
     *
     * @returns {Bounds | undefined}
     */
  }, {
    key: "getThumbBounds",
    value: function getThumbBounds() {
      return _getThumbBounds(this.currIndex, this.currSlide ? this.currSlide.data : this._initialItemData, this);
    }
    /**
     * If the PhotoSwipe can have continuous loop
     * @returns Boolean
     */
  }, {
    key: "canLoop",
    value: function canLoop() {
      return this.options.loop && this.getNumItems() > 2;
    }
    /**
     * @private
     * @param {PhotoSwipeOptions} options
     * @returns {PreparedPhotoSwipeOptions}
     */
  }, {
    key: "_prepareOptions",
    value: function _prepareOptions(options) {
      if (window.matchMedia('(prefers-reduced-motion), (update: slow)').matches) {
        options.showHideAnimationType = 'none';
        options.zoomAnimationDuration = 0;
      }
      /** @type {PreparedPhotoSwipeOptions} */

      return _objectSpread(_objectSpread({}, defaultOptions), options);
    }
  }]);
}(PhotoSwipeBase);

},{}],110:[function(require,module,exports){
(function (global){(function (){
!function(e){"use strict";function t(e,t){this.options={},e=e||this.options;var i={frequency:350,peak:1};this.inputNode=this.filterNode=s.context.createBiquadFilter(),this.filterNode.type=t,this.outputNode=o.context.createGain(),this.filterNode.connect(this.outputNode);for(var n in i)this[n]=e[n],this[n]=void 0===this[n]||null===this[n]?i[n]:this[n]}function i(){var e,t,i=s.context.sampleRate*this.time,n=o.context.createBuffer(2,i,s.context.sampleRate),a=n.getChannelData(0),r=n.getChannelData(1);for(t=0;i>t;t++)e=this.reverse?i-t:t,a[t]=(2*Math.random()-1)*Math.pow(1-e/i,this.decay),r[t]=(2*Math.random()-1)*Math.pow(1-e/i,this.decay);this.reverbNode.buffer&&(this.inputNode.disconnect(this.reverbNode),this.reverbNode.disconnect(this.wetGainNode),this.reverbNode=o.context.createConvolver(),this.inputNode.connect(this.reverbNode),this.reverbNode.connect(this.wetGainNode)),this.reverbNode.buffer=n}function n(e){for(var t=s.context.sampleRate,i=new Float32Array(t),n=Math.PI/180,o=0;t>o;o++){var a=2*o/t-1;i[o]=(3+e)*a*20*n/(Math.PI+e*Math.abs(a))}return i}var o={},s=o,a="object"==typeof module&&module.exports,r="function"==typeof define&&define.amd;a?module.exports=o:r?define([],o):e.Pizzicato=e.Pz=o;var c=e.AudioContext||e.webkitAudioContext;if(!c)return void console.error("No AudioContext found in this environment. Please ensure your window or global object contains a working AudioContext constructor function.");o.context=new c;var h=o.context.createGain();h.connect(o.context.destination),o.Util={isString:function(e){return"[object String]"===toString.call(e)},isObject:function(e){return"[object Object]"===toString.call(e)},isFunction:function(e){return"[object Function]"===toString.call(e)},isNumber:function(e){return"[object Number]"===toString.call(e)&&e===+e},isArray:function(e){return"[object Array]"===toString.call(e)},isInRange:function(e,t,i){return s.Util.isNumber(e)&&s.Util.isNumber(t)&&s.Util.isNumber(i)?e>=t&&i>=e:!1},isBool:function(e){return"boolean"==typeof e},isOscillator:function(e){return e&&"[object OscillatorNode]"===e.toString()},isAudioBufferSourceNode:function(e){return e&&"[object AudioBufferSourceNode]"===e.toString()},isSound:function(e){return e instanceof s.Sound},isEffect:function(e){for(var t in o.Effects)if(e instanceof o.Effects[t])return!0;return!1},normalize:function(e,t,i){return s.Util.isNumber(e)&&s.Util.isNumber(t)&&s.Util.isNumber(i)?(i-t)*e/1+t:void 0},getDryLevel:function(e){return!s.Util.isNumber(e)||e>1||0>e?0:.5>=e?1:1-2*(e-.5)},getWetLevel:function(e){return!s.Util.isNumber(e)||e>1||0>e?0:e>=.5?1:1-2*(.5-e)}};var u=o.context.createGain(),d=Object.getPrototypeOf(Object.getPrototypeOf(u)),l=d.connect;d.connect=function(e){var t=s.Util.isEffect(e)?e.inputNode:e;return l.call(this,t),e},Object.defineProperty(o,"volume",{enumerable:!0,get:function(){return h.gain.value},set:function(e){s.Util.isInRange(e,0,1)&&h&&(h.gain.value=e)}}),Object.defineProperty(o,"masterGainNode",{enumerable:!1,get:function(){return h},set:function(e){console.error("Can't set the master gain node")}}),o.Events={on:function(e,t,i){if(e&&t){this._events=this._events||{};var n=this._events[e]||(this._events[e]=[]);n.push({callback:t,context:i||this,handler:this})}},trigger:function(e){if(e){var t,i,n,o;if(this._events=this._events||{},t=this._events[e]||(this._events[e]=[])){for(i=Math.max(0,arguments.length-1),n=[],o=0;i>o;o++)n[o]=arguments[o+1];for(o=0;o<t.length;o++)t[o].callback.apply(t[o].context,n)}}},off:function(e){e?this._events[e]=void 0:this._events={}}},o.Sound=function(e,t){function i(e){var t=["wave","file","input","script","sound"];if(e&&!d.isFunction(e)&&!d.isString(e)&&!d.isObject(e))return"Description type not supported. Initialize a sound using an object, a function or a string.";if(d.isObject(e)){if(!d.isString(e.source)||-1===t.indexOf(e.source))return"Specified source not supported. Sources can be wave, file, input or script";if(!("file"!==e.source||e.options&&e.options.path))return"A path is needed for sounds with a file source";if(!("script"!==e.source||e.options&&e.options.audioFunction))return"An audio function is needed for sounds with a script source"}}function n(e,t){e=e||{},this.getRawSourceNode=function(){var t=this.sourceNode?this.sourceNode.frequency.value:e.frequency,i=o.context.createOscillator();return i.type=e.type||"sine",i.frequency.value=t||440,i},this.sourceNode=this.getRawSourceNode(),this.sourceNode.gainSuccessor=s.context.createGain(),this.sourceNode.connect(this.sourceNode.gainSuccessor),d.isFunction(t)&&t()}function a(e,t){e=d.isArray(e)?e:[e];var i=new XMLHttpRequest;i.open("GET",e[0],!0),i.responseType="arraybuffer",i.onload=function(i){o.context.decodeAudioData(i.target.response,function(e){u.getRawSourceNode=function(){var t=o.context.createBufferSource();return t.loop=this.loop,t.buffer=e,t},d.isFunction(t)&&t()}.bind(u),function(i){return console.error("Error decoding audio file "+e[0]),e.length>1?(e.shift(),void a(e,t)):(i=i||new Error("Error decoding audio file "+e[0]),void(d.isFunction(t)&&t(i)))}.bind(u))},i.onreadystatechange=function(t){4===i.readyState&&200!==i.status&&console.error("Error while fetching "+e[0]+". "+i.statusText)},i.send()}function r(e,t){if(navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia,!navigator.getUserMedia&&!navigator.mediaDevices.getUserMedia)return void console.error("Your browser does not support getUserMedia");var i=function(e){u.getRawSourceNode=function(){return o.context.createMediaStreamSource(e)},d.isFunction(t)&&t()}.bind(u),n=function(e){d.isFunction(t)&&t(e)};navigator.mediaDevices.getUserMedia?navigator.mediaDevices.getUserMedia({audio:!0}).then(i)["catch"](n):navigator.getUserMedia({audio:!0},i,n)}function c(e,t){var i=d.isFunction(e)?e:e.audioFunction,n=d.isObject(e)&&e.bufferSize?e.bufferSize:null;if(!n)try{o.context.createScriptProcessor()}catch(s){n=2048}this.getRawSourceNode=function(){var e=o.context.createScriptProcessor(n,1,1);return e.onaudioprocess=i,e}}function h(e,t){this.getRawSourceNode=e.sound.getRawSourceNode,e.sound.sourceNode&&s.Util.isOscillator(e.sound.sourceNode)&&(this.sourceNode=this.getRawSourceNode(),this.frequency=e.sound.frequency)}var u=this,d=o.Util,l=i(e),f=d.isObject(e)&&d.isObject(e.options),p=.04,v=.04;if(l)throw console.error(l),new Error("Error initializing Pizzicato Sound: "+l);this.detached=f&&e.options.detached,this.masterVolume=o.context.createGain(),this.fadeNode=o.context.createGain(),this.fadeNode.gain.value=0,this.detached||this.masterVolume.connect(o.masterGainNode),this.lastTimePlayed=0,this.effects=[],this.effectConnectors=[],this.playing=this.paused=!1,this.loop=f&&e.options.loop,this.attack=f&&d.isNumber(e.options.attack)?e.options.attack:p,this.volume=f&&d.isNumber(e.options.volume)?e.options.volume:1,f&&d.isNumber(e.options.release)?this.release=e.options.release:f&&d.isNumber(e.options.sustain)?(console.warn("'sustain' is deprecated. Use 'release' instead."),this.release=e.options.sustain):this.release=v,e?d.isString(e)?a.bind(this)(e,t):d.isFunction(e)?c.bind(this)(e,t):"file"===e.source?a.bind(this)(e.options.path,t):"wave"===e.source?n.bind(this)(e.options,t):"input"===e.source?r.bind(this)(e,t):"script"===e.source?c.bind(this)(e.options,t):"sound"===e.source&&h.bind(this)(e.options,t):n.bind(this)({},t)},o.Sound.prototype=Object.create(o.Events,{play:{enumerable:!0,value:function(e,t){this.playing||(s.Util.isNumber(t)||(t=this.offsetTime||0),s.Util.isNumber(e)||(e=0),this.playing=!0,this.paused=!1,this.sourceNode=this.getSourceNode(),this.applyAttack(),s.Util.isFunction(this.sourceNode.start)&&(this.lastTimePlayed=o.context.currentTime-t,this.sourceNode.start(s.context.currentTime+e,t)),this.trigger("play"))}},stop:{enumerable:!0,value:function(){(this.paused||this.playing)&&(this.paused=this.playing=!1,this.stopWithRelease(),this.offsetTime=0,this.trigger("stop"))}},pause:{enumerable:!0,value:function(){if(!this.paused&&this.playing){this.paused=!0,this.playing=!1,this.stopWithRelease();var e=s.context.currentTime-this.lastTimePlayed;this.sourceNode.buffer?this.offsetTime=e%(this.sourceNode.buffer.length/s.context.sampleRate):this.offsetTime=e,this.trigger("pause")}}},clone:{enumerable:!0,value:function(){for(var e=new o.Sound({source:"sound",options:{loop:this.loop,attack:this.attack,release:this.release,volume:this.volume,sound:this}}),t=0;t<this.effects.length;t++)e.addEffect(this.effects[t]);return e}},onEnded:{enumerable:!0,value:function(e){return function(){this.sourceNode&&this.sourceNode!==e||(this.playing&&this.stop(),this.paused||this.trigger("end"))}}},addEffect:{enumerable:!0,value:function(e){if(!s.Util.isEffect(e))return console.error("The object provided is not a Pizzicato effect."),this;this.effects.push(e);var t=this.effectConnectors.length>0?this.effectConnectors[this.effectConnectors.length-1]:this.fadeNode;t.disconnect(),t.connect(e);var i=s.context.createGain();return this.effectConnectors.push(i),e.connect(i),i.connect(this.masterVolume),this}},removeEffect:{enumerable:!0,value:function(e){var t=this.effects.indexOf(e);if(-1===t)return console.warn("Cannot remove effect that is not applied to this sound."),this;var i=this.playing;i&&this.pause();var n=0===t?this.fadeNode:this.effectConnectors[t-1];n.disconnect();var o=this.effectConnectors[t];o.disconnect(),e.disconnect(o),this.effectConnectors.splice(t,1),this.effects.splice(t,1);var s;return s=t>this.effects.length-1||0===this.effects.length?this.masterVolume:this.effects[t],n.connect(s),i&&this.play(),this}},connect:{enumerable:!0,value:function(e){return this.masterVolume.connect(e),this}},disconnect:{enumerable:!0,value:function(e){return this.masterVolume.disconnect(e),this}},connectEffects:{enumerable:!0,value:function(){for(var e=[],t=0;t<this.effects.length;t++){var i=t===this.effects.length-1,n=i?this.masterVolume:this.effects[t+1].inputNode;e[t]=s.context.createGain(),this.effects[t].outputNode.disconnect(this.effectConnectors[t]),this.effects[t].outputNode.connect(n)}}},volume:{enumerable:!0,get:function(){return this.masterVolume?this.masterVolume.gain.value:void 0},set:function(e){s.Util.isInRange(e,0,1)&&this.masterVolume&&(this.masterVolume.gain.value=e)}},frequency:{enumerable:!0,get:function(){return this.sourceNode&&s.Util.isOscillator(this.sourceNode)?this.sourceNode.frequency.value:null},set:function(e){this.sourceNode&&s.Util.isOscillator(this.sourceNode)&&(this.sourceNode.frequency.value=e)}},sustain:{enumerable:!0,get:function(){return console.warn("'sustain' is deprecated. Use 'release' instead."),this.release},set:function(e){console.warn("'sustain' is deprecated. Use 'release' instead."),s.Util.isInRange(e,0,10)&&(this.release=e)}},getSourceNode:{enumerable:!0,value:function(){if(this.sourceNode){var e=this.sourceNode;e.gainSuccessor.gain.setValueAtTime(e.gainSuccessor.gain.value,s.context.currentTime),e.gainSuccessor.gain.linearRampToValueAtTime(1e-4,s.context.currentTime+.2),setTimeout(function(){e.disconnect(),e.gainSuccessor.disconnect()},200)}var t=this.getRawSourceNode();return t.gainSuccessor=s.context.createGain(),t.connect(t.gainSuccessor),t.gainSuccessor.connect(this.fadeNode),this.fadeNode.connect(this.getInputNode()),s.Util.isAudioBufferSourceNode(t)&&(t.onended=this.onEnded(t).bind(this)),t}},getInputNode:{enumerable:!0,value:function(){return this.effects.length>0?this.effects[0].inputNode:this.masterVolume}},applyAttack:{enumerable:!1,value:function(){this.fadeNode.gain.value;if(this.fadeNode.gain.cancelScheduledValues(s.context.currentTime),!this.attack)return void this.fadeNode.gain.setTargetAtTime(1,s.context.currentTime,.001);var e=navigator.userAgent.toLowerCase().indexOf("firefox")>-1,t=this.attack;e||(t=(1-this.fadeNode.gain.value)*this.attack),this.fadeNode.gain.setTargetAtTime(1,s.context.currentTime,2*t)}},stopWithRelease:{enumerable:!1,value:function(e){var t=this.sourceNode,i=function(){return s.Util.isFunction(t.stop)?t.stop(0):t.disconnect()};this.fadeNode.gain.value;if(this.fadeNode.gain.cancelScheduledValues(s.context.currentTime),!this.release)return this.fadeNode.gain.setTargetAtTime(0,s.context.currentTime,.001),void i();var n=navigator.userAgent.toLowerCase().indexOf("firefox")>-1,o=this.release;n||(o=this.fadeNode.gain.value*this.release),this.fadeNode.gain.setTargetAtTime(1e-5,s.context.currentTime,o/5),window.setTimeout(function(){i()},1e3*o)}}}),o.Group=function(e){e=e||[],this.mergeGainNode=s.context.createGain(),this.masterVolume=s.context.createGain(),this.sounds=[],this.effects=[],this.effectConnectors=[],this.mergeGainNode.connect(this.masterVolume),this.masterVolume.connect(s.masterGainNode);for(var t=0;t<e.length;t++)this.addSound(e[t])},o.Group.prototype=Object.create(s.Events,{connect:{enumerable:!0,value:function(e){return this.masterVolume.connect(e),this}},disconnect:{enumerable:!0,value:function(e){return this.masterVolume.disconnect(e),this}},addSound:{enumerable:!0,value:function(e){return s.Util.isSound(e)?this.sounds.indexOf(e)>-1?void console.warn("The Pizzicato.Sound object was already added to this group"):e.detached?void console.warn("Groups do not support detached sounds. You can manually create an audio graph to group detached sounds together."):(e.disconnect(s.masterGainNode),e.connect(this.mergeGainNode),void this.sounds.push(e)):void console.error("You can only add Pizzicato.Sound objects")}},removeSound:{enumerable:!0,value:function(e){var t=this.sounds.indexOf(e);return-1===t?void console.warn("Cannot remove a sound that is not part of this group."):(e.disconnect(this.mergeGainNode),e.connect(s.masterGainNode),void this.sounds.splice(t,1))}},volume:{enumerable:!0,get:function(){return this.masterVolume?this.masterVolume.gain.value:void 0},set:function(e){s.Util.isInRange(e,0,1)&&(this.masterVolume.gain.value=e)}},play:{enumerable:!0,value:function(){for(var e=0;e<this.sounds.length;e++)this.sounds[e].play();this.trigger("play")}},stop:{enumerable:!0,value:function(){for(var e=0;e<this.sounds.length;e++)this.sounds[e].stop();this.trigger("stop")}},pause:{enumerable:!0,value:function(){for(var e=0;e<this.sounds.length;e++)this.sounds[e].pause();this.trigger("pause")}},addEffect:{enumerable:!0,value:function(e){if(!s.Util.isEffect(e))return console.error("The object provided is not a Pizzicato effect."),this;this.effects.push(e);var t=this.effectConnectors.length>0?this.effectConnectors[this.effectConnectors.length-1]:this.mergeGainNode;t.disconnect(),t.connect(e);var i=s.context.createGain();return this.effectConnectors.push(i),e.connect(i),i.connect(this.masterVolume),this}},removeEffect:{enumerable:!0,value:function(e){var t=this.effects.indexOf(e);if(-1===t)return console.warn("Cannot remove effect that is not applied to this group."),this;var i=0===t?this.mergeGainNode:this.effectConnectors[t-1];i.disconnect();var n=this.effectConnectors[t];n.disconnect(),e.disconnect(n),this.effectConnectors.splice(t,1),this.effects.splice(t,1);var o;return o=t>this.effects.length-1||0===this.effects.length?this.masterVolume:this.effects[t],i.connect(o),this}}}),o.Effects={};var f=Object.create(null,{connect:{enumerable:!0,value:function(e){return this.outputNode.connect(e),this}},disconnect:{enumerable:!0,value:function(e){return this.outputNode.disconnect(e),this}}});o.Effects.Delay=function(e){this.options={},e=e||this.options;var t={feedback:.5,time:.3,mix:.5};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.feedbackGainNode=o.context.createGain(),this.delayNode=o.context.createDelay(),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.delayNode.connect(this.feedbackGainNode),this.feedbackGainNode.connect(this.delayNode),this.inputNode.connect(this.delayNode),this.delayNode.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Delay.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},time:{enumerable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,0,180)&&(this.options.time=e,this.delayNode.delayTime.value=e)}},feedback:{enumerable:!0,get:function(){return this.options.feedback},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.feedback=parseFloat(e,10),this.feedbackGainNode.gain.value=this.feedback)}}}),o.Effects.Compressor=function(e){this.options={},e=e||this.options;var t={threshold:-24,knee:30,attack:.003,release:.25,ratio:12};this.inputNode=this.compressorNode=o.context.createDynamicsCompressor(),this.outputNode=o.context.createGain(),this.compressorNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Compressor.prototype=Object.create(f,{threshold:{enumerable:!0,get:function(){return this.compressorNode.threshold.value},set:function(e){o.Util.isInRange(e,-100,0)&&(this.compressorNode.threshold.value=e)}},knee:{enumerable:!0,get:function(){return this.compressorNode.knee.value},set:function(e){o.Util.isInRange(e,0,40)&&(this.compressorNode.knee.value=e)}},attack:{enumerable:!0,get:function(){return this.compressorNode.attack.value},set:function(e){o.Util.isInRange(e,0,1)&&(this.compressorNode.attack.value=e)}},release:{enumerable:!0,get:function(){return this.compressorNode.release.value},set:function(e){o.Util.isInRange(e,0,1)&&(this.compressorNode.release.value=e)}},ratio:{enumerable:!0,get:function(){return this.compressorNode.ratio.value},set:function(e){o.Util.isInRange(e,1,20)&&(this.compressorNode.ratio.value=e)}},getCurrentGainReduction:function(){return this.compressorNode.reduction}}),o.Effects.LowPassFilter=function(e){t.call(this,e,"lowpass")},o.Effects.HighPassFilter=function(e){t.call(this,e,"highpass")};var p=Object.create(f,{frequency:{enumerable:!0,get:function(){return this.filterNode.frequency.value},set:function(e){o.Util.isInRange(e,10,22050)&&(this.filterNode.frequency.value=e)}},peak:{enumerable:!0,get:function(){return this.filterNode.Q.value},set:function(e){o.Util.isInRange(e,1e-4,1e3)&&(this.filterNode.Q.value=e)}}});o.Effects.LowPassFilter.prototype=p,o.Effects.HighPassFilter.prototype=p,o.Effects.Distortion=function(e){this.options={},e=e||this.options;var t={gain:.5};this.waveShaperNode=o.context.createWaveShaper(),this.inputNode=this.outputNode=this.waveShaperNode;for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Distortion.prototype=Object.create(f,{gain:{enumerable:!0,get:function(){return this.options.gain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.gain=e,this.adjustGain())}},adjustGain:{writable:!1,configurable:!1,enumerable:!1,value:function(){for(var e,t=s.Util.isNumber(this.options.gain)?parseInt(100*this.options.gain,10):50,i=44100,n=new Float32Array(i),o=Math.PI/180,a=0;i>a;++a)e=2*a/i-1,n[a]=(3+t)*e*20*o/(Math.PI+t*Math.abs(e));this.waveShaperNode.curve=n}}}),o.Effects.Flanger=function(e){this.options={},e=e||this.options;var t={time:.45,speed:.2,depth:.1,feedback:.1,mix:.5};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.inputFeedbackNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.delayNode=o.context.createDelay(),this.oscillatorNode=o.context.createOscillator(),this.gainNode=o.context.createGain(),this.feedbackNode=o.context.createGain(),this.oscillatorNode.type="sine",this.inputNode.connect(this.inputFeedbackNode),this.inputNode.connect(this.dryGainNode),this.inputFeedbackNode.connect(this.delayNode),this.inputFeedbackNode.connect(this.wetGainNode),this.delayNode.connect(this.wetGainNode),this.delayNode.connect(this.feedbackNode),this.feedbackNode.connect(this.inputFeedbackNode),this.oscillatorNode.connect(this.gainNode),this.gainNode.connect(this.delayNode.delayTime),this.dryGainNode.connect(this.outputNode),this.wetGainNode.connect(this.outputNode),this.oscillatorNode.start(0);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Flanger.prototype=Object.create(f,{time:{enumberable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.time=e,this.delayNode.delayTime.value=s.Util.normalize(e,.001,.02))}},speed:{enumberable:!0,get:function(){return this.options.speed},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.speed=e,this.oscillatorNode.frequency.value=s.Util.normalize(e,.5,5))}},depth:{enumberable:!0,get:function(){return this.options.depth},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.depth=e,this.gainNode.gain.value=s.Util.normalize(e,5e-4,.005))}},feedback:{enumberable:!0,get:function(){return this.options.feedback},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.feedback=e,this.feedbackNode.gain.value=s.Util.normalize(e,0,.8))}},mix:{enumberable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}}}),o.Effects.StereoPanner=function(e){this.options={},e=e||this.options;var t={pan:0};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),o.context.createStereoPanner?(this.pannerNode=o.context.createStereoPanner(),this.inputNode.connect(this.pannerNode),this.pannerNode.connect(this.outputNode)):o.context.createPanner?(console.warn("Your browser does not support the StereoPannerNode. Will use PannerNode instead."),this.pannerNode=o.context.createPanner(),this.pannerNode.type="equalpower",this.inputNode.connect(this.pannerNode),this.pannerNode.connect(this.outputNode)):(console.warn("Your browser does not support the Panner effect."),this.inputNode.connect(this.outputNode));for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.StereoPanner.prototype=Object.create(f,{pan:{enumerable:!0,get:function(){return this.options.pan},set:function(e){if(s.Util.isInRange(e,-1,1)&&(this.options.pan=e,this.pannerNode)){var t=this.pannerNode.toString().indexOf("StereoPannerNode")>-1;t?this.pannerNode.pan.value=e:this.pannerNode.setPosition(e,0,1-Math.abs(e))}}}}),o.Effects.Convolver=function(e,t){this.options={},e=e||this.options;var i=this,n=new XMLHttpRequest,a={mix:.5};this.callback=t,this.inputNode=o.context.createGain(),this.convolverNode=o.context.createConvolver(),this.outputNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.inputNode.connect(this.convolverNode),this.convolverNode.connect(this.wetGainNode),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.wetGainNode.connect(this.outputNode);for(var r in a)this[r]=e[r],this[r]=void 0===this[r]||null===this[r]?a[r]:this[r];return e.impulse?(n.open("GET",e.impulse,!0),n.responseType="arraybuffer",n.onload=function(e){var t=e.target.response;o.context.decodeAudioData(t,function(e){i.convolverNode.buffer=e,i.callback&&s.Util.isFunction(i.callback)&&i.callback()},function(e){e=e||new Error("Error decoding impulse file"),i.callback&&s.Util.isFunction(i.callback)&&i.callback(e)})},n.onreadystatechange=function(t){4===n.readyState&&200!==n.status&&console.error("Error while fetching "+e.impulse+". "+n.statusText)},void n.send()):void console.error("No impulse file specified.")},o.Effects.Convolver.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}}}),o.Effects.PingPongDelay=function(e){this.options={},e=e||this.options;var t={feedback:.5,time:.3,mix:.5};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.delayNodeLeft=o.context.createDelay(),this.delayNodeRight=o.context.createDelay(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.feedbackGainNode=o.context.createGain(),this.channelMerger=o.context.createChannelMerger(2),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.delayNodeLeft.connect(this.channelMerger,0,0),this.delayNodeRight.connect(this.channelMerger,0,1),this.delayNodeLeft.connect(this.delayNodeRight),this.feedbackGainNode.connect(this.delayNodeLeft),this.delayNodeRight.connect(this.feedbackGainNode),this.inputNode.connect(this.feedbackGainNode),this.channelMerger.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.PingPongDelay.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},time:{enumerable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,0,180)&&(this.options.time=e,this.delayNodeLeft.delayTime.value=e,this.delayNodeRight.delayTime.value=e)}},feedback:{enumerable:!0,get:function(){return this.options.feedback},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.feedback=parseFloat(e,10),this.feedbackGainNode.gain.value=this.feedback)}}}),o.Effects.Reverb=function(e){this.options={},e=e||this.options;var t={mix:.5,time:.01,decay:.01,reverse:!1};this.inputNode=o.context.createGain(),this.reverbNode=o.context.createConvolver(),this.outputNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.inputNode.connect(this.reverbNode),this.reverbNode.connect(this.wetGainNode),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.wetGainNode.connect(this.outputNode);for(var n in t)this[n]=e[n],this[n]=void 0===this[n]||null===this[n]?t[n]:this[n];i.bind(this)()},o.Effects.Reverb.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},time:{enumerable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,1e-4,10)&&(this.options.time=e,i.bind(this)())}},decay:{enumerable:!0,get:function(){return this.options.decay},set:function(e){s.Util.isInRange(e,1e-4,10)&&(this.options.decay=e,i.bind(this)())}},reverse:{enumerable:!0,get:function(){return this.options.reverse},set:function(e){s.Util.isBool(e)&&(this.options.reverse=e,i.bind(this)())}}}),o.Effects.Tremolo=function(e){this.options={},e=e||this.options;var t={speed:4,depth:1,mix:.8};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.tremoloGainNode=o.context.createGain(),this.tremoloGainNode.gain.value=0,this.lfoNode=o.context.createOscillator(),this.shaperNode=o.context.createWaveShaper(),this.shaperNode.curve=new Float32Array([0,1]),this.shaperNode.connect(this.tremoloGainNode.gain),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.lfoNode.connect(this.shaperNode),this.lfoNode.type="sine",this.lfoNode.start(0),this.inputNode.connect(this.tremoloGainNode),this.tremoloGainNode.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Tremolo.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},speed:{enumerable:!0,get:function(){return this.options.speed},set:function(e){s.Util.isInRange(e,0,20)&&(this.options.speed=e,this.lfoNode.frequency.value=e)}},depth:{enumerable:!0,get:function(){return this.options.depth},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.depth=e,this.shaperNode.curve=new Float32Array([1-e,1]))}}}),o.Effects.DubDelay=function(e){this.options={},e=e||this.options;var t={feedback:.6,time:.7,mix:.5,cutoff:700};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.feedbackGainNode=o.context.createGain(),this.delayNode=o.context.createDelay(),this.bqFilterNode=o.context.createBiquadFilter(),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.inputNode.connect(this.wetGainNode),this.inputNode.connect(this.feedbackGainNode),this.feedbackGainNode.connect(this.bqFilterNode),this.bqFilterNode.connect(this.delayNode),this.delayNode.connect(this.feedbackGainNode),this.delayNode.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.DubDelay.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},time:{enumerable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,0,180)&&(this.options.time=e,this.delayNode.delayTime.value=e)}},feedback:{enumerable:!0,get:function(){return this.options.feedback},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.feedback=parseFloat(e,10),this.feedbackGainNode.gain.value=this.feedback)}},cutoff:{enumerable:!0,get:function(){return this.options.cutoff},set:function(e){s.Util.isInRange(e,0,4e3)&&(this.options.cutoff=e,this.bqFilterNode.frequency.value=this.cutoff)}}}),o.Effects.RingModulator=function(e){this.options={},e=e||this.options;var t={speed:30,distortion:1,mix:.5};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.vIn=o.context.createOscillator(),this.vIn.start(0),this.vInGain=o.context.createGain(),this.vInGain.gain.value=.5,this.vInInverter1=o.context.createGain(),this.vInInverter1.gain.value=-1,this.vInInverter2=o.context.createGain(),this.vInInverter2.gain.value=-1,this.vInDiode1=new v(o.context),this.vInDiode2=new v(o.context),this.vInInverter3=o.context.createGain(),this.vInInverter3.gain.value=-1,this.vcInverter1=o.context.createGain(),this.vcInverter1.gain.value=-1,this.vcDiode3=new v(o.context),this.vcDiode4=new v(o.context),this.outGain=o.context.createGain(),this.outGain.gain.value=3,this.compressor=o.context.createDynamicsCompressor(),this.compressor.threshold.value=-24,this.compressor.ratio.value=16,this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.inputNode.connect(this.vcInverter1),this.inputNode.connect(this.vcDiode4.node),this.vcInverter1.connect(this.vcDiode3.node),this.vIn.connect(this.vInGain),this.vInGain.connect(this.vInInverter1),this.vInGain.connect(this.vcInverter1),this.vInGain.connect(this.vcDiode4.node),this.vInInverter1.connect(this.vInInverter2),this.vInInverter1.connect(this.vInDiode2.node),this.vInInverter2.connect(this.vInDiode1.node),this.vInDiode1.connect(this.vInInverter3),this.vInDiode2.connect(this.vInInverter3),this.vInInverter3.connect(this.compressor),this.vcDiode3.connect(this.compressor),this.vcDiode4.connect(this.compressor),this.compressor.connect(this.outGain),
this.outGain.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]};var v=function(e){this.context=e,this.node=this.context.createWaveShaper(),this.vb=.2,this.vl=.4,this.h=1,this.setCurve()};return v.prototype.setDistortion=function(e){return this.h=e,this.setCurve()},v.prototype.setCurve=function(){var e,t,i,n,o,s,a,r;for(t=1024,o=new Float32Array(t),e=s=0,a=o.length;a>=0?a>s:s>a;e=a>=0?++s:--s)i=(e-t/2)/(t/2),i=Math.abs(i),n=i<=this.vb?0:this.vb<i&&i<=this.vl?this.h*(Math.pow(i-this.vb,2)/(2*this.vl-2*this.vb)):this.h*i-this.h*this.vl+this.h*(Math.pow(this.vl-this.vb,2)/(2*this.vl-2*this.vb)),o[e]=n;return r=this.node.curve=o},v.prototype.connect=function(e){return this.node.connect(e)},o.Effects.RingModulator.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},speed:{enumerable:!0,get:function(){return this.options.speed},set:function(e){s.Util.isInRange(e,0,2e3)&&(this.options.speed=e,this.vIn.frequency.value=e)}},distortion:{enumerable:!0,get:function(){return this.options.distortion},set:function(e){if(s.Util.isInRange(e,.2,50)){this.options.distortion=parseFloat(e,10);for(var t=[this.vInDiode1,this.vInDiode2,this.vcDiode3,this.vcDiode4],i=0,n=t.length;n>i;i++)t[i].setDistortion(e)}}}}),o.Effects.Quadrafuzz=function(e){this.options={},e=e||this.options;var t={lowGain:.6,midLowGain:.8,midHighGain:.5,highGain:.6};this.inputNode=s.context.createGain(),this.outputNode=s.context.createGain(),this.dryGainNode=s.context.createGain(),this.wetGainNode=s.context.createGain(),this.lowpassLeft=s.context.createBiquadFilter(),this.lowpassLeft.type="lowpass",this.lowpassLeft.frequency.value=147,this.lowpassLeft.Q.value=.7071,this.bandpass1Left=s.context.createBiquadFilter(),this.bandpass1Left.type="bandpass",this.bandpass1Left.frequency.value=587,this.bandpass1Left.Q.value=.7071,this.bandpass2Left=s.context.createBiquadFilter(),this.bandpass2Left.type="bandpass",this.bandpass2Left.frequency.value=2490,this.bandpass2Left.Q.value=.7071,this.highpassLeft=s.context.createBiquadFilter(),this.highpassLeft.type="highpass",this.highpassLeft.frequency.value=4980,this.highpassLeft.Q.value=.7071,this.overdrives=[];for(var i=0;4>i;i++)this.overdrives[i]=s.context.createWaveShaper(),this.overdrives[i].curve=n();this.inputNode.connect(this.wetGainNode),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode);var o=[this.lowpassLeft,this.bandpass1Left,this.bandpass2Left,this.highpassLeft];for(i=0;i<o.length;i++)this.wetGainNode.connect(o[i]),o[i].connect(this.overdrives[i]),this.overdrives[i].connect(this.outputNode);for(var a in t)this[a]=e[a],this[a]=void 0===this[a]||null===this[a]?t[a]:this[a]},o.Effects.Quadrafuzz.prototype=Object.create(f,{lowGain:{enumerable:!0,get:function(){return this.options.lowGain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.lowGain=e,this.overdrives[0].curve=n(s.Util.normalize(this.lowGain,0,150)))}},midLowGain:{enumerable:!0,get:function(){return this.options.midLowGain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.midLowGain=e,this.overdrives[1].curve=n(s.Util.normalize(this.midLowGain,0,150)))}},midHighGain:{enumerable:!0,get:function(){return this.options.midHighGain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.midHighGain=e,this.overdrives[2].curve=n(s.Util.normalize(this.midHighGain,0,150)))}},highGain:{enumerable:!0,get:function(){return this.options.highGain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.highGain=e,this.overdrives[3].curve=n(s.Util.normalize(this.highGain,0,150)))}}}),o}("undefined"!=typeof window?window:global);
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],111:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],112:[function(require,module,exports){

const canPromise = require('./can-promise')

const QRCode = require('./core/qrcode')
const CanvasRenderer = require('./renderer/canvas')
const SvgRenderer = require('./renderer/svg-tag.js')

function renderCanvas (renderFunc, canvas, text, opts, cb) {
  const args = [].slice.call(arguments, 1)
  const argsNum = args.length
  const isLastArgCb = typeof args[argsNum - 1] === 'function'

  if (!isLastArgCb && !canPromise()) {
    throw new Error('Callback required as last argument')
  }

  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 2) {
      cb = text
      text = canvas
      canvas = opts = undefined
    } else if (argsNum === 3) {
      if (canvas.getContext && typeof cb === 'undefined') {
        cb = opts
        opts = undefined
      } else {
        cb = opts
        opts = text
        text = canvas
        canvas = undefined
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 1) {
      text = canvas
      canvas = opts = undefined
    } else if (argsNum === 2 && !canvas.getContext) {
      opts = text
      text = canvas
      canvas = undefined
    }

    return new Promise(function (resolve, reject) {
      try {
        const data = QRCode.create(text, opts)
        resolve(renderFunc(data, canvas, opts))
      } catch (e) {
        reject(e)
      }
    })
  }

  try {
    const data = QRCode.create(text, opts)
    cb(null, renderFunc(data, canvas, opts))
  } catch (e) {
    cb(e)
  }
}

exports.create = QRCode.create
exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render)
exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL)

// only svg for now.
exports.toString = renderCanvas.bind(null, function (data, _, opts) {
  return SvgRenderer.render(data, opts)
})

},{"./can-promise":113,"./core/qrcode":129,"./renderer/canvas":136,"./renderer/svg-tag.js":137}],113:[function(require,module,exports){
// can-promise has a crash in some versions of react native that dont have
// standard global objects
// https://github.com/soldair/node-qrcode/issues/157

module.exports = function () {
  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
}

},{}],114:[function(require,module,exports){
/**
 * Alignment pattern are fixed reference pattern in defined positions
 * in a matrix symbology, which enables the decode software to re-synchronise
 * the coordinate mapping of the image modules in the event of moderate amounts
 * of distortion of the image.
 *
 * Alignment patterns are present only in QR Code symbols of version 2 or larger
 * and their number depends on the symbol version.
 */

const getSymbolSize = require('./utils').getSymbolSize

/**
 * Calculate the row/column coordinates of the center module of each alignment pattern
 * for the specified QR Code version.
 *
 * The alignment patterns are positioned symmetrically on either side of the diagonal
 * running from the top left corner of the symbol to the bottom right corner.
 *
 * Since positions are simmetrical only half of the coordinates are returned.
 * Each item of the array will represent in turn the x and y coordinate.
 * @see {@link getPositions}
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinate
 */
exports.getRowColCoords = function getRowColCoords (version) {
  if (version === 1) return []

  const posCount = Math.floor(version / 7) + 2
  const size = getSymbolSize(version)
  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2
  const positions = [size - 7] // Last coord is always (size - 7)

  for (let i = 1; i < posCount - 1; i++) {
    positions[i] = positions[i - 1] - intervals
  }

  positions.push(6) // First coord is always 6

  return positions.reverse()
}

/**
 * Returns an array containing the positions of each alignment pattern.
 * Each array's element represent the center point of the pattern as (x, y) coordinates
 *
 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
 * and filtering out the items that overlaps with finder pattern
 *
 * @example
 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
 * The alignment patterns, therefore, are to be centered on (row, column)
 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
 * and are not therefore used for alignment patterns.
 *
 * let pos = getPositions(7)
 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
exports.getPositions = function getPositions (version) {
  const coords = []
  const pos = exports.getRowColCoords(version)
  const posLength = pos.length

  for (let i = 0; i < posLength; i++) {
    for (let j = 0; j < posLength; j++) {
      // Skip if position is occupied by finder patterns
      if ((i === 0 && j === 0) || // top-left
          (i === 0 && j === posLength - 1) || // bottom-left
          (i === posLength - 1 && j === 0)) { // top-right
        continue
      }

      coords.push([pos[i], pos[j]])
    }
  }

  return coords
}

},{"./utils":133}],115:[function(require,module,exports){
const Mode = require('./mode')

/**
 * Array of characters available in alphanumeric mode
 *
 * As per QR Code specification, to each character
 * is assigned a value from 0 to 44 which in this case coincides
 * with the array index
 *
 * @type {Array}
 */
const ALPHA_NUM_CHARS = [
  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  ' ', '$', '%', '*', '+', '-', '.', '/', ':'
]

function AlphanumericData (data) {
  this.mode = Mode.ALPHANUMERIC
  this.data = data
}

AlphanumericData.getBitsLength = function getBitsLength (length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2)
}

AlphanumericData.prototype.getLength = function getLength () {
  return this.data.length
}

AlphanumericData.prototype.getBitsLength = function getBitsLength () {
  return AlphanumericData.getBitsLength(this.data.length)
}

AlphanumericData.prototype.write = function write (bitBuffer) {
  let i

  // Input data characters are divided into groups of two characters
  // and encoded as 11-bit binary codes.
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    // The character value of the first character is multiplied by 45
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45

    // The character value of the second digit is added to the product
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])

    // The sum is then stored as 11-bit binary number
    bitBuffer.put(value, 11)
  }

  // If the number of input data characters is not a multiple of two,
  // the character value of the final character is encoded as a 6-bit binary number.
  if (this.data.length % 2) {
    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)
  }
}

module.exports = AlphanumericData

},{"./mode":126}],116:[function(require,module,exports){
function BitBuffer () {
  this.buffer = []
  this.length = 0
}

BitBuffer.prototype = {

  get: function (index) {
    const bufIndex = Math.floor(index / 8)
    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
  },

  put: function (num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit(((num >>> (length - i - 1)) & 1) === 1)
    }
  },

  getLengthInBits: function () {
    return this.length
  },

  putBit: function (bit) {
    const bufIndex = Math.floor(this.length / 8)
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0)
    }

    if (bit) {
      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8))
    }

    this.length++
  }
}

module.exports = BitBuffer

},{}],117:[function(require,module,exports){
/**
 * Helper class to handle QR Code symbol modules
 *
 * @param {Number} size Symbol size
 */
function BitMatrix (size) {
  if (!size || size < 1) {
    throw new Error('BitMatrix size must be defined and greater than 0')
  }

  this.size = size
  this.data = new Uint8Array(size * size)
  this.reservedBit = new Uint8Array(size * size)
}

/**
 * Set bit value at specified location
 * If reserved flag is set, this bit will be ignored during masking process
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 * @param {Boolean} reserved
 */
BitMatrix.prototype.set = function (row, col, value, reserved) {
  const index = row * this.size + col
  this.data[index] = value
  if (reserved) this.reservedBit[index] = true
}

/**
 * Returns bit value at specified location
 *
 * @param  {Number}  row
 * @param  {Number}  col
 * @return {Boolean}
 */
BitMatrix.prototype.get = function (row, col) {
  return this.data[row * this.size + col]
}

/**
 * Applies xor operator at specified location
 * (used during masking process)
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 */
BitMatrix.prototype.xor = function (row, col, value) {
  this.data[row * this.size + col] ^= value
}

/**
 * Check if bit at specified location is reserved
 *
 * @param {Number}   row
 * @param {Number}   col
 * @return {Boolean}
 */
BitMatrix.prototype.isReserved = function (row, col) {
  return this.reservedBit[row * this.size + col]
}

module.exports = BitMatrix

},{}],118:[function(require,module,exports){
const Mode = require('./mode')

function ByteData (data) {
  this.mode = Mode.BYTE
  if (typeof (data) === 'string') {
    this.data = new TextEncoder().encode(data)
  } else {
    this.data = new Uint8Array(data)
  }
}

ByteData.getBitsLength = function getBitsLength (length) {
  return length * 8
}

ByteData.prototype.getLength = function getLength () {
  return this.data.length
}

ByteData.prototype.getBitsLength = function getBitsLength () {
  return ByteData.getBitsLength(this.data.length)
}

ByteData.prototype.write = function (bitBuffer) {
  for (let i = 0, l = this.data.length; i < l; i++) {
    bitBuffer.put(this.data[i], 8)
  }
}

module.exports = ByteData

},{"./mode":126}],119:[function(require,module,exports){
const ECLevel = require('./error-correction-level')

const EC_BLOCKS_TABLE = [
// L  M  Q  H
  1, 1, 1, 1,
  1, 1, 1, 1,
  1, 1, 2, 2,
  1, 2, 2, 4,
  1, 2, 4, 4,
  2, 4, 4, 4,
  2, 4, 6, 5,
  2, 4, 6, 6,
  2, 5, 8, 8,
  4, 5, 8, 8,
  4, 5, 8, 11,
  4, 8, 10, 11,
  4, 9, 12, 16,
  4, 9, 16, 16,
  6, 10, 12, 18,
  6, 10, 17, 16,
  6, 11, 16, 19,
  6, 13, 18, 21,
  7, 14, 21, 25,
  8, 16, 20, 25,
  8, 17, 23, 25,
  9, 17, 23, 34,
  9, 18, 25, 30,
  10, 20, 27, 32,
  12, 21, 29, 35,
  12, 23, 34, 37,
  12, 25, 34, 40,
  13, 26, 35, 42,
  14, 28, 38, 45,
  15, 29, 40, 48,
  16, 31, 43, 51,
  17, 33, 45, 54,
  18, 35, 48, 57,
  19, 37, 51, 60,
  19, 38, 53, 63,
  20, 40, 56, 66,
  21, 43, 59, 70,
  22, 45, 62, 74,
  24, 47, 65, 77,
  25, 49, 68, 81
]

const EC_CODEWORDS_TABLE = [
// L  M  Q  H
  7, 10, 13, 17,
  10, 16, 22, 28,
  15, 26, 36, 44,
  20, 36, 52, 64,
  26, 48, 72, 88,
  36, 64, 96, 112,
  40, 72, 108, 130,
  48, 88, 132, 156,
  60, 110, 160, 192,
  72, 130, 192, 224,
  80, 150, 224, 264,
  96, 176, 260, 308,
  104, 198, 288, 352,
  120, 216, 320, 384,
  132, 240, 360, 432,
  144, 280, 408, 480,
  168, 308, 448, 532,
  180, 338, 504, 588,
  196, 364, 546, 650,
  224, 416, 600, 700,
  224, 442, 644, 750,
  252, 476, 690, 816,
  270, 504, 750, 900,
  300, 560, 810, 960,
  312, 588, 870, 1050,
  336, 644, 952, 1110,
  360, 700, 1020, 1200,
  390, 728, 1050, 1260,
  420, 784, 1140, 1350,
  450, 812, 1200, 1440,
  480, 868, 1290, 1530,
  510, 924, 1350, 1620,
  540, 980, 1440, 1710,
  570, 1036, 1530, 1800,
  570, 1064, 1590, 1890,
  600, 1120, 1680, 1980,
  630, 1204, 1770, 2100,
  660, 1260, 1860, 2220,
  720, 1316, 1950, 2310,
  750, 1372, 2040, 2430
]

/**
 * Returns the number of error correction block that the QR Code should contain
 * for the specified version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction blocks
 */
exports.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel.L:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
    case ECLevel.M:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
    case ECLevel.Q:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
    case ECLevel.H:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
}

/**
 * Returns the number of error correction codewords to use for the specified
 * version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction codewords
 */
exports.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel.L:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
    case ECLevel.M:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
    case ECLevel.Q:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
    case ECLevel.H:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
}

},{"./error-correction-level":120}],120:[function(require,module,exports){
exports.L = { bit: 1 }
exports.M = { bit: 0 }
exports.Q = { bit: 3 }
exports.H = { bit: 2 }

function fromString (string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string')
  }

  const lcStr = string.toLowerCase()

  switch (lcStr) {
    case 'l':
    case 'low':
      return exports.L

    case 'm':
    case 'medium':
      return exports.M

    case 'q':
    case 'quartile':
      return exports.Q

    case 'h':
    case 'high':
      return exports.H

    default:
      throw new Error('Unknown EC Level: ' + string)
  }
}

exports.isValid = function isValid (level) {
  return level && typeof level.bit !== 'undefined' &&
    level.bit >= 0 && level.bit < 4
}

exports.from = function from (value, defaultValue) {
  if (exports.isValid(value)) {
    return value
  }

  try {
    return fromString(value)
  } catch (e) {
    return defaultValue
  }
}

},{}],121:[function(require,module,exports){
const getSymbolSize = require('./utils').getSymbolSize
const FINDER_PATTERN_SIZE = 7

/**
 * Returns an array containing the positions of each finder pattern.
 * Each array's element represent the top-left point of the pattern as (x, y) coordinates
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
exports.getPositions = function getPositions (version) {
  const size = getSymbolSize(version)

  return [
    // top-left
    [0, 0],
    // top-right
    [size - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size - FINDER_PATTERN_SIZE]
  ]
}

},{"./utils":133}],122:[function(require,module,exports){
const Utils = require('./utils')

const G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)
const G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)
const G15_BCH = Utils.getBCHDigit(G15)

/**
 * Returns format information with relative error correction bits
 *
 * The format information is a 15-bit sequence containing 5 data bits,
 * with 10 error correction bits calculated using the (15, 5) BCH code.
 *
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Number} mask                 Mask pattern
 * @return {Number}                      Encoded format information bits
 */
exports.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {
  const data = ((errorCorrectionLevel.bit << 3) | mask)
  let d = data << 10

  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH))
  }

  // xor final data with mask pattern in order to ensure that
  // no combination of Error Correction Level and data mask pattern
  // will result in an all-zero data string
  return ((data << 10) | d) ^ G15_MASK
}

},{"./utils":133}],123:[function(require,module,exports){
const EXP_TABLE = new Uint8Array(512)
const LOG_TABLE = new Uint8Array(256)
/**
 * Precompute the log and anti-log tables for faster computation later
 *
 * For each possible value in the galois field 2^8, we will pre-compute
 * the logarithm and anti-logarithm (exponential) of this value
 *
 * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
 */
;(function initTables () {
  let x = 1
  for (let i = 0; i < 255; i++) {
    EXP_TABLE[i] = x
    LOG_TABLE[x] = i

    x <<= 1 // multiply by 2

    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
    // This means that when a number is 256 or larger, it should be XORed with 0x11D.
    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
      x ^= 0x11D
    }
  }

  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
  // stay inside the bounds (because we will mainly use this table for the multiplication of
  // two GF numbers, no more).
  // @see {@link mul}
  for (let i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255]
  }
}())

/**
 * Returns log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
exports.log = function log (n) {
  if (n < 1) throw new Error('log(' + n + ')')
  return LOG_TABLE[n]
}

/**
 * Returns anti-log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
exports.exp = function exp (n) {
  return EXP_TABLE[n]
}

/**
 * Multiplies two number inside Galois Field
 *
 * @param  {Number} x
 * @param  {Number} y
 * @return {Number}
 */
exports.mul = function mul (x, y) {
  if (x === 0 || y === 0) return 0

  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
  // @see {@link initTables}
  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
}

},{}],124:[function(require,module,exports){
const Mode = require('./mode')
const Utils = require('./utils')

function KanjiData (data) {
  this.mode = Mode.KANJI
  this.data = data
}

KanjiData.getBitsLength = function getBitsLength (length) {
  return length * 13
}

KanjiData.prototype.getLength = function getLength () {
  return this.data.length
}

KanjiData.prototype.getBitsLength = function getBitsLength () {
  return KanjiData.getBitsLength(this.data.length)
}

KanjiData.prototype.write = function (bitBuffer) {
  let i

  // In the Shift JIS system, Kanji characters are represented by a two byte combination.
  // These byte values are shifted from the JIS X 0208 values.
  // JIS X 0208 gives details of the shift coded representation.
  for (i = 0; i < this.data.length; i++) {
    let value = Utils.toSJIS(this.data[i])

    // For characters with Shift JIS values from 0x8140 to 0x9FFC:
    if (value >= 0x8140 && value <= 0x9FFC) {
      // Subtract 0x8140 from Shift JIS value
      value -= 0x8140

    // For characters with Shift JIS values from 0xE040 to 0xEBBF
    } else if (value >= 0xE040 && value <= 0xEBBF) {
      // Subtract 0xC140 from Shift JIS value
      value -= 0xC140
    } else {
      throw new Error(
        'Invalid SJIS character: ' + this.data[i] + '\n' +
        'Make sure your charset is UTF-8')
    }

    // Multiply most significant byte of result by 0xC0
    // and add least significant byte to product
    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff)

    // Convert result to a 13-bit binary string
    bitBuffer.put(value, 13)
  }
}

module.exports = KanjiData

},{"./mode":126,"./utils":133}],125:[function(require,module,exports){
/**
 * Data mask pattern reference
 * @type {Object}
 */
exports.Patterns = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
}

/**
 * Weighted penalty scores for the undesirable features
 * @type {Object}
 */
const PenaltyScores = {
  N1: 3,
  N2: 3,
  N3: 40,
  N4: 10
}

/**
 * Check if mask pattern value is valid
 *
 * @param  {Number}  mask    Mask pattern
 * @return {Boolean}         true if valid, false otherwise
 */
exports.isValid = function isValid (mask) {
  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
}

/**
 * Returns mask pattern from a value.
 * If value is not valid, returns undefined
 *
 * @param  {Number|String} value        Mask pattern value
 * @return {Number}                     Valid mask pattern or undefined
 */
exports.from = function from (value) {
  return exports.isValid(value) ? parseInt(value, 10) : undefined
}

/**
* Find adjacent modules in row/column with the same color
* and assign a penalty value.
*
* Points: N1 + i
* i is the amount by which the number of adjacent modules of the same color exceeds 5
*/
exports.getPenaltyN1 = function getPenaltyN1 (data) {
  const size = data.size
  let points = 0
  let sameCountCol = 0
  let sameCountRow = 0
  let lastCol = null
  let lastRow = null

  for (let row = 0; row < size; row++) {
    sameCountCol = sameCountRow = 0
    lastCol = lastRow = null

    for (let col = 0; col < size; col++) {
      let module = data.get(row, col)
      if (module === lastCol) {
        sameCountCol++
      } else {
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)
        lastCol = module
        sameCountCol = 1
      }

      module = data.get(col, row)
      if (module === lastRow) {
        sameCountRow++
      } else {
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)
        lastRow = module
        sameCountRow = 1
      }
    }

    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)
    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)
  }

  return points
}

/**
 * Find 2x2 blocks with the same color and assign a penalty value
 *
 * Points: N2 * (m - 1) * (n - 1)
 */
exports.getPenaltyN2 = function getPenaltyN2 (data) {
  const size = data.size
  let points = 0

  for (let row = 0; row < size - 1; row++) {
    for (let col = 0; col < size - 1; col++) {
      const last = data.get(row, col) +
        data.get(row, col + 1) +
        data.get(row + 1, col) +
        data.get(row + 1, col + 1)

      if (last === 4 || last === 0) points++
    }
  }

  return points * PenaltyScores.N2
}

/**
 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
 * preceded or followed by light area 4 modules wide
 *
 * Points: N3 * number of pattern found
 */
exports.getPenaltyN3 = function getPenaltyN3 (data) {
  const size = data.size
  let points = 0
  let bitsCol = 0
  let bitsRow = 0

  for (let row = 0; row < size; row++) {
    bitsCol = bitsRow = 0
    for (let col = 0; col < size; col++) {
      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)
      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++

      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)
      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++
    }
  }

  return points * PenaltyScores.N3
}

/**
 * Calculate proportion of dark modules in entire symbol
 *
 * Points: N4 * k
 *
 * k is the rating of the deviation of the proportion of dark modules
 * in the symbol from 50% in steps of 5%
 */
exports.getPenaltyN4 = function getPenaltyN4 (data) {
  let darkCount = 0
  const modulesCount = data.data.length

  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]

  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)

  return k * PenaltyScores.N4
}

/**
 * Return mask value at given position
 *
 * @param  {Number} maskPattern Pattern reference value
 * @param  {Number} i           Row
 * @param  {Number} j           Column
 * @return {Boolean}            Mask value
 */
function getMaskAt (maskPattern, i, j) {
  switch (maskPattern) {
    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0
    case exports.Patterns.PATTERN001: return i % 2 === 0
    case exports.Patterns.PATTERN010: return j % 3 === 0
    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0
    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0
    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0
    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0

    default: throw new Error('bad maskPattern:' + maskPattern)
  }
}

/**
 * Apply a mask pattern to a BitMatrix
 *
 * @param  {Number}    pattern Pattern reference number
 * @param  {BitMatrix} data    BitMatrix data
 */
exports.applyMask = function applyMask (pattern, data) {
  const size = data.size

  for (let col = 0; col < size; col++) {
    for (let row = 0; row < size; row++) {
      if (data.isReserved(row, col)) continue
      data.xor(row, col, getMaskAt(pattern, row, col))
    }
  }
}

/**
 * Returns the best mask pattern for data
 *
 * @param  {BitMatrix} data
 * @return {Number} Mask pattern reference number
 */
exports.getBestMask = function getBestMask (data, setupFormatFunc) {
  const numPatterns = Object.keys(exports.Patterns).length
  let bestPattern = 0
  let lowerPenalty = Infinity

  for (let p = 0; p < numPatterns; p++) {
    setupFormatFunc(p)
    exports.applyMask(p, data)

    // Calculate penalty
    const penalty =
      exports.getPenaltyN1(data) +
      exports.getPenaltyN2(data) +
      exports.getPenaltyN3(data) +
      exports.getPenaltyN4(data)

    // Undo previously applied mask
    exports.applyMask(p, data)

    if (penalty < lowerPenalty) {
      lowerPenalty = penalty
      bestPattern = p
    }
  }

  return bestPattern
}

},{}],126:[function(require,module,exports){
const VersionCheck = require('./version-check')
const Regex = require('./regex')

/**
 * Numeric mode encodes data from the decimal digit set (0 - 9)
 * (byte values 30HEX to 39HEX).
 * Normally, 3 data characters are represented by 10 bits.
 *
 * @type {Object}
 */
exports.NUMERIC = {
  id: 'Numeric',
  bit: 1 << 0,
  ccBits: [10, 12, 14]
}

/**
 * Alphanumeric mode encodes data from a set of 45 characters,
 * i.e. 10 numeric digits (0 - 9),
 *      26 alphabetic characters (A - Z),
 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
 * Normally, two input characters are represented by 11 bits.
 *
 * @type {Object}
 */
exports.ALPHANUMERIC = {
  id: 'Alphanumeric',
  bit: 1 << 1,
  ccBits: [9, 11, 13]
}

/**
 * In byte mode, data is encoded at 8 bits per character.
 *
 * @type {Object}
 */
exports.BYTE = {
  id: 'Byte',
  bit: 1 << 2,
  ccBits: [8, 16, 16]
}

/**
 * The Kanji mode efficiently encodes Kanji characters in accordance with
 * the Shift JIS system based on JIS X 0208.
 * The Shift JIS values are shifted from the JIS X 0208 values.
 * JIS X 0208 gives details of the shift coded representation.
 * Each two-byte character value is compacted to a 13-bit binary codeword.
 *
 * @type {Object}
 */
exports.KANJI = {
  id: 'Kanji',
  bit: 1 << 3,
  ccBits: [8, 10, 12]
}

/**
 * Mixed mode will contain a sequences of data in a combination of any of
 * the modes described above
 *
 * @type {Object}
 */
exports.MIXED = {
  bit: -1
}

/**
 * Returns the number of bits needed to store the data length
 * according to QR Code specifications.
 *
 * @param  {Mode}   mode    Data mode
 * @param  {Number} version QR Code version
 * @return {Number}         Number of bits
 */
exports.getCharCountIndicator = function getCharCountIndicator (mode, version) {
  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

  if (!VersionCheck.isValid(version)) {
    throw new Error('Invalid version: ' + version)
  }

  if (version >= 1 && version < 10) return mode.ccBits[0]
  else if (version < 27) return mode.ccBits[1]
  return mode.ccBits[2]
}

/**
 * Returns the most efficient mode to store the specified data
 *
 * @param  {String} dataStr Input data string
 * @return {Mode}           Best mode
 */
exports.getBestModeForData = function getBestModeForData (dataStr) {
  if (Regex.testNumeric(dataStr)) return exports.NUMERIC
  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
  else if (Regex.testKanji(dataStr)) return exports.KANJI
  else return exports.BYTE
}

/**
 * Return mode name as string
 *
 * @param {Mode} mode Mode object
 * @returns {String}  Mode name
 */
exports.toString = function toString (mode) {
  if (mode && mode.id) return mode.id
  throw new Error('Invalid mode')
}

/**
 * Check if input param is a valid mode object
 *
 * @param   {Mode}    mode Mode object
 * @returns {Boolean} True if valid mode, false otherwise
 */
exports.isValid = function isValid (mode) {
  return mode && mode.bit && mode.ccBits
}

/**
 * Get mode object from its name
 *
 * @param   {String} string Mode name
 * @returns {Mode}          Mode object
 */
function fromString (string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string')
  }

  const lcStr = string.toLowerCase()

  switch (lcStr) {
    case 'numeric':
      return exports.NUMERIC
    case 'alphanumeric':
      return exports.ALPHANUMERIC
    case 'kanji':
      return exports.KANJI
    case 'byte':
      return exports.BYTE
    default:
      throw new Error('Unknown mode: ' + string)
  }
}

/**
 * Returns mode from a value.
 * If value is not a valid mode, returns defaultValue
 *
 * @param  {Mode|String} value        Encoding mode
 * @param  {Mode}        defaultValue Fallback value
 * @return {Mode}                     Encoding mode
 */
exports.from = function from (value, defaultValue) {
  if (exports.isValid(value)) {
    return value
  }

  try {
    return fromString(value)
  } catch (e) {
    return defaultValue
  }
}

},{"./regex":131,"./version-check":134}],127:[function(require,module,exports){
const Mode = require('./mode')

function NumericData (data) {
  this.mode = Mode.NUMERIC
  this.data = data.toString()
}

NumericData.getBitsLength = function getBitsLength (length) {
  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
}

NumericData.prototype.getLength = function getLength () {
  return this.data.length
}

NumericData.prototype.getBitsLength = function getBitsLength () {
  return NumericData.getBitsLength(this.data.length)
}

NumericData.prototype.write = function write (bitBuffer) {
  let i, group, value

  // The input data string is divided into groups of three digits,
  // and each group is converted to its 10-bit binary equivalent.
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3)
    value = parseInt(group, 10)

    bitBuffer.put(value, 10)
  }

  // If the number of input digits is not an exact multiple of three,
  // the final one or two digits are converted to 4 or 7 bits respectively.
  const remainingNum = this.data.length - i
  if (remainingNum > 0) {
    group = this.data.substr(i)
    value = parseInt(group, 10)

    bitBuffer.put(value, remainingNum * 3 + 1)
  }
}

module.exports = NumericData

},{"./mode":126}],128:[function(require,module,exports){
const GF = require('./galois-field')

/**
 * Multiplies two polynomials inside Galois Field
 *
 * @param  {Uint8Array} p1 Polynomial
 * @param  {Uint8Array} p2 Polynomial
 * @return {Uint8Array}    Product of p1 and p2
 */
exports.mul = function mul (p1, p2) {
  const coeff = new Uint8Array(p1.length + p2.length - 1)

  for (let i = 0; i < p1.length; i++) {
    for (let j = 0; j < p2.length; j++) {
      coeff[i + j] ^= GF.mul(p1[i], p2[j])
    }
  }

  return coeff
}

/**
 * Calculate the remainder of polynomials division
 *
 * @param  {Uint8Array} divident Polynomial
 * @param  {Uint8Array} divisor  Polynomial
 * @return {Uint8Array}          Remainder
 */
exports.mod = function mod (divident, divisor) {
  let result = new Uint8Array(divident)

  while ((result.length - divisor.length) >= 0) {
    const coeff = result[0]

    for (let i = 0; i < divisor.length; i++) {
      result[i] ^= GF.mul(divisor[i], coeff)
    }

    // remove all zeros from buffer head
    let offset = 0
    while (offset < result.length && result[offset] === 0) offset++
    result = result.slice(offset)
  }

  return result
}

/**
 * Generate an irreducible generator polynomial of specified degree
 * (used by Reed-Solomon encoder)
 *
 * @param  {Number} degree Degree of the generator polynomial
 * @return {Uint8Array}    Buffer containing polynomial coefficients
 */
exports.generateECPolynomial = function generateECPolynomial (degree) {
  let poly = new Uint8Array([1])
  for (let i = 0; i < degree; i++) {
    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))
  }

  return poly
}

},{"./galois-field":123}],129:[function(require,module,exports){
const Utils = require('./utils')
const ECLevel = require('./error-correction-level')
const BitBuffer = require('./bit-buffer')
const BitMatrix = require('./bit-matrix')
const AlignmentPattern = require('./alignment-pattern')
const FinderPattern = require('./finder-pattern')
const MaskPattern = require('./mask-pattern')
const ECCode = require('./error-correction-code')
const ReedSolomonEncoder = require('./reed-solomon-encoder')
const Version = require('./version')
const FormatInfo = require('./format-info')
const Mode = require('./mode')
const Segments = require('./segments')

/**
 * QRCode for JavaScript
 *
 * modified by Ryan Day for nodejs support
 * Copyright (c) 2011 Ryan Day
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
//---------------------------------------------------------------------
// QRCode for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//   http://www.opensource.org/licenses/mit-license.php
//
// The word "QR Code" is registered trademark of
// DENSO WAVE INCORPORATED
//   http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------
*/

/**
 * Add finder patterns bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupFinderPattern (matrix, version) {
  const size = matrix.size
  const pos = FinderPattern.getPositions(version)

  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0]
    const col = pos[i][1]

    for (let r = -1; r <= 7; r++) {
      if (row + r <= -1 || size <= row + r) continue

      for (let c = -1; c <= 7; c++) {
        if (col + c <= -1 || size <= col + c) continue

        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
          matrix.set(row + r, col + c, true, true)
        } else {
          matrix.set(row + r, col + c, false, true)
        }
      }
    }
  }
}

/**
 * Add timing pattern bits to matrix
 *
 * Note: this function must be called before {@link setupAlignmentPattern}
 *
 * @param  {BitMatrix} matrix Modules matrix
 */
function setupTimingPattern (matrix) {
  const size = matrix.size

  for (let r = 8; r < size - 8; r++) {
    const value = r % 2 === 0
    matrix.set(r, 6, value, true)
    matrix.set(6, r, value, true)
  }
}

/**
 * Add alignment patterns bits to matrix
 *
 * Note: this function must be called after {@link setupTimingPattern}
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupAlignmentPattern (matrix, version) {
  const pos = AlignmentPattern.getPositions(version)

  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0]
    const col = pos[i][1]

    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        if (r === -2 || r === 2 || c === -2 || c === 2 ||
          (r === 0 && c === 0)) {
          matrix.set(row + r, col + c, true, true)
        } else {
          matrix.set(row + r, col + c, false, true)
        }
      }
    }
  }
}

/**
 * Add version info bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupVersionInfo (matrix, version) {
  const size = matrix.size
  const bits = Version.getEncodedBits(version)
  let row, col, mod

  for (let i = 0; i < 18; i++) {
    row = Math.floor(i / 3)
    col = i % 3 + size - 8 - 3
    mod = ((bits >> i) & 1) === 1

    matrix.set(row, col, mod, true)
    matrix.set(col, row, mod, true)
  }
}

/**
 * Add format info bits to matrix
 *
 * @param  {BitMatrix} matrix               Modules matrix
 * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
 * @param  {Number}    maskPattern          Mask pattern reference value
 */
function setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {
  const size = matrix.size
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)
  let i, mod

  for (i = 0; i < 15; i++) {
    mod = ((bits >> i) & 1) === 1

    // vertical
    if (i < 6) {
      matrix.set(i, 8, mod, true)
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true)
    } else {
      matrix.set(size - 15 + i, 8, mod, true)
    }

    // horizontal
    if (i < 8) {
      matrix.set(8, size - i - 1, mod, true)
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true)
    } else {
      matrix.set(8, 15 - i - 1, mod, true)
    }
  }

  // fixed module
  matrix.set(size - 8, 8, 1, true)
}

/**
 * Add encoded data bits to matrix
 *
 * @param  {BitMatrix}  matrix Modules matrix
 * @param  {Uint8Array} data   Data codewords
 */
function setupData (matrix, data) {
  const size = matrix.size
  let inc = -1
  let row = size - 1
  let bitIndex = 7
  let byteIndex = 0

  for (let col = size - 1; col > 0; col -= 2) {
    if (col === 6) col--

    while (true) {
      for (let c = 0; c < 2; c++) {
        if (!matrix.isReserved(row, col - c)) {
          let dark = false

          if (byteIndex < data.length) {
            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)
          }

          matrix.set(row, col - c, dark)
          bitIndex--

          if (bitIndex === -1) {
            byteIndex++
            bitIndex = 7
          }
        }
      }

      row += inc

      if (row < 0 || size <= row) {
        row -= inc
        inc = -inc
        break
      }
    }
  }
}

/**
 * Create encoded codewords from data input
 *
 * @param  {Number}   version              QR Code version
 * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
 * @param  {ByteData} data                 Data input
 * @return {Uint8Array}                    Buffer containing encoded codewords
 */
function createData (version, errorCorrectionLevel, segments) {
  // Prepare data buffer
  const buffer = new BitBuffer()

  segments.forEach(function (data) {
    // prefix data with mode indicator (4 bits)
    buffer.put(data.mode.bit, 4)

    // Prefix data with character count indicator.
    // The character count indicator is a string of bits that represents the
    // number of characters that are being encoded.
    // The character count indicator must be placed after the mode indicator
    // and must be a certain number of bits long, depending on the QR version
    // and data mode
    // @see {@link Mode.getCharCountIndicator}.
    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))

    // add binary data sequence to buffer
    data.write(buffer)
  })

  // Calculate required number of bits
  const totalCodewords = Utils.getSymbolTotalCodewords(version)
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8

  // Add a terminator.
  // If the bit string is shorter than the total number of required bits,
  // a terminator of up to four 0s must be added to the right side of the string.
  // If the bit string is more than four bits shorter than the required number of bits,
  // add four 0s to the end.
  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer.put(0, 4)
  }

  // If the bit string is fewer than four bits shorter, add only the number of 0s that
  // are needed to reach the required number of bits.

  // After adding the terminator, if the number of bits in the string is not a multiple of 8,
  // pad the string on the right with 0s to make the string's length a multiple of 8.
  while (buffer.getLengthInBits() % 8 !== 0) {
    buffer.putBit(0)
  }

  // Add pad bytes if the string is still shorter than the total number of required bits.
  // Extend the buffer to fill the data capacity of the symbol corresponding to
  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
  // and 00010001 (0x11) alternately.
  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8
  for (let i = 0; i < remainingByte; i++) {
    buffer.put(i % 2 ? 0x11 : 0xEC, 8)
  }

  return createCodewords(buffer, version, errorCorrectionLevel)
}

/**
 * Encode input data with Reed-Solomon and return codewords with
 * relative error correction bits
 *
 * @param  {BitBuffer} bitBuffer            Data to encode
 * @param  {Number}    version              QR Code version
 * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
 * @return {Uint8Array}                     Buffer containing encoded codewords
 */
function createCodewords (bitBuffer, version, errorCorrectionLevel) {
  // Total codewords for this QR code version (Data + Error correction)
  const totalCodewords = Utils.getSymbolTotalCodewords(version)

  // Total number of error correction codewords
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)

  // Total number of data codewords
  const dataTotalCodewords = totalCodewords - ecTotalCodewords

  // Total number of blocks
  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)

  // Calculate how many blocks each group should contain
  const blocksInGroup2 = totalCodewords % ecTotalBlocks
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2

  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)

  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1

  // Number of EC codewords is the same for both groups
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1

  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
  const rs = new ReedSolomonEncoder(ecCount)

  let offset = 0
  const dcData = new Array(ecTotalBlocks)
  const ecData = new Array(ecTotalBlocks)
  let maxDataSize = 0
  const buffer = new Uint8Array(bitBuffer.buffer)

  // Divide the buffer into the required number of blocks
  for (let b = 0; b < ecTotalBlocks; b++) {
    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2

    // extract a block of data from buffer
    dcData[b] = buffer.slice(offset, offset + dataSize)

    // Calculate EC codewords for this data block
    ecData[b] = rs.encode(dcData[b])

    offset += dataSize
    maxDataSize = Math.max(maxDataSize, dataSize)
  }

  // Create final data
  // Interleave the data and error correction codewords from each block
  const data = new Uint8Array(totalCodewords)
  let index = 0
  let i, r

  // Add data codewords
  for (i = 0; i < maxDataSize; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      if (i < dcData[r].length) {
        data[index++] = dcData[r][i]
      }
    }
  }

  // Apped EC codewords
  for (i = 0; i < ecCount; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      data[index++] = ecData[r][i]
    }
  }

  return data
}

/**
 * Build QR Code symbol
 *
 * @param  {String} data                 Input string
 * @param  {Number} version              QR Code version
 * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
 * @param  {MaskPattern} maskPattern     Mask pattern
 * @return {Object}                      Object containing symbol data
 */
function createSymbol (data, version, errorCorrectionLevel, maskPattern) {
  let segments

  if (Array.isArray(data)) {
    segments = Segments.fromArray(data)
  } else if (typeof data === 'string') {
    let estimatedVersion = version

    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data)

      // Estimate best version that can contain raw splitted segments
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)
    }

    // Build optimized segments
    // If estimated version is undefined, try with the highest version
    segments = Segments.fromString(data, estimatedVersion || 40)
  } else {
    throw new Error('Invalid data')
  }

  // Get the min version that can contain data
  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)

  // If no version is found, data cannot be stored
  if (!bestVersion) {
    throw new Error('The amount of data is too big to be stored in a QR Code')
  }

  // If not specified, use min version as default
  if (!version) {
    version = bestVersion

  // Check if the specified version can contain the data
  } else if (version < bestVersion) {
    throw new Error('\n' +
      'The chosen QR Code version cannot contain this amount of data.\n' +
      'Minimum version required to store current data is: ' + bestVersion + '.\n'
    )
  }

  const dataBits = createData(version, errorCorrectionLevel, segments)

  // Allocate matrix buffer
  const moduleCount = Utils.getSymbolSize(version)
  const modules = new BitMatrix(moduleCount)

  // Add function modules
  setupFinderPattern(modules, version)
  setupTimingPattern(modules)
  setupAlignmentPattern(modules, version)

  // Add temporary dummy bits for format info just to set them as reserved.
  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
  // since the masking operation must be performed only on the encoding region.
  // These blocks will be replaced with correct values later in code.
  setupFormatInfo(modules, errorCorrectionLevel, 0)

  if (version >= 7) {
    setupVersionInfo(modules, version)
  }

  // Add data codewords
  setupData(modules, dataBits)

  if (isNaN(maskPattern)) {
    // Find best mask pattern
    maskPattern = MaskPattern.getBestMask(modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel))
  }

  // Apply mask pattern
  MaskPattern.applyMask(maskPattern, modules)

  // Replace format info bits with correct values
  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)

  return {
    modules: modules,
    version: version,
    errorCorrectionLevel: errorCorrectionLevel,
    maskPattern: maskPattern,
    segments: segments
  }
}

/**
 * QR Code
 *
 * @param {String | Array} data                 Input data
 * @param {Object} options                      Optional configurations
 * @param {Number} options.version              QR Code version
 * @param {String} options.errorCorrectionLevel Error correction level
 * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
 */
exports.create = function create (data, options) {
  if (typeof data === 'undefined' || data === '') {
    throw new Error('No input text')
  }

  let errorCorrectionLevel = ECLevel.M
  let version
  let mask

  if (typeof options !== 'undefined') {
    // Use higher error correction level as default
    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)
    version = Version.from(options.version)
    mask = MaskPattern.from(options.maskPattern)

    if (options.toSJISFunc) {
      Utils.setToSJISFunction(options.toSJISFunc)
    }
  }

  return createSymbol(data, version, errorCorrectionLevel, mask)
}

},{"./alignment-pattern":114,"./bit-buffer":116,"./bit-matrix":117,"./error-correction-code":119,"./error-correction-level":120,"./finder-pattern":121,"./format-info":122,"./mask-pattern":125,"./mode":126,"./reed-solomon-encoder":130,"./segments":132,"./utils":133,"./version":135}],130:[function(require,module,exports){
const Polynomial = require('./polynomial')

function ReedSolomonEncoder (degree) {
  this.genPoly = undefined
  this.degree = degree

  if (this.degree) this.initialize(this.degree)
}

/**
 * Initialize the encoder.
 * The input param should correspond to the number of error correction codewords.
 *
 * @param  {Number} degree
 */
ReedSolomonEncoder.prototype.initialize = function initialize (degree) {
  // create an irreducible generator polynomial
  this.degree = degree
  this.genPoly = Polynomial.generateECPolynomial(this.degree)
}

/**
 * Encodes a chunk of data
 *
 * @param  {Uint8Array} data Buffer containing input data
 * @return {Uint8Array}      Buffer containing encoded data
 */
ReedSolomonEncoder.prototype.encode = function encode (data) {
  if (!this.genPoly) {
    throw new Error('Encoder not initialized')
  }

  // Calculate EC for this data block
  // extends data size to data+genPoly size
  const paddedData = new Uint8Array(data.length + this.degree)
  paddedData.set(data)

  // The error correction codewords are the remainder after dividing the data codewords
  // by a generator polynomial
  const remainder = Polynomial.mod(paddedData, this.genPoly)

  // return EC data blocks (last n byte, where n is the degree of genPoly)
  // If coefficients number in remainder are less than genPoly degree,
  // pad with 0s to the left to reach the needed number of coefficients
  const start = this.degree - remainder.length
  if (start > 0) {
    const buff = new Uint8Array(this.degree)
    buff.set(remainder, start)

    return buff
  }

  return remainder
}

module.exports = ReedSolomonEncoder

},{"./polynomial":128}],131:[function(require,module,exports){
const numeric = '[0-9]+'
const alphanumeric = '[A-Z $%*+\\-./:]+'
let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'
kanji = kanji.replace(/u/g, '\\u')

const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+'

exports.KANJI = new RegExp(kanji, 'g')
exports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g')
exports.BYTE = new RegExp(byte, 'g')
exports.NUMERIC = new RegExp(numeric, 'g')
exports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')

const TEST_KANJI = new RegExp('^' + kanji + '$')
const TEST_NUMERIC = new RegExp('^' + numeric + '$')
const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$')

exports.testKanji = function testKanji (str) {
  return TEST_KANJI.test(str)
}

exports.testNumeric = function testNumeric (str) {
  return TEST_NUMERIC.test(str)
}

exports.testAlphanumeric = function testAlphanumeric (str) {
  return TEST_ALPHANUMERIC.test(str)
}

},{}],132:[function(require,module,exports){
const Mode = require('./mode')
const NumericData = require('./numeric-data')
const AlphanumericData = require('./alphanumeric-data')
const ByteData = require('./byte-data')
const KanjiData = require('./kanji-data')
const Regex = require('./regex')
const Utils = require('./utils')
const dijkstra = require('dijkstrajs')

/**
 * Returns UTF8 byte length
 *
 * @param  {String} str Input string
 * @return {Number}     Number of byte
 */
function getStringByteLength (str) {
  return unescape(encodeURIComponent(str)).length
}

/**
 * Get a list of segments of the specified mode
 * from a string
 *
 * @param  {Mode}   mode Segment mode
 * @param  {String} str  String to process
 * @return {Array}       Array of object with segments data
 */
function getSegments (regex, mode, str) {
  const segments = []
  let result

  while ((result = regex.exec(str)) !== null) {
    segments.push({
      data: result[0],
      index: result.index,
      mode: mode,
      length: result[0].length
    })
  }

  return segments
}

/**
 * Extracts a series of segments with the appropriate
 * modes from a string
 *
 * @param  {String} dataStr Input string
 * @return {Array}          Array of object with segments data
 */
function getSegmentsFromString (dataStr) {
  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)
  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)
  let byteSegs
  let kanjiSegs

  if (Utils.isKanjiModeEnabled()) {
    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)
    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)
  } else {
    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)
    kanjiSegs = []
  }

  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)

  return segs
    .sort(function (s1, s2) {
      return s1.index - s2.index
    })
    .map(function (obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      }
    })
}

/**
 * Returns how many bits are needed to encode a string of
 * specified length with the specified mode
 *
 * @param  {Number} length String length
 * @param  {Mode} mode     Segment mode
 * @return {Number}        Bit length
 */
function getSegmentBitsLength (length, mode) {
  switch (mode) {
    case Mode.NUMERIC:
      return NumericData.getBitsLength(length)
    case Mode.ALPHANUMERIC:
      return AlphanumericData.getBitsLength(length)
    case Mode.KANJI:
      return KanjiData.getBitsLength(length)
    case Mode.BYTE:
      return ByteData.getBitsLength(length)
  }
}

/**
 * Merges adjacent segments which have the same mode
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */
function mergeSegments (segs) {
  return segs.reduce(function (acc, curr) {
    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null
    if (prevSeg && prevSeg.mode === curr.mode) {
      acc[acc.length - 1].data += curr.data
      return acc
    }

    acc.push(curr)
    return acc
  }, [])
}

/**
 * Generates a list of all possible nodes combination which
 * will be used to build a segments graph.
 *
 * Nodes are divided by groups. Each group will contain a list of all the modes
 * in which is possible to encode the given text.
 *
 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
 * The group for '12345' will contain then 3 objects, one for each
 * possible encoding mode.
 *
 * Each node represents a possible segment.
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */
function buildNodes (segs) {
  const nodes = []
  for (let i = 0; i < segs.length; i++) {
    const seg = segs[i]

    switch (seg.mode) {
      case Mode.NUMERIC:
        nodes.push([seg,
          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
          { data: seg.data, mode: Mode.BYTE, length: seg.length }
        ])
        break
      case Mode.ALPHANUMERIC:
        nodes.push([seg,
          { data: seg.data, mode: Mode.BYTE, length: seg.length }
        ])
        break
      case Mode.KANJI:
        nodes.push([seg,
          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
        ])
        break
      case Mode.BYTE:
        nodes.push([
          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
        ])
    }
  }

  return nodes
}

/**
 * Builds a graph from a list of nodes.
 * All segments in each node group will be connected with all the segments of
 * the next group and so on.
 *
 * At each connection will be assigned a weight depending on the
 * segment's byte length.
 *
 * @param  {Array} nodes    Array of object with segments data
 * @param  {Number} version QR Code version
 * @return {Object}         Graph of all possible segments
 */
function buildGraph (nodes, version) {
  const table = {}
  const graph = { start: {} }
  let prevNodeIds = ['start']

  for (let i = 0; i < nodes.length; i++) {
    const nodeGroup = nodes[i]
    const currentNodeIds = []

    for (let j = 0; j < nodeGroup.length; j++) {
      const node = nodeGroup[j]
      const key = '' + i + j

      currentNodeIds.push(key)
      table[key] = { node: node, lastCount: 0 }
      graph[key] = {}

      for (let n = 0; n < prevNodeIds.length; n++) {
        const prevNodeId = prevNodeIds[n]

        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
          graph[prevNodeId][key] =
            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)

          table[prevNodeId].lastCount += node.length
        } else {
          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length

          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost
        }
      }
    }

    prevNodeIds = currentNodeIds
  }

  for (let n = 0; n < prevNodeIds.length; n++) {
    graph[prevNodeIds[n]].end = 0
  }

  return { map: graph, table: table }
}

/**
 * Builds a segment from a specified data and mode.
 * If a mode is not specified, the more suitable will be used.
 *
 * @param  {String} data             Input data
 * @param  {Mode | String} modesHint Data mode
 * @return {Segment}                 Segment
 */
function buildSingleSegment (data, modesHint) {
  let mode
  const bestMode = Mode.getBestModeForData(data)

  mode = Mode.from(modesHint, bestMode)

  // Make sure data can be encoded
  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
    throw new Error('"' + data + '"' +
      ' cannot be encoded with mode ' + Mode.toString(mode) +
      '.\n Suggested mode is: ' + Mode.toString(bestMode))
  }

  // Use Mode.BYTE if Kanji support is disabled
  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
    mode = Mode.BYTE
  }

  switch (mode) {
    case Mode.NUMERIC:
      return new NumericData(data)

    case Mode.ALPHANUMERIC:
      return new AlphanumericData(data)

    case Mode.KANJI:
      return new KanjiData(data)

    case Mode.BYTE:
      return new ByteData(data)
  }
}

/**
 * Builds a list of segments from an array.
 * Array can contain Strings or Objects with segment's info.
 *
 * For each item which is a string, will be generated a segment with the given
 * string and the more appropriate encoding mode.
 *
 * For each item which is an object, will be generated a segment with the given
 * data and mode.
 * Objects must contain at least the property "data".
 * If property "mode" is not present, the more suitable mode will be used.
 *
 * @param  {Array} array Array of objects with segments data
 * @return {Array}       Array of Segments
 */
exports.fromArray = function fromArray (array) {
  return array.reduce(function (acc, seg) {
    if (typeof seg === 'string') {
      acc.push(buildSingleSegment(seg, null))
    } else if (seg.data) {
      acc.push(buildSingleSegment(seg.data, seg.mode))
    }

    return acc
  }, [])
}

/**
 * Builds an optimized sequence of segments from a string,
 * which will produce the shortest possible bitstream.
 *
 * @param  {String} data    Input string
 * @param  {Number} version QR Code version
 * @return {Array}          Array of segments
 */
exports.fromString = function fromString (data, version) {
  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())

  const nodes = buildNodes(segs)
  const graph = buildGraph(nodes, version)
  const path = dijkstra.find_path(graph.map, 'start', 'end')

  const optimizedSegs = []
  for (let i = 1; i < path.length - 1; i++) {
    optimizedSegs.push(graph.table[path[i]].node)
  }

  return exports.fromArray(mergeSegments(optimizedSegs))
}

/**
 * Splits a string in various segments with the modes which
 * best represent their content.
 * The produced segments are far from being optimized.
 * The output of this function is only used to estimate a QR Code version
 * which may contain the data.
 *
 * @param  {string} data Input string
 * @return {Array}       Array of segments
 */
exports.rawSplit = function rawSplit (data) {
  return exports.fromArray(
    getSegmentsFromString(data, Utils.isKanjiModeEnabled())
  )
}

},{"./alphanumeric-data":115,"./byte-data":118,"./kanji-data":124,"./mode":126,"./numeric-data":127,"./regex":131,"./utils":133,"dijkstrajs":70}],133:[function(require,module,exports){
let toSJISFunction
const CODEWORDS_COUNT = [
  0, // Not used
  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
]

/**
 * Returns the QR Code size for the specified version
 *
 * @param  {Number} version QR Code version
 * @return {Number}         size of QR code
 */
exports.getSymbolSize = function getSymbolSize (version) {
  if (!version) throw new Error('"version" cannot be null or undefined')
  if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
  return version * 4 + 17
}

/**
 * Returns the total number of codewords used to store data and EC information.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Data length in bits
 */
exports.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {
  return CODEWORDS_COUNT[version]
}

/**
 * Encode data with Bose-Chaudhuri-Hocquenghem
 *
 * @param  {Number} data Value to encode
 * @return {Number}      Encoded value
 */
exports.getBCHDigit = function (data) {
  let digit = 0

  while (data !== 0) {
    digit++
    data >>>= 1
  }

  return digit
}

exports.setToSJISFunction = function setToSJISFunction (f) {
  if (typeof f !== 'function') {
    throw new Error('"toSJISFunc" is not a valid function.')
  }

  toSJISFunction = f
}

exports.isKanjiModeEnabled = function () {
  return typeof toSJISFunction !== 'undefined'
}

exports.toSJIS = function toSJIS (kanji) {
  return toSJISFunction(kanji)
}

},{}],134:[function(require,module,exports){
/**
 * Check if QR Code version is valid
 *
 * @param  {Number}  version QR Code version
 * @return {Boolean}         true if valid version, false otherwise
 */
exports.isValid = function isValid (version) {
  return !isNaN(version) && version >= 1 && version <= 40
}

},{}],135:[function(require,module,exports){
const Utils = require('./utils')
const ECCode = require('./error-correction-code')
const ECLevel = require('./error-correction-level')
const Mode = require('./mode')
const VersionCheck = require('./version-check')

// Generator polynomial used to encode version information
const G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)
const G18_BCH = Utils.getBCHDigit(G18)

function getBestVersionForDataLength (mode, length, errorCorrectionLevel) {
  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
      return currentVersion
    }
  }

  return undefined
}

function getReservedBitsCount (mode, version) {
  // Character count indicator + mode indicator bits
  return Mode.getCharCountIndicator(mode, version) + 4
}

function getTotalBitsFromDataArray (segments, version) {
  let totalBits = 0

  segments.forEach(function (data) {
    const reservedBits = getReservedBitsCount(data.mode, version)
    totalBits += reservedBits + data.getBitsLength()
  })

  return totalBits
}

function getBestVersionForMixedData (segments, errorCorrectionLevel) {
  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
    const length = getTotalBitsFromDataArray(segments, currentVersion)
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
      return currentVersion
    }
  }

  return undefined
}

/**
 * Returns version number from a value.
 * If value is not a valid version, returns defaultValue
 *
 * @param  {Number|String} value        QR Code version
 * @param  {Number}        defaultValue Fallback value
 * @return {Number}                     QR Code version number
 */
exports.from = function from (value, defaultValue) {
  if (VersionCheck.isValid(value)) {
    return parseInt(value, 10)
  }

  return defaultValue
}

/**
 * Returns how much data can be stored with the specified QR code version
 * and error correction level
 *
 * @param  {Number} version              QR Code version (1-40)
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Mode}   mode                 Data mode
 * @return {Number}                      Quantity of storable data
 */
exports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {
  if (!VersionCheck.isValid(version)) {
    throw new Error('Invalid QR Code version')
  }

  // Use Byte mode as default
  if (typeof mode === 'undefined') mode = Mode.BYTE

  // Total codewords for this QR code version (Data + Error correction)
  const totalCodewords = Utils.getSymbolTotalCodewords(version)

  // Total number of error correction codewords
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)

  // Total number of data codewords
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8

  if (mode === Mode.MIXED) return dataTotalCodewordsBits

  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)

  // Return max number of storable codewords
  switch (mode) {
    case Mode.NUMERIC:
      return Math.floor((usableBits / 10) * 3)

    case Mode.ALPHANUMERIC:
      return Math.floor((usableBits / 11) * 2)

    case Mode.KANJI:
      return Math.floor(usableBits / 13)

    case Mode.BYTE:
    default:
      return Math.floor(usableBits / 8)
  }
}

/**
 * Returns the minimum version needed to contain the amount of data
 *
 * @param  {Segment} data                    Segment of data
 * @param  {Number} [errorCorrectionLevel=H] Error correction level
 * @param  {Mode} mode                       Data mode
 * @return {Number}                          QR Code version
 */
exports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {
  let seg

  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)

  if (Array.isArray(data)) {
    if (data.length > 1) {
      return getBestVersionForMixedData(data, ecl)
    }

    if (data.length === 0) {
      return 1
    }

    seg = data[0]
  } else {
    seg = data
  }

  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
}

/**
 * Returns version information with relative error correction bits
 *
 * The version information is included in QR Code symbols of version 7 or larger.
 * It consists of an 18-bit sequence containing 6 data bits,
 * with 12 error correction bits calculated using the (18, 6) Golay code.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Encoded version info bits
 */
exports.getEncodedBits = function getEncodedBits (version) {
  if (!VersionCheck.isValid(version) || version < 7) {
    throw new Error('Invalid QR Code version')
  }

  let d = version << 12

  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))
  }

  return (version << 12) | d
}

},{"./error-correction-code":119,"./error-correction-level":120,"./mode":126,"./utils":133,"./version-check":134}],136:[function(require,module,exports){
const Utils = require('./utils')

function clearCanvas (ctx, canvas, size) {
  ctx.clearRect(0, 0, canvas.width, canvas.height)

  if (!canvas.style) canvas.style = {}
  canvas.height = size
  canvas.width = size
  canvas.style.height = size + 'px'
  canvas.style.width = size + 'px'
}

function getCanvasElement () {
  try {
    return document.createElement('canvas')
  } catch (e) {
    throw new Error('You need to specify a canvas element')
  }
}

exports.render = function render (qrData, canvas, options) {
  let opts = options
  let canvasEl = canvas

  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas
    canvas = undefined
  }

  if (!canvas) {
    canvasEl = getCanvasElement()
  }

  opts = Utils.getOptions(opts)
  const size = Utils.getImageWidth(qrData.modules.size, opts)

  const ctx = canvasEl.getContext('2d')
  const image = ctx.createImageData(size, size)
  Utils.qrToImageData(image.data, qrData, opts)

  clearCanvas(ctx, canvasEl, size)
  ctx.putImageData(image, 0, 0)

  return canvasEl
}

exports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {
  let opts = options

  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas
    canvas = undefined
  }

  if (!opts) opts = {}

  const canvasEl = exports.render(qrData, canvas, opts)

  const type = opts.type || 'image/png'
  const rendererOpts = opts.rendererOpts || {}

  return canvasEl.toDataURL(type, rendererOpts.quality)
}

},{"./utils":138}],137:[function(require,module,exports){
const Utils = require('./utils')

function getColorAttrib (color, attrib) {
  const alpha = color.a / 255
  const str = attrib + '="' + color.hex + '"'

  return alpha < 1
    ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
    : str
}

function svgCmd (cmd, x, y) {
  let str = cmd + x
  if (typeof y !== 'undefined') str += ' ' + y

  return str
}

function qrToPath (data, size, margin) {
  let path = ''
  let moveBy = 0
  let newRow = false
  let lineLength = 0

  for (let i = 0; i < data.length; i++) {
    const col = Math.floor(i % size)
    const row = Math.floor(i / size)

    if (!col && !newRow) newRow = true

    if (data[i]) {
      lineLength++

      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow
          ? svgCmd('M', col + margin, 0.5 + row + margin)
          : svgCmd('m', moveBy, 0)

        moveBy = 0
        newRow = false
      }

      if (!(col + 1 < size && data[i + 1])) {
        path += svgCmd('h', lineLength)
        lineLength = 0
      }
    } else {
      moveBy++
    }
  }

  return path
}

exports.render = function render (qrData, options, cb) {
  const opts = Utils.getOptions(options)
  const size = qrData.modules.size
  const data = qrData.modules.data
  const qrcodesize = size + opts.margin * 2

  const bg = !opts.color.light.a
    ? ''
    : '<path ' + getColorAttrib(opts.color.light, 'fill') +
      ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>'

  const path =
    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
    ' d="' + qrToPath(data, size, opts.margin) + '"/>'

  const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"'

  const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" '

  const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n'

  if (typeof cb === 'function') {
    cb(null, svgTag)
  }

  return svgTag
}

},{"./utils":138}],138:[function(require,module,exports){
function hex2rgba (hex) {
  if (typeof hex === 'number') {
    hex = hex.toString()
  }

  if (typeof hex !== 'string') {
    throw new Error('Color should be defined as hex string')
  }

  let hexCode = hex.slice().replace('#', '').split('')
  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
    throw new Error('Invalid hex color: ' + hex)
  }

  // Convert from short to long form (fff -> ffffff)
  if (hexCode.length === 3 || hexCode.length === 4) {
    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
      return [c, c]
    }))
  }

  // Add default alpha value
  if (hexCode.length === 6) hexCode.push('F', 'F')

  const hexValue = parseInt(hexCode.join(''), 16)

  return {
    r: (hexValue >> 24) & 255,
    g: (hexValue >> 16) & 255,
    b: (hexValue >> 8) & 255,
    a: hexValue & 255,
    hex: '#' + hexCode.slice(0, 6).join('')
  }
}

exports.getOptions = function getOptions (options) {
  if (!options) options = {}
  if (!options.color) options.color = {}

  const margin = typeof options.margin === 'undefined' ||
    options.margin === null ||
    options.margin < 0
    ? 4
    : options.margin

  const width = options.width && options.width >= 21 ? options.width : undefined
  const scale = options.scale || 4

  return {
    width: width,
    scale: width ? 4 : scale,
    margin: margin,
    color: {
      dark: hex2rgba(options.color.dark || '#000000ff'),
      light: hex2rgba(options.color.light || '#ffffffff')
    },
    type: options.type,
    rendererOpts: options.rendererOpts || {}
  }
}

exports.getScale = function getScale (qrSize, opts) {
  return opts.width && opts.width >= qrSize + opts.margin * 2
    ? opts.width / (qrSize + opts.margin * 2)
    : opts.scale
}

exports.getImageWidth = function getImageWidth (qrSize, opts) {
  const scale = exports.getScale(qrSize, opts)
  return Math.floor((qrSize + opts.margin * 2) * scale)
}

exports.qrToImageData = function qrToImageData (imgData, qr, opts) {
  const size = qr.modules.size
  const data = qr.modules.data
  const scale = exports.getScale(size, opts)
  const symbolSize = Math.floor((size + opts.margin * 2) * scale)
  const scaledMargin = opts.margin * scale
  const palette = [opts.color.light, opts.color.dark]

  for (let i = 0; i < symbolSize; i++) {
    for (let j = 0; j < symbolSize; j++) {
      let posDst = (i * symbolSize + j) * 4
      let pxColor = opts.color.light

      if (i >= scaledMargin && j >= scaledMargin &&
        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
        const iSrc = Math.floor((i - scaledMargin) / scale)
        const jSrc = Math.floor((j - scaledMargin) / scale)
        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0]
      }

      imgData[posDst++] = pxColor.r
      imgData[posDst++] = pxColor.g
      imgData[posDst++] = pxColor.b
      imgData[posDst] = pxColor.a
    }
  }
}

},{}],139:[function(require,module,exports){
"use strict";
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backoff = Backoff;
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
};

},{}],140:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

},{"./manager.js":141,"./socket.js":143,"./url.js":144,"debug":145,"engine.io-client":75,"socket.io-parser":148}],141:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
const engine_io_client_1 = require("engine.io-client");
const socket_js_1 = require("./socket.js");
const parser = __importStar(require("socket.io-parser"));
const on_js_1 = require("./on.js");
const backo2_js_1 = require("./contrib/backo2.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:manager"); // debug()
class Manager extends component_emitter_1.Emitter {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        (0, engine_io_client_1.installTimerFunctions)(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2_js_1.Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        if (!v) {
            this.skipReconnect = true;
        }
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        debug("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
            return this;
        debug("opening %s", this.uri);
        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = (0, on_js_1.on)(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        const onError = (err) => {
            debug("error");
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                this.maybeReconnectOnOpen();
            }
        };
        // emit `error`
        const errorSub = (0, on_js_1.on)(socket, "error", onError);
        if (false !== this._timeout) {
            const timeout = this._timeout;
            debug("connect attempt will timeout after %d", timeout);
            // set timer
            const timer = this.setTimeoutFn(() => {
                debug("connect attempt timed out after %d", timeout);
                openSubDestroy();
                onError(new Error("timeout"));
                socket.close();
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        debug("open");
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push((0, on_js_1.on)(socket, "ping", this.onping.bind(this)), (0, on_js_1.on)(socket, "data", this.ondata.bind(this)), (0, on_js_1.on)(socket, "error", this.onerror.bind(this)), (0, on_js_1.on)(socket, "close", this.onclose.bind(this)), 
        // @ts-ignore
        (0, on_js_1.on)(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        try {
            this.decoder.add(data);
        }
        catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        (0, engine_io_client_1.nextTick)(() => {
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        debug("error", err);
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new socket_js_1.Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        else if (this._autoConnect && !socket.active) {
            socket.connect();
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                debug("socket %s is still active, skipping close", nsp);
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        debug("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        debug("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        debug("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called when:
     *
     * - the low-level engine is closed
     * - the parser encountered a badly formatted packet
     * - all sockets are disconnected
     *
     * @private
     */
    onclose(reason, description) {
        var _a;
        debug("closed due to %s", reason);
        this.cleanup();
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug("reconnect failed");
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", delay);
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                debug("attempting reconnect");
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        debug("reconnect attempt error");
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        debug("reconnect success");
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}
exports.Manager = Manager;

},{"./contrib/backo2.js":139,"./on.js":142,"./socket.js":143,"@socket.io/component-emitter":63,"debug":145,"engine.io-client":75,"socket.io-parser":148}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.on = on;
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}

},{}],143:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const socket_io_parser_1 = require("socket.io-parser");
const on_js_1 = require("./on.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:socket"); // debug()
/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
class Socket extends component_emitter_1.Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */
        this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */
        this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */
        this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */
        this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */
        this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */
        this._queueSeq = 0;
        this.ids = 0;
        /**
         * A map containing acknowledgement handlers.
         *
         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
         *
         * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
         * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
         * - `const value = await socket.emitWithAck("test")`
         *
         * From those that don't:
         *
         * - `socket.emit("test", (value) => { ... });`
         *
         * In the first case, the handlers will be called with an error when:
         *
         * - the timeout is reached
         * - the socket gets disconnected
         *
         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
         * an acknowledgement from the server.
         *
         * @private
         */
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            (0, on_js_1.on)(io, "open", this.onopen.bind(this)),
            (0, on_js_1.on)(io, "packet", this.onpacket.bind(this)),
            (0, on_js_1.on)(io, "error", this.onerror.bind(this)),
            (0, on_js_1.on)(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
        var _a, _b, _c;
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            debug("emitting packet with ack id %d", id);
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
        const discardPacket = this.flags.volatile && !isTransportWritable;
        if (discardPacket) {
            debug("discard packet as the transport is not currently writable");
        }
        else if (isConnected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    debug("removing packet with ack id %d from the buffer", id);
                    this.sendBuffer.splice(i, 1);
                }
            }
            debug("event with ack id %d has timed out after %d ms", id, timeout);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        const fn = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, args);
        };
        fn.withError = true;
        this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            const fn = (arg1, arg2) => {
                return arg1 ? reject(arg1) : resolve(arg2);
            };
            fn.withError = true;
            args.push(fn);
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
            ack = args.pop();
        }
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({ fromQueue: true }, this.flags),
        };
        args.push((err, ...responseArgs) => {
            if (packet !== this._queue[0]) {
                // the packet has already been acknowledged
                return;
            }
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
                    this._queue.shift();
                    if (ack) {
                        ack(err);
                    }
                }
            }
            else {
                debug("packet [%d] was successfully sent", packet.id);
                this._queue.shift();
                if (ack) {
                    ack(null, ...responseArgs);
                }
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
        debug("draining queue");
        if (!this.connected || this._queue.length === 0) {
            return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
            debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
            return;
        }
        packet.pending = true;
        packet.tryCount++;
        debug("sending packet [%d] (try nÂ°%d)", packet.id, packet.tryCount);
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
        debug("transport is open - connecting");
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this._sendConnectPacket(data);
            });
        }
        else {
            this._sendConnectPacket(this.auth);
        }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
        this.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: this._pid
                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)
                : data,
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        debug("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
        this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
    _clearAcks() {
        Object.keys(this.acks).forEach((id) => {
            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
            if (!isBuffered) {
                // note: handlers that do not accept an error as first argument are ignored here
                const ack = this.acks[id];
                delete this.acks[id];
                if (ack.withError) {
                    ack.call(this, new Error("socket has been disconnected"));
                }
            }
        });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser_1.PacketType.CONNECT:
                if (packet.data && packet.data.sid) {
                    this.onconnect(packet.data.sid, packet.data.pid);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case socket_io_parser_1.PacketType.EVENT:
            case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.ACK:
            case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser_1.PacketType.CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
            this._lastOffset = args[args.length - 1];
        }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            debug("sending ack %j", args);
            self.packet({
                type: socket_io_parser_1.PacketType.ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack !== "function") {
            debug("bad ack %s", packet.id);
            return;
        }
        delete this.acks[packet.id];
        debug("calling ack %s with %j", packet.id, packet.data);
        // @ts-ignore FIXME ack is incorrectly inferred as 'never'
        if (ack.withError) {
            packet.data.unshift(null);
        }
        // @ts-ignore
        ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id, pid) {
        debug("socket connected with id %s", id);
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        debug("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
        if (this.connected) {
            debug("performing disconnect (%s)", this.nsp);
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
}
exports.Socket = Socket;

},{"./on.js":142,"@socket.io/component-emitter":63,"debug":145,"socket.io-parser":148}],144:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.url = url;
const engine_io_client_1 = require("engine.io-client");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:url"); // debug()
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        debug("parse %s", uri);
        obj = (0, engine_io_client_1.parse)(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}

},{"debug":145,"engine.io-client":75}],145:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"./common":146,"_process":111,"dup":85}],146:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"dup":86,"ms":105}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deconstructPacket = deconstructPacket;
exports.reconstructPacket = reconstructPacket;
var _isBinary = require("./is-binary.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {
    packet: pack,
    buffers: buffers
  };
}
function _deconstructPacket(data, buffers) {
  if (!data) return data;
  if ((0, _isBinary.isBinary)(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return _newData;
  }
  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments; // no longer useful
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data) return data;
  if (data && data._placeholder === true) {
    var isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num]; // appropriate buffer (should be natural order anyway)
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

},{"./is-binary.js":149}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.protocol = exports.PacketType = exports.Encoder = exports.Decoder = void 0;
var _componentEmitter = require("@socket.io/component-emitter");
var _binary = require("./binary.js");
var _isBinary = require("./is-binary.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * These strings must not be used as event names, as they have a special meaning.
 */
var RESERVED_EVENTS = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener" // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
var protocol = exports.protocol = 5;
var PacketType;
(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (exports.PacketType = PacketType = {}));
/**
 * A socket.io Encoder instance
 */
var Encoder = exports.Encoder = /*#__PURE__*/function () {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  function Encoder(replacer) {
    _classCallCheck(this, Encoder);
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  return _createClass(Encoder, [{
    key: "encode",
    value: function encode(obj) {
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if ((0, _isBinary.hasBinary)(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type;
      // attachments if we have them
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      // if we have a namespace other than `/`
      // we append it followed by a comma `,`
      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      }
      // immediately followed by the id
      if (null != obj.id) {
        str += obj.id;
      }
      // json data
      if (null != obj.data) {
        str += JSON.stringify(obj.data, this.replacer);
      }
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = (0, _binary.deconstructPacket)(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list
      return buffers; // write all the buffers
    }
  }]);
}(); // see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
var Decoder = exports.Decoder = /*#__PURE__*/function (_Emitter) {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  function Decoder(reviver) {
    var _this;
    _classCallCheck(this, Decoder);
    _this = _callSuper(this, Decoder);
    _this.reviver = reviver;
    return _this;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  _inherits(Decoder, _Emitter);
  return _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        var isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet);
          // no attachments, labeled binary but no binary data to follow
          if (packet.attachments === 0) {
            _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
          }
        } else {
          // non-binary full packet
          _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
        }
      } else if ((0, _isBinary.isBinary)(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            // received final buffer
            this.reconstructor = null;
            _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0;
      // look up type
      var p = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      }
      // look up attachments if type binary
      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {}
        var buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      // look up namespace (if any)
      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }
        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      }
      // look up id
      var next = str.charAt(i + 1);
      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;
        while (++i) {
          var _c = str.charAt(i);
          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }
          if (i === str.length) break;
        }
        p.id = Number(str.substring(_start2, i + 1));
      }
      // look up json data
      if (str.charAt(++i)) {
        var payload = this.tryParse(str.substr(i));
        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      return p;
    }
  }, {
    key: "tryParse",
    value: function tryParse(str) {
      try {
        return JSON.parse(str, this.reviver);
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "destroy",
    value:
    /**
     * Deallocates a parser's resources
     */
    function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return isObject(payload);
        case PacketType.DISCONNECT:
          return payload === undefined;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || isObject(payload);
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);
}(_componentEmitter.Emitter);
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  return _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = (0, _binary.reconstructPacket)(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);
}();

},{"./binary.js":147,"./is-binary.js":149,"@socket.io/component-emitter":63}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasBinary = hasBinary;
exports.isBinary = isBinary;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

},{}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _objectHash = _interopRequireDefault(require("object-hash"));
var _events2 = require("events");
var _tinyEssentials = require("tiny-essentials");
var _jsBase = require("js-base64");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @typedef {Object} SessionDataContent
 * @property {AIContentData[]} data
 * @property {string[]} ids
 * @property {{ data: Array<TokenCount>; [key: string]: * }} tokens
 * @property {{ data: Array<string>; [key: string]: * }} hash
 * @property {string|null} systemInstruction
 * @property {{ name: string; type: string; }[]} [customList]
 * @property {string|null} model
 *
 */
/**
 * @typedef {Record<string, any> & SessionDataContent} SessionData
 */
/**
 * @typedef {Object} AiModel
 * @property {any} _response
 * @property {number} index
 * @property {string|null} name
 * @property {string|null} id
 * @property {string|null} displayName
 * @property {string|null} version
 * @property {string|null} description
 * @property {number|null} inputTokenLimit
 * @property {number|null} outputTokenLimit
 * @property {number|null} temperature
 * @property {number|null} maxTemperature
 * @property {number|null} topP
 * @property {number|null} topK
 * @property {string[]} [supportedGenerationMethods]
 */
/**
 * @typedef {Object} AiCategory
 * @property {string} category
 * @property {string} displayName
 * @property {number} index
 * @property {AiModel[]} data
 */
/**
 * Tiny AI Server Communication API
 * -----------------------------
 * This class is responsible for managing AI session data, including models, history, and content generation.
 * The script is designed to interact with the AI API, providing a complete structure for creating user interfaces (UI) or AI-powered chatbots.
 * It implements a session management system to help handle multiple different bots.
 * However, this script is not optimized for efficiently handling multiple AI instances simultaneously, which may be required for high-load scenarios or when running several AI instances at once.
 *
 * **Note**: This script does not automatically manage or track the token count for messages. Developers need to implement their own logic to monitor and manage token usage if necessary.
 *
 * Documentation written with the assistance of OpenAI's ChatGPT.
 */
var _events = /*#__PURE__*/new WeakMap();
var _sysEvents = /*#__PURE__*/new WeakMap();
var _sysEventsUsed = /*#__PURE__*/new WeakMap();
var _TinyAiInstance_brand = /*#__PURE__*/new WeakSet();
var _apiKey = /*#__PURE__*/new WeakMap();
var _getModels = /*#__PURE__*/new WeakMap();
var _countTokens = /*#__PURE__*/new WeakMap();
var _genContentApi = /*#__PURE__*/new WeakMap();
var _selectedHistory = /*#__PURE__*/new WeakMap();
var _partTypes = /*#__PURE__*/new WeakMap();
var _insertIntoHistory = /*#__PURE__*/new WeakMap();
var TinyAiInstance = /*#__PURE__*/function () {
  /**
   * Creates an instance of the TinyAiInstance class.
   * Initializes internal variables, sets up initial configurations for handling AI models,
   * session history, and content generation, with the option to use a single or multiple instances.
   *
   * @param {boolean} [isSingle] - If true, configures the instance to handle a single session only.
   */
  function TinyAiInstance() {
    var isSingle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    _classCallCheck(this, TinyAiInstance);
    /**
     * Emits an event with optional arguments to all system emit.
     * @param {string | symbol} event - The name of the event to emit.
     * @param {...any} args - Arguments passed to event listeners.
     */
    _classPrivateMethodInitSpec(this, _TinyAiInstance_brand);
    /**
     * Important instance used to make event emitter.
     * @type {EventEmitter}
     */
    _classPrivateFieldInitSpec(this, _events, new _events2.EventEmitter());
    /**
     * Important instance used to make system event emitter.
     * @type {EventEmitter}
     */
    _classPrivateFieldInitSpec(this, _sysEvents, new _events2.EventEmitter());
    _classPrivateFieldInitSpec(this, _sysEventsUsed, false);
    /**
     * @typedef {Object} AIContentData
     * @property {Array<Record<'text' | 'inlineData', string | { mime_type: string, data: string } | null>>} parts
     * @property {string|undefined} [role]
     * @property {string|number|undefined} [finishReason]
     */
    /**
     * @typedef {{ count: number|null, hide?: boolean }} TokenCount
     */
    /** @type {string|null} */
    _classPrivateFieldInitSpec(this, _apiKey, null);
    /** @type {function|null} */_classPrivateFieldInitSpec(this, _getModels, null);
    /** @type {function|null} */_classPrivateFieldInitSpec(this, _countTokens, null);
    /** @type {function|null} */_classPrivateFieldInitSpec(this, _genContentApi, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _selectedHistory, null);
    /** @type {Record<string, function>} */_classPrivateFieldInitSpec(this, _partTypes, {});
    /** @type {function} */_classPrivateFieldInitSpec(this, _insertIntoHistory, function () {});
    /** @type {Record<string|number, string|{ text: string, hide?: boolean }>} */
    _defineProperty(this, "_errorCode", {});
    /** @type {string|null} */
    _defineProperty(this, "_nextModelsPageToken", null);
    /** @type {(AiModel|AiCategory)[]} */
    _defineProperty(this, "models", []);
    /** @type {Object.<string, SessionData>} */
    _defineProperty(this, "history", {});
    _defineProperty(this, "_isSingle", false);
    this._isSingle = isSingle;
    /**
     * Updates an existing entry in the session history.
     *
     * @param {string} id - The session identifier.
     * @param {Record<string, any>} data - Data fields to update within the session.
     * @returns {boolean} True if the update succeeded, false otherwise.
     */
    _classPrivateFieldSet(_insertIntoHistory, this, function (id, data) {
      if (typeof id === 'string' && this.history[id]) {
        for (var where in data) {
          this.history[id][where] = data[where];
        }
        return true;
      }
      return false;
    });
    /**
     * Parsers for different part types.
     * @type {{ text: (input: any) => string|null, inlineData: (input: any) => { mime_type: string, data: string }|null }}
     */
    _classPrivateFieldSet(_partTypes, this, {
      text: function text(/** @type {string} */_text) {
        return typeof _text === 'string' ? _text : null;
      },
      inlineData: function inlineData(/** @type {{ mime_type: string; data: string; }} */data) {
        if (typeof data.mime_type === 'string' && typeof data.data === 'string') return data;
        return null;
      }
    });
    // Is single instance
    if (this._isSingle) {
      this.startDataId('main', true);
      // @ts-ignore
      this.startDataId = null;
      // @ts-ignore
      this.stopDataId = null;
      // @ts-ignore
      this.selectDataId = null;
    }
  }
  /**
   * Capitalizes the first letter of the provided string.
   *
   * @param {string} str - The input string to capitalize.
   * @returns {string} The string with the first character in uppercase.
   */
  return _createClass(TinyAiInstance, [{
    key: "getSysEvents",
    value:
    /**
     * Provides access to a secure internal EventEmitter for subclass use only.
     *
     * This method exposes a dedicated EventEmitter instance intended specifically for subclasses
     * that extend the main class. It prevents subclasses from accidentally or intentionally using
     * the primary class's public event system (`emit`), which could lead to unpredictable behavior
     * or interference in the base class's event flow.
     *
     * For security and consistency, this method is designed to be accessed only once.
     * Multiple accesses are blocked to avoid leaks or misuse of the internal event bus.
     *
     * @returns {EventEmitter} A special internal EventEmitter instance for subclass use.
     * @throws {Error} If the method is called more than once.
     */
    function getSysEvents() {
      if (_classPrivateFieldGet(_sysEventsUsed, this)) throw new Error('Access denied: getSysEvents() can only be called once. ' + 'This restriction ensures subclass event isolation and prevents accidental interference ' + 'with the main class event emitter.');
      _classPrivateFieldSet(_sysEventsUsed, this, true);
      return _classPrivateFieldGet(_sysEvents, this);
    }
    /**
     * @typedef {(...args: any[]) => void} ListenerCallback
     * A generic callback function used for event listeners.
     */
    /**
     * Sets the maximum number of listeners for the internal event emitter.
     *
     * @param {number} max - The maximum number of listeners allowed.
     */
  }, {
    key: "setMaxListeners",
    value: function setMaxListeners(max) {
      _classPrivateFieldGet(_events, this).setMaxListeners(max);
    }
    /**
     * Emits an event with optional arguments.
     * @param {string | symbol} event - The name of the event to emit.
     * @param {...any} args - Arguments passed to event listeners.
     * @returns {boolean} `true` if the event had listeners, `false` otherwise.
     */
  }, {
    key: "emit",
    value: function emit(event) {
      var _classPrivateFieldGet2;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_events, this)).emit.apply(_classPrivateFieldGet2, [event].concat(args));
    }
    /**
     * Registers a listener for the specified event.
     * @param {string | symbol} event - The name of the event to listen for.
     * @param {ListenerCallback} listener - The callback function to invoke.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "on",
    value: function on(event, listener) {
      _classPrivateFieldGet(_events, this).on(event, listener);
      return this;
    }
    /**
     * Registers a one-time listener for the specified event.
     * @param {string | symbol} event - The name of the event to listen for once.
     * @param {ListenerCallback} listener - The callback function to invoke.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "once",
    value: function once(event, listener) {
      _classPrivateFieldGet(_events, this).once(event, listener);
      return this;
    }
    /**
     * Removes a listener from the specified event.
     * @param {string | symbol} event - The name of the event.
     * @param {ListenerCallback} listener - The listener to remove.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "off",
    value: function off(event, listener) {
      _classPrivateFieldGet(_events, this).off(event, listener);
      return this;
    }
    /**
     * Alias for `on`.
     * @param {string | symbol} event - The name of the event.
     * @param {ListenerCallback} listener - The callback to register.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "addListener",
    value: function addListener(event, listener) {
      _classPrivateFieldGet(_events, this).addListener(event, listener);
      return this;
    }
    /**
     * Alias for `off`.
     * @param {string | symbol} event - The name of the event.
     * @param {ListenerCallback} listener - The listener to remove.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "removeListener",
    value: function removeListener(event, listener) {
      _classPrivateFieldGet(_events, this).removeListener(event, listener);
      return this;
    }
    /**
     * Removes all listeners for a specific event, or all events if no event is specified.
     * @param {string | symbol} [event] - The name of the event. If omitted, all listeners from all events will be removed.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(event) {
      _classPrivateFieldGet(_events, this).removeAllListeners(event);
      return this;
    }
    /**
     * Returns the number of times the given `listener` is registered for the specified `event`.
     * If no `listener` is passed, returns how many listeners are registered for the `event`.
     * @param {string | symbol} eventName - The name of the event.
     * @param {Function} [listener] - Optional listener function to count.
     * @returns {number} Number of matching listeners.
     */
  }, {
    key: "listenerCount",
    value: function listenerCount(eventName, listener) {
      return _classPrivateFieldGet(_events, this).listenerCount(eventName, listener);
    }
    /**
     * Adds a listener function to the **beginning** of the listeners array for the specified event.
     * The listener is called every time the event is emitted.
     * @param {string | symbol} eventName - The event name.
     * @param {ListenerCallback} listener - The callback function.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "prependListener",
    value: function prependListener(eventName, listener) {
      _classPrivateFieldGet(_events, this).prependListener(eventName, listener);
      return this;
    }
    /**
     * Adds a **one-time** listener function to the **beginning** of the listeners array.
     * The next time the event is triggered, this listener is removed and then invoked.
     * @param {string | symbol} eventName - The event name.
     * @param {ListenerCallback} listener - The callback function.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "prependOnceListener",
    value: function prependOnceListener(eventName, listener) {
      _classPrivateFieldGet(_events, this).prependOnceListener(eventName, listener);
      return this;
    }
    /**
     * Returns an array of event names for which listeners are currently registered.
     * @returns {(string | symbol)[]} Array of event names.
     */
  }, {
    key: "eventNames",
    value: function eventNames() {
      return _classPrivateFieldGet(_events, this).eventNames();
    }
    /**
     * Gets the current maximum number of listeners allowed for any single event.
     * @returns {number} The max listener count.
     */
  }, {
    key: "getMaxListeners",
    value: function getMaxListeners() {
      return _classPrivateFieldGet(_events, this).getMaxListeners();
    }
    /**
     * Returns a copy of the listeners array for the specified event.
     * @param {string | symbol} eventName - The event name.
     * @returns {Function[]} An array of listener functions.
     */
  }, {
    key: "listeners",
    value: function listeners(eventName) {
      return _classPrivateFieldGet(_events, this).listeners(eventName);
    }
    /**
     * Returns a copy of the internal listeners array for the specified event,
     * including wrapper functions like those used by `.once()`.
     * @param {string | symbol} eventName - The event name.
     * @returns {Function[]} An array of raw listener functions.
     */
  }, {
    key: "rawListeners",
    value: function rawListeners(eventName) {
      return _classPrivateFieldGet(_events, this).rawListeners(eventName);
    }
  }, {
    key: "setCustomValue",
    value:
    /**
     * Sets a custom value in the selected session history.
     *
     * @param {string} name - The name of the custom value to set.
     * @param {*} value - The value to be assigned to the custom key.
     * @param {number} [tokenAmount] - The token amount associated with the custom value (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the custom value name is invalid (not a non-empty string) or conflicts with existing data.
     * @returns {void} This method does not return a value.
     */
    function setCustomValue(name, value, tokenAmount, id) {
      if (typeof name === 'string' && name.length > 0 && name !== 'customList') {
        // Prepare value to send
        var sendValue = _defineProperty({}, name, value);
        // This value is extremely important for the import process to identify which custom values are being used
        var selectedId = this.getId(id);
        if (selectedId && this.history[selectedId]) {
          var history = this.history[selectedId];
          if (!Array.isArray(history.customList)) history.customList = [];
          // Validate the custom value
          if (value !== null) {
            var props = history.customList.find(function (/** @type {*} */item) {
              return item.name === name;
            });
            if (!props || typeof props.type !== 'string' || typeof props.name !== 'string') {
              if (typeof history[name] === 'undefined') history.customList.push({
                name: name,
                // @ts-ignore
                type: (0, _tinyEssentials.objType)(value)
              });else throw new Error('This value name is already being used!');
            } else if (props.type !== (0, _tinyEssentials.objType)(value)) throw new Error("Invalid custom value type! ".concat(name, ": ").concat(props.type, " === ").concat((0, _tinyEssentials.objType)(value)));
          }
          // Add Tokens
          if (typeof tokenAmount === 'number') this.history[selectedId].tokens[name] = tokenAmount;
          // Send custom value into the history
          if (value !== null) {
            _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, sendValue);
            this.history[selectedId].hash[name] = (0, _objectHash["default"])(value);
          }
          // Complete
          _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, "set".concat(_assertClassBrand(_TinyAiInstance_brand, this, _capitalizeFirstLetter).call(this, name)), value, selectedId);
          return;
        }
      }
      throw new Error('Invalid custom value!');
    }
    /**
     * Resets a custom value in the selected session history.
     *
     * @param {string} name - The name of the custom value to reset.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the custom value name is invalid or does not match an existing entry.
     * @returns {void} This method does not return a value.
     */
  }, {
    key: "resetCustomValue",
    value: function resetCustomValue(name, id) {
      if (typeof name === 'string' && name.length > 0 && name !== 'customList') {
        // Prepare value to send
        var sendValue = _defineProperty({}, name, null);
        // This value is extremely important for the import process to identify which custom values are being used
        var selectedId = this.getId(id);
        if (selectedId && this.history[selectedId]) {
          var history = this.history[selectedId];
          if (!Array.isArray(history.customList)) history.customList = [];
          // Validate the custom value
          var props = history.customList.find(function (/** @type {*} */item) {
            return item.name === name;
          });
          if ((0, _tinyEssentials.isJsonObject)(props) && typeof props.type === 'string' && typeof props.name === 'string') {
            // Reset Tokens
            if (typeof this.history[selectedId].tokens[name] !== 'undefined') delete this.history[selectedId].tokens[name];
            // Reset custom value
            _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, sendValue);
            if (typeof this.history[selectedId].hash[name] !== 'undefined') delete this.history[selectedId].hash[name];
            // Complete
            _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, "set".concat(_assertClassBrand(_TinyAiInstance_brand, this, _capitalizeFirstLetter).call(this, name)), null, selectedId);
            return;
          }
        }
        throw new Error('Invalid custom value data type!');
      }
      throw new Error('Invalid custom value!');
    }
    /**
     * Completely removes a custom value from the selected session history.
     *
     * @param {string} name - The name of the custom value to erase.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the custom value name is invalid or does not exist.
     * @returns {void} This method does not return a value.
     */
  }, {
    key: "eraseCustomValue",
    value: function eraseCustomValue(name, id) {
      this.resetCustomValue(name, id);
      var history = this.getData(id);
      if (history && history.customList) {
        var index = history.customList.findIndex(function (item) {
          return item.name === name;
        });
        if (index > -1) history.customList.splice(index, 1);
        return;
      }
      throw new Error('Invalid custom value!');
    }
    /**
     * Retrieves a custom value from the selected session history.
     *
     * @param {string} name - The name of the custom value to retrieve.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {*} The value associated with the specified name, or `null` if it does not exist.
     */
  }, {
    key: "getCustomValue",
    value: function getCustomValue(name, id) {
      var history = this.getData(id);
      return history && typeof history[name] !== 'undefined' && history[name] !== null ? history[name] : null;
    }
    /**
     * Retrieves the list of custom values from the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {Array<*>} An array of custom values if available, or an empty array if no custom values exist.
     */
  }, {
    key: "getCustomValueList",
    value: function getCustomValueList(id) {
      var history = this.getData(id);
      return history && Array.isArray(history.customList) ? history.customList : [];
    }
    /**
     * Set the maximum output tokens setting for an AI session.
     *
     * @param {number} value - The maximum number of output tokens to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setMaxOutputTokens",
    value: function setMaxOutputTokens(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          maxOutputTokens: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setMaxOutputTokens', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the maximum output tokens setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The maximum output tokens value, or null if not set.
     */
  }, {
    key: "getMaxOutputTokens",
    value: function getMaxOutputTokens(id) {
      var history = this.getData(id);
      return history && typeof history.maxOutputTokens === 'number' ? history.maxOutputTokens : null;
    }
    /**
     * Set the AI temperature setting for a session.
     *
     * @param {number} value - The temperature value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setTemperature",
    value: function setTemperature(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          temperature: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setTemperature', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the AI temperature setting for a session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The temperature value, or null if not set.
     */
  }, {
    key: "getTemperature",
    value: function getTemperature(id) {
      var history = this.getData(id);
      return history && _typeof(history.temperature) ? history.temperature : null;
    }
    /**
     * Set the top-p (nucleus sampling) value in an AI session.
     *
     * @param {number} value - The top-p value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setTopP",
    value: function setTopP(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          topP: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setTopP', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the top-p (nucleus sampling) setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The top-p value, or null if not set.
     */
  }, {
    key: "getTopP",
    value: function getTopP(id) {
      var history = this.getData(id);
      return history && typeof history.topP === 'number' ? history.topP : null;
    }
    /**
     * Set the top-k setting for an AI session.
     *
     * @param {number} value - The top-k value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setTopK",
    value: function setTopK(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          topK: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setTopK', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the top-k setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The top-k value, or null if not set.
     */
  }, {
    key: "getTopK",
    value: function getTopK(id) {
      var history = this.getData(id);
      return history && typeof history.topK === 'number' ? history.topK : null;
    }
    /**
     * Set the presence penalty setting for an AI session.
     *
     * @param {number} value - The presence penalty value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setPresencePenalty",
    value: function setPresencePenalty(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          presencePenalty: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setPresencePenalty', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the presence penalty setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The presence penalty value, or null if not set.
     */
  }, {
    key: "getPresencePenalty",
    value: function getPresencePenalty(id) {
      var history = this.getData(id);
      return history && typeof history.presencePenalty === 'number' ? history.presencePenalty : null;
    }
    /**
     * Set the frequency penalty setting for an AI session.
     *
     * @param {number} value - The frequency penalty value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setFrequencyPenalty",
    value: function setFrequencyPenalty(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          frequencyPenalty: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setFrequencyPenalty', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the frequency penalty setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The frequency penalty value, or null if not set.
     */
  }, {
    key: "getFrequencyPenalty",
    value: function getFrequencyPenalty(id) {
      var history = this.getData(id);
      return history && typeof history.frequencyPenalty === 'number' ? history.frequencyPenalty : null;
    }
    /**
     * Set the setting for enabling enhanced civic answers in an AI session.
     *
     * @param {boolean} value - Whether to enable enhanced civic answers (true or false).
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setEnabledEnchancedCivicAnswers",
    value: function setEnabledEnchancedCivicAnswers(value, id) {
      if (typeof value === 'boolean') {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          enableEnhancedCivicAnswers: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setEnabledEnchancedCivicAnswers', value, selectedId);
        return;
      }
      throw new Error('Invalid boolean value!');
    }
    /**
     * Get the setting for whether enhanced civic answers are enabled in an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {boolean | null} The value indicating whether enhanced civic answers are enabled, or null if not set.
     */
  }, {
    key: "isEnabledEnchancedCivicAnswers",
    value: function isEnabledEnchancedCivicAnswers(id) {
      var history = this.getData(id);
      return history && typeof history.enableEnhancedCivicAnswers === 'boolean' ? history.enableEnhancedCivicAnswers : null;
    }
    /**
     * Set the model for an AI session.
     *
     * @param {string} data - The model to be set (must be a string).
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setModel",
    value: function setModel(data, id) {
      var model = typeof data === 'string' ? data : null;
      var selectedId = this.getId(id);
      _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
        model: model
      });
      _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setModel', model, selectedId);
    }
    /**
     * Get the model for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {string | null} The model, or null if not set.
     */
  }, {
    key: "getModel",
    value: function getModel(id) {
      var history = this.getData(id);
      return history && typeof history.model === 'string' ? history.model : null;
    }
    /**
     * Build content data for an AI session.
     *
     * @param {Array<*>} [contents] - An optional array to which the built content data will be pushed.
     * @param {Record<string, any>} item - The item containing content parts or a content object.
     * @param {string|null} [role] - The role to be associated with the content (optional).
     * @param {boolean} [rmFinishReason=false] - If true, removes the `finishReason` property from the content.
     * @returns {AIContentData|number} The constructed content data object, or array length if pushed to an array.
     */
  }, {
    key: "buildContents",
    value: function buildContents(contents) {
      var item = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var role = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var rmFinishReason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      // Content Data
      var tinyThis = this;
      /** @type {{ finishReason: string|number|undefined, parts: any[], role: string|undefined }} */
      var contentData = {
        parts: [],
        finishReason: undefined,
        role: undefined
      };
      // Role
      if (typeof role === 'string') contentData.role = role;
      /** @param {Record<string, any>} content */
      var insertPart = function insertPart(content) {
        /** @type {Record<string, function>} */
        var tinyResult = {};
        for (var valName in content) {
          if (typeof _classPrivateFieldGet(_partTypes, tinyThis)[valName] === 'function') tinyResult[valName] = _classPrivateFieldGet(_partTypes, tinyThis)[valName](content[valName]);
        }
        contentData.parts.push(tinyResult);
      };
      if (Array.isArray(item.parts)) {
        for (var index in item.parts) insertPart(item.parts[index]);
      } else if (item.content) insertPart(item.content);
      if (!rmFinishReason) if (typeof item.finishReason === 'string' || typeof item.finishReason === 'number') contentData.finishReason = item.finishReason;
      // Complete
      if (Array.isArray(contents)) return contents.push(contentData);
      return contentData;
    }
    /**
     * Set the API key for the AI session.
     *
     * @param {string} apiKey - The API key to be set.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setApiKey",
    value: function setApiKey(apiKey) {
      _classPrivateFieldSet(_apiKey, this, typeof apiKey === 'string' ? apiKey : null);
    }
    /**
     * Set the token for the next page of models in the AI session.
     *
     * @param {string} nextModelsPageToken - The token for the next models page.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "_setNextModelsPageToken",
    value: function _setNextModelsPageToken(nextModelsPageToken) {
      this._nextModelsPageToken = typeof nextModelsPageToken === 'string' ? nextModelsPageToken : null;
    }
    /**
     * Set the function to retrieve models for the AI session.
     *
     * @param {Function} getModels - The function to retrieve models.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "_setGetModels",
    value: function _setGetModels(getModels) {
      _classPrivateFieldSet(_getModels, this, typeof getModels === 'function' ? getModels : null);
    }
    /**
     * Get a list of models for the AI session.
     *
     * @param {number} [pageSize=50] - The number of models to retrieve per page. Defaults to 50.
     * @param {string|null} [pageToken=null] - The token for the next page of models, if available. Defaults to null.
     * @returns {Array<*>} The list of models retrieved.
     * @throws {Error} If no model list API function is defined.
     */
  }, {
    key: "getModels",
    value: function getModels() {
      var pageSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      var pageToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (typeof _classPrivateFieldGet(_getModels, this) === 'function') return _classPrivateFieldGet(_getModels, this).call(this, _classPrivateFieldGet(_apiKey, this), pageSize, pageToken || this._nextModelsPageToken);
      throw new Error('No model list api script defined.');
    }
    /**
     * Get the list of models for the AI session.
     *
     * @returns {(AiModel|AiCategory)[]} The list of models.
     */
  }, {
    key: "getModelsList",
    value: function getModelsList() {
      return Array.isArray(this.models) ? this.models : [];
    }
    /**
     * Get model data from the list of models.
     *
     * @param {string} id - The model data id to search for in the models list.
     * @returns {AiModel|null} The model data if found, otherwise null.
     */
  }, {
    key: "getModelData",
    value: function getModelData(id) {
      // @ts-ignore
      var model = this.models.find(function (item) {
        return item.id === id;
      });
      // @ts-ignore
      if (model) return model;else {
        for (var index in this.models) {
          // @ts-ignore
          if (this.models[index].category) {
            // @ts-ignore
            var modelCategory = this.models[index].data.find(function (item) {
              return item.id === id;
            });
            if (modelCategory) return modelCategory;
          }
        }
      }
      return null;
    }
    /**
     * Check if a model exists in the model list.
     *
     * @param {string} id - The model id to check for in the models list.
     * @returns {boolean} True if the model exists, false otherwise.
     */
  }, {
    key: "existsModel",
    value: function existsModel(id) {
      return this.getModelData(id) ? true : false;
    }
    /**
     * Insert a new model into the AI session's models list.
     * If the model already exists, it will not be inserted again.
     *
     * @param {Object} model - The model to insert.
     * @param {*} model._response - The raw response.
     * @param {number} model.index - The index position.
     * @param {string} model.id - The unique identifier for the model.
     * @param {string} [model.name] - The name of the model.
     * @param {string} [model.displayName] - The display name of the model.
     * @param {string} [model.version] - The version of the model.
     * @param {string} [model.description] - A description of the model.
     * @param {number} [model.inputTokenLimit] - The input token limit for the model.
     * @param {number} [model.outputTokenLimit] - The output token limit for the model.
     * @param {number} [model.temperature] - The temperature setting for the model.
     * @param {number} [model.maxTemperature] - The maximum temperature setting for the model.
     * @param {number} [model.topP] - The top P setting for the model.
     * @param {number} [model.topK] - The top K setting for the model.
     * @param {Array<string>} [model.supportedGenerationMethods] - The generation methods supported by the model.
     * @param {Object} [model.category] - The category of the model.
     * @param {string} model.category.id - The unique identifier for the category.
     * @param {string} model.category.displayName - The display name of the category.
     * @param {number} model.category.index - The index of the category.
     * @returns {Record<string, any>|null} The inserted model data, or null if the model already exists.
     */
  }, {
    key: "_insertNewModel",
    value: function _insertNewModel(model) {
      if (!(0, _tinyEssentials.isJsonObject)(model)) throw new Error('Model data must be a valid object.');
      // @ts-ignore
      if (this.models.findIndex(function (item) {
        return item.id === model.id;
      }) < 0) {
        /** @type {AiModel} */
        var newData = {
          _response: model._response,
          index: typeof model.index === 'number' ? model.index : 9999999,
          name: typeof model.name === 'string' ? model.name : null,
          id: typeof model.id === 'string' ? model.id : null,
          displayName: typeof model.displayName === 'string' ? model.displayName : null,
          version: typeof model.version === 'string' ? model.version : null,
          description: typeof model.description === 'string' ? model.description : null,
          inputTokenLimit: typeof model.inputTokenLimit === 'number' ? model.inputTokenLimit : null,
          outputTokenLimit: typeof model.outputTokenLimit === 'number' ? model.outputTokenLimit : null,
          temperature: typeof model.temperature === 'number' ? model.temperature : null,
          maxTemperature: typeof model.maxTemperature === 'number' ? model.maxTemperature : null,
          topP: typeof model.topP === 'number' ? model.topP : null,
          topK: typeof model.topK === 'number' ? model.topK : null
        };
        // Supported generation methods
        if (Array.isArray(model.supportedGenerationMethods)) {
          newData.supportedGenerationMethods = [];
          for (var index in model.supportedGenerationMethods) {
            if (typeof model.supportedGenerationMethods[index] === 'string') newData.supportedGenerationMethods.push(model.supportedGenerationMethods[index]);
          }
        }
        // Is category
        if (model.category && typeof model.category.id === 'string' && typeof model.category.displayName === 'string' && typeof model.category.index === 'number') {
          // Check category
          /** @type {AiCategory|null} */
          // @ts-ignore
          var category = this.models.find(function (item) {
            return item.category === model.category.id;
          });
          // Insert new category
          if (!category) {
            category = {
              category: model.category.id,
              displayName: model.category.displayName,
              index: model.category.index,
              data: []
            };
            this.models.push(category);
          }
          // Compare function that sorts objects by their `index` property.
          category.data.push(newData);
          category.data.sort(/** @param {{ index: number, [key: string]: any }} a @param {{ index: number, [key: string]: any }} b */
          function (a, b) {
            return a.index - b.index;
          });
        }
        // Normal mode
        else this.models.push(newData);
        // Sort data
        this.models.sort(function (a, b) {
          return a.index - b.index;
        });
        return newData;
      }
      return null;
    }
    /**
     * Sets a function to handle the count of tokens in the AI session.
     * If a valid function is provided, it will be used to count tokens.
     *
     * @param {Function} countTokens - The function that will handle the token count.
     * @throws {Error} Throws an error if the provided value is not a function.
     * @returns {void}
     */
  }, {
    key: "_setCountTokens",
    value: function _setCountTokens(countTokens) {
      _classPrivateFieldSet(_countTokens, this, typeof countTokens === 'function' ? countTokens : null);
    }
    /**
     * Counts the tokens based on the provided data and model, using a defined token counting function.
     * If the function to count tokens is not set, an error is thrown.
     *
     * @param {Record<string, any>} data - The data that needs to be tokenized.
     * @param {string} [model] - The model to use for counting tokens. If not provided, the default model is used.
     * @param {AbortController} [controller] - The controller that manages the process or settings for counting tokens.
     * @throws {Error} Throws an error if no token counting function is defined.
     * @returns {Record<string, any>} The count of tokens.
     */
  }, {
    key: "countTokens",
    value: function countTokens(data, model, controller) {
      if (typeof _classPrivateFieldGet(_countTokens, this) === 'function') return _classPrivateFieldGet(_countTokens, this).call(this, _classPrivateFieldGet(_apiKey, this), model || this.getModel(), controller, data);
      throw new Error('No count token api script defined.');
    }
    /**
     * @typedef {{ text: string, hide?: boolean }} ErrorCode
     */
    /**
     * Sets the error codes for the current session.
     *
     * @param {Record<string|number, string|ErrorCode>} errors - The error codes to set, typically an object containing error code definitions.
     * @returns {void}
     */
  }, {
    key: "_setErrorCodes",
    value: function _setErrorCodes(errors) {
      this._errorCode = errors;
    }
    /**
     * Get error details based on the provided error code.
     *
     * @param {string|number} code - The error code to look up.
     * @returns {ErrorCode|null} An object containing the error message, or null if no error is found.
     */
  }, {
    key: "getErrorCode",
    value: function getErrorCode(code) {
      if (this._errorCode) {
        var errData = this._errorCode[code];
        if (errData) {
          if (typeof errData === 'string') return {
            text: errData
          };else if ((0, _tinyEssentials.isJsonObject)(errData) && typeof errData.text === 'string') return errData;
        }
      }
      return null;
    }
    /**
     * Sets the content generation callback function for the AI session.
     *
     * @param {Function} callback - The callback function that handles content generation.
     * @returns {void}
     */
  }, {
    key: "_setGenContent",
    value: function _setGenContent(callback) {
      _classPrivateFieldSet(_genContentApi, this, typeof callback === 'function' ? callback : null);
    }
    /**
     * Generates content for the AI session.
     *
     * @param {Record<string, any>} data - The data for content generation.
     * @param {string} [model] - The model to be used for content generation. If not provided, the default model is used.
     * @param {AbortController} [controller] - The controller managing the content generation process.
     * @param {Function} [streamCallback] - The callback function for streaming content (optional).
     * @returns {Record<string, any>} The generated content returned by the API.
     * @throws {Error} If no content generator API script is defined.
     */
  }, {
    key: "genContent",
    value: function genContent(data, model, controller, streamCallback) {
      if (typeof _classPrivateFieldGet(_genContentApi, this) === 'function') return _classPrivateFieldGet(_genContentApi, this).call(this, _classPrivateFieldGet(_apiKey, this), typeof streamCallback === 'function' ? true : false, data, model || this.getModel(), streamCallback, controller);
      throw new Error('No content generator api script defined.');
    }
    /**
     * Select a session history ID to set as the active session.
     * If `null` is passed, it deselects the current session ID.
     *
     * @param {string|null} id - The session history ID to select, or `null` to deselect the current session.
     * @returns {boolean} `true` if the session ID was successfully selected or deselected, `false` if the ID does not exist in history.
     */
  }, {
    key: "selectDataId",
    value: function selectDataId(id) {
      if (id !== null) {
        if (this.history[id]) {
          _classPrivateFieldSet(_selectedHistory, this, id);
          _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'selectDataId', id);
          return true;
        }
        return false;
      }
      _classPrivateFieldSet(_selectedHistory, this, null);
      _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'selectDataId', null);
      return true;
    }
    /**
     * Get the currently selected session history ID.
     * If no ID is provided, it returns the default selected session history ID.
     *
     * @param {string} [id] - The session history ID to retrieve. If not provided, it uses the default selected ID.
     * @returns {string|null} The selected session history ID, or `null` if no history ID is selected.
     */
  }, {
    key: "getId",
    value: function getId(id) {
      var result = id && !this._isSingle ? id : _classPrivateFieldGet(_selectedHistory, this);
      if (typeof result === 'string') return result;
      return null;
    }
    /**
     * Get the data associated with a specific session history ID.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {SessionData|null} The data associated with the session ID, or `null` if no data exists for that ID.
     */
  }, {
    key: "getData",
    value: function getData(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) return this.history[selectedId];
      return null;
    }
    /**
     * Calculates the total number of tokens used for messages in the session history.
     *
     * This method iterates over the `tokens` array in the session history and sums the `count` of tokens
     * from each message, returning the total sum. If no valid session history is found or if token data is
     * missing, it will return `null`.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {number|null} The total number of tokens used in the session history, or `null` if no data is available.
     */
  }, {
    key: "getTotalTokens",
    value: function getTotalTokens(id) {
      var history = this.getData(id);
      if (history) {
        var result = 0;
        for (var msgIndex in history.tokens.data) {
          if (typeof history.tokens.data[msgIndex].count === 'number') result += history.tokens.data[msgIndex].count;
        }
        for (var item in history.tokens) {
          if (typeof history.tokens[item] === 'number') {
            result += history.tokens[item];
          }
        }
        return result;
      }
      return null;
    }
    /**
     * Retrieves the token data for a specific message in the session history by its index.
     *
     * **Note**: This method does not manage the token count automatically. It assumes that token data has been added
     * to the history using the `addData` method.
     *
     * @param {number} msgIndex - The index of the message in the session history.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {TokenCount|null} The token data associated with the message at the specified index, or `null` if the data is not found.
     */
  }, {
    key: "getMsgTokensByIndex",
    value: function getMsgTokensByIndex(msgIndex, id) {
      var history = this.getData(id);
      if (history) {
        var existsIndex = this.indexExists(msgIndex, id);
        if (existsIndex) return history.tokens.data[msgIndex];
      }
      return null;
    }
    /**
     * Retrieves the token data for a specific message in the session history by its message ID.
     *
     * **Note**: This method does not manage the token count automatically. It assumes that token data has been added
     * to the history using the `addData` method.
     *
     * @param {string} msgId - The unique ID of the message in the session history.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {TokenCount|null} The token data associated with the message with the given ID, or `null` if the message is not found.
     */
  }, {
    key: "getMsgTokensById",
    value: function getMsgTokensById(msgId, id) {
      var history = this.getData(id);
      if (history) {
        var msgIndex = this.getIndexOfId(msgId);
        if (msgIndex > -1) return history.tokens.data[msgIndex];
      }
      return null;
    }
    /**
     * Retrieves the hash of a message at a specified index in the selected session history.
     *
     * @param {number} msgIndex - The index of the message whose hash is being retrieved.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The hash value of the message at the specified index, or null if the index is invalid or does not exist.
     */
  }, {
    key: "getMsgHashByIndex",
    value: function getMsgHashByIndex(msgIndex, id) {
      var history = this.getData(id);
      if (history) {
        var existsIndex = this.indexExists(msgIndex, id);
        if (existsIndex) return history.hash.data[msgIndex];
      }
      return null;
    }
    /**
     * Retrieves the hash of a message based on its ID from the selected session history.
     *
     * @param {string} msgId - The ID of the message whose hash is being retrieved.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The hash value of the message with the specified ID, or null if the message ID is invalid or does not exist.
     */
  }, {
    key: "getMsgHashById",
    value: function getMsgHashById(msgId, id) {
      var history = this.getData(id);
      if (history) {
        var msgIndex = this.getIndexOfId(msgId);
        if (msgIndex > -1) return history.hash.data[msgIndex];
      }
      return null;
    }
    /**
     * Checks if a specific index exists in the session history.
     *
     * **Note**: This method assumes that the history data is available and that the `getMsgByIndex` method is used
     * to retrieve the index. If the `getMsgByIndex` method returns a valid index, this method will return `true`.
     *
     * @param {number} index - The index to check for existence in the session history.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {boolean} `true` if the index exists, otherwise `false`.
     */
  }, {
    key: "indexExists",
    value: function indexExists(index, id) {
      return this.getMsgByIndex(index, id) ? true : false;
    }
    /**
     * Retrieve a specific data entry by its index from the session history.
     *
     * @param {number} index - The index of the data entry to retrieve.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {AIContentData|null} The data entry at the specified index, or `null` if the index is out of bounds or no data exists for the given session ID.
     */
  }, {
    key: "getMsgByIndex",
    value: function getMsgByIndex(index, id) {
      var history = this.getData(id);
      if (history && history.data[index]) return history.data[index];
      return null;
    }
    /**
     * Retrieves a specific message by its ID from the session history.
     *
     * @param {string} msgId - The ID of the message to retrieve.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {AIContentData|null} The message data associated with the given ID, or `null` if the message ID is invalid or does not exist.
     */
  }, {
    key: "getMsgById",
    value: function getMsgById(msgId, id) {
      var history = this.getData(id);
      if (history) {
        var index = this.getIndexOfId(msgId);
        if (history.data[index]) return history.data[index];
      }
      return null;
    }
    /**
     * Retrieve the index of a specific message ID in the session history.
     *
     * @param {string} msgId - The message ID to search for.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {number} The index of the message ID in the session history, or `-1` if not found.
     */
  }, {
    key: "getIndexOfId",
    value: function getIndexOfId(msgId, id) {
      var history = this.getData(id);
      if (history) return history.ids.indexOf(msgId);
      return -1;
    }
    /**
     * Retrieve the message ID at a specific index in the session history.
     *
     * @param {number} index - The index of the data to retrieve.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|number} The message ID at the specified index, or `-1` if the index is out of bounds or not found.
     */
  }, {
    key: "getIdByIndex",
    value: function getIdByIndex(index, id) {
      var history = this.getData(id);
      if (history) return history.data[index] ? history.ids[index] : -1;
      return -1;
    }
    /**
     * Delete a specific entry from the session history at the given index.
     *
     * @param {number} index - The index of the entry to delete.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {boolean} `true` if the entry was successfully deleted, `false` if the index is invalid or the entry does not exist.
     */
  }, {
    key: "deleteIndex",
    value: function deleteIndex(index, id) {
      var history = this.getData(id);
      if (history && history.data[index]) {
        var msgId = this.getIdByIndex(index);
        history.data.splice(index, 1);
        history.ids.splice(index, 1);
        history.hash.data.splice(index, 1);
        history.tokens.data.splice(index, 1);
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'deleteIndex', index, msgId, this.getId(id));
        return true;
      }
      return false;
    }
    /**
     * Replaces an entry at the specified index in the session history with new data.
     *
     * @param {number} index - The index of the entry to replace.
     * @param {AIContentData} [data] - The new data to replace the existing entry (optional).
     * @param {TokenCount} [tokens] - The token count associated with the new entry (optional).
     * @param {string} [id] - The session ID (optional). If omitted, the currently selected session history ID will be used.
     * @returns {boolean} `true` if the entry was successfully replaced, `false` if the index is invalid or the entry does not exist.
     */
  }, {
    key: "replaceIndex",
    value: function replaceIndex(index, data, tokens, id) {
      var history = this.getData(id);
      if (history && history.data[index] && (data || tokens)) {
        var hash = null;
        if (data) {
          hash = (0, _objectHash["default"])(data);
          history.data[index] = data;
          history.hash.data[index] = hash;
        }
        if (tokens) history.tokens.data[index] = tokens;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'replaceIndex', index, data, tokens, hash, this.getId(id));
        return true;
      }
      return false;
    }
    /**
     * Retrieve the index of the last entry in the session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {number} The index of the last entry in the session history, or `-1` if the history is empty or invalid.
     */
  }, {
    key: "getLastIndex",
    value: function getLastIndex(id) {
      var history = this.getData(id);
      if (history && history.data[history.data.length - 1]) return history.data.length - 1;
      return -1;
    }
    /**
     * Retrieve the data of the last entry in the session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {AIContentData|null} The data of the last entry in the session history, or `null` if the history is empty or invalid.
     */
  }, {
    key: "getLastIndexData",
    value: function getLastIndexData(id) {
      var history = this.getData(id);
      if (history && history.data[history.data.length - 1]) return history.data[history.data.length - 1];
      return null;
    }
    /**
     * Check if the session history has at least one entry.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {boolean} `true` if the session history has at least one entry, `false` otherwise.
     */
  }, {
    key: "existsFirstIndex",
    value: function existsFirstIndex(id) {
      var history = this.getData(id);
      if (history && history.data[0]) return true;
      return false;
    }
    /**
     * Retrieve the first entry in the session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {AIContentData|null} The first entry of the session history, or `null` if no entry exists.
     */
  }, {
    key: "getFirstIndexData",
    value: function getFirstIndexData(id) {
      var history = this.getData(id);
      if (history && history.data[0]) return history.data[0];
      return null;
    }
    /**
     * Adds new data to the selected session history.
     * If no session ID is provided, the currently selected session history ID will be used.
     *
     * **Note**: The `tokenData` parameter is optional and can be used to track token-related data associated with the new entry.
     * This may include token counts, but this script does not manage token counting automatically. Developers must implement token management separately if necessary.
     *
     * @param {AIContentData} data - The data to be added to the session history.
     * @param {TokenCount} [tokenData={count: null}] - Optional token-related data to be associated with the new entry. Defaults to `{count: null}`.
     * @param {string} [id] - The session history ID. If omitted, the currently selected session ID will be used.
     * @returns {number} The new ID of the added data entry.
     * @throws {Error} If the provided session ID is invalid or the session ID does not exist in history.
     */
  }, {
    key: "addData",
    value: function addData(data) {
      var tokenData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        count: null
      };
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        if (typeof this.history[selectedId].nextId !== 'number') this.history[selectedId].nextId = 0;
        var newId = this.history[selectedId].nextId;
        this.history[selectedId].nextId++;
        var hash = (0, _objectHash["default"])(data);
        var tokenContent = (0, _tinyEssentials.isJsonObject)(tokenData) ? tokenData : {
          count: typeof tokenData === 'number' ? tokenData : null
        };
        this.history[selectedId].data.push(data);
        this.history[selectedId].tokens.data.push(tokenContent);
        this.history[selectedId].ids.push(newId);
        this.history[selectedId].hash.data.push(hash);
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'addData', newId, data, tokenContent, hash, selectedId);
        return newId;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Sets a prompt for the selected session history.
     *
     * @param {string} [promptData] - The prompt to be set for the session.
     * @param {number} [tokenAmount] - The number of tokens associated with the prompt (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the provided session ID is invalid or the prompt data is not a string.
     */
  }, {
    key: "setPrompt",
    value: function setPrompt(promptData, tokenAmount, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        if (typeof promptData === 'string') {
          var hash = (0, _objectHash["default"])(promptData);
          this.history[selectedId].prompt = promptData;
          this.history[selectedId].hash.prompt = hash;
        }
        if (typeof tokenAmount === 'number') this.history[selectedId].tokens.prompt = tokenAmount;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setPrompt', promptData, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Retrieves the prompt of the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The prompt for the session if available, otherwise null.
     */
  }, {
    key: "getPrompt",
    value: function getPrompt(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].prompt === 'string' && this.history[selectedId].prompt.length > 0) {
        return this.history[selectedId].prompt;
      }
      return null;
    }
    /**
     * Sets the first dialogue for the selected session history.
     *
     * @param {string} [dialogue] - The dialogue to set as the first dialogue.
     * @param {number} [tokenAmount] - The number of tokens associated with the dialogue (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} Throws an error if the session ID is invalid or the dialogue is not a string.
     * @returns {void}
     */
  }, {
    key: "setFirstDialogue",
    value: function setFirstDialogue(dialogue, tokenAmount, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        if (typeof dialogue === 'string') {
          var hash = (0, _objectHash["default"])(dialogue);
          this.history[selectedId].firstDialogue = dialogue;
          this.history[selectedId].hash.firstDialogue = hash;
        }
        if (typeof tokenAmount === 'number') this.history[selectedId].tokens.firstDialogue = tokenAmount;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setFirstDialogue', dialogue, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Retrieves the first dialogue from the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The first dialogue if it exists and is a non-empty string, or null if no first dialogue is set.
     */
  }, {
    key: "getFirstDialogue",
    value: function getFirstDialogue(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].firstDialogue === 'string' && this.history[selectedId].firstDialogue.length > 0) {
        return this.history[selectedId].firstDialogue;
      }
      return null;
    }
    /**
     * Sets file data for the selected session history.
     *
     * @param {string} [mime] - The MIME type of the file (e.g., 'text/plain', 'application/pdf').
     * @param {string} [data] - The file content, either as a string or base64-encoded.
     * @param {boolean} [isBase64=false] - A flag indicating whether the `data` is already base64-encoded. Defaults to false.
     * @param {number} [tokenAmount] - The token count associated with the file data (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the session ID is invalid or data/mime is not a string.
     * @returns {void}
     */
  }, {
    key: "setFileData",
    value: function setFileData(mime, data) {
      var isBase64 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tokenAmount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      var id = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        var hash;
        if (typeof data === 'string' && typeof mime === 'string') {
          this.history[selectedId].file = {
            mime: mime,
            data: data,
            base64: !isBase64 ? (0, _jsBase.encode)(data) : data
          };
          hash = (0, _objectHash["default"])(this.history[selectedId].file);
          this.history[selectedId].hash.file = hash;
        }
        if (typeof tokenAmount === 'number') this.history[selectedId].tokens.file = tokenAmount;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setFileData', this.history[selectedId].file, hash, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Removes file data from the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the session history ID is invalid.
     * @returns {void} This method does not return a value.
     */
  }, {
    key: "removeFileData",
    value: function removeFileData(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        delete this.history[selectedId].file;
        delete this.history[selectedId].hash.file;
        delete this.history[selectedId].tokens.file;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setFileData', null, null, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Retrieves file data from the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {{data: string, mime: string}|null} The file data, including MIME type and encoded content, or null if no file data is found.
     * @throws {Error} If no valid session history ID is found.
     */
  }, {
    key: "getFileData",
    value: function getFileData(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && this.history[selectedId].file && typeof this.history[selectedId].file.data === 'string' && typeof this.history[selectedId].file.mime === 'string') {
        return this.history[selectedId].file;
      }
      return null;
    }
    /**
     * Sets a system instruction for the selected session history.
     *
     * @param {string} [data] - The system instruction to set.
     * @param {number} [tokenAmount] - The token count associated with the system instruction (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the session history ID is invalid or the provided data is not a string.
     * @returns {void}
     */
  }, {
    key: "setSystemInstruction",
    value: function setSystemInstruction(data, tokenAmount, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        if (typeof data === 'string') {
          var hash = (0, _objectHash["default"])(data);
          this.history[selectedId].systemInstruction = data;
          this.history[selectedId].hash.systemInstruction = hash;
        }
        if (typeof tokenAmount === 'number') this.history[selectedId].tokens.systemInstruction = tokenAmount;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setSystemInstruction', data, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Retrieves the system instruction for the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The system instruction for the selected session, or `null` if no instruction is set.
     */
  }, {
    key: "getSystemInstruction",
    value: function getSystemInstruction(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].systemInstruction === 'string') {
        return this.history[selectedId].systemInstruction;
      }
      return null;
    }
    /**
     * Retrieves the token count for a specific category within the selected session history.
     *
     * @param {string} where - The category from which to retrieve the token count (e.g., 'prompt', 'file', 'systemInstruction').
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {number|null} The token count if available, otherwise null.
     */
  }, {
    key: "getTokens",
    value: function getTokens(where, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].tokens[where] === 'number') return this.history[selectedId].tokens[where];
      return null;
    }
    /**
     * Retrieves the hash value for a specific item in the selected session history.
     *
     * @param {string} where - The key representing the item whose hash value is being retrieved (e.g., 'prompt', 'file', 'systemInstruction').
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The hash value of the specified item, or null if the item does not exist.
     */
  }, {
    key: "getHash",
    value: function getHash(where, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].hash[where] === 'string') return this.history[selectedId].hash[where];
      return null;
    }
    /**
     * Starts a new data session with the given session ID.
     *
     * @param {string} id - The session ID for the new data session.
     * @param {boolean} [selected=false] - A flag to indicate whether this session should be selected as the active session.
     * @returns {SessionData} The newly created session data, which includes an empty data array, an empty IDs array, and null values for system instruction and model.
     */
  }, {
    key: "startDataId",
    value: function startDataId(id) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.history[id] = {
        data: [],
        ids: [],
        tokens: {
          data: []
        },
        hash: {
          data: []
        },
        systemInstruction: null,
        model: null
      };
      if (selected) this.selectDataId(id);
      _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'startDataId', this.history[id], id, selected ? true : false);
      return this.history[id];
    }
    /**
     * Stop the data session associated with the provided ID.
     * This will remove the session data from history and reset the selected session ID if necessary.
     *
     * @param {string} id - The session history ID to stop and remove from history.
     * @returns {boolean} `true` if the session ID was found and successfully stopped, `false` otherwise.
     */
  }, {
    key: "stopDataId",
    value: function stopDataId(id) {
      if (this.history[id]) {
        delete this.history[id];
        if (this.getId() === id) this.selectDataId(null);
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'stopDataId', id);
        return true;
      }
      return false;
    }
    /**
     * Destroys the instance by clearing history and removing all event listeners.
     *
     * This method resets the internal `history` object, effectively discarding any stored
     * data or state associated with the instance's operations. It also removes all listeners
     * from both `#events` and `#sysEvents` to ensure no further event handling occurs and to
     * prevent memory leaks.
     *
     * This method should be called when the instance is no longer needed.
     *
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.history = {};
      _classPrivateFieldGet(_events, this).removeAllListeners();
      _classPrivateFieldGet(_sysEvents, this).removeAllListeners();
    }
  }]);
}();
function _emit(event) {
  var _classPrivateFieldGet3, _classPrivateFieldGet4;
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  (_classPrivateFieldGet3 = _classPrivateFieldGet(_events, this)).emit.apply(_classPrivateFieldGet3, [event].concat(args));
  if (_classPrivateFieldGet(_sysEventsUsed, this)) (_classPrivateFieldGet4 = _classPrivateFieldGet(_sysEvents, this)).emit.apply(_classPrivateFieldGet4, [event].concat(args));
}
function _capitalizeFirstLetter(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var _default = exports["default"] = TinyAiInstance;

},{"events":92,"js-base64":98,"object-hash":106,"tiny-essentials":181}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "TinyAiInstance", {
  enumerable: true,
  get: function get() {
    return _TinyAiInstance["default"];
  }
});
Object.defineProperty(exports, "TinyGoogleAi", {
  enumerable: true,
  get: function get() {
    return _Google.TinyGoogleAi;
  }
});
Object.defineProperty(exports, "setTinyGoogleAi", {
  enumerable: true,
  get: function get() {
    return _Google.setTinyGoogleAi;
  }
});
var _Google = require("./services/Google.mjs");
var _TinyAiInstance = _interopRequireDefault(require("./TinyAiInstance.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"./TinyAiInstance.mjs":150,"./services/Google.mjs":152}],152:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyGoogleAi = void 0;
exports.setTinyGoogleAi = setTinyGoogleAi;
var _jsonrepair = require("jsonrepair");
var _TinyAiInstance2 = _interopRequireDefault(require("../TinyAiInstance.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/**
 * Configures the Tiny AI Api to use the Google Gemini API.
 *
 * This function sets up the Google Gemini API in a TinyAiApi instance, providing
 * the required authentication and model parameters.
 *
 * @param {TinyAiInstance} tinyGoogleAI - The TinyAiApi instance to be configured.
 * @param {string} GEMINI_API_KEY - The API key for Google Gemini.
 * @param {string} [MODEL_DATA='gemini-2.0-flash'] - The model to use (default is 'gemini-2.0-flash').
 */
function setTinyGoogleAi(tinyGoogleAI, GEMINI_API_KEY) {
  var MODEL_DATA = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'gemini-2.0-flash';
  var apiUrl = 'https://generativelanguage.googleapis.com/v1beta';
  tinyGoogleAI.setApiKey(GEMINI_API_KEY);
  tinyGoogleAI.setModel(MODEL_DATA);
  /**
   * A comprehensive map of HTTP status codes and their corresponding human-readable descriptions.
   *
   * This object includes:
   * - Standard HTTP status codes (1xxâ5xx)
   * - Cloudflare-specific codes (520â530, 598â599)
   * - Nginx-specific codes (444, 494â499)
   *
   * These codes are useful for interpreting responses from HTTP requests and displaying
   * user-friendly messages or handling programmatic logic based on response status.
   *
   * @constant
   * @type {Object<number, string>}
   *
   * @example
   * const message = errorCodes[404]; // "Not Found"
   * if (status >= 400) {
   *   console.warn(`Error ${status}: ${errorCodes[status] || 'Unknown Status Code'}`);
   * }
   */
  var errorCodes = {
    100: 'Continue',
    101: 'Switching Protocols',
    102: 'Processing',
    103: 'Early Hints',
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    207: 'Multi-Status',
    208: 'Already Reported',
    226: 'IM Used',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    306: 'Switch Proxy',
    307: 'Temporary Redirect',
    308: 'Permanent Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Payload Too Large',
    414: 'URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Range Not Satisfiable',
    417: 'Expectation Failed',
    418: "I'm a teapot",
    421: 'Misdirected Request',
    422: 'Unprocessable Entity',
    423: 'Locked',
    424: 'Failed Dependency',
    425: 'Too Early',
    426: 'Upgrade Required',
    428: 'Precondition Required',
    429: 'Too Many Requests',
    431: 'Request Header Fields Too Large',
    451: 'Unavailable For Legal Reasons',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported',
    506: 'Variant Also Negotiates',
    507: 'Insufficient Storage',
    508: 'Loop Detected',
    510: 'Not Extended',
    511: 'Network Authentication Required',
    520: 'Web Server Returned an Unknown Error',
    521: 'Web Server Is Down',
    522: 'Connection Timed Out',
    523: 'Origin Is Unreachable',
    524: 'A Timeout Occurred',
    525: 'SSL Handshake Failed',
    526: 'Invalid SSL Certificate',
    527: 'Railgun Error',
    530: 'Site Frozen',
    598: 'Network Read Timeout Error',
    599: 'Network Connect Timeout Error',
    // Nginx
    444: 'No Response',
    494: 'Request Header Too Large',
    495: 'SSL Certificate Error',
    496: 'SSL Certificate Required',
    497: 'HTTP Request Sent to HTTPS Port',
    499: 'Client Closed Request'
  };
  /**
   * Registers a predefined set of error codes and their associated messages for interpreting
   * the finish reasons returned by the Google Generative AI API.
   *
   * Each error code maps to a human-readable explanation and optional display rules (e.g. `hide`).
   * These can be used to provide meaningful messages in the UI or logs when handling model responses.
   *
   * @function
   * @name tinyGoogleAI._setErrorCodes
   * @param {Object<string, {text: string, hide?: boolean}>} errorCodes - An object where each key is an error/finish reason returned by the API,
   * and the value contains a `text` message and optionally a `hide` flag to control visibility in UI.
   *
   * @returns {void}
   *
   * @example
   * tinyGoogleAI._setErrorCodes({
   *   STOP: { text: 'Natural stop point of the model or provided stop sequence.', hide: true },
   *   MAX_TOKENS: { text: 'The maximum number of tokens as specified in the request was reached.' },
   *   SAFETY: { text: 'The response candidate content was flagged for safety reasons.' },
   *   ...
   * });
   *
   * Example usage:
   * const reason = response.finishReason;
   * const errorInfo = tinyGoogleAI.getErrorCode(reason);
   * console.log(errorInfo.text); // Shows friendly explanation for the finish reason
   */
  tinyGoogleAI._setErrorCodes({
    FINISH_REASON_UNSPECIFIED: {
      text: 'Default value. This value is unused.'
    },
    STOP: {
      text: 'Natural stop point of the model or provided stop sequence.',
      hide: true
    },
    MAX_TOKENS: {
      text: 'The maximum number of tokens as specified in the request was reached.'
    },
    SAFETY: {
      text: 'The response candidate content was flagged for safety reasons.'
    },
    RECITATION: {
      text: 'The response candidate content was flagged for recitation reasons.'
    },
    LANGUAGE: {
      text: 'The response candidate content was flagged for using an unsupported language.'
    },
    OTHER: {
      text: 'Unknown reason.'
    },
    BLOCKLIST: {
      text: 'Token generation stopped because the content contains forbidden terms.'
    },
    PROHIBITED_CONTENT: {
      text: 'Token generation stopped for potentially containing prohibited content.'
    },
    SPII: {
      text: 'Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).'
    },
    MALFORMED_FUNCTION_CALL: {
      text: 'The function call generated by the model is invalid.'
    },
    IMAGE_SAFETY: {
      text: 'Token generation stopped because generated images contain safety violations.'
    }
  });
  /**
   * @param {*} [result={ error: { code: null, message: null, status: null, details: null } }]
   * @param {*} [finalData={ error: { code: null, message: null, status: null, details: null } }]
   */
  var buildErrorData = function buildErrorData() {
    var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      error: {
        code: null,
        message: null,
        status: null,
        details: null
      }
    };
    var finalData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      error: {
        code: null,
        message: null,
        status: null,
        details: null
      }
    };
    if (typeof result === 'undefined') throw new Error('Invalid result or missing error object');
    finalData.error = {
      code: typeof result.error.code === 'number' ? result.error.code : null,
      message: typeof result.error.message === 'string' ? result.error.message : null,
      status: typeof result.error.status === 'string' ? result.error.status : null
    };
    if (result.error.details) finalData.error.details = result.error.details;
  };
  /**
   * Constructs the full request body for the Google Gemini API call.
   *
   * @param {*} data
   * @param {*} [config={}]
   * @param {*} [cache=null]
   * @param {boolean} [cacheMode=false]
   * @returns {*}
   */
  var requestBuilder = function requestBuilder(data) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var cacheMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    /**
     * @type {{
     * safetySettings: {};
     * model: any;
     * ttl: any;
     * name: any;
     * contents: Array<any>;
     * systemInstruction: any;
     * generationConfig: {
     *    maxOutputTokens: any;
     *    temperature: any;
     *    topP: any;
     *    topK: any;
     *    presencePenalty: any;
     *    frequencyPenalty: any;
     *    enableEnhancedCivicAnswers: any;
     * };
     *  cachedContent: any;
     * }}
     */
    var requestBody = {};
    if (!cacheMode) requestBody.safetySettings = [];
    // Model
    if (typeof config.model === 'string') requestBody.model = config.model;
    // Expiration
    if (typeof config.ttl === 'string') requestBody.ttl = config.ttl;
    // Expiration
    if (typeof config.name === 'string') requestBody.name = config.name;
    // Execute builder
    for (var index in data) {
      var item = data[index];
      if (item) {
        if (item.role !== 'system') {
          if (!Array.isArray(requestBody.contents)) requestBody.contents = [];
          tinyGoogleAI.buildContents(requestBody.contents, item, item.role, true);
        } else {
          if (!Array.isArray(requestBody.systemInstruction)) requestBody.systemInstruction = [];
          tinyGoogleAI.buildContents(requestBody.systemInstruction, item, undefined, true);
          requestBody.systemInstruction = requestBody.systemInstruction[0];
        }
      }
    }
    // Config
    if (!cacheMode) {
      requestBody.generationConfig = {};
      if (typeof tinyGoogleAI.getMaxOutputTokens() === 'number') requestBody.generationConfig.maxOutputTokens = tinyGoogleAI.getMaxOutputTokens();
      if (typeof tinyGoogleAI.getTemperature() === 'number') requestBody.generationConfig.temperature = tinyGoogleAI.getTemperature();
      if (typeof tinyGoogleAI.getTopP() === 'number') requestBody.generationConfig.topP = tinyGoogleAI.getTopP();
      if (typeof tinyGoogleAI.getTopK() === 'number') requestBody.generationConfig.topK = tinyGoogleAI.getTopK();
      if (typeof tinyGoogleAI.getPresencePenalty() === 'number') requestBody.generationConfig.presencePenalty = tinyGoogleAI.getPresencePenalty();
      if (typeof tinyGoogleAI.getFrequencyPenalty() === 'number') requestBody.generationConfig.frequencyPenalty = tinyGoogleAI.getFrequencyPenalty();
      if (typeof tinyGoogleAI.isEnabledEnchancedCivicAnswers() === 'boolean') requestBody.generationConfig.enableEnhancedCivicAnswers = tinyGoogleAI.isEnabledEnchancedCivicAnswers();
    }
    // Cache
    if (cache) requestBody.cachedContent = cache;
    // Complete
    return requestBody;
  };
  // https://ai.google.dev/api/generate-content?hl=pt-br#method:-models.generatecontent
  /**
   * Internal method that integrates with Google Gemini via generateContent or streamGenerateContent.
   * It builds the request body, handles normal and streaming responses, parses tokens and content,
   * and returns structured response data.
   *
   * @function
   * @name tinyGoogleAI._setGenContent
   * @param {string} apiKey - Your Google AI API key.
   * @param {boolean} isStream - Whether the request is a streaming request.
   * @param {object[]} data - An array of messages to send (prompt).
   * @param {string} model - The Gemini model ID (e.g., "gemini-pro").
   * @param {Function} streamingCallback - Callback for streaming results. Called with partials.
   * @param {AbortController} controller - Optional abort controller for cancelling requests.
   * @returns {Promise<object>} finalData - A promise that resolves with a structured response object:
   * - finalData.contents: Parsed content output
   * - finalData.tokenUsage: Usage info with prompt/candidate/total counts
   * - finalData.modelVersion: Model version string
   * - finalData._response: Raw response
   * - finalData.error: (If error occurred) contains message, status, and code
   */
  tinyGoogleAI._setGenContent(
  /**
   * @param {string} apiKey
   * @param {boolean} isStream
   * @param {any} data
   * @param {string} model
   * @param {function} streamingCallback
   * @param {AbortController} controller
   * @returns {any}
   */
  function (apiKey, isStream, data, model, streamingCallback, controller) {
    return new Promise(function (resolve, reject) {
      // Request
      var requestBody = requestBuilder(data);
      /**
       * Parses token usage metadata from the result object.
       *
       * @param {*} result - The API response containing usageMetadata.
       * @returns {[object, boolean]} Tuple of metadata object and whether an error occurred.
       * @private
       */
      var buildUsageMetada = function buildUsageMetada(result) {
        var usageMetadata = {
          count: {
            candidates: null,
            prompt: null,
            total: null
          }
        };
        var needShowMetadataError = false;
        if (result.usageMetadata) {
          // Candidates
          if (typeof result.usageMetadata.candidatesTokenCount === 'number') usageMetadata.count.candidates = result.usageMetadata.candidatesTokenCount;
          // Prompt
          if (typeof result.usageMetadata.promptTokenCount === 'number') usageMetadata.count.prompt = result.usageMetadata.promptTokenCount;
          // Total
          if (typeof result.usageMetadata.totalTokenCount === 'number') usageMetadata.count.total = result.usageMetadata.totalTokenCount;
        }
        // Error
        else needShowMetadataError = true;
        return [usageMetadata, needShowMetadataError];
      };
      /**
       * Parses and adds content candidates to the final result object.
       *
       * @param {*} result - The result object from the API response.
       * @param {*} finalData - The object where content candidates are appended.
       * @private
       */
      var buildContent = function buildContent(result, finalData) {
        if (Array.isArray(result.candidates)) {
          for (var index in result.candidates) {
            var item = result.candidates[index];
            if (item.content) {
              // Finished reason
              var finishReason = null;
              if (typeof item.finishReason === 'string') finishReason = item.finishReason.toUpperCase();
              // Build content
              tinyGoogleAI.buildContents(finalData.contents, item.content, item.content.role);
              finalData.contents[finalData.contents.length - 1].finishReason = finishReason;
            }
          }
        }
      };
      /**
       * Final handler that transforms the result into a structured response.
       *
       * @param {*} result - The response from the Gemini API.
       * @returns {*} finalData - Structured result with content, usage, model version, or error.
       * @private
       */
      var finalPromise = function finalPromise(result) {
        // Prepare final data
        /** @type {*} */
        var finalData = {
          _response: result
        };
        if (!result.error) {
          // Content
          finalData.contents = [];
          // Model Version
          finalData.modelVersion = typeof result.modelVersion === 'string' ? result.modelVersion : null;
          // Token Usage
          var _buildUsageMetada = buildUsageMetada(result),
            _buildUsageMetada2 = _slicedToArray(_buildUsageMetada, 2),
            tokenUsage = _buildUsageMetada2[0],
            needShowMetadataError = _buildUsageMetada2[1];
          finalData.tokenUsage = tokenUsage;
          if (needShowMetadataError) {
            console.error('Usage Metadata not found in the Google AI result.');
            console.log(result);
          }
          // Build content
          buildContent(result, finalData);
        }
        // Error result
        else buildErrorData(result, finalData);
        // Complete
        return finalData;
      };
      /**
       * Handles streaming Gemini response via Fetch and TextDecoder.
       * Buffers content and sends back partials using the streamingCallback.
       *
       * @async
       * @param {ReadableStream} stream - The ReadableStream from fetch().body
       * @returns {Promise<void>}
       * @private
       */
      var streamingResponse = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(stream) {
          var reader, decoder, done, countData, streamResult, streamCache, readerData, value, streamDone, chunk, cleanedJson, jsonChunk, indexResult, result, tinyData, tinyResult, index, index2, item, finalData, _index, _index2, _t;
          return _regenerator().w(function (_context) {
            while (1) switch (_context.n) {
              case 0:
                _context.p = 0;
                reader = stream.getReader();
                decoder = new TextDecoder('utf-8');
                done = false;
                countData = 0;
                streamResult = {};
                /** @type {*} */
                streamCache = []; // Read streaming
                console.groupCollapsed('[google-generative] Streaming request.');
                console.log("[ai-config] [".concat(model, "]"), requestBody, data);
              case 1:
                if (done) {
                  _context.n = 5;
                  break;
                }
                if (!(reader && typeof reader.read === 'function')) {
                  _context.n = 3;
                  break;
                }
                _context.n = 2;
                return reader.read();
              case 2:
                readerData = _context.v;
                value = readerData.value, streamDone = readerData.done;
                done = streamDone;
                if (value) {
                  chunk = decoder.decode(value, {
                    stream: true
                  });
                  if (!done) {
                    cleanedJson = '';
                    try {
                      cleanedJson = chunk.trim();
                      if (cleanedJson.startsWith(',')) cleanedJson = cleanedJson.substring(1);
                      if (cleanedJson.length > 1) {
                        cleanedJson = (0, _jsonrepair.jsonrepair)(cleanedJson);
                        cleanedJson = "".concat(!cleanedJson.startsWith('[') ? '[' : '').concat(cleanedJson).concat(!cleanedJson.endsWith(']') ? ']' : '');
                        jsonChunk = JSON.parse(cleanedJson);
                        console.log("[".concat(countData, "]"), chunk);
                        console.log("[".concat(countData, "]"), cleanedJson);
                        console.log("[".concat(countData, "]"), jsonChunk);
                        // Send temp data
                        for (indexResult in jsonChunk) {
                          result = jsonChunk[indexResult];
                          if (result) {
                            /** @type {*} */
                            tinyData = {
                              contents: []
                            };
                            buildContent(result, tinyData);
                            /** @type {*} */
                            tinyResult = {
                              tokenUsage: buildUsageMetada(result)[0]
                            };
                            for (index in tinyData.contents) {
                              if (!Array.isArray(streamCache[index])) streamCache[index] = [];
                              for (index2 in tinyData.contents[index].parts) {
                                item = tinyData.contents[index].parts[index2];
                                if (typeof item.text === 'string') {
                                  if (!streamCache[index][index2]) streamCache[index][index2] = {};
                                  if (typeof streamCache[index][index2].text !== 'string') streamCache[index][index2].text = '';
                                  streamCache[index][index2].text += item.text;
                                  item.text = streamCache[index][index2].text;
                                  if (typeof tinyData.contents[index].role === 'string') streamCache[index][index2].role = tinyData.contents[index].role;
                                }
                              }
                            }
                            // Complete
                            streamResult = result;
                            tinyResult.contents = tinyData.contents;
                            tinyResult.done = false;
                            streamingCallback(tinyResult);
                          }
                        }
                      }
                    } catch (_unused) {
                      console.log("[google-generative] [ai-error] [chuck] [".concat(countData, "]"), chunk);
                      console.log("[google-generative] [ai-error] [cleanedJson] [".concat(countData, "]"), cleanedJson);
                    }
                  }
                }
                countData++;
                _context.n = 4;
                break;
              case 3:
                done = true;
              case 4:
                _context.n = 1;
                break;
              case 5:
                console.groupEnd();
                // Complete
                streamingCallback({
                  done: true
                });
                finalData = finalPromise(streamResult);
                for (_index in finalData.contents) {
                  for (_index2 in finalData.contents[_index].parts) {
                    if (typeof finalData.contents[_index].parts[_index2].text === 'string') finalData.contents[_index].parts[_index2].text = streamCache[_index][_index2];
                  }
                }
                resolve(finalData);
                _context.n = 7;
                break;
              case 6:
                _context.p = 6;
                _t = _context.v;
                reject(_t);
              case 7:
                return _context.a(2);
            }
          }, _callee, null, [[0, 6]]);
        }));
        return function streamingResponse(_x) {
          return _ref.apply(this, arguments);
        };
      }();
      // Request
      var fetchRequest = fetch("".concat(apiUrl, "/models/").concat(model, ":").concat(!isStream ? 'generateContent' : 'streamGenerateContent', "?key=").concat(encodeURIComponent(apiKey)), {
        signal: controller ? controller.signal : undefined,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });
      // Normal
      // Request
      fetchRequest.then(function (res) {
        // Normal
        if (!isStream) res.json().then(function (result) {
          return resolve(finalPromise(result));
        })["catch"](reject);else {
          // Error Streaming
          if (!res.body) reject(new Error('No AI streaming value found.'));else if (!res.ok) reject(new Error("Error ".concat(typeof res.status === 'number' ? "HTTP ".concat(res.status) : 'UNKNOWN ERROR', ": ").concat(typeof res.statusText === 'string' ? res.statusText.length > 0 ? res.statusText : typeof errorCodes[Number(res.status)] === 'string' ? errorCodes[Number(res.status)] : '???' : 'Unknown')));
          // Streaming
          else streamingResponse(res.body);
        }
      })
      // Error
      ["catch"](reject);
    });
  });
  // https://ai.google.dev/api/models?hl=pt_br#method:-models.list
  /**
   * Registers a function to fetch and organize the list of available Google AI models.
   * The returned models are grouped into categories (`main`, `exp`, `others`) and sorted based on a predefined versioning logic.
   *
   * @function
   * @name tinyGoogleAI._setGetModels
   * @param {function(string, number, string=): Promise<Object>} callback - A function that takes an API key, an optional page size, and an optional page token,
   * and returns a Promise with the processed models data.
   *
   * @returns {void}
   *
   * @example
   * tinyGoogleAI._setGetModels((apiKey, pageSize, pageToken) => { ... });
   *
   * Returned object when resolved:
   * {
   *   _response: <original API response>,
   *   newData: [<processed and inserted model objects>]
   * }
   *
   * Model structure inserted into `tinyGoogleAI`:
   * {
   *   _response: <original model>,
   *   category: { displayName, id, index },
   *   index: <number>,
   *   name: <string>,
   *   id: <string>,
   *   displayName: <string>,
   *   version: <string>,
   *   description: <string>,
   *   inputTokenLimit: <number>,
   *   outputTokenLimit: <number>,
   *   temperature: <number>,
   *   maxTemperature: <number>,
   *   topP: <number>,
   *   topK: <number>,
   *   supportedGenerationMethods: [<string>]
   * }
   */
  tinyGoogleAI._setGetModels(
  /**
   * @param {string} apiKey
   * @param {number} pageSize
   * @param {string} pageToken
   * @returns {any}
   */
  function (apiKey, pageSize, pageToken) {
    return new Promise(function (resolve, reject) {
      return fetch("".concat(apiUrl, "/models?key=").concat(encodeURIComponent(apiKey), "&pageSize=").concat(encodeURIComponent(pageSize)).concat(pageToken ? "&pageToken=".concat(encodeURIComponent(pageToken)) : ''), {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      })
      // Request
      .then(function (res) {
        return res.json();
      }).then(function (result) {
        // Prepare final data
        /** @type {*} */
        var finalData = {
          _response: result
        };
        if (!result.error) {
          finalData.newData = [];
          // Update Token
          tinyGoogleAI._setNextModelsPageToken(result.nextPageToken);
          // Categories
          /** @type {*} */
          var newModels = [{
            category: 'main',
            index: 0,
            displayName: '--> Main models',
            data: []
          }, {
            category: 'exp',
            index: 1,
            displayName: '--> Experimental models',
            data: []
          }, {
            category: 'others',
            index: 2,
            displayName: '--> Other models',
            data: []
          }];
          var modelOrderIndexUsed = {
            main: -1,
            exp: -1
          };
          /** @type {*} */
          var modelOrder = {};
          var addModelVersions = function addModelVersions() {
            var version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            // Release
            modelOrderIndexUsed.main++;
            modelOrder["gemini-".concat(version, "-flash")] = {
              index: modelOrderIndexUsed.main,
              category: 'main'
            };
            modelOrderIndexUsed.main++;
            modelOrder["gemini-".concat(version, "-pro")] = {
              index: modelOrderIndexUsed.main,
              category: 'main'
            };
            // Exp
            modelOrderIndexUsed.exp++;
            modelOrder["gemini-".concat(version, "-flash-exp")] = {
              index: modelOrderIndexUsed.exp,
              category: 'exp'
            };
            modelOrderIndexUsed.exp++;
            modelOrder["gemini-".concat(version, "-pro-exp")] = {
              index: modelOrderIndexUsed.exp,
              category: 'exp'
            };
          };
          for (var versionNumber = 99; versionNumber >= 2; versionNumber--) {
            addModelVersions("".concat(versionNumber, ".0"));
            addModelVersions("".concat(versionNumber, ".5"));
          }
          addModelVersions('1.5');
          // Read models
          console.log('[Google Generative] Models list', result.models);
          var _loop = function _loop() {
            var id = result.models[index].name.substring(7);
            var allowed = false;
            if (Array.isArray(result.models[index].supportedGenerationMethods) && result.models[index].supportedGenerationMethods.indexOf('generateContent') > -1 && result.models[index].supportedGenerationMethods.indexOf('countTokens') > -1) {
              for (var id2 in modelOrder) {
                if (id.startsWith(id2) || id === id2) allowed = true;
              }
            }
            // Allow add the model
            if (allowed) {
              // Add custom order
              if (modelOrder[id] && typeof modelOrder[id].index === 'number') result.models[index]._NEW_ORDER = modelOrder[id].index;else result.models[index]._NEW_ORDER = 999999;
              // Add Category
              if (modelOrder[id] && typeof modelOrder[id].category === 'string') {
                var category = newModels.find(function (/** @type {any} */item) {
                  return item.category === modelOrder[id].category;
                });
                if (category) category.data.push(result.models[index]);
                // Nope
                else newModels[newModels.length - 1].data.push(result.models[index]);
              } else newModels[newModels.length - 1].data.push(result.models[index]);
            }
          };
          for (var index in result.models) {
            _loop();
          }
          // Send data
          for (var _index3 in newModels) {
            for (var index2 in newModels[_index3].data) {
              var newModel = {
                _response: newModels[_index3].data[index2],
                category: {
                  displayName: newModels[_index3].displayName,
                  id: newModels[_index3].category,
                  index: newModels[_index3].index
                },
                index: newModels[_index3].data[index2]._NEW_ORDER,
                name: newModels[_index3].data[index2].name,
                id: newModels[_index3].data[index2].name.substring(7),
                displayName: newModels[_index3].data[index2].displayName,
                version: newModels[_index3].data[index2].version,
                description: newModels[_index3].data[index2].description,
                inputTokenLimit: newModels[_index3].data[index2].inputTokenLimit,
                outputTokenLimit: newModels[_index3].data[index2].outputTokenLimit,
                temperature: newModels[_index3].data[index2].temperature,
                maxTemperature: newModels[_index3].data[index2].maxTemperature,
                topP: newModels[_index3].data[index2].topP,
                topK: newModels[_index3].data[index2].topK,
                supportedGenerationMethods: newModels[_index3].data[index2].supportedGenerationMethods
              };
              var inserted = tinyGoogleAI._insertNewModel(newModel);
              if (inserted) finalData.newData.push(inserted);
            }
          }
        }
        // Error result
        else buildErrorData(result, finalData);
        // Complete
        resolve(finalData);
      })
      // Error
      ["catch"](reject);
    });
  });
  // https://ai.google.dev/api/tokens?hl=pt-br#method:-models.counttokens
  /**
   * Registers a function to calculate token usage for a given model and input data using Google AI's `countTokens` endpoint.
   *
   * @function
   * @name tinyGoogleAI._setCountTokens
   * @param {function(string, string, AbortController?, Object): Promise<Object>} callback - A function that takes an API key, model ID,
   * an optional AbortController, and the input data for the token count request. Returns a Promise with token count information.
   *
   * @returns {void}
   *
   * @example
   * tinyGoogleAI._setCountTokens((apiKey, model, controller, data) => { ... });
   *
   * Returned object when resolved:
   * {
   *   _response: <original API response>,
   *   totalTokens: <number|null>,
   *   cachedContentTokenCount: <number|null>,
   *   promptTokensDetails: {
   *     tokenCount: <number|null>,
   *     modality: <string|null>
   *   }
   * }
   */
  tinyGoogleAI._setCountTokens(
  /**
   * @param {string} apiKey
   * @param {string} model
   * @param {AbortController} controller
   * @param {any} data
   * @returns {any}
   */
  function (apiKey, model, controller, data) {
    return new Promise(function (resolve, reject) {
      var dataContent = requestBuilder(data);
      /** @type {*} */
      var modelInfo = tinyGoogleAI.getModelData(model);
      dataContent.model = modelInfo === null || modelInfo === void 0 ? void 0 : modelInfo.name;
      if (Array.isArray(dataContent.contents) && dataContent.contents.length > 0) {
        fetch("".concat(apiUrl, "/models/").concat(model, ":countTokens?key=").concat(encodeURIComponent(apiKey)), {
          signal: controller ? controller.signal : undefined,
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            generateContentRequest: dataContent
          })
        })
        // Request
        .then(function (res) {
          return res.json();
        }).then(function (result) {
          /** @type {*} */
          var finalData = {
            _response: result
          };
          if (!result.error) {
            // Total tokens
            if (typeof result.totalTokens === 'number') finalData.totalTokens = result.totalTokens;else finalData.totalTokens = null;
            // Cached Content Token Count
            if (typeof result.cachedContentTokenCount === 'number') finalData.cachedContentTokenCount = result.cachedContentTokenCount;else finalData.cachedContentTokenCount = null;
            // Prompt tokens details
            if (result.promptTokensDetails) {
              if (!finalData.promptTokensDetails) finalData.promptTokensDetails = {};
              // Token Count
              if (typeof result.promptTokensDetails.tokenCount === 'number') finalData.promptTokensDetails.tokenCount = result.promptTokensDetails.tokenCount;else finalData.promptTokensDetails.tokenCount = null;
              // Modality
              if (typeof result.promptTokensDetails.modality === 'string') finalData.promptTokensDetails.modality = result.promptTokensDetails.modality;else finalData.promptTokensDetails.modality = null;
            }
          }
          // Error result
          else buildErrorData(result, finalData);
          // Complete
          resolve(finalData);
        })
        // Error
        ["catch"](reject);
      } else resolve({
        _response: {},
        totalTokens: null,
        cachedContentTokenCount: null
      });
    });
  });
  // Complete
  return tinyGoogleAI;
}
/**
 * Creates and configures a new TinyAiInstance that is set up with the Google Gemini API.
 *
 * @class
 * @extends TinyAiInstance
 * @param {string} GEMINI_API_KEY - The API key used to authenticate with the Google Gemini API.
 * @param {string} [MODEL_DATA='gemini-2.0-flash'] - Optional. The model identifier to use. Defaults to `'gemini-2.0-flash'`.
 * @param {boolean} [isSingle=false] - If true, configures the instance to handle a single session only.
 * @returns {TinyAiInstance} A configured instance of TinyAiApi.
 */
var TinyGoogleAi = exports.TinyGoogleAi = /*#__PURE__*/function (_TinyAiInstance) {
  function TinyGoogleAi() {
    var _this;
    var GEMINI_API_KEY = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var MODEL_DATA = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'gemini-2.0-flash';
    var isSingle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    _classCallCheck(this, TinyGoogleAi);
    _this = _callSuper(this, TinyGoogleAi, [isSingle]);
    setTinyGoogleAi(_this, GEMINI_API_KEY, MODEL_DATA);
    return _this;
  }
  _inherits(TinyGoogleAi, _TinyAiInstance);
  return _createClass(TinyGoogleAi);
}(_TinyAiInstance2["default"]);

},{"../TinyAiInstance.mjs":150,"jsonrepair":99}],153:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _tinyEssentials = require("tiny-essentials");
var _validateColor = _interopRequireDefault(require("validate-color"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * TinyDices - JavaScript class for rendering animated 3D dice with HTML/CSS.
 *
 * Created by: Yasmin Seidel (JasminDreasond)
 * Co-developed with: ChatGPT (OpenAI) as coding assistant
 *
 * Features:
 * - Roll any number of dice
 * - Supports custom max values per die
 * - Optional spinning animation (infinite or ending)
 * - Dynamic cube generation and animation
 * - Option to include zero in rolls (canZero)
 *
 * Usage:
 * const container = document.getElementById('myDice');
 * const dice = new TinyDices(container);
 *
 * dice.roll('7,7,7');                    // Rolls 3d6
 * dice.roll('6,12,20');                 // Rolls d6, d12, and d20
 * dice.roll([10, 10], false, true);     // Rolls 2d10 with infinite spin
 * dice.roll([10, 10], true);            // Rolls 2d10 starting from 0
 * dice.roll([4, 8, 6], true, true);     // Rolls d4, d8, and d6 from 0 with infinite spin
 *
 * Customization:
 * dice.setBgSkin('gray');                // Sets background skin to gray
 * dice.setTextSkin('red');               // Sets text skin to red
 * dice.setBorderSkin('2px solid black'); // Sets border skin to black
 *
 * dice.getBgSkin();                       // Gets current or default background skin
 * dice.getTextSkin();                     // Gets current or default text skin
 * dice.getBorderSkin();                   // Gets current or default border skin
 */
var _elements = /*#__PURE__*/new WeakMap();
var _cubeId = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _defaultBgSkin = /*#__PURE__*/new WeakMap();
var _defaultBorderSkin = /*#__PURE__*/new WeakMap();
var _defaultSelectionTextSkin = /*#__PURE__*/new WeakMap();
var _defaultSelectionBgSkin = /*#__PURE__*/new WeakMap();
var _defaultTextSkin = /*#__PURE__*/new WeakMap();
var _selectionBgSkin = /*#__PURE__*/new WeakMap();
var _selectionTextSkin = /*#__PURE__*/new WeakMap();
var _bgSkin = /*#__PURE__*/new WeakMap();
var _bgImg = /*#__PURE__*/new WeakMap();
var _textSkin = /*#__PURE__*/new WeakMap();
var _borderSkin = /*#__PURE__*/new WeakMap();
var _diceBase = /*#__PURE__*/new WeakMap();
var _createCube = /*#__PURE__*/new WeakMap();
var _TinyDices_brand = /*#__PURE__*/new WeakSet();
var TinyDices = /*#__PURE__*/function () {
  /**
   * Creates a new TinyDices instance attached to a specified HTML element.
   *
   * @param {HTMLElement} diceBase - The HTML container element where the dice will be rendered.
   * @param {(result: number, max: number, canZero?: boolean, rollInfinity?: boolean) => CubeResult} [createCubeScript=null]
   *        - Optional function to override the internal cube creation logic.
   *          If provided, it will be used instead of the built-in method.
   *
   *          The function should accept the following parameters:
   *            - result {number} - The main value to appear on the front face of the die.
   *            - max {number} - The maximum value allowed for a face of the die.
   *            - canZero {boolean} [optional] - If true, faces can include the number 0.
   *            - rollInfinity {boolean} [optional] - If true, the die spins infinitely.
   *
   *          And return:
   *            - {HTMLElement} cube - The DOM element representing the dice cube.
   *            - {number[]} sequence - An array containing all the face values of the die.
   *
   *
   * When implementing a custom dice creation logic, you can use the following internal methods:
   *
   * @function tinyDice.addElement
   * Adds a structured dice object to the internal list for tracking and future cleanup.
   * This method expects an object with `faces`, `container`, and `wrapper` properties.
   *
   * @function tinyDice.rollNumber(max: number, canZero: boolean): number
   * Generates a random number based on the maximum value and zero allowance.
   * Useful when assigning values to non-front faces of the die.
   *
   * @function tinyDice.updateDiceFaceSkin(face: HTMLElement): void
   * Applies the dice face style or skin to a given face element.
   * This is usually a visual effect or texture that the user can define.
   *
   * @function tinyDice.addCubeId(): number
   * Returns a unique identifier for each die. This value is typically used to set the `z-index`
   * of the container, so that new dice appear above older ones.
   *
   *
   */
  function TinyDices(diceBase, createCubeScript) {
    _classCallCheck(this, TinyDices);
    /**
     * Internal helper to check if the dice base element is a valid HTMLElement.
     *
     * @returns {boolean} - True if #diceBase is a valid HTMLElement.
     */
    _classPrivateMethodInitSpec(this, _TinyDices_brand);
    /**
     * @typedef {Object} DiceElement
     * @property {HTMLElement[]} faces - An array of six face elements.
     * @property {HTMLElement|null} container - The outer wrapper element.
     * @property {HTMLElement|null} wrapper - The rotating inner cube element.
     */
    /**
     * @typedef {Object} CubeResult
     * @property {HTMLDivElement} cube - The DOM element representing the cube container.
     * @property {number[]} sequence - The final sequence of values shown on each face.
     */
    /**
     * Stores all current dice elements created by the instance.
     *
     * Each element follows the `DiceElement` structure, containing cube faces,
     * its container, and the cube wrapper for rotation.
     *
     * @type {DiceElement[]}
     */
    _classPrivateFieldInitSpec(this, _elements, []);
    _classPrivateFieldInitSpec(this, _cubeId, 0);
    // used for incremental z-index to avoid overlapping issues
    _classPrivateFieldInitSpec(this, _destroyed, false);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultBgSkin, 'linear-gradient(135deg, #ff3399, #33ccff)');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultBorderSkin, '2px solid rgba(255, 255, 255, 0.2)');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultSelectionTextSkin, '#FFF');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultSelectionBgSkin, '#000');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultTextSkin, 'white');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _selectionBgSkin, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _selectionTextSkin, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _bgSkin, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _bgImg, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _textSkin, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _borderSkin, null);
    /** @type {HTMLElement|null} */_classPrivateFieldInitSpec(this, _diceBase, null);
    /** @type {HTMLElement|null} */
    _defineProperty(this, "diceArea", null);
    /** @type {HTMLElement|null} */
    _defineProperty(this, "container", null);
    /**
     * Creates a cube DOM element with animated faces and randomized values.
     *
     * @param {number} result - The main value to appear on the front face.
     * @param {number} max - The maximum possible value for the die.
     * @param {boolean} [rollInfinity=false] - If true, the cube will spin infinitely.
     * @returns {CubeResult} - The cube element and an array of all face values.
     */
    _classPrivateFieldInitSpec(this, _createCube, void 0);
    if (typeof createCubeScript === 'function') _classPrivateFieldSet(_createCube, this, createCubeScript);else _assertClassBrand(_TinyDices_brand, this, _insertCreateCube).call(this);
    if (typeof HTMLElement !== 'undefined' && diceBase instanceof HTMLElement) {
      _classPrivateFieldSet(_diceBase, this, diceBase);
      _classPrivateFieldGet(_diceBase, this).classList.add('tiny-dices-body');
      this.diceArea = document.createElement('div');
      this.diceArea.classList.add('dice-area');
      _classPrivateFieldGet(_diceBase, this).appendChild(this.diceArea);
    }
  }
  return _createClass(TinyDices, [{
    key: "existsHtml",
    value:
    /**
     * Checks if the internal HTML structure (dice base container) still exists in the DOM.
     *
     * Useful to verify if the TinyDices component is still rendered and operational.
     *
     * @returns {boolean} - Returns `true` if the HTML elements exist, otherwise `false`.
     */
    function existsHtml() {
      return _assertClassBrand(_TinyDices_brand, this, _existsHtml).call(this);
    }
    /**
     * Increments and returns the current cube ID.
     *
     * This ID is used to set a unique z-index for each die,
     * ensuring that newer dice appear above older ones in the stack.
     *
     * @returns {number} The current cube ID before incrementing.
     */
  }, {
    key: "addCubeId",
    value: function addCubeId() {
      var _this$cubeId, _this$cubeId2;
      return _classPrivateFieldSet(_cubeId, this, (_this$cubeId = _classPrivateFieldGet(_cubeId, this), _this$cubeId2 = _this$cubeId++, _this$cubeId)), _this$cubeId2;
    }
    /**
     * Validates and stores a new dice element into the internal list.
     *
     * This method ensures that the given object has the correct structure
     * before appending it to the internal array of rendered dice elements.
     *
     * @param {DiceElement} item - The dice element object to validate and store.
     * @returns {boolean} `true` if the item was valid and added; otherwise, `false`.
     */
  }, {
    key: "addElement",
    value:
    /**
     * Adds a new dice element to the internal storage.
     *
     * This is the public wrapper for the internal method `#addElement`.
     * It validates the structure of the dice element before adding.
     *
     * @param {DiceElement} item
     *        - The dice element object to add. It must contain:
     *          - `faces`: an array of six face elements,
     *          - `container`: the outer wrapper element,
     *          - `wrapper`: the rotating inner cube element.
     *
     * @returns {boolean} `true` if the element was valid and added, otherwise `false`.
     */
    function addElement(item) {
      return _assertClassBrand(_TinyDices_brand, this, _addElement).call(this, item);
    }
    /**
     * Validates a background-image value restricted to safe data:image URLs only.
     *
     * @param {string} value - The CSS background-image value.
     * @returns {boolean}
     */
  }, {
    key: "setBgImg",
    value:
    /**
     * Sets the background image using a `data:` URL or, optionally, a standard image URL if forced.
     *
     * For security reasons, only `data:` URLs are accepted by default to avoid external resource injection.
     * You can override this restriction using the `forceUnsafe` flag, but this is discouraged unless trusted.
     *
     * @param {string|null} value - The background-image URL (must be a `data:` image by default).
     * @param {boolean} [forceUnsafe=false] - Allows setting non-data URLs if true (use with caution).
     */
    function setBgImg(value) {
      var forceUnsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      _classPrivateFieldSet(_bgImg, this, typeof value === 'string' && (forceUnsafe || _assertClassBrand(_TinyDices_brand, this, _isValidDataImage).call(this, value)) ? value : null);
    }
    /**
     * Returns the currently set background image if valid, or null.
     *
     * @returns {string|null} - The current background-image value (data:image URL) or null if none is set.
     */
  }, {
    key: "getBgImg",
    value: function getBgImg() {
      return _classPrivateFieldGet(_bgImg, this) || null;
    }
    /**
     * Sets the background skin style if it's a valid CSS color or linear-gradient.
     * Prevents injection of unsafe or malformed styles.
     *
     * @param {string} skin - A valid CSS color string or gradient.
     */
  }, {
    key: "setBgSkin",
    value: function setBgSkin(skin) {
      if (typeof skin !== 'string') {
        _classPrivateFieldSet(_bgSkin, this, null);
        return;
      }
      var trimmed = skin.trim();
      var isGradient = _assertClassBrand(_TinyDices_brand, this, _isValidLinearGradient).call(this, trimmed);
      var isColor = (0, _validateColor["default"])(trimmed);
      _classPrivateFieldSet(_bgSkin, this, isGradient || isColor ? trimmed : null);
    }
    /**
     * Gets the currently applied background skin.
     * @returns {string|null} The current background skin, or the default if not set.
     */
  }, {
    key: "getBgSkin",
    value: function getBgSkin() {
      return _classPrivateFieldGet(_bgSkin, this) || _classPrivateFieldGet(_defaultBgSkin, this);
    }
    /**
     * Sets the text skin (style) of the dice numbers.
     * @param {string|null} skin - The skin name to apply to the text. Pass null or non-string to reset to default.
     */
  }, {
    key: "setTextSkin",
    value: function setTextSkin(skin) {
      _classPrivateFieldSet(_textSkin, this, typeof skin === 'string' && (0, _validateColor["default"])(skin) ? skin : null);
    }
    /**
     * Gets the currently applied text skin.
     * @returns {string|null} The current text skin, or the default if not set.
     */
  }, {
    key: "getTextSkin",
    value: function getTextSkin() {
      return _classPrivateFieldGet(_textSkin, this) || _classPrivateFieldGet(_defaultTextSkin, this);
    }
    /**
     * Sets the border skin (style) of the dice edges.
     * @param {string|null} skin - The skin name to apply to the border. Pass null or non-string to reset to default.
     */
  }, {
    key: "setBorderSkin",
    value: function setBorderSkin(skin) {
      _classPrivateFieldSet(_borderSkin, this, typeof skin === 'string' && _assertClassBrand(_TinyDices_brand, this, _isValidCssBorder).call(this, skin) ? skin : null);
    }
    /**
     * Gets the currently applied border skin.
     * @returns {string|null} The current border skin, or the default if not set.
     */
  }, {
    key: "getBorderSkin",
    value: function getBorderSkin() {
      return _classPrivateFieldGet(_borderSkin, this) || _classPrivateFieldGet(_defaultBorderSkin, this);
    }
    /**
     * Sets the background skin for selected dice.
     * Accepts valid CSS color strings or `linear-gradient(...)`.
     * Invalid values reset the skin to `null`.
     *
     * @param {string} skin - The CSS background to apply when a die is selected.
     */
  }, {
    key: "setSelectionBgSkin",
    value: function setSelectionBgSkin(skin) {
      if (typeof skin !== 'string') {
        _classPrivateFieldSet(_selectionBgSkin, this, null);
        return;
      }
      var trimmed = skin.trim();
      var isGradient = _assertClassBrand(_TinyDices_brand, this, _isValidLinearGradient).call(this, trimmed);
      var isColor = (0, _validateColor["default"])(trimmed);
      _classPrivateFieldSet(_selectionBgSkin, this, isGradient || isColor ? trimmed : null);
    }
    /**
     * Gets the background skin used for selected dice.
     * Returns the custom value if set; otherwise, returns the default.
     *
     * @returns {string|null} The current background skin for selected dice.
     */
  }, {
    key: "getSelectionBgSkin",
    value: function getSelectionBgSkin() {
      return _classPrivateFieldGet(_selectionBgSkin, this) || _classPrivateFieldGet(_defaultSelectionBgSkin, this);
    }
    /**
     * Sets the text color for selected dice.
     * Only valid CSS color values are accepted.
     * Invalid inputs will reset the color to `null`.
     *
     * @param {string} skin - The text color for selected dice.
     */
  }, {
    key: "setSelectionTextSkin",
    value: function setSelectionTextSkin(skin) {
      _classPrivateFieldSet(_selectionTextSkin, this, typeof skin === 'string' && (0, _validateColor["default"])(skin) ? skin : null);
    }
    /**
     * Gets the text color used for selected dice.
     * Returns the custom value if set; otherwise, returns the default.
     *
     * @returns {string|null} The current text color for selected dice.
     */
  }, {
    key: "getSelectionTextSkin",
    value: function getSelectionTextSkin() {
      return _classPrivateFieldGet(_selectionTextSkin, this) || _classPrivateFieldGet(_defaultSelectionTextSkin, this);
    }
    /**
     * Applies the current visual skin to a specific dice face element.
     * This includes background color, text color, border style, and optionally
     * a `background-image` if set via `setBgImg`.
     *
     * @param {HTMLElement} face - The HTML element representing a dice face.
     */
  }, {
    key: "updateDiceFaceSkin",
    value:
    /**
     * Updates the visual skin or style of a single dice face element.
     *
     * This is a public wrapper around the internal method `#updateDiceFaceSkin`,
     * allowing external calls to apply the dice face style dynamically.
     *
     * @param {HTMLElement} face - The DOM element representing a single face of the die.
     * @returns {void}
     */
    function updateDiceFaceSkin(face) {
      return _assertClassBrand(_TinyDices_brand, this, _updateDiceFaceSkin).call(this, face);
    }
    /**
     * Updates the visual skin of all dice face elements currently rendered.
     * Iterates through each dice in `this.#elements` and applies the active
     * background, text color, border, and background image styles using `#updateDiceFaceSkin`.
     *
     */
  }, {
    key: "updateDicesSkin",
    value: function updateDicesSkin() {
      for (var index in _classPrivateFieldGet(_elements, this)) this.updateDiceSkin(index);
    }
    /**
     * Updates the visual skin of a specific die by index.
     * Applies current background color, text color, border style, and background image
     * to all face elements of the selected die using `#updateDiceFaceSkin`.
     *
     * @param {number|string} index - The index of the die to update.
     * @throws {Error} If the index is not a valid number or string convertible to number.
     *
     * @returns {boolean} Returns `true` if the die was found and updated; otherwise `false`.
     */
  }, {
    key: "updateDiceSkin",
    value: function updateDiceSkin(index) {
      var parsedIndex = typeof index === 'string' ? parseInt(index) : typeof index === 'number' ? index : -1;
      if (Number.isNaN(parsedIndex)) throw new Error('updateDiceSkin: index must be a number or a numeric string.');
      var element = _classPrivateFieldGet(_elements, this)[parsedIndex];
      if (element) {
        for (var index2 in element.faces) _assertClassBrand(_TinyDices_brand, this, _updateDiceFaceSkin).call(this, element.faces[index2]);
        return true;
      } else return false;
    }
    /**
     * Generates a random integer between 1 and max (inclusive).
     * If `canZero` is true, the range becomes 0 to max (inclusive).
     *
     * @param {number} max - The maximum value for the roll (inclusive).
     * @param {boolean} [canZero=false] - Whether the result can include 0.
     * @returns {number} A random integer between 1 and max, or 0 and max if `canZero` is true. Returns 0 if max <= 0.
     */
  }, {
    key: "rollNumber",
    value:
    /**
     * Generates a random integer between a lower bound and a maximum value.
     *
     * This is a public wrapper for the internal method `#rollNumber`, which handles
     * dice-style number generation, optionally allowing zero as a result.
     *
     * @param {number} [max=0] - The maximum value (inclusive upper bound if `canZero` is true).
     * @param {boolean} [canZero=false] - If true, the roll can return 0 (or a range starting from 0).
     * @returns {number} A pseudo-random integer within the expected range.
     *
     * - If `canZero` is false: returns a number from 1 to `max`.
     * - If `canZero` is true: returns a number from 0 to `max`.
     * - If `max <= 0`: always returns 0.
     */
    function rollNumber() {
      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return _assertClassBrand(_TinyDices_brand, this, _rollNumber).call(this, max, canZero);
    }
    /**
     * Parses input parameters to determine the dice configuration.
     *
     * @param {string|Array<number>} perDieValues - Optional: a comma-separated string or array of individual max values.
     * @returns {number[]} - Parsed dice configuration.
     */
  }, {
    key: "parseRollConfig",
    value: function parseRollConfig() {
      var perDieValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      // Get per die data
      return typeof perDieValues === 'string' && perDieValues.length > 0 ? perDieValues.trim().split(',').map(function (raw) {
        var val = 0;
        try {
          val = parseInt(raw.trim(), 10);
        } catch (_unused) {
          val = 0;
        }
        if (typeof val === 'number' && !Number.isNaN(val) && Number.isFinite(val) && val > -1) return val;
        return -1;
      }) : Array.isArray(perDieValues) ? perDieValues : [];
    }
    /**
     * Inserts a single 3D die into the DOM with animation.
     *
     * @param {number} result - The value displayed on the front face of the die.
     * @param {number} max - The maximum value for the die (used to generate other random faces).
     * @param {boolean} [canZero=false] - Whether 0 is a valid face value.
     * @param {boolean} [rollInfinity=false] - Whether the die should spin indefinitely.
     *
     * @throws {Error} If `this.diceArea` is not a valid HTMLElement.
     * @throws {Error} If `this.#createCube` is not a function.
     * @throws {Error} If cube creation fails or returns an invalid sequence.
     * @returns {number[]} - An array representing the values on all six faces of the cube.
     */
  }, {
    key: "insertDiceElement",
    value: function insertDiceElement(result, max, canZero, rollInfinity) {
      if (typeof HTMLElement === 'undefined' || !(this.diceArea instanceof HTMLElement)) throw new Error('insertDiceElement: this.diceArea is not a valid HTMLElement.');
      if (typeof _classPrivateFieldGet(_createCube, this) !== 'function') throw new Error('insertDiceElement: this.#createCube is not a valid function.');
      var _classPrivateFieldGet2 = _classPrivateFieldGet(_createCube, this).call(this, result, max, canZero, rollInfinity),
        cube = _classPrivateFieldGet2.cube,
        sequence = _classPrivateFieldGet2.sequence;
      if (!Array.isArray(sequence)) throw new Error('insertDiceElement: invalid cube sequence returned.');
      this.diceArea.appendChild(cube);
      return sequence;
    }
    /**
     * Clears all dice cubes from the display area.
     * Resets internal cube counter to avoid z-index conflicts.
     */
  }, {
    key: "clearDiceArea",
    value: function clearDiceArea() {
      _classPrivateFieldSet(_cubeId, this, 0);
      if (typeof HTMLElement !== 'undefined' && this.diceArea instanceof HTMLElement) this.diceArea.innerHTML = '';
      _classPrivateFieldSet(_elements, this, []);
    }
    /**
     * Initializes the default cube creation function and assigns it to `this.#createCube`.
     *
     * This function builds a customizable cube with 6 animated faces, where each face is
     * assigned a unique number (avoiding duplicates when possible). The front face shows the
     * result value passed in, and the others are randomized based on the `max` value.
     *
     * @remarks
     * If `createCubeScript` was not provided to the constructor, this method sets up the default cube generator.
     *
     * @returns {void}
     *
     * @function
     */
  }, {
    key: "rollDice",
    value:
    /**
     * Inserts a single die cube into the DOM using the specified configuration.
     *
     * @param {number} max - Default maximum value for dice (if no individual values are given).
     * @param {boolean} [canZero=false] - Whether 0 is a valid result.
     * @param {boolean} [rollInfinity=false] - Whether all dice should spin infinitely.
     * @returns {{ result: number, sequence?: number[] }} - Array with results and face sequences for each die.
     */
    function rollDice(max) {
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rollInfinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var cube = {
        result: _assertClassBrand(_TinyDices_brand, this, _rollNumber).call(this, max, canZero)
      };
      if (_assertClassBrand(_TinyDices_brand, this, _existsHtml).call(this))
        // @ts-ignore
        cube.sequence = this.insertDiceElement(cube.result, max, canZero, rollInfinity);
      return cube;
    }
    /**
     * Inserts multiple dice cubes into the DOM using the specified configuration.
     *
     * @param {number[]} perDieData - Array of individual max values per die.
     * @param {boolean} [canZero=false] - Whether 0 is a valid result on any die.
     * @param {boolean} [rollInfinity=false] - Whether all dice should spin infinitely.
     * @returns {Array<{ result: number, sequence?: number[] }>} - Array with results and face sequences for each die.
     */
  }, {
    key: "rollDices",
    value: function rollDices(perDieData) {
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rollInfinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var cubes = [];
      for (var i = 0; i < perDieData.length; i++) {
        var max = perDieData[i];
        var cube = {
          result: _assertClassBrand(_TinyDices_brand, this, _rollNumber).call(this, max, canZero)
        };
        if (_assertClassBrand(_TinyDices_brand, this, _existsHtml).call(this))
          // @ts-ignore
          cube.sequence = this.insertDiceElement(cube.result, max, canZero, rollInfinity);
        cubes.push(cube);
      }
      return cubes;
    }
    /**
     * Rolls the dice by clearing existing cubes and inserting new ones.
     *
     * @param {string|Array<number>} perDieInput - Either a comma-separated string or array of max values per die.
     * @param {boolean} [canZero=false] - Whether 0 is a valid result.
     * @param {boolean} [rollInfinity=false] - Whether dice spin infinitely.
     * @returns {Array<{ result: number, sequence?: number[] }>} - Array with results and face sequences for each die.
     */
  }, {
    key: "roll",
    value: function roll(perDieInput) {
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rollInfinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var perDieData = this.parseRollConfig(perDieInput);
      this.clearDiceArea();
      return this.rollDices(perDieData, canZero, rollInfinity);
    }
    /**
     * Checks whether the TinyDices instance has been destroyed.
     *
     * @returns {boolean} - Returns `true` if the instance was destroyed, otherwise `false`.
     *
     * @example
     * if (dice.isDestroyed()) {
     *   console.warn('This instance is no longer usable.');
     * }
     */
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return _classPrivateFieldGet(_destroyed, this);
    }
    /**
     * Completely destroys the TinyDices instance by removing DOM elements and resetting internal state.
     *
     * This method:
     * - Clears all rendered dice.
     * - Empties the base DOM elements (container, diceBase, diceArea).
     * - Resets all visual skin configurations.
     * - Nullifies DOM references.
     * - Sets an internal flag to block further usage of the instance.
     *
     * @example
     * dice.destroy(); // ð£ Cleans up everything and makes the instance unusable
     */
  }, {
    key: "destroy",
    value: function destroy() {
      // Clear any dice already rendered
      this.clearDiceArea();
      // Remove container element content (optional: comment if you want to preserve it)
      if (typeof HTMLElement !== 'undefined') {
        if (this.container instanceof HTMLElement) this.container.innerHTML = '';
        if (_classPrivateFieldGet(_diceBase, this) instanceof HTMLElement) _classPrivateFieldGet(_diceBase, this).innerHTML = '';
        if (this.diceArea instanceof HTMLElement) this.diceArea.innerHTML = '';
      }
      // Optionally, unset the container reference
      _classPrivateFieldSet(_diceBase, this, null);
      this.diceArea = null;
      this.container = null;
      // Reset any styles or configs (if you store them in other properties, reset them here)
      _classPrivateFieldSet(_defaultBgSkin, this, null);
      _classPrivateFieldSet(_defaultBorderSkin, this, null);
      _classPrivateFieldSet(_defaultSelectionTextSkin, this, null);
      _classPrivateFieldSet(_defaultSelectionBgSkin, this, null);
      _classPrivateFieldSet(_defaultTextSkin, this, null);
      _classPrivateFieldSet(_selectionBgSkin, this, null);
      _classPrivateFieldSet(_selectionTextSkin, this, null);
      _classPrivateFieldSet(_bgSkin, this, null);
      _classPrivateFieldSet(_bgImg, this, null);
      _classPrivateFieldSet(_textSkin, this, null);
      _classPrivateFieldSet(_borderSkin, this, null);
      // Optionally, mark as destroyed to prevent further use
      _classPrivateFieldSet(_destroyed, this, true);
    }
  }]);
}();
function _existsHtml() {
  return typeof HTMLElement !== 'undefined' && _classPrivateFieldGet(_diceBase, this) instanceof HTMLElement ? true : false;
}
function _addElement(item) {
  if ((0, _tinyEssentials.objType)(item, 'object') && Array.isArray(item.faces) && typeof HTMLElement !== 'undefined' && item.container instanceof HTMLElement && item.wrapper instanceof HTMLElement) {
    _classPrivateFieldGet(_elements, this).push(item);
    return true;
  }
  return false;
}
function _isValidDataImage(value) {
  if (typeof value !== 'string') return false;
  var normalized = value.trim();
  // Only allow data:image/... base64 or URL-encoded images
  var dataUrlPattern = /^data:image\/(png|jpeg|jpg|gif|webp);base64,[a-z0-9+\/=]+$/i;
  return dataUrlPattern.test(normalized);
}
/**
 * Validates a linear-gradient string to prevent unsafe or malformed styles.
 *
 * @param {string} value - The CSS gradient string.
 * @returns {boolean}
 */
function _isValidLinearGradient(value) {
  if (typeof value !== 'string') return false;
  var normalized = value.trim().toLowerCase();
  // Must start with 'linear-gradient(' and end with ')'
  if (!normalized.startsWith('linear-gradient(') || !normalized.endsWith(')')) {
    return false;
  }
  // Block unsafe patterns
  var unsafePattern = /(url\s*\(|expression\s*\(|javascript:|<|>|data:)/i;
  if (unsafePattern.test(value)) {
    return false;
  }
  // Extract content inside the parentheses
  var content = value.slice(value.indexOf('(') + 1, -1).trim();
  if (!content) return false;
  // Safe split by commas outside of parentheses
  var parts = [];
  var buffer = '';
  var depth = 0;
  var _iterator = _createForOfIteratorHelper(content),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _char = _step.value;
      if (_char === '(') depth++;
      if (_char === ')') depth--;
      if (_char === ',' && depth === 0) {
        parts.push(buffer.trim());
        buffer = '';
      } else {
        buffer += _char;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (buffer.trim()) parts.push(buffer.trim());
  if (parts.length < 1) return false; // needs at least one component
  var colorCount = 0;
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    // First item can optionally be a direction or angle
    if (i === 0 && /^(to\s+\w+|\d+deg|[+-]?\d+rad|[+-]?\d+turn)$/i.test(part)) {
      continue;
    }
    if ((0, _validateColor["default"])(part.trim())) {
      colorCount++;
    } else {
      // Extract possible color value before any stop (e.g. "red 20%" â "red")
      var colorCandidate = part.trim().split(/\s+/)[0];
      if ((0, _validateColor["default"])(colorCandidate)) {
        colorCount++;
      } else {
        return false; // invalid color
      }
    }
  }
  // Must have at least 1 valid color and no more than 50
  return colorCount >= 1 && colorCount <= 50;
}
/**
 * Validates a CSS border string like '1px solid red' or '2px dashed linear-gradient(...)'.
 *
 * @param {string} value - The CSS border string.
 * @returns {boolean}
 */
function _isValidCssBorder(value) {
  if (typeof value !== 'string') return false;
  var parts = value.trim().split(/\s+/);
  if (parts.length < 3) return false;
  var _parts = _toArray(parts),
    width = _parts[0],
    style = _parts[1],
    colorParts = _parts.slice(2);
  var color = colorParts.join(' ');
  // Validate width (basic check for length units)
  var isValidWidth = /^(\d+(\.\d+)?)(px|em|rem|%)$/.test(width);
  if (!isValidWidth) return false;
  // Validate border style
  var validStyles = ['none', 'solid', 'dashed', 'dotted', 'double', 'groove', 'ridge', 'inset', 'outset', 'hidden'];
  if (!validStyles.includes(style)) return false;
  // Validate color (either direct or linear-gradient)
  return (0, _validateColor["default"])(color) || _assertClassBrand(_TinyDices_brand, this, _isValidLinearGradient).call(this, color);
}
function _updateDiceFaceSkin(face) {
  // Skin
  face.style.background = this.getBgSkin() || '';
  face.style.color = this.getTextSkin() || '';
  face.style.border = this.getBorderSkin() || '';
  face.style.setProperty('--dice-selection-bg', this.getSelectionBgSkin());
  face.style.setProperty('--dice-selection-text', this.getSelectionTextSkin());
  // Background image
  var bgImg = this.getBgImg();
  if (bgImg) {
    face.style.backgroundImage = "url(\"".concat(bgImg, "\")");
    face.style.backgroundPosition = 'center';
    face.style.backgroundSize = '100%';
    face.style.backgroundRepeat = 'repeat';
  }
}
function _rollNumber() {
  var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  // Throw an error if the value is not a valid number
  if (typeof max !== 'number' || Number.isNaN(max)) {
    throw new Error("Invalid die max value: ".concat(max, ". All values must be positive numbers."));
  }
  // Valid number
  if (max > 0) {
    var maxValue = max;
    var finalValue = 1;
    if (canZero) {
      maxValue++;
      finalValue--;
    }
    return Math.floor(Math.random() * maxValue) + finalValue;
  } else return 0;
}
function _insertCreateCube() {
  var tinyDice = this;
  /** @type {function(number, number, boolean=, boolean=): CubeResult} */
  _classPrivateFieldSet(_createCube, this, function (result, max) {
    var canZero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var rollInfinity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    // Container
    /** @type {DiceElement} */
    var diceElements = {
      faces: [],
      container: null,
      wrapper: null
    };
    var container = document.createElement('div');
    container.className = 'dice-container';
    container.style.zIndex = String(1000 + tinyDice.addCubeId()); // each dice with higher priority
    diceElements.container = container;
    // Wrapper
    var wrapper = document.createElement('div');
    wrapper.className = "cube-wrapper".concat(rollInfinity ? " spin-infinite" : '');
    diceElements.wrapper = wrapper;
    // Get rot
    var rotX = 360 * (3 + Math.floor(Math.random() * 5));
    var rotY = 360 * (3 + Math.floor(Math.random() * 5));
    // Wrapper animation
    wrapper.style.animation = "tinyDiceSpinCubeCustom 2s ease-in-out forwards";
    wrapper.style.setProperty('--rotX', "".concat(rotX, "deg"));
    wrapper.style.setProperty('--rotY', "".concat(rotY, "deg"));
    // Create the cube
    var sequence = [];
    var countSeq = new Set();
    var min = !canZero ? 0 : -1;
    for (var i = 1; i <= 6; i++) {
      // Element
      var face = document.createElement('div');
      face.className = "face face".concat(i);
      _assertClassBrand(_TinyDices_brand, tinyDice, _updateDiceFaceSkin).call(tinyDice, face);
      // Ignored results
      if (i !== 1) {
        var roll = void 0;
        // Normal max
        if (max > min) {
          var extraValue = min;
          var usingExtra = false;
          do {
            roll = !usingExtra ? _assertClassBrand(_TinyDices_brand, tinyDice, _rollNumber).call(tinyDice, max, canZero) : extraValue;
            if (usingExtra || sequence.length >= max) {
              if (extraValue >= max) {
                extraValue = min;
                countSeq.clear();
              }
              extraValue++;
              usingExtra = true;
            }
          } while (countSeq.has(roll));
        }
        // 0 or negative max
        else roll = max;
        // Insert sequence
        if (roll < 1) roll = 0;
        sequence.push(roll);
        countSeq.add(roll);
        face.textContent = String(roll);
      }
      // The result!
      else {
        face.textContent = String(result);
        sequence.push(result);
        countSeq.add(result);
      }
      // Side added
      wrapper.appendChild(face);
      diceElements.faces.push(face);
    }
    // Stop cube animation
    if (!rollInfinity) {
      setTimeout(function () {
        if (wrapper) wrapper.classList.add('stopped');
      }, 2000);
    }
    // Insert the cube
    container.appendChild(wrapper);
    _assertClassBrand(_TinyDices_brand, tinyDice, _addElement).call(tinyDice, diceElements);
    return {
      cube: container,
      sequence: sequence
    };
  });
}
var _default = exports["default"] = TinyDices;

},{"tiny-essentials":162,"validate-color":205}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = arraySortPositions;
/**
 * Generates a comparator function to sort an array of objects by a given key.
 *
 * @param {string} item - The object key to sort by.
 * @param {boolean} [isReverse=false] - If `true`, the sorting will be in descending order.
 * @returns {(a: Object<string|number, *>, b: Object<string|number, *>) => number} Comparator function compatible with Array.prototype.sort().
 *
 * @example
 * const arr = [{ pos: 2 }, { pos: 1 }, { pos: 3 }];
 * arr.sort(arraySortPositions('pos')); // Ascending: [{pos: 1}, {pos: 2}, {pos: 3}]
 *
 * @example
 * const arr = [{ pos: 2 }, { pos: 1 }, { pos: 3 }];
 * arr.sort(arraySortPositions('pos', true)); // Descending: [{pos: 3}, {pos: 2}, {pos: 1}]
 */
function arraySortPositions(item) {
  var isReverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!isReverse) {
    return function (a, b) {
      return a[item] < b[item] ? -1 : a[item] > b[item] ? 1 : 0;
    };
  } else {
    return function (a, b) {
      return a[item] > b[item] ? -1 : a[item] < b[item] ? 1 : 0;
    };
  }
}

},{}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = asyncReplace;
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Asynchronously replaces matches in a string using a regex and an async function.
 *
 * @param {string} str - The input string to perform replacements on.
 * @param {RegExp} regex - The regular expression to match substrings for replacement.
 * @param {Function} asyncFn - An asynchronous function that returns a replacement for each match.
 *                             It receives the same arguments as a standard `replace` callback.
 * @returns {Promise<string>} The resulting string with all async replacements applied.
 *
 * @example
 * await asyncReplace("Hello @user1 and @user2!", /@\w+/g, async (mention) => {
 *   return await getUserNameFromMention(mention);
 * });
 */
function asyncReplace(_x, _x2, _x3) {
  return _asyncReplace.apply(this, arguments);
}
function _asyncReplace() {
  _asyncReplace = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(str, regex, asyncFn) {
    var promises, data;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          /**
           * @type {any[]}
           */
          promises = []; // Collect promises
          str.replace(regex, function (match) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            promises.push(asyncFn.apply(void 0, [match].concat(args)));
            return match;
          });
          _context.n = 1;
          return Promise.all(promises);
        case 1:
          data = _context.v;
          return _context.a(2, str.replace(regex, function () {
            return data.shift();
          }));
      }
    }, _callee);
  }));
  return _asyncReplace.apply(this, arguments);
}

},{}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Represents a user object used.
 *
 * @typedef {Object} UserEditor
 * @property {number} exp - Current experience points of the user.
 * @property {number} level - Current level of the user.
 * @property {number} totalExp - Total accumulated experience.
 */
/**
 * Class to manage user level-up logic based on experience points.
 */
var TinyLevelUp = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {number} giveExp - Base experience value for random experience generation.
   * @param {number} expLevel - Base experience needed to level up (per level).
   */
  function TinyLevelUp(giveExp, expLevel) {
    _classCallCheck(this, TinyLevelUp);
    if (typeof giveExp !== 'number' || Number.isNaN(giveExp)) throw new Error('giveExp must be a valid number');
    if (typeof expLevel !== 'number' || Number.isNaN(expLevel)) throw new Error('expLevel must be a valid number');
    this.giveExp = giveExp;
    this.expLevel = expLevel;
  }
  /**
   * Creates a new user object starting at level 0 with 0 experience.
   * @returns {UserEditor} A fresh user object.
   */
  return _createClass(TinyLevelUp, [{
    key: "createUser",
    value: function createUser() {
      return {
        exp: 0,
        level: 1,
        totalExp: 0
      };
    }
    /**
     * Validates if the given user object has valid numeric properties.
     * Throws an error if any property is invalid.
     *
     * @param {UserEditor} user - The user object to validate.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "validateUser",
    value: function validateUser(user) {
      if (typeof user.exp !== 'number' || Number.isNaN(user.exp)) throw new Error('exp must be a valid number');
      if (typeof user.level !== 'number' || Number.isNaN(user.level)) throw new Error('level must be a valid number');
      if (user.level < 1) throw new Error('level must be at least 1');
      if (typeof user.totalExp !== 'number' || Number.isNaN(user.totalExp)) throw new Error('totalExp must be a valid number');
    }
    /**
     * Checks if the given user object is valid by verifying its numeric properties.
     *
     * @param {UserEditor} user - The user object to check.
     * @returns {boolean} `true` if all properties (exp, level, totalExp) are valid numbers; otherwise `false`.
     */
  }, {
    key: "isValidUser",
    value: function isValidUser(user) {
      if (typeof user.exp !== 'number' || Number.isNaN(user.exp)) return false;
      if (typeof user.level !== 'number' || Number.isNaN(user.level)) return false;
      if (user.level < 1) return false;
      if (typeof user.totalExp !== 'number' || Number.isNaN(user.totalExp)) return false;
      return true;
    }
    /**
     * Returns the base experience value used for random experience generation.
     * Throws an error if the internal giveExp value is not a valid number.
     *
     * @returns {number} The base experience value.
     * @throws {Error} If giveExp is not a valid number.
     */
  }, {
    key: "getGiveExpBase",
    value: function getGiveExpBase() {
      if (typeof this.giveExp !== 'number' || Number.isNaN(this.giveExp)) throw new Error('giveExp must be a valid number');
      return this.giveExp;
    }
    /**
     * Returns the base experience required to level up.
     * Throws an error if the internal expLevel value is not a valid number.
     *
     * @returns {number} The base experience needed per level.
     * @throws {Error} If expLevel is not a valid number.
     */
  }, {
    key: "getExpLevelBase",
    value: function getExpLevelBase() {
      if (typeof this.expLevel !== 'number' || Number.isNaN(this.expLevel)) throw new Error('expLevel must be a valid number');
      return this.expLevel;
    }
    /**
     * Validates and adjusts the user's level based on their current experience.
     * @param {UserEditor} user - The user object containing experience and level properties.
     * @returns {UserEditor} The updated user object.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "expValidator",
    value: function expValidator(user) {
      var expLevel = this.getExpLevelBase();
      this.validateUser(user);
      var extraValue = 0;
      var nextLevelExp = expLevel * user.level;
      // Level Up
      if (user.exp >= nextLevelExp) {
        user.level++;
        extraValue = user.exp - nextLevelExp;
        user.exp = 0;
        if (extraValue > 0) return this.give(user, extraValue, 'extra');
      }
      // Level Down
      if (user.exp < 1 && user.level > 1) {
        user.level--;
        extraValue = Math.abs(user.exp);
        user.exp = expLevel * user.level;
        if (extraValue > 0) return this.remove(user, extraValue, 'extra');
      }
      return user;
    }
    /**
     * Calculates the total experience based on the user's level.
     * @param {UserEditor} user - The user object containing experience and level properties.
     * @returns {number} The total experience of the user.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "getTotalExp",
    value: function getTotalExp(user) {
      this.validateUser(user);
      var totalExp = 0;
      for (var p = 1; p <= user.level; p++) totalExp += this.getExpLevelBase() * p;
      totalExp += user.exp;
      return totalExp;
    }
    /**
     * Generates random experience points based on the configured multiplier.
     * @param {number} [multi] - A multiplier for the generated experience.
     * @returns {number} The generated experience points.
     */
  }, {
    key: "expGenerator",
    value: function expGenerator() {
      var multi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      if (typeof multi !== 'number' || Number.isNaN(multi)) throw new Error('multi must be a valid number');
      return Math.floor(Math.random() * this.getGiveExpBase()) * multi;
    }
    /**
     * Calculates how much experience is missing to next level.
     * @param {UserEditor} user
     * @returns {number}
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "getMissingExp",
    value: function getMissingExp(user) {
      return this.getProgress(user) - user.exp;
    }
    /**
     * Gets the experience points required to reach the next level.
     * @param {UserEditor} user - The user object containing the level.
     * @returns {number} The experience required for the next level.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "progress",
    value: function progress(user) {
      return this.getProgress(user);
    }
    /**
     * Gets the experience points required to reach the next level.
     * @param {UserEditor} user - The user object containing the level.
     * @returns {number} The experience required for the next level.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "getProgress",
    value: function getProgress(user) {
      this.validateUser(user);
      return this.getExpLevelBase() * user.level;
    }
    /**
     * Sets the experience value for the user, adjusting their level if necessary.
     * @param {UserEditor} user - The user object.
     * @param {number} value - The new experience value to set.
     * @returns {UserEditor} The updated user object.
     */
  }, {
    key: "set",
    value: function set(user, value) {
      if (typeof value !== 'number' || Number.isNaN(value)) throw new Error('value must be a valid number');
      user.exp = value;
      this.expValidator(user);
      user.totalExp = this.getTotalExp(user);
      return user;
    }
    /**
     * Adds experience to the user, adjusting their level if necessary.
     * @param {UserEditor} user - The user object.
     * @param {number} [extraExp] - Additional experience to be added.
     * @param {'add' | 'extra'} [type] - Type of addition ('add' or 'extra').
     * @param {number} [multi] - Multiplier for experience generation.
     * @returns {UserEditor} The updated user object.
     */
  }, {
    key: "give",
    value: function give(user) {
      var extraExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'add';
      var multi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if (typeof multi !== 'number' || Number.isNaN(multi)) throw new Error('multi must be a valid number');
      if (typeof extraExp !== 'number' || Number.isNaN(extraExp)) throw new Error('extraExp must be a valid number');
      if (typeof type !== 'string') throw new Error('type must be a valid string');
      if (type === 'add') user.exp += this.expGenerator(multi) + extraExp;else if (type === 'extra') user.exp += extraExp;
      this.expValidator(user);
      user.totalExp = this.getTotalExp(user);
      return user;
    }
    /**
     * Removes experience from the user, adjusting their level if necessary.
     * @param {UserEditor} user - The user object.
     * @param {number} [extraExp] - Additional experience to remove.
     * @param {'add' | 'extra'} [type] - Type of removal ('add' or 'extra').
     * @param {number} [multi] - Multiplier for experience generation.
     * @returns {UserEditor} The updated user object.
     */
  }, {
    key: "remove",
    value: function remove(user) {
      var extraExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'add';
      var multi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if (typeof multi !== 'number' || Number.isNaN(multi)) throw new Error('multi must be a valid number');
      if (typeof extraExp !== 'number' || Number.isNaN(extraExp)) throw new Error('extraExp must be a valid number');
      if (typeof type !== 'string') throw new Error('type must be a valid string');
      if (type === 'add') user.exp -= this.expGenerator(multi) + extraExp;else if (type === 'extra') user.exp -= extraExp;
      this.expValidator(user);
      user.totalExp = this.getTotalExp(user);
      return user;
    }
  }]);
}();
var _default = exports["default"] = TinyLevelUp;

},{}],157:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shuffleArray = shuffleArray;
// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
/**
 * Randomly shuffles the elements of an array in place using the FisherâYates algorithm.
 *
 * This implementation ensures a uniform distribution of permutations.
 * Original algorithm source: StackOverflow (link above).
 *
 * @param {any[]} items - The array to shuffle.
 * @returns {any[]} The same array instance, now shuffled in place.
 */
function shuffleArray(items) {
  var currentIndex = items.length,
    randomIndex;
  // While there remain elements to shuffle...
  while (currentIndex !== 0) {
    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    // And swap it with the current element.
    var _ref = [items[randomIndex], items[currentIndex]];
    items[currentIndex] = _ref[0];
    items[randomIndex] = _ref[1];
  }
  return items;
}

},{}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatCustomTimer = formatCustomTimer;
exports.formatDayTimer = formatDayTimer;
exports.formatTimer = formatTimer;
exports.getTimeDuration = getTimeDuration;
/**
 * Calculates the time duration between the current time and a given time offset.
 *
 * @param {Date} timeData - The target time as a Date object.
 * @param {string} [durationType='asSeconds'] - The type of duration to return. Can be 'asMilliseconds', 'asSeconds', 'asMinutes', 'asHours', 'asDays'.
 * @param {Date|null} [now=null] - The current time as a Date object. Defaults to the current date and time if not provided.
 * @returns {number|null} The calculated duration in the specified unit, or `null` if `timeData` is not provided.
 */
function getTimeDuration() {
  var timeData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  var durationType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'asSeconds';
  var now = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (timeData instanceof Date) {
    var currentTime = now instanceof Date ? now : new Date();
    /** @type {number} */
    var diffMs = timeData.getTime() - currentTime.getTime();
    switch (durationType) {
      case 'asMilliseconds':
        return diffMs;
      case 'asSeconds':
        return diffMs / 1000;
      case 'asMinutes':
        return diffMs / (1000 * 60);
      case 'asHours':
        return diffMs / (1000 * 60 * 60);
      case 'asDays':
        return diffMs / (1000 * 60 * 60 * 24);
      default:
        return diffMs / 1000;
      // default to seconds
    }
  }
  return null;
}
/**
 * Formats a custom timer string based on total seconds and a detail level.
 * Includes proper reallocation of lower units into higher ones, ensuring consistent hierarchy.
 *
 * @param {number} totalSeconds - The total amount of seconds to convert.
 * @param {'seconds'|'minutes'|'hours'|'days'|'months'|'years'} [level] - The highest level to calculate and display.
 * @param {string} [format='{time}'] - Output template with placeholders like {years}, {months}, {days}, {hours}, {minutes}, {seconds}, {time}, {total}.
 * @returns {string} The formatted timer string.
 */
function formatCustomTimer(totalSeconds) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'seconds';
  var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '{time}';
  totalSeconds = Math.max(0, Math.floor(totalSeconds));
  var levels = ['seconds', 'minutes', 'hours', 'days', 'months', 'years'];
  var index = levels.indexOf(level);
  var include = {
    years: index >= 5,
    months: index >= 4,
    days: index >= 3,
    hours: index >= 2,
    minutes: index >= 1,
    seconds: index >= 0
  };
  /**
   * @type {{
   *   years: number|NaN,
   *   months: number|NaN,
   *   days: number|NaN,
   *   hours: number|NaN,
   *   minutes: number|NaN,
   *   seconds: number|NaN,
   *   total: number|NaN
   * }}
   */
  var parts = {
    years: include.years ? 0 : NaN,
    months: include.months ? 0 : NaN,
    days: include.days ? 0 : NaN,
    hours: include.hours ? 0 : NaN,
    minutes: include.minutes ? 0 : NaN,
    seconds: include.seconds ? 0 : NaN,
    total: NaN
  };
  var remaining = totalSeconds;
  if (include.years || include.months || include.days) {
    var baseDate = new Date(1980, 0, 1);
    var targetDate = new Date(baseDate.getTime() + remaining * 1000);
    var workingDate = new Date(baseDate);
    // Years
    if (include.years) {
      while (new Date(workingDate.getFullYear() + 1, workingDate.getMonth(), workingDate.getDate()).getTime() <= targetDate.getTime()) {
        workingDate.setFullYear(workingDate.getFullYear() + 1);
        parts.years++;
      }
    }
    // Months
    if (include.months) {
      while (new Date(workingDate.getFullYear(), workingDate.getMonth() + 1, workingDate.getDate()).getTime() <= targetDate.getTime()) {
        workingDate.setMonth(workingDate.getMonth() + 1);
        parts.months++;
      }
    }
    // Days
    if (include.days) {
      while (new Date(workingDate.getFullYear(), workingDate.getMonth(), workingDate.getDate() + 1).getTime() <= targetDate.getTime()) {
        workingDate.setDate(workingDate.getDate() + 1);
        parts.days++;
      }
    }
    remaining = Math.floor((targetDate.getTime() - workingDate.getTime()) / 1000);
  }
  if (include.hours) {
    parts.hours = Math.floor(remaining / 3600);
    remaining %= 3600;
  }
  if (include.minutes) {
    parts.minutes = Math.floor(remaining / 60);
    remaining %= 60;
  }
  if (include.seconds) {
    parts.seconds = remaining;
  }
  // Calculate total
  var totalMap = {
    seconds: include.seconds ? totalSeconds : NaN,
    minutes: include.minutes ? totalSeconds / 60 : NaN,
    hours: include.hours ? totalSeconds / 3600 : NaN,
    days: include.days ? totalSeconds / 86400 : NaN,
    months: include.months ? parts.years * 12 + parts.months + (parts.days || 0) / 30 : NaN,
    years: include.years ? parts.years + (parts.months || 0) / 12 + (parts.days || 0) / 365 : NaN
  };
  parts.total = +(totalMap[level] || 0).toFixed(2).replace(/\.00$/, '');
  /**
   * Pads a number to ensure it is at least two digits long, using leading zeros if necessary.
   *
   * @param {number|string} n - The number or string to pad.
   * @returns {string} The padded string.
   */
  var pad = function pad(n) {
    var num = typeof n === 'string' ? parseInt(n) : n;
    return Number.isNaN(num) ? 'NaN' : String(num).padStart(2, '0');
  };
  var timeString = [include.hours ? pad(parts.hours) : null, include.minutes ? pad(parts.minutes) : null, include.seconds ? pad(parts.seconds) : null].filter(function (v) {
    return v !== null;
  }).join(':');
  return format.replace(/\{years\}/g, String(parts.years)).replace(/\{months\}/g, String(parts.months)).replace(/\{days\}/g, String(parts.days)).replace(/\{hours\}/g, pad(parts.hours)).replace(/\{minutes\}/g, pad(parts.minutes)).replace(/\{seconds\}/g, pad(parts.seconds)).replace(/\{time\}/g, timeString).replace(/\{total\}/g, String(parts.total)).trim();
}
/**
 * Formats a duration (in seconds) into a timer string showing only hours, minutes, and seconds.
 *
 * Example output: "05:32:10"
 *
 * @param {number} seconds - The total number of seconds to format.
 * @returns {string} The formatted timer string in "HH:MM:SS" format.
 */
function formatTimer(seconds) {
  return formatCustomTimer(seconds, 'hours', '{hours}:{minutes}:{seconds}');
}
/**
 * Formats a duration (in seconds) into a timer string including days, hours, minutes, and seconds.
 *
 * Example output: "2d 05:32:10"
 *
 * @param {number} seconds - The total number of seconds to format.
 * @returns {string} The formatted timer string in "Xd HH:MM:SS" format.
 */
function formatDayTimer(seconds) {
  return formatCustomTimer(seconds, 'days', '{days}d {hours}:{minutes}:{seconds}');
}

},{}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkObj = checkObj;
exports.cloneObjTypeOrder = cloneObjTypeOrder;
exports.countObj = countObj;
exports.extendObjType = extendObjType;
exports.getCheckObj = getCheckObj;
exports.isJsonObject = isJsonObject;
exports.objType = objType;
exports.reorderObjTypeOrder = reorderObjTypeOrder;
var _buffer = require("buffer");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
/**
 * An object containing type validation functions and their evaluation order.
 *
 * Each item in `typeValidator.items` is a function that receives any value
 * and returns a boolean indicating whether the value matches the corresponding type.
 *
 * The `order` array defines the priority in which types should be checked,
 * which can be useful for functions that infer types in a consistent manner.
 *
 */
var typeValidator = {
  items: {},
  /**
   * Evaluation order of the type checkers.
   * @type {string[]}
   * */
  order: []
};
/** @typedef {Object.<string, (val: any) => *>} ExtendObjType */
/** @typedef {Array<[string, (val: any) => *]>} ExtendObjTypeArray */
/**
 * Adds new type checkers to the typeValidator without overwriting existing ones.
 *
 * Accepts either an object with named functions or an array of [key, fn] arrays.
 * If no index is provided, the type is inserted just before 'object' (if it exists), or at the end.
 *
 * @param {ExtendObjType|ExtendObjTypeArray} newItems
 *        - New type validators to be added.
 * @param {number} [index] - Optional. Position at which to insert each new type. Ignored if the type already exists.
 * @returns {string[]} - A list of successfully added type names.
 *
 * @example
 * extendObjType({
 *   htmlElement2: val => typeof HTMLElement !== 'undefined' && val instanceof HTMLElement
 * });
 *
 * @example
 * extendObjType([
 *   ['alpha', val => typeof val === 'string'],
 *   ['beta', val => Array.isArray(val)]
 * ]);
 */
function extendObjType(newItems, index) {
  var added = [];
  var entries = Array.isArray(newItems) ? newItems : Object.entries(newItems);
  var _iterator = _createForOfIteratorHelper(entries),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        key = _step$value[0],
        fn = _step$value[1];
      if (!typeValidator.items.hasOwnProperty(key)) {
        // @ts-ignore
        typeValidator.items[key] = fn;
        var insertAt = typeof index === 'number' ? index : -1; // Default to -1 if index isn't provided
        // Default to before 'object', or to the end
        if (insertAt === -1) {
          var objectIndex = typeValidator.order.indexOf('object');
          insertAt = objectIndex > -1 ? objectIndex : typeValidator.order.length;
        }
        // Ensure insertAt is a valid number and not out of bounds
        insertAt = Math.min(Math.max(0, insertAt), typeValidator.order.length);
        typeValidator.order.splice(insertAt, 0, key);
        added.push(key);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return added;
}
/**
 * Reorders the typeValidator.order array according to a custom new order.
 * All values in the new order must already exist in the current order.
 * The function does not mutate the original array structure directly.
 *
 * @param {string[]} newOrder - The new order of type names.
 * @returns {boolean} - Returns true if the reorder was successful, false if invalid keys were found.
 *
 * @example
 * reorderObjTypeOrder([
 *   'string', 'number', 'array', 'object'
 * ]);
 */
function reorderObjTypeOrder(newOrder) {
  var currentOrder = _toConsumableArray(typeValidator.order); // shallow clone
  // All keys in newOrder must exist in currentOrder
  var isValid = newOrder.every(function (type) {
    return currentOrder.includes(type);
  });
  if (!isValid) return false;
  // Reassign only if valid
  typeValidator.order = newOrder.slice(); // assign shallow copy
  return true;
}
/**
 * Returns a cloned version of the `typeValidator.order` array.
 * The cloned array will not be affected by future changes to the original `order`.
 *
 * @returns {string[]} - A new array with the same values as `typeValidator.order`.
 */
function cloneObjTypeOrder() {
  return _toConsumableArray(typeValidator.order); // Creates a shallow copy of the array
}
/**
 * Returns the detected type name of a given value based on predefined type validators.
 *
 * This function uses `getType` with a predefined `typeValidator` to determine or compare types safely.
 * in the specified `typeValidator.order`. The first matching type is returned.
 *
 * If `val` is `null`, it immediately returns `'null'`.
 * If no match is found, it returns `'unknown'`.
 *
 * @param {any} val - The value whose type should be determined.
 * @returns {string} - The type name of the value (e.g., "array", "date", "map"), or "unknown" if no match is found.
 *
 * @example
 * getType([]); // "array"
 * getType(null); // "null"
 * getType(new Set()); // "set"
 * getType(() => {}); // "unknown"
 */
var getType = function getType(val) {
  if (val === null) return 'null';
  // @ts-ignore
  var _iterator2 = _createForOfIteratorHelper(typeValidator.order),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var name = _step2.value;
      // @ts-ignore
      if (typeof typeValidator.items[name] !== 'function' || typeValidator.items[name](val)) return name;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return 'unknown';
};
/**
 * Checks the type of a given object or returns its type as a string.
 *
 * @param {*} obj - The object to check or identify.
 * @param {string} [type] - Optional. If provided, checks whether the object matches this type (e.g., "object", "array", "string").
 * @returns {boolean|string|null} - Returns `true` if the type matches, `false` if not,
 *                                   the type string if no type is provided, or `null` if the object is `undefined`.
 *
 * @example
 * objType([], 'array'); // true
 * objType({}, 'object'); // true
 * objType('hello'); // "string"
 * objType(undefined); // null
 */
function objType(obj, type) {
  if (typeof obj === 'undefined') return null;
  var result = getType(obj);
  if (typeof type === 'string') return result === type.toLowerCase();
  return result;
}
/**
 * Checks the type of a given object and returns the validation value if a known type is detected.
 *
 * @param {*} obj - The object to check or identify.
 * @returns {{ valid:*; type: string | null }} - Returns the type result.
 */
function checkObj(obj) {
  /** @type {{ valid:*; type: string | null }} */
  var data = {
    valid: null,
    type: null
  };
  var _iterator3 = _createForOfIteratorHelper(typeValidator.order),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var name = _step3.value;
      // @ts-ignore
      if (typeof typeValidator.items[name] === 'function') {
        // @ts-ignore
        var result = typeValidator.items[name](obj);
        if (result) {
          data.valid = result;
          data.type = name;
          break;
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return data;
}
/**
 * Creates a clone of the functions from the `typeValidator` object.
 * It returns a new object where the keys are the same and the values are the cloned functions.
 */
function getCheckObj() {
  return Object.fromEntries(Object.entries(typeValidator.items).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[0],
      fn = _ref2[1];
    return [key, fn];
  }));
}
/**
 * Counts the number of elements in an array or the number of properties in an object.
 *
 * @param {Array<*>|Record<string|number, any>} obj - The array or object to count.
 * @returns {number} - The count of items (array elements or object keys), or `0` if the input is neither an array nor an object.
 *
 * @example
 * countObj([1, 2, 3]); // 3
 * countObj({ a: 1, b: 2 }); // 2
 * countObj('not an object'); // 0
 */
function countObj(obj) {
  // Is Array
  if (Array.isArray(obj)) return obj.length;
  // Object
  if (objType(obj, 'object')) return Object.keys(obj).length;
  // Nothing
  return 0;
}
/**
 * Determines whether a given value is a pure JSON object (plain object).
 *
 * A pure object satisfies the following:
 * - It is not null.
 * - Its type is "object".
 * - Its internal [[Class]] is "[object Object]".
 * - It is not an instance of built-in types like Array, Date, Map, Set, etc.
 *
 * This function is useful for strict data validation when you want to ensure
 * a value is a clean JSON-compatible object, free of class instances or special types.
 *
 * @param {unknown} value - The value to test.
 * @returns {value is Record<string | number | symbol, unknown>} Returns true if the value is a pure object.
 */
function isJsonObject(value) {
  if (value === null || _typeof(value) !== 'object') return false;
  if (Array.isArray(value)) return false;
  if (Object.prototype.toString.call(value) !== '[object Object]') return false;
  return true;
}
// Insert obj types
extendObjType([['undefined', /** @param {*} val @returns {val is undefined} */
function (val) {
  return typeof val === 'undefined';
}], ['null', /** @param {*} val @returns {val is null} */
function (val) {
  return val === null;
}], ['boolean', /** @param {*} val @returns {val is boolean} */
function (val) {
  return typeof val === 'boolean';
}], ['number', /** @param {*} val @returns {val is number} */
function (val) {
  return typeof val === 'number' && !Number.isNaN(val);
}], ['bigint', /** @param {*} val @returns {val is bigint} */
function (val) {
  return typeof val === 'bigint';
}], ['string', /** @param {*} val @returns {val is string} */
function (val) {
  return typeof val === 'string';
}], ['symbol', /** @param {*} val @returns {val is symbol} */
function (val) {
  return _typeof(val) === 'symbol';
}], ['function', /** @param {*} val @returns {val is Function} */
function (val) {
  return typeof val === 'function';
}], ['array', /** @param {*} val @returns {val is any[]} */
function (val) {
  return Array.isArray(val);
}]]);
if (!isBrowser) {
  extendObjType([['buffer', /** @param {*} val @returns {val is Buffer} */
  function (val) {
    return typeof _buffer.Buffer !== 'undefined' && _buffer.Buffer.isBuffer(val);
  }]]);
}
if (isBrowser) {
  extendObjType([['file', /** @param {*} val @returns {val is File} */
  function (val) {
    return typeof File !== 'undefined' && val instanceof File;
  }]]);
}
extendObjType([['date', /** @param {*} val @returns {val is Date} */
function (val) {
  return val instanceof Date;
}], ['regexp', /** @param {*} val @returns {val is RegExp} */
function (val) {
  return val instanceof RegExp;
}], ['map', /** @param {*} val @returns {val is Map<unknown, unknown>} */
function (val) {
  return val instanceof Map;
}], ['set', /** @param {*} val @returns {val is Set<unknown>} */
function (val) {
  return val instanceof Set;
}], ['weakmap', /** @param {*} val @returns {val is WeakMap<unknown, unknown>} */
function (val) {
  return val instanceof WeakMap;
}], ['weakset', /** @param {*} val @returns {val is WeakSet<unknown>} */
function (val) {
  return val instanceof WeakSet;
}], ['promise', /** @param {*} val @returns {val is Promise<unknown>} */
function (val) {
  return val instanceof Promise;
}]]);
if (isBrowser) {
  extendObjType([['htmlelement', /** @param {*} val @returns {val is HTMLElement} */
  function (val) {
    return typeof HTMLElement !== 'undefined' && val instanceof HTMLElement;
  }]]);
}
extendObjType([['object', /** @param {*} val @returns {val is Record<string | number | symbol, unknown>} */
function (val) {
  return isJsonObject(val);
}]]);

},{"buffer":67}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatBytes = formatBytes;
exports.getAge = getAge;
exports.getSimplePerc = getSimplePerc;
exports.ruleOfThree = ruleOfThree;
/**
 * Executes a Rule of Three calculation.
 *
 * @param {number} val1 - The first reference value (numerator in direct proportion, denominator in inverse).
 * @param {number} val2 - The second reference value (denominator in direct proportion, numerator in inverse).
 * @param {number} val3 - The third value (numerator in direct proportion, denominator in inverse).
 * @param {boolean} [inverse] - Whether the calculation should use inverse proportion (true for inverse, false for direct).
 * @returns {number} The result of the Rule of Three operation.
 *
 * Rule of Three Formula (Direct Proportion):
 *      val1 / val2 = val3 / result
 *
 * For Inverse Proportion:
 *      val1 / val3 = val2 / result
 *
 * Visual Representation:
 *
 * For Direct Proportion:
 *      val1      val2
 *      -----  =  ------
 *      val3      result
 *
 * For Inverse Proportion:
 *      val1      val2
 *      -----  =  ------
 *      val3      result
 *
 * @example
 * // Direct proportion:
 * ruleOfThree.execute(2, 6, 3, false); // â 9
 *
 * @example
 * // Inverse proportion:
 * ruleOfThree.execute(2, 6, 3, true); // â 4
 */
function ruleOfThree(val1, val2, val3) {
  var inverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return inverse ? Number(val1 * val2) / val3 : Number(val3 * val2) / val1;
}
/**
 * Calculates a percentage of a given base value.
 * @param {number} price - The base value.
 * @param {number} percentage - The percentage to apply.
 * @returns {number} The result of the percentage calculation.
 *
 * @example
 * getSimplePerc(200, 15); // 30
 */
function getSimplePerc(price, percentage) {
  return price * (percentage / 100);
}
/**
 * Calculates the age based on the given date.
 *
 * @param {number|string|Date} timeData - The birth date (can be a timestamp, ISO string, or Date object).
 * @param {Date|null} [now=null] - The Date object representing the current date. Defaults to the current date and time if not provided.
 * @returns {number|null} The age in years, or null if `timeData` is not provided or invalid.
 */
function getAge() {
  var timeData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (typeof timeData !== 'undefined' && timeData !== null && timeData !== 0) {
    var birthDate = new Date(timeData);
    if (Number.isNaN(birthDate.getTime())) return null;
    var currentDate = now instanceof Date ? now : new Date();
    var age = currentDate.getFullYear() - birthDate.getFullYear();
    var currentMonth = currentDate.getMonth();
    var birthMonth = birthDate.getMonth();
    var currentDay = currentDate.getDate();
    var birthDay = birthDate.getDate();
    // Adjust if birthday hasn't occurred yet this year
    if (currentMonth < birthMonth || currentMonth === birthMonth && currentDay < birthDay) age--;
    return Math.abs(age);
  }
  return null;
}
/**
 * @typedef {Object} FormattedByteResult
 * @property {string|null} unit - The resulting unit (e.g., 'MB', 'GB') or null if input is invalid.
 * @property {number|null} value - The numerical value in the chosen unit, or null if input is invalid.
 */
/**
 * Converts a byte value into a human-readable format with unit and value separated.
 *
 * @param {number} bytes - The number of bytes to format. Must be a non-negative number.
 * @param {number|null} [decimals=null] - The number of decimal places to include in the result. Defaults to null. If negative, it will be treated as 0. If null, no rounding is applied.
 * @param {string|null} [maxUnit=null] - Optional unit limit. If provided, restricts conversion to this unit at most (e.g., 'MB' prevents conversion to 'GB' or higher). Must be one of: 'Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'.
 * @returns {FormattedByteResult} An object with the converted value and its corresponding unit. Returns nulls if input is invalid.
 *
 * @example
 * formatBytes(123456789);
 * // â { unit: 'MB', value: 117.74 }
 *
 * @example
 * formatBytes(1073741824, 2, 'MB');
 * // â { unit: 'MB', value: 1024 }
 */
function formatBytes(bytes) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var maxUnit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (typeof bytes !== 'number' || bytes < 0) return {
    unit: null,
    value: null
  };
  if (bytes === 0) return {
    unit: 'Bytes',
    value: 0
  };
  var k = 1024;
  var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  var maxIndex = maxUnit && sizes.includes(maxUnit) ? sizes.indexOf(maxUnit) : sizes.length - 1;
  var i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), maxIndex);
  var value = bytes / Math.pow(k, i);
  if (decimals !== null) {
    var dm = decimals < 0 ? 0 : decimals;
    value = parseFloat(value.toFixed(dm));
  }
  var unit = sizes[i];
  return {
    unit: unit,
    value: value
  };
}

},{}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAiMarkerShortcut = addAiMarkerShortcut;
exports.toTitleCase = toTitleCase;
exports.toTitleCaseLowerFirst = toTitleCaseLowerFirst;
/**
 * Converts a string to title case where the first letter of each word is capitalized.
 * All other letters are converted to lowercase.
 *
 * Example: "hello world" -> "Hello World"
 *
 * @param {string} str - The string to be converted to title case.
 * @returns {string} The string converted to title case.
 */
function toTitleCase(str) {
  return str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}
/**
 * Converts a string to title case where the first letter of each word is capitalized,
 * but the first letter of the entire string is left lowercase.
 *
 * Example: "hello world" -> "hello World"
 *
 * @param {string} str - The string to be converted to title case with the first letter in lowercase.
 * @returns {string} The string converted to title case with the first letter in lowercase.
 */
function toTitleCaseLowerFirst(str) {
  var titleCased = str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
  return titleCased.charAt(0).toLowerCase() + titleCased.slice(1);
}
/**
 * Enables a keyboard shortcut to toggle a CSS class on the document body.
 *
 * This function listens for a specific key combination: `Ctrl + Alt + [key]`.
 * When triggered, it prevents the default behavior and toggles the
 * `detect-made-by-ai` class on the `<body>`, which can be used to apply visual
 * indicators or filters on AI-generated content.
 *
 * If executed outside of a browser environment (e.g., in Node.js), the function logs an error and exits.
 * If the `<body>` is not available at the moment the shortcut is triggered, a warning is logged.
 *
 * @param {string} [key='a'] - The lowercase character key to be used in combination with Ctrl and Alt.
 */
function addAiMarkerShortcut() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'a';
  if (typeof HTMLElement === 'undefined') {
    console.error('[AiMarkerShortcut] Environment does not support the DOM. This function must be run in a browser.');
    return;
  }
  document.addEventListener('keydown', function (event) {
    if (event.ctrlKey && event.altKey && event.key.toLowerCase() === key) {
      event.preventDefault(); // Prevent any default behavior
      if (!document.body) {
        console.warn('[AiMarkerShortcut] <body> element not found. Cannot toggle class. Ensure the DOM is fully loaded when using the shortcut.');
        return;
      }
      document.body.classList.toggle('detect-made-by-ai');
    }
  });
}
/*
import { useEffect } from "react";

function KeyPressHandler() {
    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.ctrlKey && event.altKey && event.key.toLowerCase() === "a") {
                event.preventDefault();
                document.body.classList.toggle("detect-made-by-ai");
            }
        };
        
        document.addEventListener("keydown", handleKeyDown);
        return () => {
            document.removeEventListener("keydown", handleKeyDown);
        };
    }, []);

    return null;
}

export default KeyPressHandler;
*/

},{}],162:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ColorSafeStringify", {
  enumerable: true,
  get: function get() {
    return _ColorSafeStringify["default"];
  }
});
Object.defineProperty(exports, "TinyLevelUp", {
  enumerable: true,
  get: function get() {
    return _userLevel["default"];
  }
});
Object.defineProperty(exports, "TinyPromiseQueue", {
  enumerable: true,
  get: function get() {
    return _TinyPromiseQueue["default"];
  }
});
Object.defineProperty(exports, "TinyRateLimiter", {
  enumerable: true,
  get: function get() {
    return _TinyRateLimiter["default"];
  }
});
Object.defineProperty(exports, "addAiMarkerShortcut", {
  enumerable: true,
  get: function get() {
    return _text.addAiMarkerShortcut;
  }
});
Object.defineProperty(exports, "arraySortPositions", {
  enumerable: true,
  get: function get() {
    return _arraySortPositions["default"];
  }
});
Object.defineProperty(exports, "asyncReplace", {
  enumerable: true,
  get: function get() {
    return _replaceAsync["default"];
  }
});
Object.defineProperty(exports, "checkObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.checkObj;
  }
});
Object.defineProperty(exports, "cloneObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.cloneObjTypeOrder;
  }
});
Object.defineProperty(exports, "countObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.countObj;
  }
});
Object.defineProperty(exports, "extendObjType", {
  enumerable: true,
  get: function get() {
    return _objFilter.extendObjType;
  }
});
Object.defineProperty(exports, "formatBytes", {
  enumerable: true,
  get: function get() {
    return _simpleMath.formatBytes;
  }
});
Object.defineProperty(exports, "formatCustomTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatCustomTimer;
  }
});
Object.defineProperty(exports, "formatDayTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatDayTimer;
  }
});
Object.defineProperty(exports, "formatTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatTimer;
  }
});
Object.defineProperty(exports, "getAge", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getAge;
  }
});
Object.defineProperty(exports, "getSimplePerc", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getSimplePerc;
  }
});
Object.defineProperty(exports, "getTimeDuration", {
  enumerable: true,
  get: function get() {
    return _clock.getTimeDuration;
  }
});
Object.defineProperty(exports, "isJsonObject", {
  enumerable: true,
  get: function get() {
    return _objFilter.isJsonObject;
  }
});
Object.defineProperty(exports, "objType", {
  enumerable: true,
  get: function get() {
    return _objFilter.objType;
  }
});
Object.defineProperty(exports, "reorderObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.reorderObjTypeOrder;
  }
});
Object.defineProperty(exports, "ruleOfThree", {
  enumerable: true,
  get: function get() {
    return _simpleMath.ruleOfThree;
  }
});
Object.defineProperty(exports, "shuffleArray", {
  enumerable: true,
  get: function get() {
    return _array.shuffleArray;
  }
});
Object.defineProperty(exports, "toTitleCase", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCase;
  }
});
Object.defineProperty(exports, "toTitleCaseLowerFirst", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCaseLowerFirst;
  }
});
var _replaceAsync = _interopRequireDefault(require("../legacy/libs/replaceAsync.mjs"));
var _userLevel = _interopRequireDefault(require("../legacy/libs/userLevel.mjs"));
var _arraySortPositions = _interopRequireDefault(require("../legacy/libs/arraySortPositions.mjs"));
var _array = require("./basics/array.mjs");
var _clock = require("./basics/clock.mjs");
var _objFilter = require("./basics/objFilter.mjs");
var _simpleMath = require("./basics/simpleMath.mjs");
var _text = require("./basics/text.mjs");
var _ColorSafeStringify = _interopRequireDefault(require("./libs/ColorSafeStringify.mjs"));
var _TinyPromiseQueue = _interopRequireDefault(require("./libs/TinyPromiseQueue.mjs"));
var _TinyRateLimiter = _interopRequireDefault(require("./libs/TinyRateLimiter.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"../legacy/libs/arraySortPositions.mjs":154,"../legacy/libs/replaceAsync.mjs":155,"../legacy/libs/userLevel.mjs":156,"./basics/array.mjs":157,"./basics/clock.mjs":158,"./basics/objFilter.mjs":159,"./basics/simpleMath.mjs":160,"./basics/text.mjs":161,"./libs/ColorSafeStringify.mjs":163,"./libs/TinyPromiseQueue.mjs":164,"./libs/TinyRateLimiter.mjs":165}],163:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _colors = /*#__PURE__*/new WeakMap();
var _ColorSafeStringify_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {Record<string, string>} ColorsList
 * Represents a mapping of color keys to ANSI escape codes.
 */
var ColorSafeStringify = /*#__PURE__*/function () {
  /**
   * Constructs a new instance with an optional base preset or custom override.
   * @param {ColorsList} [defaultColors] - Optional override for the default color scheme.
   */
  function ColorSafeStringify() {
    var defaultColors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, ColorSafeStringify);
    /**
     * Internal method to apply ANSI color codes to different parts of a JSON string.
     * @param {string} str - Raw JSON string to be colorized.
     * @param {ColorsList} colors - ANSI color mapping to be applied to each JSON element type.
     * @returns {string} Colorized JSON string.
     */
    _classPrivateMethodInitSpec(this, _ColorSafeStringify_brand);
    /**
     * Currently active color configuration.
     * @type {ColorsList}
     */
    _classPrivateFieldInitSpec(this, _colors, void 0);
    _classPrivateFieldSet(_colors, this, _objectSpread(_objectSpread({}, _PRESETS._["default"]), defaultColors));
  }
  return _createClass(ColorSafeStringify, [{
    key: "colorize",
    value:
    /**
     * Colorizes a JSON string using the active or optionally overridden color set.
     * @param {string} json - The JSON string to format.
     * @param {ColorsList} [customColors] - Optional temporary color override.
     * @returns {string}
     */
    function colorize(json) {
      var customColors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var colors = _objectSpread(_objectSpread({}, _classPrivateFieldGet(_colors, this)), customColors);
      return _assertClassBrand(_ColorSafeStringify_brand, this, _colorizeJSON).call(this, json, colors);
    }
    /**
     * Returns the currently active color scheme.
     * @returns {ColorsList}
     */
  }, {
    key: "getColors",
    value: function getColors() {
      return _objectSpread({}, _classPrivateFieldGet(_colors, this));
    }
    /**
     * Updates the current color scheme with a partial override.
     * @param {Partial<ColorsList>} newColors
     */
  }, {
    key: "updateColors",
    value: function updateColors(newColors) {
      Object.assign(_classPrivateFieldGet(_colors, this), newColors);
    }
    /**
     * Resets the current color scheme to the default preset.
     */
  }, {
    key: "resetColors",
    value: function resetColors() {
      _classPrivateFieldSet(_colors, this, _objectSpread({}, _PRESETS._["default"]));
    }
    /**
     * Loads a color preset by name.
     * @param {string} presetName - Name of the preset to load.
     * @throws Will throw if the preset doesn't exist.
     */
  }, {
    key: "loadColorPreset",
    value: function loadColorPreset(presetName) {
      var preset = _PRESETS._[presetName];
      if (!preset) throw new Error("Preset \"".concat(presetName, "\" not found."));
      _classPrivateFieldSet(_colors, this, _objectSpread({}, preset));
    }
    /**
     * Saves a new custom color preset.
     * @param {string} name - Name of the new preset.
     * @param {ColorsList} colors - ANSI color map to save.
     */
  }, {
    key: "saveColorPreset",
    value: function saveColorPreset(name, colors) {
      _PRESETS._[name] = _objectSpread({}, colors);
    }
    /**
     * Returns a list of all available color preset names.
     * @returns {string[]}
     */
  }, {
    key: "getAvailablePresets",
    value: function getAvailablePresets() {
      return Object.keys(_PRESETS._);
    }
  }]);
}();
function _colorizeJSON(str, colors) {
  /** @type {{ marker: string, key: string }[]} */
  var keyMatches = [];
  // Colorize numeric values
  str = str.replace(/(?<!")\b(-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b(?!")/g, "".concat(colors.number, "$1").concat(colors.reset));
  // Replace keys with temporary markers for later colorization
  str = str.replace(/"([^"]+)":/g, function (_, key) {
    var marker = "___KEY".concat(keyMatches.length, "___");
    keyMatches.push({
      marker: marker,
      key: key
    });
    return "".concat(marker, ":"); // Keep the colon for valid syntax
  });
  // Replace strings and apply specific colors based on their content
  str = str.replace(/"(?:\\.|[^"\\])*?"/g, function (match) {
    var val = match.slice(1, -1); // Remove surrounding quotes
    if (/^(https?|ftp):\/\/[^\s]+$/i.test(val)) {
      return "".concat(colors.string_url).concat(match).concat(colors.reset);
    }
    if (/^(true|false|null)$/.test(val)) {
      return "".concat(colors.string_bool).concat(match).concat(colors.reset);
    }
    if (/^-?\d+(\.\d+)?([eE][+-]?\d+)?$/.test(val)) {
      return "".concat(colors.string_number).concat(match).concat(colors.reset);
    }
    return "".concat(colors.string).concat(match).concat(colors.reset);
  });
  // Replace markers with colorized keys
  for (var _i = 0, _keyMatches = keyMatches; _i < _keyMatches.length; _i++) {
    var _keyMatches$_i = _keyMatches[_i],
      marker = _keyMatches$_i.marker,
      key = _keyMatches$_i.key;
    var regex = new RegExp(marker, 'g');
    str = str.replace(regex, "".concat(colors.key, "\"").concat(key, "\"").concat(colors.reset));
  }
  // Colorize boolean values
  str = str.replace(/(?<!")\b(true|false)\b(?!")/g, "".concat(colors["boolean"], "$1").concat(colors.reset));
  // Colorize null values
  str = str.replace(/(?<!")\bnull\b(?!")/g, "".concat(colors["null"], "null").concat(colors.reset));
  // Highlight special placeholder values
  str = str.replace(/\[Circular\]/g, "".concat(colors.special, "[Circular]").concat(colors.reset));
  str = str.replace(/\[undefined\]/g, "".concat(colors.special, "[undefined]").concat(colors.reset));
  // Colorize function string representations
  str = str.replace(/"function[^]*?[^\\]"/g, "".concat(colors.func, "$&").concat(colors.reset));
  return str;
}
/**
 * Preset collections (internal and user-defined).
 * @type {Record<string, ColorsList>}
 * @static
 */
var _PRESETS = {
  _: {
    "default": {
      reset: '\x1b[0m',
      key: '\x1b[36m',
      // Cyan (object keys)
      string: '\x1b[32m',
      // Green (regular strings)
      string_url: '\x1b[34m',
      // Blue (URLs)
      string_bool: '\x1b[35m',
      // Magenta (boolean/null in string form)
      string_number: '\x1b[33m',
      // Yellow (numbers in string form)
      number: '\x1b[33m',
      // Yellow (raw numbers)
      "boolean": '\x1b[35m',
      // Magenta (true/false)
      "null": '\x1b[1;30m',
      // Gray (null)
      special: '\x1b[31m',
      // Red (e.g., [Circular], [undefined])
      func: '\x1b[90m' // Dim (function string representations)
    },
    solarized: {
      reset: '\x1b[0m',
      key: '\x1b[38;5;37m',
      string: '\x1b[38;5;136m',
      string_url: '\x1b[38;5;33m',
      string_bool: '\x1b[38;5;166m',
      string_number: '\x1b[38;5;136m',
      number: '\x1b[38;5;136m',
      "boolean": '\x1b[38;5;166m',
      "null": '\x1b[38;5;241m',
      special: '\x1b[38;5;160m',
      func: '\x1b[38;5;244m'
    },
    monokai: {
      reset: '\x1b[0m',
      key: '\x1b[38;5;81m',
      string: '\x1b[38;5;114m',
      string_url: '\x1b[38;5;75m',
      string_bool: '\x1b[38;5;204m',
      string_number: '\x1b[38;5;221m',
      number: '\x1b[38;5;221m',
      "boolean": '\x1b[38;5;204m',
      "null": '\x1b[38;5;241m',
      special: '\x1b[38;5;160m',
      func: '\x1b[38;5;102m'
    }
  }
};
var _default = exports["default"] = ColorSafeStringify;

},{}],164:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _queue = /*#__PURE__*/new WeakMap();
var _running = /*#__PURE__*/new WeakMap();
var _timeouts = /*#__PURE__*/new WeakMap();
var _blacklist = /*#__PURE__*/new WeakMap();
var _TinyPromiseQueue_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {Object} QueuedTask
 * @property {(...args: any[]) => Promise<any>|Promise<any>} task - The async task to execute.
 * @property {(value: any) => any} resolve - The resolve function from the Promise.
 * @property {(reason?: any) => any} reject - The reject function from the Promise.
 * @property {string|undefined} [id] - Optional identifier for the task.
 * @property {string|null|undefined} [marker] - Optional marker for the task.
 * @property {number|null|undefined} [delay] - Optional delay (in ms) before the task is executed.
 */
/**
 * A queue system for managing and executing asynchronous tasks sequentially, one at a time.
 *
 * Tasks can be delayed, reordered, canceled, and processed in strict order. The queue ensures that each task
 * is executed after the previous one finishes, and any task can be skipped or canceled if needed.
 *
 * @class
 */
var TinyPromiseQueue = /*#__PURE__*/function () {
  function TinyPromiseQueue() {
    _classCallCheck(this, TinyPromiseQueue);
    /**
     * Processes the a normal task.
     *
     * @param {QueuedTask} data
     *
     * @returns {Promise<void>}
     */
    _classPrivateMethodInitSpec(this, _TinyPromiseQueue_brand);
    /** @type {QueuedTask[]} */
    _classPrivateFieldInitSpec(this, _queue, []);
    _classPrivateFieldInitSpec(this, _running, false);
    /** @type {Record<string, ReturnType<typeof setTimeout>>} */
    _classPrivateFieldInitSpec(this, _timeouts, {});
    /** @type {Set<string>} */
    _classPrivateFieldInitSpec(this, _blacklist, new Set());
  }
  return _createClass(TinyPromiseQueue, [{
    key: "isRunning",
    value:
    /**
     * Returns whether the queue is currently processing a task.
     *
     * @returns {boolean}
     */
    function isRunning() {
      return _classPrivateFieldGet(_running, this);
    }
  }, {
    key: "getIndexById",
    value:
    /**
     * Returns the index of a task by its ID.
     *
     * @param {string} id The ID of the task to locate.
     * @returns {number} The index of the task in the queue, or -1 if not found.
     */
    function getIndexById(id) {
      return _classPrivateFieldGet(_queue, this).findIndex(function (item) {
        return item.id === id;
      });
    }
    /**
     * Returns a list of IDs for all tasks currently in the queue.
     *
     * @returns {{ index: number, id: string }[]} An array of task IDs currently queued.
     */
  }, {
    key: "getQueuedIds",
    value: function getQueuedIds() {
      // @ts-ignore
      return _classPrivateFieldGet(_queue, this).map(function (item, index) {
        return {
          index: index,
          id: item.id
        };
      }).filter(function (entry) {
        return typeof entry.id === 'string';
      });
    }
    /**
     * Reorders a task in the queue from one index to another.
     *
     * @param {number} fromIndex The current index of the task to move.
     * @param {number} toIndex The index where the task should be placed.
     */
  }, {
    key: "reorderQueue",
    value: function reorderQueue(fromIndex, toIndex) {
      if (typeof fromIndex !== 'number' || typeof toIndex !== 'number' || fromIndex < 0 || toIndex < 0 || fromIndex >= _classPrivateFieldGet(_queue, this).length || toIndex >= _classPrivateFieldGet(_queue, this).length) return;
      var _classPrivateFieldGet2 = _classPrivateFieldGet(_queue, this).splice(fromIndex, 1),
        _classPrivateFieldGet3 = _slicedToArray(_classPrivateFieldGet2, 1),
        item = _classPrivateFieldGet3[0];
      _classPrivateFieldGet(_queue, this).splice(toIndex, 0, item);
    }
    /**
     * Inserts a point in the queue where subsequent tasks will be grouped and executed together in a Promise.all.
     * If the queue is currently empty, behaves like a regular promise.
     *
     * @param {(...args: any[]) => Promise<any>|Promise<any>} task A function that returns a Promise.
     * @param {string} [id] Optional ID to identify the task in the queue.
     * @returns {Promise<any>} A Promise that resolves or rejects with the result of the task once it's processed.
     * @throws {Error} Throws if param is invalid.
     */
  }, {
    key: "enqueuePoint",
    value: (function () {
      var _enqueuePoint = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(task, id) {
        var _this = this;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!(typeof task !== 'function')) {
                _context.n = 1;
                break;
              }
              return _context.a(2, Promise.reject(new Error('Task must be a function returning a Promise.')));
            case 1:
              if (!(typeof id !== 'undefined' && typeof id !== 'string')) {
                _context.n = 2;
                break;
              }
              throw new Error('The "id" parameter must be a string.');
            case 2:
              if (_classPrivateFieldGet(_running, this)) {
                _context.n = 3;
                break;
              }
              return _context.a(2, task());
            case 3:
              return _context.a(2, new Promise(function (resolve, reject) {
                _classPrivateFieldGet(_queue, _this).push({
                  marker: 'POINT_MARKER',
                  task: task,
                  resolve: resolve,
                  reject: reject,
                  id: id
                });
                _assertClassBrand(_TinyPromiseQueue_brand, _this, _processQueue).call(_this);
              }));
          }
        }, _callee, this);
      }));
      function enqueuePoint(_x, _x2) {
        return _enqueuePoint.apply(this, arguments);
      }
      return enqueuePoint;
    }()
    /**
     * Adds a new async task to the queue and ensures it runs in order after previous tasks.
     * Optionally, a delay can be added before the task is executed.
     *
     * If the task is canceled before execution, it will be rejected with the message:
     * "The function was canceled on TinyPromiseQueue."
     *
     * @param {(...args: any[]) => Promise<any>|Promise<any>} task A function that returns a Promise to be executed sequentially.
     * @param {number|null} [delay] Optional delay (in ms) before the task is executed.
     * @param {string} [id] Optional ID to identify the task in the queue.
     * @returns {Promise<any>} A Promise that resolves or rejects with the result of the task once it's processed.
     * @throws {Error} Throws if param is invalid.
     */
    )
  }, {
    key: "enqueue",
    value: function enqueue(task, delay, id) {
      var _this2 = this;
      if (typeof task !== 'function') return Promise.reject(new Error('Task must be a function returning a Promise.'));
      if (typeof delay !== 'undefined' && (typeof delay !== 'number' || delay < 0)) return Promise.reject(new Error('Delay must be a positive number or undefined.'));
      if (typeof id !== 'undefined' && typeof id !== 'string') throw new Error('The "id" parameter must be a string.');
      return new Promise(function (resolve, reject) {
        _classPrivateFieldGet(_queue, _this2).push({
          task: task,
          resolve: resolve,
          reject: reject,
          id: id,
          delay: delay
        });
        _assertClassBrand(_TinyPromiseQueue_brand, _this2, _processQueue).call(_this2);
      });
    }
    /**
     * Cancels a scheduled delay and removes the task from the queue.
     * Adds the ID to a blacklist so the task is skipped if already being processed.
     *
     * @param {string} id The ID of the task to cancel.
     * @returns {boolean} True if a delay was cancelled and the task was removed.
     * @throws {Error} Throws if `id` is not a string.
     */
  }, {
    key: "cancelTask",
    value: function cancelTask(id) {
      if (typeof id !== 'string') throw new Error('The "id" parameter must be a string.');
      var cancelled = false;
      if (id in _classPrivateFieldGet(_timeouts, this)) {
        clearTimeout(_classPrivateFieldGet(_timeouts, this)[id]);
        delete _classPrivateFieldGet(_timeouts, this)[id];
        cancelled = true;
      }
      var index = this.getIndexById(id);
      if (index !== -1) {
        var _removed$reject;
        var _classPrivateFieldGet4 = _classPrivateFieldGet(_queue, this).splice(index, 1),
          _classPrivateFieldGet5 = _slicedToArray(_classPrivateFieldGet4, 1),
          removed = _classPrivateFieldGet5[0];
        removed === null || removed === void 0 || (_removed$reject = removed.reject) === null || _removed$reject === void 0 || _removed$reject.call(removed, new Error('The function was canceled on TinyPromiseQueue.'));
        cancelled = true;
      }
      if (cancelled) _classPrivateFieldGet(_blacklist, this).add(id);
      return cancelled;
    }
  }]);
}();
function _normalProcessQueue(_x3) {
  return _normalProcessQueue2.apply(this, arguments);
}
function _normalProcessQueue2() {
  _normalProcessQueue2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(data) {
    var _this3 = this;
    var task, resolve, reject, delay, id, result, _t;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          if (!(data && typeof data.task === 'function' && typeof data.resolve === 'function' && typeof data.reject === 'function')) {
            _context2.n = 7;
            break;
          }
          task = data.task, resolve = data.resolve, reject = data.reject, delay = data.delay, id = data.id;
          _context2.p = 1;
          if (!(id && _classPrivateFieldGet(_blacklist, this).has(id))) {
            _context2.n = 2;
            break;
          }
          reject(new Error('The function was canceled on TinyPromiseQueue.'));
          _classPrivateFieldGet(_blacklist, this)["delete"](id);
          _classPrivateFieldSet(_running, this, false);
          _assertClassBrand(_TinyPromiseQueue_brand, this, _processQueue).call(this);
          return _context2.a(2);
        case 2:
          if (!(delay && id)) {
            _context2.n = 3;
            break;
          }
          _context2.n = 3;
          return new Promise(function (resolveDelay) {
            var timeoutId = setTimeout(function () {
              delete _classPrivateFieldGet(_timeouts, _this3)[id];
              resolveDelay(null);
            }, delay);
            _classPrivateFieldGet(_timeouts, _this3)[id] = timeoutId;
          });
        case 3:
          _context2.n = 4;
          return task();
        case 4:
          result = _context2.v;
          resolve(result);
          _context2.n = 6;
          break;
        case 5:
          _context2.p = 5;
          _t = _context2.v;
          reject(_t);
        case 6:
          _context2.p = 6;
          _classPrivateFieldSet(_running, this, false);
          _assertClassBrand(_TinyPromiseQueue_brand, this, _processQueue).call(this);
          return _context2.f(6);
        case 7:
          return _context2.a(2);
      }
    }, _callee2, this, [[1, 5, 6, 7]]);
  }));
  return _normalProcessQueue2.apply(this, arguments);
}
/**
 * Processes a group task.
 *
 * @returns {Promise<void>}
 */
function _groupProcessQueue() {
  return _groupProcessQueue2.apply(this, arguments);
}
function _groupProcessQueue2() {
  _groupProcessQueue2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
    var _this4 = this;
    var grouped, _classPrivateFieldGet6;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          /** @type {Array<QueuedTask>} */
          grouped = [];
          while (_classPrivateFieldGet(_queue, this).length && ((_classPrivateFieldGet6 = _classPrivateFieldGet(_queue, this)[0]) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.marker) === 'POINT_MARKER') {
            // @ts-ignore
            grouped.push(_classPrivateFieldGet(_queue, this).shift());
          }
          if (!(grouped.length === 0)) {
            _context4.n = 1;
            break;
          }
          _classPrivateFieldSet(_running, this, false);
          _assertClassBrand(_TinyPromiseQueue_brand, this, _processQueue).call(this);
          return _context4.a(2);
        case 1:
          _context4.n = 2;
          return Promise.all(grouped.map(function (_ref) {
            var task = _ref.task,
              resolve = _ref.resolve,
              reject = _ref.reject,
              id = _ref.id;
            return new Promise(/*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(pResolve) {
                return _regenerator().w(function (_context3) {
                  while (1) switch (_context3.n) {
                    case 0:
                      if (!(id && _classPrivateFieldGet(_blacklist, _this4).has(id))) {
                        _context3.n = 1;
                        break;
                      }
                      _classPrivateFieldGet(_blacklist, _this4)["delete"](id);
                      reject(new Error('The function was canceled on TinyPromiseQueue.'));
                      pResolve(true);
                      return _context3.a(2);
                    case 1:
                      _context3.n = 2;
                      return task().then(resolve)["catch"](reject);
                    case 2:
                      pResolve(true);
                    case 3:
                      return _context3.a(2);
                  }
                }, _callee3);
              }));
              return function (_x4) {
                return _ref2.apply(this, arguments);
              };
            }());
          }));
        case 2:
          _classPrivateFieldSet(_running, this, false);
          _assertClassBrand(_TinyPromiseQueue_brand, this, _processQueue).call(this);
        case 3:
          return _context4.a(2);
      }
    }, _callee4, this);
  }));
  return _groupProcessQueue2.apply(this, arguments);
}
/**
 * Processes the next task in the queue if not already running.
 * Ensures tasks are executed in order, one at a time.
 *
 * @returns {Promise<void>}
 */
function _processQueue() {
  return _processQueue2.apply(this, arguments);
}
function _processQueue2() {
  _processQueue2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
    var _classPrivateFieldGet7, _classPrivateFieldGet8;
    var data;
    return _regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          if (!(_classPrivateFieldGet(_running, this) || _classPrivateFieldGet(_queue, this).length === 0)) {
            _context5.n = 1;
            break;
          }
          return _context5.a(2);
        case 1:
          _classPrivateFieldSet(_running, this, true);
          if (typeof ((_classPrivateFieldGet7 = _classPrivateFieldGet(_queue, this)[0]) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.marker) !== 'string' || ((_classPrivateFieldGet8 = _classPrivateFieldGet(_queue, this)[0]) === null || _classPrivateFieldGet8 === void 0 ? void 0 : _classPrivateFieldGet8.marker) !== 'POINT_MARKER') {
            data = _classPrivateFieldGet(_queue, this).shift(); // @ts-ignore
            _assertClassBrand(_TinyPromiseQueue_brand, this, _normalProcessQueue).call(this, data);
          } else _assertClassBrand(_TinyPromiseQueue_brand, this, _groupProcessQueue).call(this);
        case 2:
          return _context5.a(2);
      }
    }, _callee5, this);
  }));
  return _processQueue2.apply(this, arguments);
}
var _default = exports["default"] = TinyPromiseQueue;

},{}],165:[function(require,module,exports){
(function (process){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _maxMemory = /*#__PURE__*/new WeakMap();
var _cleanupTimer = /*#__PURE__*/new WeakMap();
var _maxHits = /*#__PURE__*/new WeakMap();
var _interval = /*#__PURE__*/new WeakMap();
var _cleanupInterval = /*#__PURE__*/new WeakMap();
var _maxIdle = /*#__PURE__*/new WeakMap();
var _onMemoryExceeded = /*#__PURE__*/new WeakMap();
var _onGroupExpired = /*#__PURE__*/new WeakMap();
/** @typedef {(groupId: string) => void} OnMemoryExceeded */
/** @typedef {(groupId: string) => void} OnGroupExpired */
/**
 * Class representing a flexible rate limiter per user or group.
 *
 * This rate limiter supports limiting per user or per group by mapping
 * userIds to a common groupId. All users within the same group share
 * rate limits.
 */
var TinyRateLimiter = /*#__PURE__*/function () {
  /**
   * @param {Object} options
   * @param {number|null} [options.maxMemory] - Max memory allowed
   * @param {number} [options.maxHits] - Max interactions allowed
   * @param {number} [options.interval] - Time window in milliseconds
   * @param {number} [options.cleanupInterval] - Interval for automatic cleanup (ms)
   * @param {number} [options.maxIdle=300000] - Max idle time for a user before being cleaned (ms)
   */
  function TinyRateLimiter(_ref) {
    var _this = this;
    var maxHits = _ref.maxHits,
      interval = _ref.interval,
      cleanupInterval = _ref.cleanupInterval,
      _ref$maxIdle = _ref.maxIdle,
      maxIdle = _ref$maxIdle === void 0 ? 300000 : _ref$maxIdle,
      _ref$maxMemory = _ref.maxMemory,
      maxMemory = _ref$maxMemory === void 0 ? 100000 : _ref$maxMemory;
    _classCallCheck(this, TinyRateLimiter);
    /** @type {number|null} */
    _classPrivateFieldInitSpec(this, _maxMemory, null);
    /** @type {NodeJS.Timeout|null} */
    _classPrivateFieldInitSpec(this, _cleanupTimer, null);
    /** @type {number|null|undefined} */
    _classPrivateFieldInitSpec(this, _maxHits, null);
    /** @type {number|null|undefined} */
    _classPrivateFieldInitSpec(this, _interval, null);
    /** @type {number|null|undefined} */
    _classPrivateFieldInitSpec(this, _cleanupInterval, null);
    /** @type {number|null|undefined} */
    _classPrivateFieldInitSpec(this, _maxIdle, null);
    /** @type {Map<string, number[]>} */
    _defineProperty(this, "groupData", new Map());
    // groupId -> timestamps[]
    /** @type {Map<string, number>} */
    _defineProperty(this, "lastSeen", new Map());
    // groupId -> timestamp
    /** @type {Map<string, string>} */
    _defineProperty(this, "userToGroup", new Map());
    // userId -> groupId
    /** @type {Map<string, boolean>} */
    _defineProperty(this, "groupFlags", new Map());
    // groupId -> boolean
    /**
     * @type {Map<string, number>}
     * Stores TTL (in ms) for each groupId individually
     */
    _defineProperty(this, "groupTTL", new Map());
    /**
     * @type {null|OnMemoryExceeded}
     */
    _classPrivateFieldInitSpec(this, _onMemoryExceeded, null);
    /**
     * @type {null|OnGroupExpired}
     */
    _classPrivateFieldInitSpec(this, _onGroupExpired, null);
    /** @param {number|undefined} val */
    var isPositiveInteger = function isPositiveInteger(val) {
      return typeof val === 'number' && Number.isFinite(val) && val >= 1 && Number.isInteger(val);
    };
    var isMaxHitsValid = isPositiveInteger(maxHits);
    var isIntervalValid = isPositiveInteger(interval);
    var isCleanupValid = isPositiveInteger(cleanupInterval);
    var isMaxIdleValid = isPositiveInteger(maxIdle);
    if (!isMaxHitsValid && !isIntervalValid) throw new Error("RateLimiter requires at least one valid option: 'maxHits' or 'interval'.");
    if (maxHits !== undefined && !isMaxHitsValid) throw new Error("'maxHits' must be a positive integer if defined.");
    if (interval !== undefined && !isIntervalValid) throw new Error("'interval' must be a positive integer in milliseconds if defined.");
    if (cleanupInterval !== undefined && !isCleanupValid) throw new Error("'cleanupInterval' must be a positive integer in milliseconds if defined.");
    if (!isMaxIdleValid) throw new Error("'maxIdle' must be a positive integer in milliseconds.");
    if (typeof maxMemory === 'number' && Number.isFinite(maxMemory) && maxMemory > 0) {
      _classPrivateFieldSet(_maxMemory, this, Math.floor(maxMemory));
    } else if (maxMemory === null || maxMemory === undefined) {
      _classPrivateFieldSet(_maxMemory, this, null);
    } else {
      throw new Error('maxMemory must be a positive number or null');
    }
    _classPrivateFieldSet(_maxHits, this, isMaxHitsValid ? maxHits : null);
    _classPrivateFieldSet(_interval, this, isIntervalValid ? interval : null);
    _classPrivateFieldSet(_cleanupInterval, this, isCleanupValid ? cleanupInterval : null);
    _classPrivateFieldSet(_maxIdle, this, maxIdle);
    // Start automatic cleanup only if cleanupInterval is valid
    if (_classPrivateFieldGet(_cleanupInterval, this) !== null) _classPrivateFieldSet(_cleanupTimer, this, setInterval(function () {
      return _this._cleanup();
    }, _classPrivateFieldGet(_cleanupInterval, this)));
  }
  /**
   * Check if a given ID is a groupId (not a userId)
   * @param {string} id
   * @returns {boolean}
   */
  return _createClass(TinyRateLimiter, [{
    key: "setOnMemoryExceeded",
    value:
    /**
     * Set the callback to be triggered when a group exceeds its limit
     * @param {OnMemoryExceeded} callback
     */
    function setOnMemoryExceeded(callback) {
      if (typeof callback !== 'function') throw new Error('onMemoryExceeded must be a function');
      _classPrivateFieldSet(_onMemoryExceeded, this, callback);
    }
    /**
     * Clear the onMemoryExceeded callback
     */
  }, {
    key: "clearOnMemoryExceeded",
    value: function clearOnMemoryExceeded() {
      _classPrivateFieldSet(_onMemoryExceeded, this, null);
    }
  }, {
    key: "setOnGroupExpired",
    value:
    /**
     * Set the callback to be triggered when a group expires and is removed.
     *
     * This callback is called automatically during cleanup when a group
     * becomes inactive for longer than its TTL.
     *
     * @param {OnGroupExpired} callback - A function that receives the expired groupId.
     */
    function setOnGroupExpired(callback) {
      if (typeof callback !== 'function') throw new Error('onGroupExpired must be a function');
      _classPrivateFieldSet(_onGroupExpired, this, callback);
    }
    /**
     * Clear the onGroupExpired callback
     */
  }, {
    key: "clearOnGroupExpired",
    value: function clearOnGroupExpired() {
      _classPrivateFieldSet(_onGroupExpired, this, null);
    }
  }, {
    key: "isGroupId",
    value: function isGroupId(id) {
      var result = this.groupFlags.get(id);
      return typeof result === 'boolean' ? result : false;
    }
    /**
     * Get all user IDs that belong to a given group.
     * @param {string} groupId
     * @returns {string[]}
     */
  }, {
    key: "getUsersInGroup",
    value: function getUsersInGroup(groupId) {
      var users = [];
      var _iterator = _createForOfIteratorHelper(this.userToGroup.entries()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            userId = _step$value[0],
            assignedGroup = _step$value[1];
          if (assignedGroup === groupId) {
            users.push(userId);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return users;
    }
    /**
     * Set TTL (in milliseconds) for a specific group
     * @param {string} groupId
     * @param {number} ttl
     */
  }, {
    key: "setGroupTTL",
    value: function setGroupTTL(groupId, ttl) {
      if (typeof ttl !== 'number' || !Number.isFinite(ttl) || ttl <= 0) throw new Error('TTL must be a positive number in milliseconds');
      this.groupTTL.set(groupId, ttl);
    }
    /**
     * Get TTL (in ms) for a specific group.
     * @param {string} groupId
     * @returns {number|null}
     */
  }, {
    key: "getGroupTTL",
    value: function getGroupTTL(groupId) {
      var _this$groupTTL$get;
      return (_this$groupTTL$get = this.groupTTL.get(groupId)) !== null && _this$groupTTL$get !== void 0 ? _this$groupTTL$get : null;
    }
    /**
     * Delete the TTL setting for a specific group
     * @param {string} groupId
     */
  }, {
    key: "deleteGroupTTL",
    value: function deleteGroupTTL(groupId) {
      this.groupTTL["delete"](groupId);
    }
    /**
     * Assign a userId to a groupId, with merge if user has existing data.
     * @param {string} userId
     * @param {string} groupId
     * @throws {Error} If userId is already assigned to a different group
     */
  }, {
    key: "assignToGroup",
    value: function assignToGroup(userId, groupId) {
      var existingGroup = this.userToGroup.get(userId);
      if (existingGroup && existingGroup !== groupId) throw new Error("User ".concat(userId, " is already assigned to group ").concat(existingGroup));
      // If the user is already in the group, nothing needs to be done
      if (existingGroup === groupId) return;
      var userData = this.groupData.get(userId);
      // Associates the user to the group
      if (this.isGroupId(userId)) {
        var _iterator2 = _createForOfIteratorHelper(this.userToGroup.entries()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
              uid = _step2$value[0],
              gId = _step2$value[1];
            if (gId === userId) this.userToGroup.set(uid, groupId);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        this.userToGroup["delete"](userId);
      } else this.userToGroup.set(userId, groupId);
      // If the user has no data, nothing needs to be done
      if (!userData) return;
      var groupData = this.groupData.get(groupId);
      if (groupData) {
        var _iterator3 = _createForOfIteratorHelper(userData),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var item = _step3.value;
            groupData.push(item);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } else {
        var newData = [];
        var _iterator4 = _createForOfIteratorHelper(userData),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _item = _step4.value;
            newData.push(_item);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        this.groupData.set(groupId, newData);
      }
      this.lastSeen.set(groupId, Date.now());
      // Removes individual data as they are now in the group
      this.groupFlags["delete"](userId);
      this.groupData["delete"](userId);
      this.lastSeen["delete"](userId);
      this.groupTTL["delete"](userId);
      this.groupFlags.set(groupId, true);
    }
    /**
     * Get the groupId for a given userId
     * @param {string} userId
     * @returns {string}
     */
  }, {
    key: "getGroupId",
    value: function getGroupId(userId) {
      return this.userToGroup.get(userId) || userId; // fallback: use userId as own group
    }
    /**
     * Register a hit for a specific user
     * @param {string} userId
     */
  }, {
    key: "hit",
    value: function hit(userId) {
      var groupId = this.getGroupId(userId);
      var now = Date.now();
      if (!this.groupData.has(groupId)) {
        this.groupData.set(groupId, []);
        this.groupFlags.set(groupId, false);
      }
      var history = this.groupData.get(groupId);
      if (!history) throw new Error("No data found for groupId: ".concat(groupId));
      history.push(now);
      this.lastSeen.set(groupId, now);
      // Clean up old entries
      if (_classPrivateFieldGet(_interval, this) !== null) {
        var interval = this.getInterval();
        var cutoff = now - interval;
        while (history.length && history[0] < cutoff) {
          history.shift();
        }
      }
      // Optional: keep only the last N entries for memory optimization
      if (_classPrivateFieldGet(_maxMemory, this) !== null && typeof _classPrivateFieldGet(_maxMemory, this) === 'number') {
        if (history.length > _classPrivateFieldGet(_maxMemory, this)) {
          history.splice(0, history.length - _classPrivateFieldGet(_maxMemory, this));
          if (typeof _classPrivateFieldGet(_onMemoryExceeded, this) === 'function') _classPrivateFieldGet(_onMemoryExceeded, this).call(this, groupId);
        }
      }
    }
    /**
     * Check if the user (via their group) is currently rate limited
     * @param {string} userId
     * @returns {boolean}
     */
  }, {
    key: "isRateLimited",
    value: function isRateLimited(userId) {
      var groupId = this.getGroupId(userId);
      if (!this.groupData.has(groupId)) return false;
      var history = this.groupData.get(groupId);
      if (!history) throw new Error("No data found for groupId: ".concat(groupId));
      if (_classPrivateFieldGet(_interval, this) !== null) {
        var now = Date.now();
        var interval = this.getInterval();
        var cutoff = now - interval;
        var count = 0;
        for (var i = history.length - 1; i >= 0; i--) {
          if (history[i] > cutoff) count++;else break;
        }
        if (_classPrivateFieldGet(_maxHits, this) !== null) return count > this.getMaxHits();
        return count > 0;
      }
      if (_classPrivateFieldGet(_maxHits, this) !== null) {
        return history.length > this.getMaxHits();
      }
      return false;
    }
    /**
     * Manually reset group data
     * @param {string} groupId
     */
  }, {
    key: "resetGroup",
    value: function resetGroup(groupId) {
      this.groupFlags["delete"](groupId);
      this.groupData["delete"](groupId);
      this.lastSeen["delete"](groupId);
      this.groupTTL["delete"](groupId);
    }
    /**
     * Manually reset user data.
     *
     * @deprecated Use `resetUserGroup(userId)` instead. This method will be removed in future versions.
     * @param {string} userId
     * @returns {void}
     */
  }, {
    key: "reset",
    value: function reset(userId) {
      var _process;
      if (((_process = process) === null || _process === void 0 || (_process = _process.env) === null || _process === void 0 ? void 0 : _process.NODE_ENV) !== 'production') console.warn("[TinyRateLimiter] 'reset()' is deprecated. Use 'resetUserGroup()' instead.");
      return this.resetUserGroup(userId);
    }
    /**
     * Manually reset a user mapping
     * @param {string} userId
     */
  }, {
    key: "resetUserGroup",
    value: function resetUserGroup(userId) {
      this.userToGroup["delete"](userId);
    }
    /**
     * Set custom timestamps to a group
     * @param {string} groupId
     * @param {number[]} timestamps
     */
  }, {
    key: "setData",
    value: function setData(groupId, timestamps) {
      if (!Array.isArray(timestamps)) throw new Error('timestamps must be an array of numbers.');
      var _iterator5 = _createForOfIteratorHelper(timestamps),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var t = _step5.value;
          if (typeof t !== 'number' || !Number.isFinite(t)) {
            throw new Error('All timestamps must be finite numbers.');
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      if (!this.groupData.has(groupId)) this.groupFlags.set(groupId, false);
      this.groupData.set(groupId, timestamps);
      this.lastSeen.set(groupId, Date.now());
    }
    /**
     * Check if a group has data
     * @param {string} groupId
     * @returns {boolean}
     */
  }, {
    key: "hasData",
    value: function hasData(groupId) {
      return this.groupData.has(groupId);
    }
    /**
     * Get timestamps from a group
     * @param {string} groupId
     * @returns {number[]}
     */
  }, {
    key: "getData",
    value: function getData(groupId) {
      return this.groupData.get(groupId) || [];
    }
    /**
     * Get the maximum idle time (in milliseconds) before a group is considered expired.
     * @returns {number}
     */
  }, {
    key: "getMaxIdle",
    value: function getMaxIdle() {
      if (typeof _classPrivateFieldGet(_maxIdle, this) !== 'number' || !Number.isFinite(_classPrivateFieldGet(_maxIdle, this)) || _classPrivateFieldGet(_maxIdle, this) < 0) {
        throw new Error("'maxIdle' must be a non-negative finite number.");
      }
      return _classPrivateFieldGet(_maxIdle, this);
    }
    /**
     * Set the maximum idle time (in milliseconds) before a group is considered expired.
     * @param {number} ms
     */
  }, {
    key: "setMaxIdle",
    value: function setMaxIdle(ms) {
      if (typeof ms !== 'number' || !Number.isFinite(ms) || ms < 0) {
        throw new Error("'maxIdle' must be a non-negative finite number.");
      }
      _classPrivateFieldSet(_maxIdle, this, ms);
    }
    /**
     * Cleanup old/inactive groups with individual TTLs
     * @private
     */
  }, {
    key: "_cleanup",
    value: function _cleanup() {
      var now = Date.now();
      var _iterator6 = _createForOfIteratorHelper(this.lastSeen.entries()),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _this$getGroupTTL;
          var _step6$value = _slicedToArray(_step6.value, 2),
            groupId = _step6$value[0],
            last = _step6$value[1];
          var ttl = (_this$getGroupTTL = this.getGroupTTL(groupId)) !== null && _this$getGroupTTL !== void 0 ? _this$getGroupTTL : this.getMaxIdle();
          if (now - last > ttl) {
            this.groupFlags["delete"](groupId);
            this.groupData["delete"](groupId);
            this.lastSeen["delete"](groupId);
            this.groupTTL["delete"](groupId);
            // Notify subclass or external binding
            if (typeof _classPrivateFieldGet(_onGroupExpired, this) === 'function') {
              _classPrivateFieldGet(_onGroupExpired, this).call(this, groupId);
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
    /**
     * Get list of active group IDs
     * @returns {string[]}
     */
  }, {
    key: "getActiveGroups",
    value: function getActiveGroups() {
      return Array.from(this.groupData.keys());
    }
    /**
     * Get a shallow copy of all user-to-group mappings as a plain object
     * @returns {Record<string, string>}
     */
  }, {
    key: "getAllUserMappings",
    value: function getAllUserMappings() {
      return Object.fromEntries(this.userToGroup);
    }
    /**
     * Get the interval window in milliseconds.
     * @returns {number}
     */
  }, {
    key: "getInterval",
    value: function getInterval() {
      if (typeof _classPrivateFieldGet(_interval, this) !== 'number' || !Number.isFinite(_classPrivateFieldGet(_interval, this))) {
        throw new Error("'interval' is not a valid finite number.");
      }
      return _classPrivateFieldGet(_interval, this);
    }
    /**
     * Get the maximum number of allowed hits.
     * @returns {number}
     */
  }, {
    key: "getMaxHits",
    value: function getMaxHits() {
      if (typeof _classPrivateFieldGet(_maxHits, this) !== 'number' || !Number.isFinite(_classPrivateFieldGet(_maxHits, this))) {
        throw new Error("'maxHits' is not a valid finite number.");
      }
      return _classPrivateFieldGet(_maxHits, this);
    }
    /**
     * Get the total number of hits recorded for a group.
     * @param {string} groupId
     * @returns {number}
     */
  }, {
    key: "getTotalHits",
    value: function getTotalHits(groupId) {
      var history = this.groupData.get(groupId);
      return Array.isArray(history) ? history.length : 0;
    }
    /**
     * Get the timestamp of the last hit for a group.
     * @param {string} groupId
     * @returns {number|null}
     */
  }, {
    key: "getLastHit",
    value: function getLastHit(groupId) {
      var history = this.groupData.get(groupId);
      return history !== null && history !== void 0 && history.length ? history[history.length - 1] : null;
    }
    /**
     * Get milliseconds since the last hit for a group.
     * @param {string} groupId
     * @returns {number|null}
     */
  }, {
    key: "getTimeSinceLastHit",
    value: function getTimeSinceLastHit(groupId) {
      var last = this.getLastHit(groupId);
      return last !== null ? Date.now() - last : null;
    }
    /**
     * Internal utility to compute average spacing
     * @private
     * @param {number[]|undefined} history
     * @returns {number|null}
     */
  }, {
    key: "_calculateAverageSpacing",
    value: function _calculateAverageSpacing(history) {
      if (!Array.isArray(history) || history.length < 2) return null;
      var total = 0;
      for (var i = 1; i < history.length; i++) {
        total += history[i] - history[i - 1];
      }
      return total / (history.length - 1);
    }
    /**
     * Get average time between hits for a group (ms).
     * @param {string} groupId
     * @returns {number|null}
     */
  }, {
    key: "getAverageHitSpacing",
    value: function getAverageHitSpacing(groupId) {
      return this._calculateAverageSpacing(this.groupData.get(groupId));
    }
    /**
     * Get metrics about a group's activity.
     * @param {string} groupId
     * @returns {{
     *   totalHits: number,
     *   lastHit: number|null,
     *   timeSinceLastHit: number|null,
     *   averageHitSpacing: number|null
     * }}
     */
  }, {
    key: "getMetrics",
    value: function getMetrics(groupId) {
      var history = this.groupData.get(groupId);
      if (!Array.isArray(history) || history.length === 0) {
        return {
          totalHits: 0,
          lastHit: null,
          timeSinceLastHit: null,
          averageHitSpacing: null
        };
      }
      var totalHits = history.length;
      var lastHit = history[totalHits - 1];
      var timeSinceLastHit = Date.now() - lastHit;
      var averageHitSpacing = this._calculateAverageSpacing(history);
      return {
        totalHits: totalHits,
        lastHit: lastHit,
        timeSinceLastHit: timeSinceLastHit,
        averageHitSpacing: averageHitSpacing
      };
    }
    /**
     * Destroy the rate limiter, stopping cleanup and clearing data
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (_classPrivateFieldGet(_cleanupTimer, this)) clearInterval(_classPrivateFieldGet(_cleanupTimer, this));
      this._cleanup();
      this.groupData.clear();
      this.lastSeen.clear();
      this.userToGroup.clear();
      this.groupTTL.clear();
      this.groupFlags.clear();
    }
  }]);
}();
var _default = exports["default"] = TinyRateLimiter;

}).call(this)}).call(this,require('_process'))
},{"_process":111}],166:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"dup":154}],167:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"dup":155}],168:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"dup":156}],169:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"dup":157}],170:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"dup":158}],171:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areElsPerfColliding = exports.areElsColliding = exports.areElsCollTop = exports.areElsCollRight = exports.areElsCollPerfTop = exports.areElsCollPerfRight = exports.areElsCollPerfLeft = exports.areElsCollPerfBottom = exports.areElsCollLeft = exports.areElsCollBottom = void 0;
exports.getElsCollDetails = getElsCollDetails;
exports.getElsCollDirDepth = getElsCollDirDepth;
exports.getElsPerfColliding = exports.getElsColliding = exports.getElsCollOverlapPos = exports.getElsCollOverlap = void 0;
exports.getElsRelativeCenterOffset = getElsRelativeCenterOffset;
exports.getRectCenter = void 0;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/**
 * A direction relative to a rectangle.
 *
 * Represents one of the four cardinal directions from the perspective of the element.
 *
 * @typedef {'top' | 'bottom' | 'left' | 'right'} Dirs
 */
/**
 * Represents all directional aspects of a collision.
 *
 * @typedef {Object} CollDirs
 * @property {Dirs | 'center' | null} in - The dominant direction of entry. `'center'` if all sides are equally overlapped. `null` if no collision.
 * @property {Dirs | null} x - The horizontal direction (`'left'` or `'right'`) the collision is biased toward, or `null`.
 * @property {Dirs | null} y - The vertical direction (`'top'` or `'bottom'`) the collision is biased toward, or `null`.
 */
/**
 * Indicates if a collision is in the negative direction (rect2 is outside rect1).
 *
 * @typedef {Object} NegCollDirs
 * @property {Dirs | null} x - Horizontal direction of negative overlap, if any.
 * @property {Dirs | null} y - Vertical direction of negative overlap, if any.
 */
/**
 * Collision depth values from each side of rect2 inside rect1.
 *
 * Positive values indicate penetration; negative values indicate gaps.
 *
 * @typedef {Object} CollData
 * @property {number} top - Depth from rect2's top into rect1.
 * @property {number} bottom - Depth from rect2's bottom into rect1.
 * @property {number} left - Depth from rect2's left into rect1.
 * @property {number} right - Depth from rect2's right into rect1.
 */
/**
 * X and Y offset representing center difference between two rectangles.
 *
 * Useful to measure how far one element's center is from another.
 *
 * @typedef {Object} CollCenter
 * @property {number} x - Horizontal distance in pixels from rect1's center to rect2's center.
 * @property {number} y - Vertical distance in pixels from rect1's center to rect2's center.
 */
/**
 * Represents a rectangular area in absolute pixel values.
 *
 * Similar to `DOMRect`, this object describes the dimensions and position of a box
 * in the 2D plane, typically representing an element's bounding box.
 *
 * @typedef {Object} ObjRect
 * @property {number} height - The total height of the rectangle in pixels.
 * @property {number} width - The total width of the rectangle in pixels.
 * @property {number} top - The Y-coordinate of the top edge of the rectangle.
 * @property {number} bottom - The Y-coordinate of the bottom edge of the rectangle.
 * @property {number} left - The X-coordinate of the left edge of the rectangle.
 * @property {number} right - The X-coordinate of the right edge of the rectangle.
 */
// Normal collision checks (loose overlap detection)
/**
 * Checks if rect1 is completely above rect2 (no vertical overlap).
 *
 * @param {ObjRect} rect1 - The bounding rectangle of the first element.
 * @param {ObjRect} rect2 - The bounding rectangle of the second element.
 * @returns {boolean} True if rect1 is entirely above rect2.
 */
var areElsCollTop = exports.areElsCollTop = function areElsCollTop(rect1, rect2) {
  return rect1.bottom < rect2.top;
};
/**
 * Checks if rect1 is completely below rect2 (no vertical overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is entirely below rect2.
 */
var areElsCollBottom = exports.areElsCollBottom = function areElsCollBottom(rect1, rect2) {
  return rect1.top > rect2.bottom;
};
/**
 * Checks if rect1 is completely to the left of rect2 (no horizontal overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is entirely to the left of rect2.
 */
var areElsCollLeft = exports.areElsCollLeft = function areElsCollLeft(rect1, rect2) {
  return rect1.right < rect2.left;
};
/**
 * Checks if rect1 is completely to the right of rect2 (no horizontal overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is entirely to the right of rect2.
 */
var areElsCollRight = exports.areElsCollRight = function areElsCollRight(rect1, rect2) {
  return rect1.left > rect2.right;
};
// Perfect collision checks (touch included)
/**
 * Checks if rect1 is perfectly above rect2 (no vertical touch or overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is fully above or touching rect2's top.
 */
var areElsCollPerfTop = exports.areElsCollPerfTop = function areElsCollPerfTop(rect1, rect2) {
  return rect1.bottom <= rect2.top;
};
/**
 * Checks if rect1 is perfectly below rect2 (no vertical touch or overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is fully below or touching rect2's bottom.
 */
var areElsCollPerfBottom = exports.areElsCollPerfBottom = function areElsCollPerfBottom(rect1, rect2) {
  return rect1.top >= rect2.bottom;
};
/**
 * Checks if rect1 is perfectly to the left of rect2 (no horizontal touch or overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is fully left or touching rect2's left.
 */
var areElsCollPerfLeft = exports.areElsCollPerfLeft = function areElsCollPerfLeft(rect1, rect2) {
  return rect1.right <= rect2.left;
};
/**
 * Checks if rect1 is perfectly to the right of rect2 (no horizontal touch or overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is fully right or touching rect2's right.
 */
var areElsCollPerfRight = exports.areElsCollPerfRight = function areElsCollPerfRight(rect1, rect2) {
  return rect1.left >= rect2.right;
};
// Main collision check
/**
 * Returns true if rect1 and rect2 are colliding (partially or fully overlapping).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if there's any collision between rect1 and rect2.
 */
var areElsColliding = exports.areElsColliding = function areElsColliding(rect1, rect2) {
  return !(areElsCollLeft(rect1, rect2) || areElsCollRight(rect1, rect2) || areElsCollTop(rect1, rect2) || areElsCollBottom(rect1, rect2));
};
/**
 * Returns true if rect1 and rect2 are colliding or perfectly touching.
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if there's any contact or overlap.
 */
var areElsPerfColliding = exports.areElsPerfColliding = function areElsPerfColliding(rect1, rect2) {
  return !(areElsCollPerfLeft(rect1, rect2) || areElsCollPerfRight(rect1, rect2) || areElsCollPerfTop(rect1, rect2) || areElsCollPerfBottom(rect1, rect2));
};
// Collision direction guess (loose and perfect)
/**
 * Attempts to determine the direction rect1 entered rect2 based on loose overlap rules.
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {string|null} 'top' | 'bottom' | 'left' | 'right' | null
 */
var getElsColliding = exports.getElsColliding = function getElsColliding(rect1, rect2) {
  if (areElsCollLeft(rect1, rect2)) return 'left';else if (areElsCollRight(rect1, rect2)) return 'right';else if (areElsCollTop(rect1, rect2)) return 'top';else if (areElsCollBottom(rect1, rect2)) return 'bottom';
  return null;
};
/**
 * Attempts to determine the direction rect1 touched or entered rect2 using perfect mode.
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {'top' | 'bottom' | 'left' | 'right' | null}
 */
var getElsPerfColliding = exports.getElsPerfColliding = function getElsPerfColliding(rect1, rect2) {
  if (areElsCollPerfLeft(rect1, rect2)) return 'left';else if (areElsCollPerfRight(rect1, rect2)) return 'right';else if (areElsCollPerfTop(rect1, rect2)) return 'top';else if (areElsCollPerfBottom(rect1, rect2)) return 'bottom';
  return null;
};
// Overlap Calculation
/**
 * Calculates overlap values between rect1 and rect2 in all directions.
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {{
 *   overlapLeft: number,
 *   overlapRight: number,
 *   overlapTop: number,
 *   overlapBottom: number
 * }} Distance of overlap from each direction (can be negative).
 */
var getElsCollOverlap = exports.getElsCollOverlap = function getElsCollOverlap(rect1, rect2) {
  return {
    overlapLeft: rect2.right - rect1.left,
    overlapRight: rect1.right - rect2.left,
    overlapTop: rect2.bottom - rect1.top,
    overlapBottom: rect1.bottom - rect2.top
  };
};
/**
 * Determines directional collision based on overlap depth.
 *
 * @param {Object} [settings={}]
 * @param {number} [settings.overlapLeft]
 * @param {number} [settings.overlapRight]
 * @param {number} [settings.overlapTop]
 * @param {number} [settings.overlapBottom]
 * @returns {{ dirX: Dirs, dirY: Dirs }} Direction of strongest X/Y overlap.
 */
var getElsCollOverlapPos = exports.getElsCollOverlapPos = function getElsCollOverlapPos() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$overlapLeft = _ref.overlapLeft,
    overlapLeft = _ref$overlapLeft === void 0 ? -1 : _ref$overlapLeft,
    _ref$overlapRight = _ref.overlapRight,
    overlapRight = _ref$overlapRight === void 0 ? -1 : _ref$overlapRight,
    _ref$overlapTop = _ref.overlapTop,
    overlapTop = _ref$overlapTop === void 0 ? -1 : _ref$overlapTop,
    _ref$overlapBottom = _ref.overlapBottom,
    overlapBottom = _ref$overlapBottom === void 0 ? -1 : _ref$overlapBottom;
  return {
    dirX: overlapLeft < overlapRight ? 'right' : 'left',
    dirY: overlapTop < overlapBottom ? 'bottom' : 'top'
  };
};
// Center utils
/**
 * Calculates the center point (X and Y) of a given Rect.
 *
 * @param {ObjRect} rect - The bounding rectangle of the element.
 * @returns {{ x: number, y: number }} An object with the `x` and `y` coordinates of the center.
 */
var getRectCenter = exports.getRectCenter = function getRectCenter(rect) {
  return {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
  };
};
/**
 * Calculates the offset between the center of rect2 and the center of rect1.
 *
 * The values will be 0 when rect1 is perfectly centered over rect2.
 *
 * @param {ObjRect} rect1 - The bounding rectangle of the reference element.
 * @param {ObjRect} rect2 - The bounding rectangle of the element being compared.
 * @returns {{
 *   x: number,
 *   y: number
 * }} An object with the X and Y offset in pixels from rect1's center to rect2's center.
 */
function getElsRelativeCenterOffset(rect1, rect2) {
  var center1X = rect1.left + rect1.width / 2;
  var center1Y = rect1.top + rect1.height / 2;
  var center2X = rect2.left + rect2.width / 2;
  var center2Y = rect2.top + rect2.height / 2;
  return {
    x: center2X - center1X,
    y: center2Y - center1Y
  };
}
// Direction & Depth detection
/**
 * Detects the direction of the dominant collision between two elements
 * and calculates how deep the overlap is in both x and y axes.
 *
 * @param {ObjRect} rect1 - The bounding rectangle of the first element.
 * @param {ObjRect} rect2 - The bounding rectangle of the second element.
 * @returns {{
 *   inDir: Dirs | null;
 *   dirX: Dirs | null;
 *   dirY: Dirs | null;
 *   depthX: number;
 *   depthY: number;
 * }} An object containing the collision direction and how deep the overlap is.
 */
function getElsCollDirDepth(rect1, rect2) {
  if (!areElsPerfColliding(rect1, rect2)) return {
    inDir: null,
    dirX: null,
    dirY: null,
    depthX: 0,
    depthY: 0
  };
  var _getElsCollOverlap = getElsCollOverlap(rect1, rect2),
    overlapLeft = _getElsCollOverlap.overlapLeft,
    overlapRight = _getElsCollOverlap.overlapRight,
    overlapTop = _getElsCollOverlap.overlapTop,
    overlapBottom = _getElsCollOverlap.overlapBottom;
  var _getElsCollOverlapPos = getElsCollOverlapPos({
      overlapLeft: overlapLeft,
      overlapRight: overlapRight,
      overlapTop: overlapTop,
      overlapBottom: overlapBottom
    }),
    dirX = _getElsCollOverlapPos.dirX,
    dirY = _getElsCollOverlapPos.dirY;
  var depthX = Math.min(overlapLeft, overlapRight);
  var depthY = Math.min(overlapTop, overlapBottom);
  /** @type {Dirs} */
  var inDir;
  if (depthX < depthY) inDir = dirX;else inDir = dirY;
  return {
    inDir: inDir,
    dirX: dirX,
    dirY: dirY,
    depthX: depthX,
    depthY: depthY
  };
}
// Full detail report
/**
 * Detects the collision direction and depth between two DOMRects.
 *
 * @param {ObjRect} rect1 - The bounding rectangle of the first element.
 * @param {ObjRect} rect2 - The bounding rectangle of the second element.
 * @returns {{ depth: CollData; dirs: CollDirs; isNeg: NegCollDirs; }} Collision info or null if no collision is detected.
 */
function getElsCollDetails(rect1, rect2) {
  var isColliding = areElsPerfColliding(rect1, rect2);
  /** @type {CollDirs} */
  var dirs = {
    "in": null,
    x: null,
    y: null
  };
  /** @type {NegCollDirs} */
  var isNeg = {
    y: null,
    x: null
  };
  /** @type {Record<Dirs, number>} */
  var depth = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  };
  // Depth
  // Yes, it's actually reversed the values orders
  var _getElsCollOverlap2 = getElsCollOverlap(rect2, rect1),
    overlapLeft = _getElsCollOverlap2.overlapLeft,
    overlapRight = _getElsCollOverlap2.overlapRight,
    overlapTop = _getElsCollOverlap2.overlapTop,
    overlapBottom = _getElsCollOverlap2.overlapBottom;
  depth.top = overlapTop;
  depth.bottom = overlapBottom;
  depth.left = overlapLeft;
  depth.right = overlapRight;
  // Dirs
  /**
   * Detect the direction with the smallest positive overlap (entry point)
   * @type {[Dirs, number][]}
   */
  // @ts-ignore
  var entries = Object.entries(depth).filter(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      val = _ref3[1];
    return val > 0;
  }).sort(function (a, b) {
    return a[1] - b[1];
  });
  // Yes, it's actually reversed the values orders here too
  var _getElsCollOverlapPos2 = getElsCollOverlapPos({
      overlapLeft: overlapRight,
      overlapRight: overlapLeft,
      overlapTop: overlapBottom,
      overlapBottom: overlapTop
    }),
    dirX = _getElsCollOverlapPos2.dirX,
    dirY = _getElsCollOverlapPos2.dirY;
  dirs.y = dirY;
  dirs.x = dirX;
  // isNeg
  if (depth.bottom < 0) isNeg.y = 'bottom';else if (depth.top < 0) isNeg.y = 'top';
  if (depth.left < 0) isNeg.x = 'left';else if (depth.right < 0) isNeg.x = 'right';
  // Inside Dir
  dirs["in"] = isColliding ? depth.top === depth.bottom && depth.bottom === depth.left && depth.left === depth.right ? 'center' : entries.length ? entries[0][0] : 'top' : null; // fallback in case of exact match
  // Complete
  return {
    dirs: dirs,
    depth: depth,
    isNeg: isNeg
  };
}

},{}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requestFullScreen = exports.onFullScreenChange = exports.offFullScreenChange = exports.isScreenFilled = exports.isFullScreenMode = exports.exitFullScreen = exports.documentIsFullScreen = void 0;
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Checks if the document is currently in fullscreen mode.
 *
 * @returns {boolean}
 */
var documentIsFullScreen = exports.documentIsFullScreen = function documentIsFullScreen() {
  return !!(document.fullscreenElement ||
  // @ts-ignore
  document.webkitFullscreenElement ||
  // @ts-ignore
  document.mozFullScreenElement ||
  // @ts-ignore
  document.msFullscreenElement ||
  // @ts-ignore
  document.webkitIsFullScreen ||
  // @ts-ignore
  document.mozFullScreen);
};
/**
 * Checks if the window occupies the entire screen dimensions.
 *
 * @returns {boolean}
 */
var isScreenFilled = exports.isScreenFilled = function isScreenFilled() {
  return window.innerHeight === screen.height && window.innerWidth === screen.width;
};
/**
 * Checks if fullscreen mode is active either via document API or by matching screen dimensions.
 *
 * @returns {boolean}
 */
var isFullScreenMode = exports.isFullScreenMode = function isFullScreenMode() {
  return documentIsFullScreen() || isScreenFilled();
};
/**
 * Requests fullscreen mode for the document.
 *
 * @param {FullscreenOptions} [ops]
 * @returns {Promise<void>}
 */
var requestFullScreen = exports.requestFullScreen = function requestFullScreen(ops) {
  return new Promise(/*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(resolve, reject) {
      var docElm, _t;
      return _regenerator().w(function (_context) {
        while (1) switch (_context.n) {
          case 0:
            docElm = document.documentElement;
            _context.p = 1;
            if (!docElm.requestFullscreen) {
              _context.n = 3;
              break;
            }
            _context.n = 2;
            return docElm.requestFullscreen(ops);
          case 2:
            _context.n = 4;
            break;
          case 3:
            if (docElm.mozRequestFullScreen) {
              // @ts-ignore
              docElm.mozRequestFullScreen(ops);
              // @ts-ignore
            } else if (docElm.webkitRequestFullScreen) {
              // @ts-ignore
              docElm.webkitRequestFullScreen(ops);
              // @ts-ignore
            } else if (docElm.msRequestFullscreen) {
              // @ts-ignore
              docElm.msRequestFullscreen(ops);
            }
          case 4:
            resolve();
            _context.n = 6;
            break;
          case 5:
            _context.p = 5;
            _t = _context.v;
            reject(_t);
          case 6:
            return _context.a(2);
        }
      }, _callee, null, [[1, 5]]);
    }));
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
};
/**
 * Exits fullscreen mode.
 *
 * @returns {Promise<void>}
 */
var exitFullScreen = exports.exitFullScreen = function exitFullScreen() {
  return new Promise(function (resolve, reject) {
    if (document.exitFullscreen) {
      document.exitFullscreen().then(resolve)["catch"](reject);
    } else {
      try {
        // @ts-ignore
        if (document.mozCancelFullScreen) document.mozCancelFullScreen();
        // @ts-ignore
        else if (document.webkitCancelFullScreen) document.webkitCancelFullScreen();
        // @ts-ignore
        else if (document.msExitFullscreen) document.msExitFullscreen();else throw new Error('Fullscreen API is not supported');
        resolve();
      } catch (err) {
        reject(err);
      }
    }
  });
};
/** @type {readonly string[]} */
var fullScreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
/**
 * Attaches a listener to fullscreen change events.
 *
 * @param {EventListenerOrEventListenerObject} listener
 * @param {boolean|AddEventListenerOptions} [ops]
 * @returns {void}
 */
var onFullScreenChange = exports.onFullScreenChange = function onFullScreenChange(listener, ops) {
  fullScreenEvents.forEach(function (event) {
    document.addEventListener(event, listener, ops);
  });
};
/**
 * Removes a listener from fullscreen change events.
 *
 * @param {EventListenerOrEventListenerObject} listener
 * @param {boolean|AddEventListenerOptions} [ops]
 * @returns {void}
 */
var offFullScreenChange = exports.offFullScreenChange = function offFullScreenChange(listener, ops) {
  fullScreenEvents.forEach(function (event) {
    document.removeEventListener(event, listener, ops);
  });
};

},{}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchBlob = fetchBlob;
exports.fetchJson = fetchJson;
exports.fetchText = fetchText;
exports.installWindowHiddenScript = installWindowHiddenScript;
exports.readBase64Blob = readBase64Blob;
exports.readFileBlob = readFileBlob;
exports.readJsonBlob = readJsonBlob;
exports.saveJsonFile = saveJsonFile;
var _objChecker = require("./objChecker.mjs");
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/////////////////////////////////////////////////////////////////
/**
 * Reads the contents of a file using the specified FileReader method.
 *
 * @param {File} file - The file to be read.
 * @param {'readAsArrayBuffer'|'readAsDataURL'|'readAsText'|'readAsBinaryString'} method -
 *   The FileReader method to use for reading the file.
 * @returns {Promise<any>} - A promise that resolves with the file content, according to the chosen method.
 * @throws {Error} - If an unexpected error occurs while handling the result.
 * @throws {DOMException} - If the FileReader encounters an error while reading the file.
 */
function readFileBlob(file, method) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();
    reader.onload = function () {
      try {
        resolve(reader.result);
      } catch (error) {
        reject(error);
      }
    };
    reader.onerror = function () {
      reject(reader.error);
    };
    reader[method](file);
  });
}
/**
 * Reads a file as a Base64 string using FileReader, and optionally formats it as a full data URL.
 *
 * Performs strict validation to ensure the result is a valid Base64 string or a proper data URL.
 *
 * @param {File} file - The file to be read.
 * @param {boolean|string} [isDataUrl=false] - If true, returns a full data URL; if false, returns only the Base64 string;
 *   if a string is passed, it is used as the MIME type in the data URL.
 * @returns {Promise<string>} - A promise that resolves with the Base64 string or data URL.
 *
 * @throws {TypeError} - If the result is not a string or if `isDataUrl` is not a valid type.
 * @throws {Error} - If the result does not match the expected data URL format or Base64 structure.
 * @throws {DOMException} - If the FileReader fails to read the file.
 */
function readBase64Blob(file) {
  var isDataUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return new Promise(function (resolve, reject) {
    if (typeof isDataUrl !== 'string' && typeof isDataUrl !== 'boolean') reject(new TypeError('The isDataUrl parameter must be a boolean or a string.'));
    readFileBlob(file, 'readAsDataURL').then(
    /**
     * Ensure that the URL format is correct in the required pattern
     * @param {string} base64Data
     */
    function (base64Data) {
      if (typeof base64Data !== 'string') throw new TypeError('Expected file content to be a string.');
      var match = base64Data.match(/^data:(.+);base64,(.*)$/);
      if (!match || !match[2]) throw new Error('Invalid data URL format or missing Base64 content.');
      var _match = _slicedToArray(match, 3),
        mimeType = _match[1],
        base64 = _match[2];
      if (!/^[\w/+]+=*$/.test(base64)) throw new Error('Base64 content is malformed.');
      if (typeof isDataUrl === 'boolean') return resolve(isDataUrl ? base64Data : base64);
      if (!/^[\w-]+\/[\w.+-]+$/.test(isDataUrl)) throw new Error("Invalid MIME type string: ".concat(isDataUrl));
      return resolve("data:".concat(isDataUrl, ";base64,").concat(base64));
    })["catch"](reject);
  });
}
/**
 * Reads a file and strictly validates its content as proper JSON using FileReader.
 *
 * Performs several checks to ensure the file contains valid, parsable JSON data.
 *
 * @param {File} file - The file to be read. It must contain valid JSON as plain text.
 * @returns {Promise<Record<string|number|symbol, any>|any[]>} - A promise that resolves with the parsed JSON object.
 *
 * @throws {SyntaxError} - If the file content is not valid JSON syntax.
 * @throws {TypeError} - If the result is not a string or does not represent a JSON value.
 * @throws {Error} - If the result is empty or structurally invalid as JSON.
 * @throws {DOMException} - If the FileReader fails to read the file.
 */
function readJsonBlob(file) {
  return new Promise(function (resolve, reject) {
    return readFileBlob(file, 'readAsText').then(function (data) {
      if (typeof data !== 'string') throw new TypeError('Expected file content to be a string.');
      var trimmed = data.trim();
      if (trimmed.length === 0) throw new Error('File is empty or contains only whitespace.');
      var parsed = JSON.parse(trimmed);
      if (_typeof(parsed) !== 'object' || parsed === null) throw new Error('Parsed content is not a valid JSON object or array.');
      resolve(parsed);
    })["catch"](reject);
  });
}
/**
 * Saves a JSON object as a downloadable file.
 * @param {string} filename
 * @param {any} data
 * @param {number} [spaces=2]
 */
function saveJsonFile(filename, data) {
  var spaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var json = JSON.stringify(data, null, spaces);
  var blob = new Blob([json], {
    type: 'application/json'
  });
  var url = URL.createObjectURL(blob);
  var link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
/**
 * @typedef {Object} FetchTemplateOptions
 * @property {string} [method="GET"] - HTTP method to use (GET, POST, etc.).
 * @property {any} [body] - Request body (only for methods like POST, PUT).
 * @property {number} [timeout=0] - Timeout in milliseconds (ignored if signal is provided).
 * @property {number} [retries=0] - Number of retry attempts (ignored if signal is provided).
 * @property {Headers|Record<string, *>} [headers={}] - Additional headers.
 * @property {AbortSignal|null} [signal] - External AbortSignal; disables timeout and retries.
 */
/**
 * @param {string} url - The full URL to fetch data from.
 * @param {FetchTemplateOptions} [options] - Optional settings.
 * @returns {Promise<Response>} Result data.
 * @throws {Error} Throws if fetch fails, times out.
 */
function fetchTemplate(_x) {
  return _fetchTemplate.apply(this, arguments);
}
/**
 * Loads and parses a JSON from a remote URL using Fetch API.
 *
 * @param {string} url - The full URL to fetch JSON from.
 * @param {FetchTemplateOptions} [options] - Optional settings.
 * @returns {Promise<any[] | Record<string | number | symbol, unknown>>} Parsed JSON object.
 * @throws {Error} Throws if fetch fails, times out, or returns invalid JSON.
 */
function _fetchTemplate() {
  _fetchTemplate = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(url) {
    var _ref2,
      _ref2$method,
      method,
      body,
      _ref2$timeout,
      timeout,
      _ref2$retries,
      retries,
      _ref2$headers,
      headers,
      _ref2$signal,
      signal,
      attempts,
      lastError,
      _loop,
      _ret,
      attempt,
      _args2 = arguments;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          _ref2 = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, _ref2$method = _ref2.method, method = _ref2$method === void 0 ? 'GET' : _ref2$method, body = _ref2.body, _ref2$timeout = _ref2.timeout, timeout = _ref2$timeout === void 0 ? 0 : _ref2$timeout, _ref2$retries = _ref2.retries, retries = _ref2$retries === void 0 ? 0 : _ref2$retries, _ref2$headers = _ref2.headers, headers = _ref2$headers === void 0 ? {} : _ref2$headers, _ref2$signal = _ref2.signal, signal = _ref2$signal === void 0 ? null : _ref2$signal;
          if (!(typeof url !== 'string' || !url.startsWith('../') && !url.startsWith('./') && !url.startsWith('/') && !url.startsWith('https://') && !url.startsWith('http://'))) {
            _context2.n = 1;
            break;
          }
          throw new Error('Invalid URL: must be a valid http or https address.');
        case 1:
          if (!(typeof method !== 'string' || !method.trim())) {
            _context2.n = 2;
            break;
          }
          throw new Error('Invalid method: must be a non-empty string.');
        case 2:
          if (signal) {
            _context2.n = 4;
            break;
          }
          if (!(typeof timeout !== 'number' || !Number.isFinite(timeout) || Number.isNaN(timeout) || timeout < 0)) {
            _context2.n = 3;
            break;
          }
          throw new Error('Invalid timeout: must be a positive number.');
        case 3:
          if (!(typeof retries !== 'number' || !Number.isFinite(retries) || Number.isNaN(retries) || retries < 0)) {
            _context2.n = 4;
            break;
          }
          throw new Error('Invalid retries: must be a positive number.');
        case 4:
          attempts = signal ? 1 : retries + 1;
          /** @type {Error|null} */
          lastError = null;
          _loop = /*#__PURE__*/_regenerator().m(function _loop(attempt) {
            var _controller$signal;
            var controller, localSignal, timer, response, _t;
            return _regenerator().w(function (_context) {
              while (1) switch (_context.n) {
                case 0:
                  controller = signal ? null : new AbortController();
                  localSignal = signal || ((_controller$signal = controller === null || controller === void 0 ? void 0 : controller.signal) !== null && _controller$signal !== void 0 ? _controller$signal : null);
                  timer = !signal && timeout && controller ? setTimeout(function () {
                    return controller.abort();
                  }, timeout) : null;
                  _context.p = 1;
                  _context.n = 2;
                  return fetch(url, {
                    method: method.toUpperCase(),
                    headers: _objectSpread({
                      Accept: 'application/json'
                    }, headers),
                    body: body !== undefined ? (0, _objChecker.isJsonObject)(body) ? JSON.stringify(body) : body : undefined,
                    signal: localSignal
                  });
                case 2:
                  response = _context.v;
                  if (timer) clearTimeout(timer);
                  if (response.ok) {
                    _context.n = 3;
                    break;
                  }
                  throw new Error("HTTP error: ".concat(response.status, " ").concat(response.statusText));
                case 3:
                  return _context.a(2, {
                    v: response
                  });
                case 4:
                  _context.p = 4;
                  _t = _context.v;
                  lastError = /** @type {Error} */_t;
                  if (!signal) {
                    _context.n = 5;
                    break;
                  }
                  return _context.a(2, 0);
                case 5:
                  if (!(attempt < retries)) {
                    _context.n = 6;
                    break;
                  }
                  _context.n = 6;
                  return new Promise(function (resolve) {
                    return setTimeout(resolve, 300 * (attempt + 1));
                  });
                case 6:
                  return _context.a(2);
              }
            }, _loop, null, [[1, 4]]);
          });
          attempt = 0;
        case 5:
          if (!(attempt < attempts)) {
            _context2.n = 9;
            break;
          }
          return _context2.d(_regeneratorValues(_loop(attempt)), 6);
        case 6:
          _ret = _context2.v;
          if (!(_ret === 0)) {
            _context2.n = 7;
            break;
          }
          return _context2.a(3, 9);
        case 7:
          if (!_ret) {
            _context2.n = 8;
            break;
          }
          return _context2.a(2, _ret.v);
        case 8:
          attempt++;
          _context2.n = 5;
          break;
        case 9:
          throw new Error("Failed to fetch JSON from \"".concat(url, "\"").concat(lastError ? ": ".concat(lastError.message) : '.'));
        case 10:
          return _context2.a(2);
      }
    }, _callee);
  }));
  return _fetchTemplate.apply(this, arguments);
}
function fetchJson(_x2, _x3) {
  return _fetchJson.apply(this, arguments);
}
/**
 * Loads a remote file as a Blob using Fetch API.
 *
 * @param {string} url - The full URL to fetch the file from.
 * @param {FetchTemplateOptions} [options] - Optional fetch options.
 * @param {string[]} [allowedMimeTypes] - Optional list of accepted MIME types (e.g., ['image/jpeg']).
 * @returns {Promise<Blob>} - The fetched file as a Blob.
 * @throws {Error} Throws if fetch fails, response is not ok, or MIME type is not allowed.
 */
function _fetchJson() {
  _fetchJson = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(url, options) {
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          return _context4.a(2, new Promise(function (resolve, reject) {
            fetchTemplate(url, options).then(/*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(res) {
                var contentType, data;
                return _regenerator().w(function (_context3) {
                  while (1) switch (_context3.n) {
                    case 0:
                      contentType = res.headers.get('content-type') || '';
                      if (contentType.includes('application/json')) {
                        _context3.n = 1;
                        break;
                      }
                      throw new Error("Unexpected content-type: ".concat(contentType));
                    case 1:
                      _context3.n = 2;
                      return res.json();
                    case 2:
                      data = _context3.v;
                      if (!(!Array.isArray(data) && !(0, _objChecker.isJsonObject)(data))) {
                        _context3.n = 3;
                        break;
                      }
                      throw new Error('Received invalid data instead of valid JSON.');
                    case 3:
                      return _context3.a(2, resolve(data));
                  }
                }, _callee2);
              }));
              return function (_x0) {
                return _ref3.apply(this, arguments);
              };
            }())["catch"](reject);
          }));
      }
    }, _callee3);
  }));
  return _fetchJson.apply(this, arguments);
}
function fetchBlob(_x4, _x5, _x6) {
  return _fetchBlob.apply(this, arguments);
}
/**
 * Loads a remote file as a text using Fetch API.
 *
 * @param {string} url - The full URL to fetch the file from.
 * @param {FetchTemplateOptions} [options] - Optional fetch options.
 * @param {string[]} [allowedMimeTypes] - Optional list of accepted MIME types (e.g., ['image/jpeg']).
 * @returns {Promise<string>} - The fetched file as a text.
 * @throws {Error} Throws if fetch fails, response is not ok, or MIME type is not allowed.
 */
function _fetchBlob() {
  _fetchBlob = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(url, allowedMimeTypes, options) {
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          return _context6.a(2, new Promise(function (resolve, reject) {
            fetchTemplate(url, options).then(/*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(res) {
                var contentType, data;
                return _regenerator().w(function (_context5) {
                  while (1) switch (_context5.n) {
                    case 0:
                      contentType = res.headers.get('content-type') || '';
                      if (!(Array.isArray(allowedMimeTypes) && allowedMimeTypes.length > 0 && !allowedMimeTypes.some(function (type) {
                        return contentType.includes(type);
                      }))) {
                        _context5.n = 1;
                        break;
                      }
                      throw new Error("Blocked MIME type: ".concat(contentType));
                    case 1:
                      _context5.n = 2;
                      return res.blob();
                    case 2:
                      data = _context5.v;
                      return _context5.a(2, resolve(data));
                  }
                }, _callee4);
              }));
              return function (_x1) {
                return _ref4.apply(this, arguments);
              };
            }())["catch"](reject);
          }));
      }
    }, _callee5);
  }));
  return _fetchBlob.apply(this, arguments);
}
function fetchText(_x7, _x8, _x9) {
  return _fetchText.apply(this, arguments);
} ///////////////////////////////////////////////////////////////////////////////
/**
 * Installs a script that toggles CSS classes on a given element
 * based on the page's visibility or focus state, and optionally
 * triggers callbacks on visibility changes.
 *
 * @param {Object} [settings={}]
 * @param {Element} [settings.element=document.body] - The element to receive visibility classes.
 * @param {string} [settings.hiddenClass='windowHidden'] - CSS class applied when the page is hidden.
 * @param {string} [settings.visibleClass='windowVisible'] - CSS class applied when the page is visible.
 * @param {(data: { type: string; oldType: string; oldClass: string; }) => void} [settings.onVisible] - Callback called when page becomes visible.
 * @param {(data: { type: string; oldType: string; oldClass: string; }) => void} [settings.onHidden] - Callback called when page becomes hidden.
 * @returns {() => void} Function that removes all installed event listeners.
 * @throws {TypeError} If any provided setting is invalid.
 */
function _fetchText() {
  _fetchText = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(url, allowedMimeTypes, options) {
    return _regenerator().w(function (_context8) {
      while (1) switch (_context8.n) {
        case 0:
          return _context8.a(2, new Promise(function (resolve, reject) {
            fetchTemplate(url, options).then(/*#__PURE__*/function () {
              var _ref5 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(res) {
                var contentType, data;
                return _regenerator().w(function (_context7) {
                  while (1) switch (_context7.n) {
                    case 0:
                      contentType = res.headers.get('content-type') || '';
                      if (!(Array.isArray(allowedMimeTypes) && allowedMimeTypes.length > 0 && !allowedMimeTypes.some(function (type) {
                        return contentType.includes(type);
                      }))) {
                        _context7.n = 1;
                        break;
                      }
                      throw new Error("Blocked MIME type: ".concat(contentType));
                    case 1:
                      _context7.n = 2;
                      return res.text();
                    case 2:
                      data = _context7.v;
                      return _context7.a(2, resolve(data));
                  }
                }, _callee6);
              }));
              return function (_x10) {
                return _ref5.apply(this, arguments);
              };
            }())["catch"](reject);
          }));
      }
    }, _callee7);
  }));
  return _fetchText.apply(this, arguments);
}
function installWindowHiddenScript() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$element = _ref.element,
    element = _ref$element === void 0 ? document.body : _ref$element,
    _ref$hiddenClass = _ref.hiddenClass,
    hiddenClass = _ref$hiddenClass === void 0 ? 'windowHidden' : _ref$hiddenClass,
    _ref$visibleClass = _ref.visibleClass,
    visibleClass = _ref$visibleClass === void 0 ? 'windowVisible' : _ref$visibleClass,
    onVisible = _ref.onVisible,
    onHidden = _ref.onHidden;
  if (!(element instanceof Element)) throw new TypeError("\"element\" must be an instance of Element.");
  if (typeof hiddenClass !== 'string') throw new TypeError("\"hiddenClass\" must be a string.");
  if (typeof visibleClass !== 'string') throw new TypeError("\"visibleClass\" must be a string.");
  if (onVisible !== undefined && typeof onVisible !== 'function') throw new TypeError("\"onVisible\" must be a function if provided.");
  if (onHidden !== undefined && typeof onHidden !== 'function') throw new TypeError("\"onHidden\" must be a function if provided.");
  var oldType = '';
  var oldClass = '';
  var removeClass = function removeClass() {
    element.classList.remove(hiddenClass);
    element.classList.remove(visibleClass);
  };
  /** @type {string|null} */
  var hiddenProp = null;
  var visibilityEvents = ['visibilitychange', 'mozvisibilitychange', 'webkitvisibilitychange', 'msvisibilitychange'];
  var visibilityProps = ['hidden', 'mozHidden', 'webkitHidden', 'msHidden'];
  for (var i = 0; i < visibilityProps.length; i++) {
    if (visibilityProps[i] in document) {
      hiddenProp = visibilityProps[i];
      break;
    }
  }
  /** @type {(this: any, evt: Event) => void} */
  var handler = function handler(evt) {
    removeClass();
    var type = evt === null || evt === void 0 ? void 0 : evt.type;
    // @ts-ignore
    var isHidden = hiddenProp && document[hiddenProp];
    var visibleEvents = ['focus', 'focusin', 'pageshow'];
    var hiddenEvents = ['blur', 'focusout', 'pagehide'];
    if (visibleEvents.includes(type)) {
      element.classList.add(visibleClass);
      onVisible === null || onVisible === void 0 || onVisible({
        type: type,
        oldClass: oldClass,
        oldType: oldType
      });
      oldClass = visibleClass;
    } else if (hiddenEvents.includes(type)) {
      element.classList.add(hiddenClass);
      onHidden === null || onHidden === void 0 || onHidden({
        type: type,
        oldClass: oldClass,
        oldType: oldType
      });
      oldClass = hiddenClass;
    } else {
      if (isHidden) {
        element.classList.add(hiddenClass);
        onHidden === null || onHidden === void 0 || onHidden({
          type: type,
          oldClass: oldClass,
          oldType: oldType
        });
        oldClass = hiddenClass;
      } else {
        element.classList.add(visibleClass);
        onVisible === null || onVisible === void 0 || onVisible({
          type: type,
          oldClass: oldClass,
          oldType: oldType
        });
        oldClass = visibleClass;
      }
    }
    oldType = type;
  };
  /** @type {() => void} */
  var uninstall = function uninstall() {};
  if (hiddenProp) {
    var eventType = visibilityEvents[visibilityProps.indexOf(hiddenProp)];
    document.addEventListener(eventType, handler);
    window.addEventListener('focus', handler);
    window.addEventListener('blur', handler);
    uninstall = function uninstall() {
      document.removeEventListener(eventType, handler);
      window.removeEventListener('focus', handler);
      window.removeEventListener('blur', handler);
      removeClass();
    };
  } else if ('onfocusin' in document) {
    // Fallback for IE9 and older
    // @ts-ignore
    document.onfocusin = document.onfocusout = handler;
    uninstall = function uninstall() {
      // @ts-ignore
      document.onfocusin = document.onfocusout = null;
      removeClass();
    };
  } else {
    // Last resort fallback
    window.onpageshow = window.onpagehide = window.onfocus = window.onblur = handler;
    uninstall = function uninstall() {
      window.onpageshow = window.onpagehide = window.onfocus = window.onblur = null;
      removeClass();
    };
  }
  // Trigger initial state
  // @ts-ignore
  var simulatedEvent = new Event(hiddenProp && document[hiddenProp] ? 'blur' : 'focus');
  handler(simulatedEvent);
  return uninstall;
}

},{"./objChecker.mjs":175}],174:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areHtmlElsColliding = areHtmlElsColliding;
exports.areHtmlElsPerfColliding = areHtmlElsPerfColliding;
exports.getHtmlElPadding = exports.getHtmlElMargin = exports.getHtmlElBordersWidth = exports.getHtmlElBorders = void 0;
exports.isInViewport = isInViewport;
exports.isScrolledIntoView = isScrolledIntoView;
var _TinyHtml = _interopRequireDefault(require("../libs/TinyHtml.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Checks if two DOM elements are colliding on the screen.
 *
 * @param {Element} elem1 - First DOM element.
 * @param {Element} elem2 - Second DOM element.
 * @returns {boolean} - Returns true if the elements are colliding.
 * @deprecated - Use TinyHtml.isCollWith instead.
 */
function areHtmlElsColliding(elem1, elem2) {
  return _TinyHtml["default"].isCollWith(elem1, elem2);
}
/**
 * Checks if two DOM elements are colliding on the screen.
 *
 * @param {Element} elem1 - First DOM element.
 * @param {Element} elem2 - Second DOM element.
 * @returns {boolean} - Returns true if the elements are colliding.
 * @deprecated - Use TinyHtml.isCollPerfWith instead.
 */
function areHtmlElsPerfColliding(elem1, elem2) {
  return _TinyHtml["default"].isCollPerfWith(elem1, elem2);
}
///////////////////////////////////////////////////////////////////////////
/**
 * @typedef {import('../libs/TinyHtml.mjs').HtmlElBoxSides} HtmlElBoxSides
 */
/**
 * Returns the total border width and individual sides from `border{Side}Width` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border widths, and each side individually.
 * @deprecated - Use TinyHtml.borderWidth instead.
 */
var getHtmlElBordersWidth = exports.getHtmlElBordersWidth = function getHtmlElBordersWidth(el) {
  return _TinyHtml["default"].borderWidth(el);
};
/**
 * Returns the total border size and individual sides from `border{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border sizes, and each side individually.
 * @deprecated - Use TinyHtml.border instead.
 */
var getHtmlElBorders = exports.getHtmlElBorders = function getHtmlElBorders(el) {
  return _TinyHtml["default"].border(el);
};
/**
 * Returns the total margin and individual sides from `margin{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) margins, and each side individually.
 * @deprecated - Use TinyHtml.margin instead.
 */
var getHtmlElMargin = exports.getHtmlElMargin = function getHtmlElMargin(el) {
  return _TinyHtml["default"].margin(el);
};
/**
 * Returns the total padding and individual sides from `padding{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) paddings, and each side individually.
 * @deprecated - Use TinyHtml.padding instead.
 */
var getHtmlElPadding = exports.getHtmlElPadding = function getHtmlElPadding(el) {
  return _TinyHtml["default"].padding(el);
};
/////////////////////////////////////////////////////////////
// The new version will receive great modifications, the deprecated code has been preserved for non-glitch designs that are using the original code.
/**
 * Checks if the given element is at least partially visible in the viewport.
 *
 * @param {HTMLElement} element - The DOM element to check.
 * @returns {boolean} True if the element is partially in the viewport, false otherwise.
 * @deprecated - Use TinyHtml.isInViewport instead.
 */
function isInViewport(element) {
  var elementTop = element.offsetTop;
  var elementBottom = elementTop + element.offsetHeight;
  var viewportTop = window.scrollY;
  var viewportBottom = viewportTop + window.innerHeight;
  return elementBottom > viewportTop && elementTop < viewportBottom;
}
/**
 * Checks if the given element is fully visible in the viewport (top and bottom).
 *
 * @param {HTMLElement} element - The DOM element to check.
 * @returns {boolean} True if the element is fully visible in the viewport, false otherwise.
 * @deprecated - Use TinyHtml.isScrolledIntoView instead.
 */
function isScrolledIntoView(element) {
  var viewportTop = window.scrollY;
  var viewportBottom = viewportTop + window.innerHeight;
  var elemTop = element.offsetTop;
  var elemBottom = elemTop + element.offsetHeight;
  return elemBottom <= viewportBottom && elemTop >= viewportTop;
}

},{"../libs/TinyHtml.mjs":190}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.countObj = countObj;
exports.isJsonObject = isJsonObject;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Counts the number of elements in an array or the number of properties in an object.
 *
 * @param {Array<*>|Record<string | number | symbol, any>} obj - The array or object to count.
 * @returns {number} - The count of items (array elements or object keys), or `0` if the input is neither an array nor an object.
 *
 * @example
 * countObj([1, 2, 3]); // 3
 * countObj({ a: 1, b: 2 }); // 2
 * countObj('not an object'); // 0
 */
function countObj(obj) {
  // Is Array
  if (Array.isArray(obj)) return obj.length;
  // Object
  if (isJsonObject(obj)) return Object.keys(obj).length;
  // Nothing
  return 0;
}
/**
 * Determines whether a given value is a pure JSON object (plain object).
 *
 * A pure object satisfies the following:
 * - It is not null.
 * - Its type is "object".
 * - Its internal [[Class]] is "[object Object]".
 * - It is not an instance of built-in types like Array, Date, Map, Set, etc.
 *
 * This function is useful for strict data validation when you want to ensure
 * a value is a clean JSON-compatible object, free of class instances or special types.
 *
 * @param {unknown} value - The value to test.
 * @returns {value is Record<string | number | symbol, unknown>} Returns true if the value is a pure object.
 */
function isJsonObject(value) {
  if (value === null || _typeof(value) !== 'object') return false;
  if (Array.isArray(value)) return false;
  if (Object.prototype.toString.call(value) !== '[object Object]') return false;
  return true;
}

},{}],176:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkObj = checkObj;
exports.cloneObjTypeOrder = cloneObjTypeOrder;
Object.defineProperty(exports, "countObj", {
  enumerable: true,
  get: function get() {
    return _objChecker.countObj;
  }
});
exports.extendObjType = extendObjType;
exports.getCheckObj = getCheckObj;
Object.defineProperty(exports, "isJsonObject", {
  enumerable: true,
  get: function get() {
    return _objChecker.isJsonObject;
  }
});
exports.objType = objType;
exports.reorderObjTypeOrder = reorderObjTypeOrder;
var _buffer = require("buffer");
var _objChecker = require("./objChecker.mjs");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
/**
 * An object containing type validation functions and their evaluation order.
 *
 * Each item in `typeValidator.items` is a function that receives any value
 * and returns a boolean indicating whether the value matches the corresponding type.
 *
 * The `order` array defines the priority in which types should be checked,
 * which can be useful for functions that infer types in a consistent manner.
 *
 */
var typeValidator = {
  items: {},
  /**
   * Evaluation order of the type checkers.
   * @type {string[]}
   * */
  order: []
};
/** @typedef {Object.<string, (val: any) => *>} ExtendObjType */
/** @typedef {Array<[string, (val: any) => *]>} ExtendObjTypeArray */
/**
 * Adds new type checkers to the typeValidator without overwriting existing ones.
 *
 * Accepts either an object with named functions or an array of [key, fn] arrays.
 * If no index is provided, the type is inserted just before 'object' (if it exists), or at the end.
 *
 * @param {ExtendObjType|ExtendObjTypeArray} newItems
 *        - New type validators to be added.
 * @param {number} [index] - Optional. Position at which to insert each new type. Ignored if the type already exists.
 * @returns {string[]} - A list of successfully added type names.
 *
 * @example
 * extendObjType({
 *   htmlElement2: val => typeof HTMLElement !== 'undefined' && val instanceof HTMLElement
 * });
 *
 * @example
 * extendObjType([
 *   ['alpha', val => typeof val === 'string'],
 *   ['beta', val => Array.isArray(val)]
 * ]);
 */
function extendObjType(newItems, index) {
  var added = [];
  var entries = Array.isArray(newItems) ? newItems : Object.entries(newItems);
  var _iterator = _createForOfIteratorHelper(entries),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        key = _step$value[0],
        fn = _step$value[1];
      if (!typeValidator.items.hasOwnProperty(key)) {
        // @ts-ignore
        typeValidator.items[key] = fn;
        var insertAt = typeof index === 'number' ? index : -1; // Default to -1 if index isn't provided
        // Default to before 'object', or to the end
        if (insertAt === -1) {
          var objectIndex = typeValidator.order.indexOf('object');
          insertAt = objectIndex > -1 ? objectIndex : typeValidator.order.length;
        }
        // Ensure insertAt is a valid number and not out of bounds
        insertAt = Math.min(Math.max(0, insertAt), typeValidator.order.length);
        typeValidator.order.splice(insertAt, 0, key);
        added.push(key);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return added;
}
/**
 * Reorders the typeValidator.order array according to a custom new order.
 * All values in the new order must already exist in the current order.
 * The function does not mutate the original array structure directly.
 *
 * @param {string[]} newOrder - The new order of type names.
 * @returns {boolean} - Returns true if the reorder was successful, false if invalid keys were found.
 *
 * @example
 * reorderObjTypeOrder([
 *   'string', 'number', 'array', 'object'
 * ]);
 */
function reorderObjTypeOrder(newOrder) {
  var currentOrder = _toConsumableArray(typeValidator.order); // shallow clone
  // All keys in newOrder must exist in currentOrder
  var isValid = newOrder.every(function (type) {
    return currentOrder.includes(type);
  });
  if (!isValid) return false;
  // Reassign only if valid
  typeValidator.order = newOrder.slice(); // assign shallow copy
  return true;
}
/**
 * Returns a cloned version of the `typeValidator.order` array.
 * The cloned array will not be affected by future changes to the original `order`.
 *
 * @returns {string[]} - A new array with the same values as `typeValidator.order`.
 */
function cloneObjTypeOrder() {
  return _toConsumableArray(typeValidator.order); // Creates a shallow copy of the array
}
/**
 * Returns the detected type name of a given value based on predefined type validators.
 *
 * This function uses `getType` with a predefined `typeValidator` to determine or compare types safely.
 * in the specified `typeValidator.order`. The first matching type is returned.
 *
 * If `val` is `null`, it immediately returns `'null'`.
 * If no match is found, it returns `'unknown'`.
 *
 * @param {any} val - The value whose type should be determined.
 * @returns {string} - The type name of the value (e.g., "array", "date", "map"), or "unknown" if no match is found.
 *
 * @example
 * getType([]); // "array"
 * getType(null); // "null"
 * getType(new Set()); // "set"
 * getType(() => {}); // "unknown"
 */
var getType = function getType(val) {
  if (val === null) return 'null';
  // @ts-ignore
  var _iterator2 = _createForOfIteratorHelper(typeValidator.order),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var name = _step2.value;
      // @ts-ignore
      if (typeof typeValidator.items[name] !== 'function' || typeValidator.items[name](val)) return name;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return 'unknown';
};
/**
 * Checks the type of a given object or returns its type as a string.
 *
 * @param {*} obj - The object to check or identify.
 * @param {string} [type] - Optional. If provided, checks whether the object matches this type (e.g., "object", "array", "string").
 * @returns {boolean|string|null} - Returns `true` if the type matches, `false` if not,
 *                                   the type string if no type is provided, or `null` if the object is `undefined`.
 *
 * @example
 * objType([], 'array'); // true
 * objType({}, 'object'); // true
 * objType('hello'); // "string"
 * objType(undefined); // null
 */
function objType(obj, type) {
  if (typeof obj === 'undefined') return null;
  var result = getType(obj);
  if (typeof type === 'string') return result === type.toLowerCase();
  return result;
}
/**
 * Checks the type of a given object and returns the validation value if a known type is detected.
 *
 * @param {*} obj - The object to check or identify.
 * @returns {{ valid:*; type: string | null }} - Returns the type result.
 */
function checkObj(obj) {
  /** @type {{ valid:*; type: string | null }} */
  var data = {
    valid: null,
    type: null
  };
  var _iterator3 = _createForOfIteratorHelper(typeValidator.order),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var name = _step3.value;
      // @ts-ignore
      if (typeof typeValidator.items[name] === 'function') {
        // @ts-ignore
        var result = typeValidator.items[name](obj);
        if (result) {
          data.valid = result;
          data.type = name;
          break;
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return data;
}
/**
 * Creates a clone of the functions from the `typeValidator` object.
 * It returns a new object where the keys are the same and the values are the cloned functions.
 */
function getCheckObj() {
  return Object.fromEntries(Object.entries(typeValidator.items).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[0],
      fn = _ref2[1];
    return [key, fn];
  }));
}
// Insert obj types
extendObjType([['undefined', /** @param {*} val @returns {val is undefined} */
function (val) {
  return typeof val === 'undefined';
}], ['null', /** @param {*} val @returns {val is null} */
function (val) {
  return val === null;
}], ['boolean', /** @param {*} val @returns {val is boolean} */
function (val) {
  return typeof val === 'boolean';
}], ['number', /** @param {*} val @returns {val is number} */
function (val) {
  return typeof val === 'number' && !Number.isNaN(val);
}], ['bigint', /** @param {*} val @returns {val is bigint} */
function (val) {
  return typeof val === 'bigint';
}], ['string', /** @param {*} val @returns {val is string} */
function (val) {
  return typeof val === 'string';
}], ['symbol', /** @param {*} val @returns {val is symbol} */
function (val) {
  return _typeof(val) === 'symbol';
}], ['function', /** @param {*} val @returns {val is Function} */
function (val) {
  return typeof val === 'function';
}], ['array', /** @param {*} val @returns {val is any[]} */
function (val) {
  return Array.isArray(val);
}]]);
if (!isBrowser) {
  extendObjType([['buffer', /** @param {*} val @returns {val is Buffer} */
  function (val) {
    return typeof _buffer.Buffer !== 'undefined' && _buffer.Buffer.isBuffer(val);
  }]]);
}
if (isBrowser) {
  extendObjType([['file', /** @param {*} val @returns {val is File} */
  function (val) {
    return typeof File !== 'undefined' && val instanceof File;
  }]]);
}
extendObjType([['date', /** @param {*} val @returns {val is Date} */
function (val) {
  return val instanceof Date;
}], ['regexp', /** @param {*} val @returns {val is RegExp} */
function (val) {
  return val instanceof RegExp;
}], ['map', /** @param {*} val @returns {val is Map<unknown, unknown>} */
function (val) {
  return val instanceof Map;
}], ['set', /** @param {*} val @returns {val is Set<unknown>} */
function (val) {
  return val instanceof Set;
}], ['weakmap', /** @param {*} val @returns {val is WeakMap<unknown, unknown>} */
function (val) {
  return val instanceof WeakMap;
}], ['weakset', /** @param {*} val @returns {val is WeakSet<unknown>} */
function (val) {
  return val instanceof WeakSet;
}], ['promise', /** @param {*} val @returns {val is Promise<unknown>} */
function (val) {
  return val instanceof Promise;
}]]);
if (isBrowser) {
  extendObjType([['htmlelement', /** @param {*} val @returns {val is HTMLElement} */
  function (val) {
    return typeof HTMLElement !== 'undefined' && val instanceof HTMLElement;
  }]]);
}
extendObjType([['object', /** @param {*} val @returns {val is Record<string | number | symbol, unknown>} */
function (val) {
  return (0, _objChecker.isJsonObject)(val);
}]]);

},{"./objChecker.mjs":175,"buffer":67}],177:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatBytes = formatBytes;
exports.genFibonacciSeq = genFibonacciSeq;
exports.getAge = getAge;
exports.getPercentage = getPercentage;
exports.getSimplePerc = getSimplePerc;
exports.ruleOfThree = ruleOfThree;
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Executes a Rule of Three calculation.
 *
 * @param {number} val1 - The first reference value (numerator in direct proportion, denominator in inverse).
 * @param {number} val2 - The second reference value (denominator in direct proportion, numerator in inverse).
 * @param {number} val3 - The third value (numerator in direct proportion, denominator in inverse).
 * @param {boolean} [inverse] - Whether the calculation should use inverse proportion (true for inverse, false for direct).
 * @returns {number} The result of the Rule of Three operation.
 *
 * Rule of Three Formula (Direct Proportion):
 *      val1 / val2 = val3 / result
 *
 * For Inverse Proportion:
 *      val1 / val3 = val2 / result
 *
 * Visual Representation:
 *
 * For Direct Proportion:
 *      val1      val2
 *      -----  =  ------
 *      val3      result
 *
 * For Inverse Proportion:
 *      val1      val2
 *      -----  =  ------
 *      val3      result
 *
 * @example
 * // Direct proportion:
 * ruleOfThree.execute(2, 6, 3, false); // â 9
 *
 * @example
 * // Inverse proportion:
 * ruleOfThree.execute(2, 6, 3, true); // â 4
 */
function ruleOfThree(val1, val2, val3) {
  var inverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return inverse ? Number(val1 * val2) / val3 : Number(val3 * val2) / val1;
}
/**
 * Calculates the actual value that corresponds to a percentage of a base number.
 * Unlike `getPercentage`, which tells how much something represents in percent,
 * this function tells how much a given percentage *is worth* in value.
 *
 * @param {number} price - The base number to apply the percentage to.
 * @param {number} percentage - The percentage to calculate from the base.
 * @returns {number} The resulting value of the percentage.
 *
 * @example
 * getSimplePerc(200, 15); // 30
 */
function getSimplePerc(price, percentage) {
  return price * (percentage / 100);
}
/**
 * Calculates how much percent a partial value represents of the total value.
 *
 * @param {number} part - The partial value to compare.
 * @param {number} total - The total or maximum value.
 * @returns {number} The percentage that 'part' represents of 'total'.
 *
 * @example
 * getPercentage(5, 100); // 5
 */
function getPercentage(part, total) {
  if (total === 0) return 0;
  return part / total * 100;
}
/**
 * Calculates the age based on the given date.
 *
 * @param {number|string|Date} timeData - The birth date (can be a timestamp, ISO string, or Date object).
 * @param {Date|null} [now=null] - The Date object representing the current date. Defaults to the current date and time if not provided.
 * @returns {number|null} The age in years, or null if `timeData` is not provided or invalid.
 */
function getAge() {
  var timeData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (typeof timeData !== 'undefined' && timeData !== null && timeData !== 0) {
    var birthDate = new Date(timeData);
    if (Number.isNaN(birthDate.getTime())) return null;
    var currentDate = now instanceof Date ? now : new Date();
    var age = currentDate.getFullYear() - birthDate.getFullYear();
    var currentMonth = currentDate.getMonth();
    var birthMonth = birthDate.getMonth();
    var currentDay = currentDate.getDate();
    var birthDay = birthDate.getDate();
    // Adjust if birthday hasn't occurred yet this year
    if (currentMonth < birthMonth || currentMonth === birthMonth && currentDay < birthDay) age--;
    return Math.abs(age);
  }
  return null;
}
/**
 * @typedef {Object} FormattedByteResult
 * @property {string|null} unit - The resulting unit (e.g., 'MB', 'GB') or null if input is invalid.
 * @property {number|null} value - The numerical value in the chosen unit, or null if input is invalid.
 */
/**
 * Converts a byte value into a human-readable format with unit and value separated.
 *
 * @param {number} bytes - The number of bytes to format. Must be a non-negative number.
 * @param {number|null} [decimals=null] - The number of decimal places to include in the result. Defaults to null. If negative, it will be treated as 0. If null, no rounding is applied.
 * @param {string|null} [maxUnit=null] - Optional unit limit. If provided, restricts conversion to this unit at most (e.g., 'MB' prevents conversion to 'GB' or higher). Must be one of: 'Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'.
 * @returns {FormattedByteResult} An object with the converted value and its corresponding unit. Returns nulls if input is invalid.
 *
 * @example
 * formatBytes(123456789);
 * // â { unit: 'MB', value: 117.74 }
 *
 * @example
 * formatBytes(1073741824, 2, 'MB');
 * // â { unit: 'MB', value: 1024 }
 */
function formatBytes(bytes) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var maxUnit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (typeof bytes !== 'number' || bytes < 0) return {
    unit: null,
    value: null
  };
  if (bytes === 0) return {
    unit: 'Bytes',
    value: 0
  };
  var k = 1024;
  var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  var maxIndex = maxUnit && sizes.includes(maxUnit) ? sizes.indexOf(maxUnit) : sizes.length - 1;
  var i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), maxIndex);
  var value = bytes / Math.pow(k, i);
  if (decimals !== null) {
    var dm = decimals < 0 ? 0 : decimals;
    value = parseFloat(value.toFixed(dm));
  }
  var unit = sizes[i];
  return {
    unit: unit,
    value: value
  };
}
/**
 * Generates a Fibonacci-like sequence as an array of vectors.
 *
 * @param {Object} [settings={}]
 * @param {number[]} [settings.baseValues=[0, 1]] - An array of two starting numbers (e.g. [0, 1] or [1, 1]).
 * @param {number} [settings.length=10] - Total number of items to generate in the sequence.
 * @param {(a: number, b: number, index: number) => number} [settings.combiner=((a, b) => a + b)] - A custom function to combine previous two numbers.
 * @returns {number[]} The resulting Fibonacci sequence.
 *
 * FibonacciVectors2D
 * @example
 * generateFibonacciSequence({
 *   baseValues: [[0, 1], [1, 1]],
 *   length: 10,
 *   combiner: ([x1, y1], [x2, y2]) => [x1 + x2, y1 + y2]
 * });
 *
 * @beta
 */
function genFibonacciSeq() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$baseValues = _ref.baseValues,
    baseValues = _ref$baseValues === void 0 ? [0, 1] : _ref$baseValues,
    _ref$length = _ref.length,
    length = _ref$length === void 0 ? 10 : _ref$length,
    _ref$combiner = _ref.combiner,
    combiner = _ref$combiner === void 0 ? function (a, b) {
      return a + b;
    } : _ref$combiner;
  if (!Array.isArray(baseValues) || baseValues.length !== 2) throw new Error('baseValues must be an array of exactly two numbers');
  var sequence = _toConsumableArray(baseValues.slice(0, 2));
  for (var i = 2; i < length; i++) {
    var next = combiner(sequence[i - 2], sequence[i - 1], i);
    sequence.push(next);
  }
  return sequence;
}

},{}],178:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAiMarkerShortcut = addAiMarkerShortcut;
exports.safeTextTrim = safeTextTrim;
exports.toTitleCase = toTitleCase;
exports.toTitleCaseLowerFirst = toTitleCaseLowerFirst;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Converts a string to title case where the first letter of each word is capitalized.
 * All other letters are converted to lowercase.
 *
 * Example: "hello world" -> "Hello World"
 *
 * @param {string} str - The string to be converted to title case.
 * @returns {string} The string converted to title case.
 */
function toTitleCase(str) {
  return str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}
/**
 * Converts a string to title case where the first letter of each word is capitalized,
 * but the first letter of the entire string is left lowercase.
 *
 * Example: "hello world" -> "hello World"
 *
 * @param {string} str - The string to be converted to title case with the first letter in lowercase.
 * @returns {string} The string converted to title case with the first letter in lowercase.
 */
function toTitleCaseLowerFirst(str) {
  var titleCased = str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
  return titleCased.charAt(0).toLowerCase() + titleCased.slice(1);
}
/**
 * Enables a keyboard shortcut to toggle a CSS class on the document body.
 *
 * This function listens for a specific key combination: `Ctrl + Alt + [key]`.
 * When triggered, it prevents the default behavior and toggles the
 * `detect-made-by-ai` class on the `<body>`, which can be used to apply visual
 * indicators or filters on AI-generated content.
 *
 * If executed outside of a browser environment (e.g., in Node.js), the function logs an error and exits.
 * If the `<body>` is not available at the moment the shortcut is triggered, a warning is logged.
 *
 * @param {string} [key='a'] - The lowercase character key to be used in combination with Ctrl and Alt.
 */
function addAiMarkerShortcut() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'a';
  if (typeof HTMLElement === 'undefined') {
    console.error('[AiMarkerShortcut] Environment does not support the DOM. This function must be run in a browser.');
    return;
  }
  document.addEventListener('keydown', function (event) {
    if (event.ctrlKey && event.altKey && event.key.toLowerCase() === key) {
      event.preventDefault(); // Prevent any default behavior
      if (!document.body) {
        console.warn('[AiMarkerShortcut] <body> element not found. Cannot toggle class. Ensure the DOM is fully loaded when using the shortcut.');
        return;
      }
      document.body.classList.toggle('detect-made-by-ai');
    }
  });
}
/**
 * Trims a text string to a specified character limit, attempting to avoid cutting words in half.
 * If a space is found before the limit and it's not too far from the limit (at least 60%),
 * the cut is made at that space; otherwise, the text is hard-cut at the limit.
 * If the input is shorter than the limit, it is returned unchanged.
 *
 * @param {string} text - The input text to be trimmed.
 * @param {number} limit - The maximum number of characters allowed.
 * @param {number} [safeCutZone=0.6] - A decimal between 0 and 1 representing the minimal acceptable position
 *                                     (as a fraction of `limit`) to cut at a space. Defaults to 0.6.
 * @returns {string} - The trimmed text, possibly ending with an ellipsis ("...").
 * @throws {TypeError} - Throws if `text` is not a string.
 * @throws {TypeError} - Throws if `limit` is not a positive integer.
 * @throws {TypeError} - Throws if `safeCutZone` is not a number between 0 and 1 (inclusive).
 */
function safeTextTrim(text, limit) {
  var safeCutZone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.6;
  if (typeof text !== 'string') throw new TypeError("Expected a string for 'text', but received ".concat(_typeof(text)));
  if (!Number.isInteger(limit) || limit <= 0) throw new TypeError("Expected 'limit' to be a positive integer, but received ".concat(limit));
  if (typeof safeCutZone !== 'number' || safeCutZone < 0 || safeCutZone > 1) throw new TypeError("Expected 'safeCutZone' to be a number between 0 and 1, but received ".concat(safeCutZone));
  var result = text.trim();
  if (result.length > limit) {
    // Try to cut the string into a space before the limit
    var safeCut = result.lastIndexOf(' ', limit);
    if (safeCut > 0 && safeCut >= limit * safeCutZone) {
      // Only cuts where there is a space, and if the cut is not too early
      return "".concat(result.substring(0, safeCut).trim(), "...");
    } else {
      // Emergency: Cuts straight to the limit and adds "...".
      return "".concat(result.substring(0, limit).trim(), "...");
    }
  }
  return result;
}
/*
import { useEffect } from "react";

function KeyPressHandler() {
    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.ctrlKey && event.altKey && event.key.toLowerCase() === "a") {
                event.preventDefault();
                document.body.classList.toggle("detect-made-by-ai");
            }
        };
        
        document.addEventListener("keydown", handleKeyDown);
        return () => {
            document.removeEventListener("keydown", handleKeyDown);
        };
    }, []);

    return null;
}

export default KeyPressHandler;
*/

},{}],179:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backupFileAsync = backupFileAsync;
exports.clearDirectoryAsync = clearDirectoryAsync;
exports.dirSizeAsync = dirSizeAsync;
exports.ensureCopyFileAsync = ensureCopyFileAsync;
exports.fileSizeAsync = fileSizeAsync;
exports.isDirEmptyAsync = isDirEmptyAsync;
exports.listDirsAsync = listDirsAsync;
exports.listFilesAsync = listFilesAsync;
exports.readJsonFileAsync = readJsonFileAsync;
exports.restoreLatestBackupAsync = restoreLatestBackupAsync;
exports.tryDeleteFileAsync = tryDeleteFileAsync;
exports.writeJsonFileAsync = writeJsonFileAsync;
exports.writeTextFileAsync = writeTextFileAsync;
var _fs = require("fs");
var _promises = require("fs/promises");
var _path = require("path");
var _normalFuncs = require("./normalFuncs.mjs");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/*========================*
 * JSON Operations
 *========================*/
/**
 * Reads and parses a JSON file.
 * Throws an error if the file content is not valid JSON.
 * @param {string} filePath
 * @returns {Promise<any>}
 */
function readJsonFileAsync(_x) {
  return _readJsonFileAsync.apply(this, arguments);
}
/**
 * Saves an object as JSON to a file.
 * Automatically creates the directory if it does not exist.
 * @param {string} filePath
 * @param {any} data
 * @param {number} [spaces=2]
 * @returns {Promise<void>}
 */
function _readJsonFileAsync() {
  _readJsonFileAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(filePath) {
    var content;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          if ((0, _fs.existsSync)(filePath)) {
            _context.n = 1;
            break;
          }
          throw new Error("File not found: ".concat(filePath));
        case 1:
          _context.n = 2;
          return (0, _promises.readFile)(filePath, 'utf-8');
        case 2:
          content = _context.v;
          return _context.a(2, JSON.parse(content));
      }
    }, _callee);
  }));
  return _readJsonFileAsync.apply(this, arguments);
}
function writeJsonFileAsync(filePath, data) {
  var spaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var json = JSON.stringify(data, null, spaces);
  return (0, _promises.writeFile)(filePath, json, 'utf-8');
}
/*========================*
 * Directory Management
 *========================*/
/**
 * Clears all contents inside a directory but keeps the directory.
 * @param {string} dirPath
 */
function clearDirectoryAsync(_x2) {
  return _clearDirectoryAsync.apply(this, arguments);
}
/*========================*
 * File Checks
 *========================*/
/**
 * Checks whether a directory is empty.
 * @param {string} dirPath
 * @returns {Promise<boolean>}
 */
function _clearDirectoryAsync() {
  _clearDirectoryAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(dirPath) {
    var files, dataList, promises, _iterator, _step, _loop, promises2, fullPath, statData, _t;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          if ((0, _fs.existsSync)(dirPath)) {
            _context3.n = 1;
            break;
          }
          return _context3.a(2);
        case 1:
          _context3.n = 2;
          return (0, _promises.readdir)(dirPath);
        case 2:
          files = _context3.v;
          /** @type {Record<string, import('fs').Stats>} */
          dataList = {};
          promises = [];
          _iterator = _createForOfIteratorHelper(files);
          _context3.p = 3;
          _loop = /*#__PURE__*/_regenerator().m(function _loop() {
            var file, fullPath, lsResult;
            return _regenerator().w(function (_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  file = _step.value;
                  fullPath = (0, _path.join)(dirPath, file);
                  lsResult = (0, _promises.lstat)(fullPath);
                  lsResult.then(function (statData) {
                    dataList[fullPath] = statData;
                    return statData;
                  });
                  promises.push(lsResult);
                case 1:
                  return _context2.a(2);
              }
            }, _loop);
          });
          _iterator.s();
        case 4:
          if ((_step = _iterator.n()).done) {
            _context3.n = 6;
            break;
          }
          return _context3.d(_regeneratorValues(_loop()), 5);
        case 5:
          _context3.n = 4;
          break;
        case 6:
          _context3.n = 8;
          break;
        case 7:
          _context3.p = 7;
          _t = _context3.v;
          _iterator.e(_t);
        case 8:
          _context3.p = 8;
          _iterator.f();
          return _context3.f(8);
        case 9:
          _context3.n = 10;
          return Promise.all(promises);
        case 10:
          promises2 = [];
          for (fullPath in dataList) {
            statData = dataList[fullPath];
            if (statData.isDirectory()) {
              promises2.push((0, _promises.rm)(fullPath, {
                recursive: true,
                force: true
              }));
            } else {
              promises2.push((0, _promises.unlink)(fullPath));
            }
          }
          _context3.n = 11;
          return Promise.all(promises2);
        case 11:
          return _context3.a(2);
      }
    }, _callee2, null, [[3, 7, 8, 9]]);
  }));
  return _clearDirectoryAsync.apply(this, arguments);
}
function isDirEmptyAsync(_x3) {
  return _isDirEmptyAsync.apply(this, arguments);
}
/*========================*
 * File Operations
 *========================*/
/**
 * Copies a file to a destination.
 * @param {string} src
 * @param {string} dest
 * @param {number} [mode]
 * @returns {Promise<void>}
 */
function _isDirEmptyAsync() {
  _isDirEmptyAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(dirPath) {
    var data;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          _context4.n = 1;
          return (0, _promises.readdir)(dirPath);
        case 1:
          data = _context4.v;
          return _context4.a(2, data.length === 0);
      }
    }, _callee3);
  }));
  return _isDirEmptyAsync.apply(this, arguments);
}
function ensureCopyFileAsync(src, dest, mode) {
  (0, _normalFuncs.ensureDirectory)((0, _path.dirname)(dest));
  return (0, _promises.copyFile)(src, dest, mode);
}
/**
 * Deletes a file (If the file exists).
 * @param {string} filePath
 * @returns {Promise<boolean>}
 */
function tryDeleteFileAsync(_x4) {
  return _tryDeleteFileAsync.apply(this, arguments);
}
/*========================*
 * Text Operations
 *========================*/
/**
 * Writes text to a file (Ensures that the directory exists, creating it recursively if needed).
 * @param {string} filePath
 * @param {string} content
 * @param {import('fs').WriteFileOptions} [ops='utf-8']
 * @returns {Promise<void>}
 */
function _tryDeleteFileAsync() {
  _tryDeleteFileAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(filePath) {
    return _regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          if (!(0, _normalFuncs.fileExists)(filePath)) {
            _context5.n = 2;
            break;
          }
          _context5.n = 1;
          return (0, _promises.unlink)(filePath);
        case 1:
          return _context5.a(2, true);
        case 2:
          return _context5.a(2, false);
      }
    }, _callee4);
  }));
  return _tryDeleteFileAsync.apply(this, arguments);
}
function writeTextFileAsync(filePath, content) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf-8';
  var dir = (0, _path.dirname)(filePath);
  (0, _normalFuncs.ensureDirectory)(dir);
  return (0, _promises.writeFile)(filePath, content, ops);
}
/*========================*
 * Directory Listings
 *========================*/
/**
 * Lists all files and dirs in a directory (optionally recursive).
 * @param {string} dirPath
 * @param {boolean} [recursive=false]
 * @returns {Promise<{ files: string[]; dirs: string[] }>}
 */
function listFilesAsync(_x5) {
  return _listFilesAsync.apply(this, arguments);
}
/**
 * Lists all directories in a directory (optionally recursive).
 * @param {string} dirPath
 * @param {boolean} [recursive=false]
 * @returns {Promise<string[]>}
 */
function _listFilesAsync() {
  _listFilesAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(dirPath) {
    var recursive,
      results,
      entries,
      _iterator2,
      _step2,
      entry,
      fullPath,
      statData,
      _results$files,
      _results$dirs,
      results2,
      _args6 = arguments,
      _t2;
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          recursive = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : false;
          /** @type {{ files: string[]; dirs: string[] }} */
          results = {
            files: [],
            dirs: []
          };
          if ((0, _normalFuncs.dirExists)(dirPath)) {
            _context6.n = 1;
            break;
          }
          return _context6.a(2, results);
        case 1:
          _context6.n = 2;
          return (0, _promises.readdir)(dirPath);
        case 2:
          entries = _context6.v;
          _iterator2 = _createForOfIteratorHelper(entries);
          _context6.p = 3;
          _iterator2.s();
        case 4:
          if ((_step2 = _iterator2.n()).done) {
            _context6.n = 10;
            break;
          }
          entry = _step2.value;
          fullPath = (0, _path.join)(dirPath, entry);
          _context6.n = 5;
          return (0, _promises.lstat)(fullPath);
        case 5:
          statData = _context6.v;
          if (!statData.isDirectory()) {
            _context6.n = 8;
            break;
          }
          results.dirs.push(fullPath);
          if (!recursive) {
            _context6.n = 7;
            break;
          }
          _context6.n = 6;
          return listFilesAsync(fullPath, true);
        case 6:
          results2 = _context6.v;
          (_results$files = results.files).push.apply(_results$files, _toConsumableArray(results2.files));
          (_results$dirs = results.dirs).push.apply(_results$dirs, _toConsumableArray(results2.dirs));
        case 7:
          _context6.n = 9;
          break;
        case 8:
          results.files.push(fullPath);
        case 9:
          _context6.n = 4;
          break;
        case 10:
          _context6.n = 12;
          break;
        case 11:
          _context6.p = 11;
          _t2 = _context6.v;
          _iterator2.e(_t2);
        case 12:
          _context6.p = 12;
          _iterator2.f();
          return _context6.f(12);
        case 13:
          return _context6.a(2, results);
      }
    }, _callee5, null, [[3, 11, 12, 13]]);
  }));
  return _listFilesAsync.apply(this, arguments);
}
function listDirsAsync(_x6) {
  return _listDirsAsync.apply(this, arguments);
}
/*========================*
 * File Info
 *========================*/
/**
 * Returns the size of a file in bytes.
 * @param {string} filePath
 * @returns {Promise<number>}
 */
function _listDirsAsync() {
  _listDirsAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(dirPath) {
    var recursive,
      results,
      entries,
      _iterator3,
      _step3,
      entry,
      fullPath,
      statData,
      _args7 = arguments,
      _t3,
      _t4,
      _t5,
      _t6,
      _t7,
      _t8;
    return _regenerator().w(function (_context7) {
      while (1) switch (_context7.n) {
        case 0:
          recursive = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : false;
          /** @type {string[]} */
          results = [];
          if ((0, _normalFuncs.dirExists)(dirPath)) {
            _context7.n = 1;
            break;
          }
          return _context7.a(2, results);
        case 1:
          _context7.n = 2;
          return (0, _promises.readdir)(dirPath);
        case 2:
          entries = _context7.v;
          _iterator3 = _createForOfIteratorHelper(entries);
          _context7.p = 3;
          _iterator3.s();
        case 4:
          if ((_step3 = _iterator3.n()).done) {
            _context7.n = 8;
            break;
          }
          entry = _step3.value;
          fullPath = (0, _path.join)(dirPath, entry);
          _context7.n = 5;
          return (0, _promises.lstat)(fullPath);
        case 5:
          statData = _context7.v;
          if (!statData.isDirectory()) {
            _context7.n = 7;
            break;
          }
          results.push(fullPath);
          if (!recursive) {
            _context7.n = 7;
            break;
          }
          _t3 = results.push;
          _t4 = results;
          _t5 = _toConsumableArray;
          _context7.n = 6;
          return listDirsAsync(fullPath, true);
        case 6:
          _t6 = _context7.v;
          _t7 = _t5(_t6);
          _t3.apply.call(_t3, _t4, _t7);
        case 7:
          _context7.n = 4;
          break;
        case 8:
          _context7.n = 10;
          break;
        case 9:
          _context7.p = 9;
          _t8 = _context7.v;
          _iterator3.e(_t8);
        case 10:
          _context7.p = 10;
          _iterator3.f();
          return _context7.f(10);
        case 11:
          return _context7.a(2, results);
      }
    }, _callee6, null, [[3, 9, 10, 11]]);
  }));
  return _listDirsAsync.apply(this, arguments);
}
function fileSizeAsync(_x7) {
  return _fileSizeAsync.apply(this, arguments);
}
/**
 * Returns the total size of a directory in bytes.
 * @param {string} dirPath
 * @returns {Promise<number>}
 */
function _fileSizeAsync() {
  _fileSizeAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(filePath) {
    var stats;
    return _regenerator().w(function (_context8) {
      while (1) switch (_context8.n) {
        case 0:
          if ((0, _normalFuncs.fileExists)(filePath)) {
            _context8.n = 1;
            break;
          }
          return _context8.a(2, 0);
        case 1:
          _context8.n = 2;
          return (0, _promises.stat)(filePath);
        case 2:
          stats = _context8.v;
          return _context8.a(2, stats.size);
      }
    }, _callee7);
  }));
  return _fileSizeAsync.apply(this, arguments);
}
function dirSizeAsync(_x8) {
  return _dirSizeAsync.apply(this, arguments);
}
/*========================*
 * Backup Utilities
 *========================*/
/**
 * Restores the most recent backup of a file.
 * @param {string} filePath
 * @param {string} [ext='bak']
 * @returns {Promise<void>}
 */
function _dirSizeAsync() {
  _dirSizeAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(dirPath) {
    var total, _yield$listFilesAsync, files, promises, _iterator4, _step4, file, result;
    return _regenerator().w(function (_context9) {
      while (1) switch (_context9.n) {
        case 0:
          total = 0;
          _context9.n = 1;
          return listFilesAsync(dirPath, true);
        case 1:
          _yield$listFilesAsync = _context9.v;
          files = _yield$listFilesAsync.files;
          promises = [];
          _iterator4 = _createForOfIteratorHelper(files);
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              file = _step4.value;
              result = fileSizeAsync(file);
              result.then(function (item) {
                total += item;
                return item;
              });
              promises.push(result);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          _context9.n = 2;
          return Promise.all(promises);
        case 2:
          return _context9.a(2, total);
      }
    }, _callee8);
  }));
  return _dirSizeAsync.apply(this, arguments);
}
function restoreLatestBackupAsync(filePath) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bak';
  var latestBackup = (0, _normalFuncs.getLatestBackupPath)(filePath, ext);
  return ensureCopyFileAsync(latestBackup, filePath);
}
/**
 * Creates a backup copy of a file with .bak timestamp suffix.
 * @param {string} filePath
 * @param {string} [ext='bak']
 * @returns {Promise<void>}
 */
function backupFileAsync(_x9) {
  return _backupFileAsync.apply(this, arguments);
}
function _backupFileAsync() {
  _backupFileAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(filePath) {
    var ext,
      timestamp,
      backupPath,
      _args0 = arguments;
    return _regenerator().w(function (_context0) {
      while (1) switch (_context0.n) {
        case 0:
          ext = _args0.length > 1 && _args0[1] !== undefined ? _args0[1] : 'bak';
          if ((0, _normalFuncs.fileExists)(filePath)) {
            _context0.n = 1;
            break;
          }
          return _context0.a(2);
        case 1:
          timestamp = new Date().toISOString().replace(/[:.]/g, '-');
          backupPath = "".concat(filePath, ".").concat(ext, ".").concat(timestamp);
          return _context0.a(2, ensureCopyFileAsync(filePath, backupPath));
      }
    }, _callee9);
  }));
  return _backupFileAsync.apply(this, arguments);
}

},{"./normalFuncs.mjs":180,"fs":66,"fs/promises":66,"path":108}],180:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backupFile = backupFile;
exports.clearDirectory = clearDirectory;
exports.dirExists = dirExists;
exports.dirSize = dirSize;
exports.ensureCopyFile = ensureCopyFile;
exports.ensureDirectory = ensureDirectory;
exports.fileExists = fileExists;
exports.fileSize = fileSize;
exports.getLatestBackupPath = getLatestBackupPath;
exports.isDirEmpty = isDirEmpty;
exports.listDirs = listDirs;
exports.listFiles = listFiles;
exports.readJsonFile = readJsonFile;
exports.renameFileAddPrefixSuffix = renameFileAddPrefixSuffix;
exports.renameFileBatch = renameFileBatch;
exports.renameFileNormalizeCase = renameFileNormalizeCase;
exports.renameFilePadNumbers = renameFilePadNumbers;
exports.renameFileRegex = renameFileRegex;
exports.restoreLatestBackup = restoreLatestBackup;
exports.tryDeleteFile = tryDeleteFile;
exports.writeJsonFile = writeJsonFile;
exports.writeTextFile = writeTextFile;
var _fs = require("fs");
var _path = require("path");
var _text = require("../basics/text.mjs");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/*========================*
 * JSON Operations
 *========================*/
/**
 * Reads and parses a JSON file.
 * Throws an error if the file content is not valid JSON.
 * @param {string} filePath
 * @returns {any}
 */
function readJsonFile(filePath) {
  if (!(0, _fs.existsSync)(filePath)) throw new Error("File not found: ".concat(filePath));
  var content = (0, _fs.readFileSync)(filePath, 'utf-8');
  return JSON.parse(content);
}
/**
 * Saves an object as JSON to a file.
 * Automatically creates the directory if it does not exist.
 * @param {string} filePath
 * @param {any} data
 * @param {number} [spaces=2]
 */
function writeJsonFile(filePath, data) {
  var spaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var json = JSON.stringify(data, null, spaces);
  (0, _fs.writeFileSync)(filePath, json, 'utf-8');
}
/*========================*
 * Directory Management
 *========================*/
/**
 * Ensures that the directory exists, creating it recursively if needed.
 * @param {string} dirPath
 */
function ensureDirectory(dirPath) {
  if (!(0, _fs.existsSync)(dirPath)) {
    (0, _fs.mkdirSync)(dirPath, {
      recursive: true
    });
  }
}
/**
 * Clears all contents inside a directory but keeps the directory.
 * @param {string} dirPath
 */
function clearDirectory(dirPath) {
  if (!(0, _fs.existsSync)(dirPath)) return;
  var files = (0, _fs.readdirSync)(dirPath);
  var _iterator = _createForOfIteratorHelper(files),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var file = _step.value;
      var fullPath = (0, _path.join)(dirPath, file);
      var statData = (0, _fs.lstatSync)(fullPath);
      if (statData.isDirectory()) {
        (0, _fs.rmSync)(fullPath, {
          recursive: true,
          force: true
        });
      } else {
        (0, _fs.unlinkSync)(fullPath);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
/*========================*
 * File Checks
 *========================*/
/**
 * Checks whether a file exists.
 * @param {string} filePath
 * @returns {boolean}
 */
function fileExists(filePath) {
  return (0, _fs.existsSync)(filePath) && (0, _fs.lstatSync)(filePath).isFile();
}
/**
 * Checks whether a directory exists.
 * @param {string} dirPath
 * @returns {boolean}
 */
function dirExists(dirPath) {
  return (0, _fs.existsSync)(dirPath) && (0, _fs.lstatSync)(dirPath).isDirectory();
}
/**
 * Checks whether a directory is empty.
 * @param {string} dirPath
 * @returns {boolean}
 */
function isDirEmpty(dirPath) {
  return (0, _fs.readdirSync)(dirPath).length === 0;
}
/*========================*
 * File Operations
 *========================*/
/**
 * Copies a file to a destination.
 * @param {string} src
 * @param {string} dest
 * @param {number} [mode]
 */
function ensureCopyFile(src, dest, mode) {
  ensureDirectory((0, _path.dirname)(dest));
  (0, _fs.copyFileSync)(src, dest, mode);
}
/**
 * Deletes a file (If the file exists).
 * @param {string} filePath
 * @returns {boolean}
 */
function tryDeleteFile(filePath) {
  if (fileExists(filePath)) {
    (0, _fs.unlinkSync)(filePath);
    return true;
  }
  return false;
}
/*========================*
 * Text Operations
 *========================*/
/**
 * Writes text to a file (Ensures that the directory exists, creating it recursively if needed).
 * @param {string} filePath
 * @param {string} content
 * @param {import('fs').WriteFileOptions} [ops='utf-8']
 */
function writeTextFile(filePath, content) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf-8';
  var dir = (0, _path.dirname)(filePath);
  ensureDirectory(dir);
  (0, _fs.writeFileSync)(filePath, content, ops);
}
/*========================*
 * Directory Listings
 *========================*/
/**
 * Lists all files and dirs in a directory (optionally recursive).
 * @param {string} dirPath
 * @param {boolean} [recursive=false]
 * @returns {{ files: string[]; dirs: string[] }}
 */
function listFiles(dirPath) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  /** @type {{ files: string[]; dirs: string[] }} */
  var results = {
    files: [],
    dirs: []
  };
  if (!dirExists(dirPath)) return results;
  var entries = (0, _fs.readdirSync)(dirPath);
  var _iterator2 = _createForOfIteratorHelper(entries),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var entry = _step2.value;
      var fullPath = (0, _path.join)(dirPath, entry);
      var statData = (0, _fs.lstatSync)(fullPath);
      if (statData.isDirectory()) {
        results.dirs.push(fullPath);
        if (recursive) {
          var _results$files, _results$dirs;
          var results2 = listFiles(fullPath, true);
          (_results$files = results.files).push.apply(_results$files, _toConsumableArray(results2.files));
          (_results$dirs = results.dirs).push.apply(_results$dirs, _toConsumableArray(results2.dirs));
        }
      } else {
        results.files.push(fullPath);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return results;
}
/**
 * Lists all directories in a directory (optionally recursive).
 * @param {string} dirPath
 * @param {boolean} [recursive=false]
 * @returns {string[]}
 */
function listDirs(dirPath) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  /** @type {string[]} */
  var results = [];
  if (!dirExists(dirPath)) return results;
  var entries = (0, _fs.readdirSync)(dirPath);
  var _iterator3 = _createForOfIteratorHelper(entries),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var entry = _step3.value;
      var fullPath = (0, _path.join)(dirPath, entry);
      var statData = (0, _fs.lstatSync)(fullPath);
      if (statData.isDirectory()) {
        results.push(fullPath);
        if (recursive) {
          results.push.apply(results, _toConsumableArray(listDirs(fullPath, true)));
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return results;
}
/*========================*
 * File Info
 *========================*/
/**
 * Returns the size of a file in bytes.
 * @param {string} filePath
 * @returns {number}
 */
function fileSize(filePath) {
  if (!fileExists(filePath)) return 0;
  var stats = (0, _fs.statSync)(filePath);
  return stats.size;
}
/**
 * Returns the total size of a directory in bytes.
 * @param {string} dirPath
 * @returns {number}
 */
function dirSize(dirPath) {
  var total = 0;
  var files = listFiles(dirPath, true).files;
  var _iterator4 = _createForOfIteratorHelper(files),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var file = _step4.value;
      total += fileSize(file);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return total;
}
/*========================*
 * Backup Utilities
 *========================*/
/**
 * Creates a backup copy of a file with .bak timestamp suffix.
 * @param {string} filePath
 * @param {string} [ext='bak']
 */
function backupFile(filePath) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bak';
  if (!fileExists(filePath)) return;
  var timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  var backupPath = "".concat(filePath, ".").concat(ext, ".").concat(timestamp);
  ensureCopyFile(filePath, backupPath);
}
/**
 * Returns the most recent backup file path for a given file.
 * @param {string} filePath
 * @param {string} [ext='bak']
 * @returns {string} Full path to the most recent backup
 */
function getLatestBackupPath(filePath) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bak';
  var dir = (0, _path.dirname)(filePath);
  var baseName = (0, _path.basename)(filePath);
  var backups = (0, _fs.readdirSync)(dir).filter(function (name) {
    return name.startsWith("".concat(baseName, ".").concat(ext, "."));
  }).sort().reverse();
  if (backups.length === 0) throw new Error("No backups found for ".concat(filePath));
  return (0, _path.join)(dir, backups[0]);
}
/**
 * Restores the most recent backup of a file.
 * @param {string} filePath
 * @param {string} [ext='bak']
 */
function restoreLatestBackup(filePath) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bak';
  var latestBackup = getLatestBackupPath(filePath, ext);
  ensureCopyFile(latestBackup, filePath);
}
/*========================*
 * Rename Utilities
 *========================*/
/**
 * Renames multiple files in a directory using a rename function.
 * @param {string} dirPath - The target directory.
 * @param {(original: string, index: number) => string} renameFn - Function that returns new filename.
 * @param {string[]} [extensions] - Optional: Only rename files with these extensions.
 *
 * @throws {TypeError} If any argument has an invalid type.
 * @throws {Error} If the directory does not exist or contains invalid files.
 */
function renameFileBatch(dirPath, renameFn) {
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  // Validate types
  if (typeof dirPath !== 'string') throw new TypeError('dirPath must be a string');
  if (typeof renameFn !== 'function') throw new TypeError('renameFn must be a function');
  if (!Array.isArray(extensions)) throw new TypeError('extensions must be an array of strings');
  if (!(0, _fs.existsSync)(dirPath) || !(0, _fs.statSync)(dirPath).isDirectory()) throw new Error("Directory not found or invalid: ".concat(dirPath));
  var _iterator5 = _createForOfIteratorHelper(extensions),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var ext = _step5.value;
      if (typeof ext !== 'string' || !ext.startsWith('.')) throw new TypeError("Invalid extension: ".concat(ext));
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  var files = listFiles(dirPath).files;
  var index = 0;
  var _iterator6 = _createForOfIteratorHelper(files),
    _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var file = _step6.value;
      var _ext = (0, _path.extname)(file);
      if (extensions.length && !extensions.includes(_ext)) continue;
      var originalName = (0, _path.basename)(file);
      var newName = renameFn(originalName, index++);
      var newPath = (0, _path.join)(dirPath, newName);
      if (originalName === newName) continue;
      (0, _fs.renameSync)(file, newPath);
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
}
/**
 * Renames files using regex replacement.
 * @param {string} dirPath
 * @param {RegExp} pattern - Regex to match in the filename.
 * @param {string} replacement - Replacement string.
 * @param {string[]} [extensions]
 */
function renameFileRegex(dirPath, pattern, replacement) {
  var extensions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  renameFileBatch(dirPath, function (filename) {
    var ext = (0, _path.extname)(filename);
    var name = (0, _path.basename)(filename, ext).replace(pattern, replacement);
    return "".concat(name).concat(ext);
  }, extensions);
}
/**
 * Adds a prefix or suffix to filenames.
 * @param {string} dirPath
 * @param {{ prefix?: string, suffix?: string }} options
 * @param {string[]} [extensions]
 */
function renameFileAddPrefixSuffix(dirPath, _ref) {
  var _ref$prefix = _ref.prefix,
    prefix = _ref$prefix === void 0 ? '' : _ref$prefix,
    _ref$suffix = _ref.suffix,
    suffix = _ref$suffix === void 0 ? '' : _ref$suffix;
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  renameFileBatch(dirPath, function (filename) {
    var ext = (0, _path.extname)(filename);
    var name = (0, _path.basename)(filename, ext);
    return "".concat(prefix).concat(name).concat(suffix).concat(ext);
  }, extensions);
}
/**
 * Normalizes all filenames to lowercase (or uppercase).
 * @param {string} dirPath
 * @param {'lower' | 'upper' | 'title'} mode
 * @param {string[]} [extensions]
 * @param {boolean} [normalizeExt=false] - Whether to apply case change to file extensions too.
 * @throws {Error} If mode is invalid.
 */
function renameFileNormalizeCase(dirPath) {
  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'lower';
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var normalizeExt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (typeof mode !== 'string' || !['lower', 'upper', 'title'].includes(mode)) throw new Error("Invalid mode \"".concat(mode, "\". Must be 'lower', 'upper' or 'title'."));
  renameFileBatch(dirPath, function (filename) {
    /**
     * @param {string} text
     * @returns {string}
     */
    var changeToMode = function changeToMode(text) {
      if (mode === 'lower') return text.toLowerCase();else if (mode === 'upper') return text.toUpperCase();else if (mode === 'title') return (0, _text.toTitleCase)(text);else return text;
    };
    var rawExt = (0, _path.extname)(filename);
    var ext = normalizeExt ? changeToMode(rawExt) : rawExt;
    var name = changeToMode((0, _path.basename)(filename, rawExt));
    return "".concat(name).concat(ext);
  }, extensions);
}
/**
 * Pads numbers in filenames (e.g., "img1.jpg" -> "img001.jpg").
 * @param {string} dirPath
 * @param {number} totalDigits
 * @param {string[]} [extensions]
 */
function renameFilePadNumbers(dirPath) {
  var totalDigits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  renameFileBatch(dirPath, function (filename) {
    return filename.replace(/\d+/, function (match) {
      return match.padStart(totalDigits, '0');
    });
  }, extensions);
}

},{"../basics/text.mjs":178,"fs":66,"path":108}],181:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ColorSafeStringify", {
  enumerable: true,
  get: function get() {
    return _ColorSafeStringify["default"];
  }
});
Object.defineProperty(exports, "TinyAfterScrollWatcher", {
  enumerable: true,
  get: function get() {
    return _TinyAfterScrollWatcher["default"];
  }
});
Object.defineProperty(exports, "TinyClipboard", {
  enumerable: true,
  get: function get() {
    return _TinyClipboard["default"];
  }
});
Object.defineProperty(exports, "TinyColorConverter", {
  enumerable: true,
  get: function get() {
    return _TinyColorConverter["default"];
  }
});
Object.defineProperty(exports, "TinyDomReadyManager", {
  enumerable: true,
  get: function get() {
    return _TinyDomReadyManager["default"];
  }
});
Object.defineProperty(exports, "TinyDragDropDetector", {
  enumerable: true,
  get: function get() {
    return _TinyDragDropDetector["default"];
  }
});
Object.defineProperty(exports, "TinyDragger", {
  enumerable: true,
  get: function get() {
    return _TinyDragger["default"];
  }
});
Object.defineProperty(exports, "TinyEvents", {
  enumerable: true,
  get: function get() {
    return _TinyEvents["default"];
  }
});
Object.defineProperty(exports, "TinyHtml", {
  enumerable: true,
  get: function get() {
    return _TinyHtml["default"];
  }
});
Object.defineProperty(exports, "TinyIframeEvents", {
  enumerable: true,
  get: function get() {
    return _TinyIframeEvents["default"];
  }
});
Object.defineProperty(exports, "TinyLevelUp", {
  enumerable: true,
  get: function get() {
    return _userLevel["default"];
  }
});
Object.defineProperty(exports, "TinyLocalStorage", {
  enumerable: true,
  get: function get() {
    return _TinyLocalStorage["default"];
  }
});
Object.defineProperty(exports, "TinyNewWinEvents", {
  enumerable: true,
  get: function get() {
    return _TinyNewWinEvents["default"];
  }
});
Object.defineProperty(exports, "TinyNotifications", {
  enumerable: true,
  get: function get() {
    return _TinyNotifications["default"];
  }
});
Object.defineProperty(exports, "TinyNotifyCenter", {
  enumerable: true,
  get: function get() {
    return _TinyNotifyCenter["default"];
  }
});
Object.defineProperty(exports, "TinyPromiseQueue", {
  enumerable: true,
  get: function get() {
    return _TinyPromiseQueue["default"];
  }
});
Object.defineProperty(exports, "TinyRateLimiter", {
  enumerable: true,
  get: function get() {
    return _TinyRateLimiter["default"];
  }
});
Object.defineProperty(exports, "TinySmartScroller", {
  enumerable: true,
  get: function get() {
    return _TinySmartScroller["default"];
  }
});
Object.defineProperty(exports, "TinyTextRangeEditor", {
  enumerable: true,
  get: function get() {
    return _TinyTextRangeEditor["default"];
  }
});
Object.defineProperty(exports, "TinyTextarea", {
  enumerable: true,
  get: function get() {
    return _TinyTextarea["default"];
  }
});
Object.defineProperty(exports, "TinyTimeout", {
  enumerable: true,
  get: function get() {
    return _TinyTimeout["default"];
  }
});
Object.defineProperty(exports, "TinyToastNotify", {
  enumerable: true,
  get: function get() {
    return _TinyToastNotify["default"];
  }
});
Object.defineProperty(exports, "UltraRandomMsgGen", {
  enumerable: true,
  get: function get() {
    return _UltraRandomMsgGen["default"];
  }
});
Object.defineProperty(exports, "addAiMarkerShortcut", {
  enumerable: true,
  get: function get() {
    return _text.addAiMarkerShortcut;
  }
});
Object.defineProperty(exports, "areElsCollBottom", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollBottom;
  }
});
Object.defineProperty(exports, "areElsCollLeft", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollLeft;
  }
});
Object.defineProperty(exports, "areElsCollPerfBottom", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollPerfBottom;
  }
});
Object.defineProperty(exports, "areElsCollPerfLeft", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollPerfLeft;
  }
});
Object.defineProperty(exports, "areElsCollPerfRight", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollPerfRight;
  }
});
Object.defineProperty(exports, "areElsCollPerfTop", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollPerfTop;
  }
});
Object.defineProperty(exports, "areElsCollRight", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollRight;
  }
});
Object.defineProperty(exports, "areElsCollTop", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollTop;
  }
});
Object.defineProperty(exports, "areElsColliding", {
  enumerable: true,
  get: function get() {
    return _collision.areElsColliding;
  }
});
Object.defineProperty(exports, "areElsPerfColliding", {
  enumerable: true,
  get: function get() {
    return _collision.areElsPerfColliding;
  }
});
Object.defineProperty(exports, "areHtmlElsColliding", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.areHtmlElsColliding;
  }
});
Object.defineProperty(exports, "arraySortPositions", {
  enumerable: true,
  get: function get() {
    return _arraySortPositions["default"];
  }
});
Object.defineProperty(exports, "asyncReplace", {
  enumerable: true,
  get: function get() {
    return _replaceAsync["default"];
  }
});
Object.defineProperty(exports, "backupFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.backupFile;
  }
});
Object.defineProperty(exports, "checkObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.checkObj;
  }
});
Object.defineProperty(exports, "clearDirectory", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.clearDirectory;
  }
});
Object.defineProperty(exports, "clearDirectoryAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.clearDirectoryAsync;
  }
});
Object.defineProperty(exports, "cloneObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.cloneObjTypeOrder;
  }
});
Object.defineProperty(exports, "countObj", {
  enumerable: true,
  get: function get() {
    return _objChecker.countObj;
  }
});
Object.defineProperty(exports, "dirExists", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.dirExists;
  }
});
Object.defineProperty(exports, "dirSize", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.dirSize;
  }
});
Object.defineProperty(exports, "dirSizeAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.dirSizeAsync;
  }
});
Object.defineProperty(exports, "documentIsFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.documentIsFullScreen;
  }
});
Object.defineProperty(exports, "ensureCopyFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.ensureCopyFile;
  }
});
Object.defineProperty(exports, "ensureDirectory", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.ensureDirectory;
  }
});
Object.defineProperty(exports, "exitFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.exitFullScreen;
  }
});
Object.defineProperty(exports, "extendObjType", {
  enumerable: true,
  get: function get() {
    return _objFilter.extendObjType;
  }
});
Object.defineProperty(exports, "fetchJson", {
  enumerable: true,
  get: function get() {
    return _html.fetchJson;
  }
});
Object.defineProperty(exports, "fetchText", {
  enumerable: true,
  get: function get() {
    return _html.fetchText;
  }
});
Object.defineProperty(exports, "fileExists", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.fileExists;
  }
});
Object.defineProperty(exports, "fileSize", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.fileSize;
  }
});
Object.defineProperty(exports, "fileSizeAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.fileSizeAsync;
  }
});
Object.defineProperty(exports, "formatBytes", {
  enumerable: true,
  get: function get() {
    return _simpleMath.formatBytes;
  }
});
Object.defineProperty(exports, "formatCustomTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatCustomTimer;
  }
});
Object.defineProperty(exports, "formatDayTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatDayTimer;
  }
});
Object.defineProperty(exports, "formatTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatTimer;
  }
});
Object.defineProperty(exports, "genFibonacciSeq", {
  enumerable: true,
  get: function get() {
    return _simpleMath.genFibonacciSeq;
  }
});
Object.defineProperty(exports, "getAge", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getAge;
  }
});
Object.defineProperty(exports, "getElsCollDetails", {
  enumerable: true,
  get: function get() {
    return _collision.getElsCollDetails;
  }
});
Object.defineProperty(exports, "getElsCollDirDepth", {
  enumerable: true,
  get: function get() {
    return _collision.getElsCollDirDepth;
  }
});
Object.defineProperty(exports, "getElsCollOverlap", {
  enumerable: true,
  get: function get() {
    return _collision.getElsCollOverlap;
  }
});
Object.defineProperty(exports, "getElsCollOverlapPos", {
  enumerable: true,
  get: function get() {
    return _collision.getElsCollOverlapPos;
  }
});
Object.defineProperty(exports, "getElsColliding", {
  enumerable: true,
  get: function get() {
    return _collision.getElsColliding;
  }
});
Object.defineProperty(exports, "getElsPerfColliding", {
  enumerable: true,
  get: function get() {
    return _collision.getElsPerfColliding;
  }
});
Object.defineProperty(exports, "getElsRelativeCenterOffset", {
  enumerable: true,
  get: function get() {
    return _collision.getElsRelativeCenterOffset;
  }
});
Object.defineProperty(exports, "getHtmlElBorders", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.getHtmlElBorders;
  }
});
Object.defineProperty(exports, "getHtmlElBordersWidth", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.getHtmlElBordersWidth;
  }
});
Object.defineProperty(exports, "getHtmlElMargin", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.getHtmlElMargin;
  }
});
Object.defineProperty(exports, "getHtmlElPadding", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.getHtmlElPadding;
  }
});
Object.defineProperty(exports, "getLatestBackupPath", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.getLatestBackupPath;
  }
});
Object.defineProperty(exports, "getPercentage", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getPercentage;
  }
});
Object.defineProperty(exports, "getRectCenter", {
  enumerable: true,
  get: function get() {
    return _collision.getRectCenter;
  }
});
Object.defineProperty(exports, "getSimplePerc", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getSimplePerc;
  }
});
Object.defineProperty(exports, "getTimeDuration", {
  enumerable: true,
  get: function get() {
    return _clock.getTimeDuration;
  }
});
Object.defineProperty(exports, "installWindowHiddenScript", {
  enumerable: true,
  get: function get() {
    return _html.installWindowHiddenScript;
  }
});
Object.defineProperty(exports, "isDirEmpty", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.isDirEmpty;
  }
});
Object.defineProperty(exports, "isDirEmptyAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.isDirEmptyAsync;
  }
});
Object.defineProperty(exports, "isFullScreenMode", {
  enumerable: true,
  get: function get() {
    return _fullScreen.isFullScreenMode;
  }
});
Object.defineProperty(exports, "isInViewport", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.isInViewport;
  }
});
Object.defineProperty(exports, "isJsonObject", {
  enumerable: true,
  get: function get() {
    return _objChecker.isJsonObject;
  }
});
Object.defineProperty(exports, "isScreenFilled", {
  enumerable: true,
  get: function get() {
    return _fullScreen.isScreenFilled;
  }
});
Object.defineProperty(exports, "isScrolledIntoView", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.isScrolledIntoView;
  }
});
Object.defineProperty(exports, "listDirs", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.listDirs;
  }
});
Object.defineProperty(exports, "listDirsAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.listDirsAsync;
  }
});
Object.defineProperty(exports, "listFiles", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.listFiles;
  }
});
Object.defineProperty(exports, "listFilesAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.listFilesAsync;
  }
});
Object.defineProperty(exports, "objType", {
  enumerable: true,
  get: function get() {
    return _objFilter.objType;
  }
});
Object.defineProperty(exports, "offFullScreenChange", {
  enumerable: true,
  get: function get() {
    return _fullScreen.offFullScreenChange;
  }
});
Object.defineProperty(exports, "onFullScreenChange", {
  enumerable: true,
  get: function get() {
    return _fullScreen.onFullScreenChange;
  }
});
Object.defineProperty(exports, "readBase64Blob", {
  enumerable: true,
  get: function get() {
    return _html.readBase64Blob;
  }
});
Object.defineProperty(exports, "readFileBlob", {
  enumerable: true,
  get: function get() {
    return _html.readFileBlob;
  }
});
Object.defineProperty(exports, "readJsonBlob", {
  enumerable: true,
  get: function get() {
    return _html.readJsonBlob;
  }
});
Object.defineProperty(exports, "readJsonFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.readJsonFile;
  }
});
Object.defineProperty(exports, "renameFileAddPrefixSuffix", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileAddPrefixSuffix;
  }
});
Object.defineProperty(exports, "renameFileBatch", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileBatch;
  }
});
Object.defineProperty(exports, "renameFileNormalizeCase", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileNormalizeCase;
  }
});
Object.defineProperty(exports, "renameFilePadNumbers", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFilePadNumbers;
  }
});
Object.defineProperty(exports, "renameFileRegex", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileRegex;
  }
});
Object.defineProperty(exports, "reorderObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.reorderObjTypeOrder;
  }
});
Object.defineProperty(exports, "requestFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.requestFullScreen;
  }
});
Object.defineProperty(exports, "restoreLatestBackup", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.restoreLatestBackup;
  }
});
Object.defineProperty(exports, "ruleOfThree", {
  enumerable: true,
  get: function get() {
    return _simpleMath.ruleOfThree;
  }
});
Object.defineProperty(exports, "safeTextTrim", {
  enumerable: true,
  get: function get() {
    return _text.safeTextTrim;
  }
});
Object.defineProperty(exports, "saveJsonFile", {
  enumerable: true,
  get: function get() {
    return _html.saveJsonFile;
  }
});
Object.defineProperty(exports, "shuffleArray", {
  enumerable: true,
  get: function get() {
    return _array.shuffleArray;
  }
});
Object.defineProperty(exports, "toTitleCase", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCase;
  }
});
Object.defineProperty(exports, "toTitleCaseLowerFirst", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCaseLowerFirst;
  }
});
Object.defineProperty(exports, "tryDeleteFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.tryDeleteFile;
  }
});
Object.defineProperty(exports, "writeJsonFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.writeJsonFile;
  }
});
Object.defineProperty(exports, "writeTextFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.writeTextFile;
  }
});
var _replaceAsync = _interopRequireDefault(require("../legacy/libs/replaceAsync.mjs"));
var _userLevel = _interopRequireDefault(require("../legacy/libs/userLevel.mjs"));
var _arraySortPositions = _interopRequireDefault(require("../legacy/libs/arraySortPositions.mjs"));
var _array = require("./basics/array.mjs");
var _clock = require("./basics/clock.mjs");
var _objFilter = require("./basics/objFilter.mjs");
var _objChecker = require("./basics/objChecker.mjs");
var _fullScreen = require("./basics/fullScreen.mjs");
var _simpleMath = require("./basics/simpleMath.mjs");
var _text = require("./basics/text.mjs");
var _ColorSafeStringify = _interopRequireDefault(require("./libs/ColorSafeStringify.mjs"));
var _TinyPromiseQueue = _interopRequireDefault(require("./libs/TinyPromiseQueue.mjs"));
var _TinyRateLimiter = _interopRequireDefault(require("./libs/TinyRateLimiter.mjs"));
var _TinyNotifyCenter = _interopRequireDefault(require("./libs/TinyNotifyCenter.mjs"));
var _TinyToastNotify = _interopRequireDefault(require("./libs/TinyToastNotify.mjs"));
var _html = require("./basics/html.mjs");
var _html_deprecated = require("./basics/html_deprecated.mjs");
var _TinyDragDropDetector = _interopRequireDefault(require("./libs/TinyDragDropDetector.mjs"));
var _normalFuncs = require("./fileManager/normalFuncs.mjs");
var _asyncFuncs = require("./fileManager/asyncFuncs.mjs");
var _TinyDragger = _interopRequireDefault(require("./libs/TinyDragger.mjs"));
var _TinyDomReadyManager = _interopRequireDefault(require("./libs/TinyDomReadyManager.mjs"));
var _TinyNotifications = _interopRequireDefault(require("./libs/TinyNotifications.mjs"));
var _collision = require("./basics/collision.mjs");
var _TinyHtml = _interopRequireDefault(require("./libs/TinyHtml.mjs"));
var _TinyAfterScrollWatcher = _interopRequireDefault(require("./libs/TinyAfterScrollWatcher.mjs"));
var _UltraRandomMsgGen = _interopRequireDefault(require("./libs/UltraRandomMsgGen.mjs"));
var _TinySmartScroller = _interopRequireDefault(require("./libs/TinySmartScroller.mjs"));
var _TinyTextRangeEditor = _interopRequireDefault(require("./libs/TinyTextRangeEditor.mjs"));
var _TinyClipboard = _interopRequireDefault(require("./libs/TinyClipboard.mjs"));
var _TinyColorConverter = _interopRequireDefault(require("./libs/TinyColorConverter.mjs"));
var _TinyTimeout = _interopRequireDefault(require("./libs/TinyTimeout.mjs"));
var _TinyEvents = _interopRequireDefault(require("./libs/TinyEvents.mjs"));
var _TinyLocalStorage = _interopRequireDefault(require("./libs/TinyLocalStorage.mjs"));
var _TinyIframeEvents = _interopRequireDefault(require("./libs/TinyIframeEvents.mjs"));
var _TinyNewWinEvents = _interopRequireDefault(require("./libs/TinyNewWinEvents.mjs"));
var _TinyTextarea = _interopRequireDefault(require("./libs/TinyTextarea.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"../legacy/libs/arraySortPositions.mjs":166,"../legacy/libs/replaceAsync.mjs":167,"../legacy/libs/userLevel.mjs":168,"./basics/array.mjs":169,"./basics/clock.mjs":170,"./basics/collision.mjs":171,"./basics/fullScreen.mjs":172,"./basics/html.mjs":173,"./basics/html_deprecated.mjs":174,"./basics/objChecker.mjs":175,"./basics/objFilter.mjs":176,"./basics/simpleMath.mjs":177,"./basics/text.mjs":178,"./fileManager/asyncFuncs.mjs":179,"./fileManager/normalFuncs.mjs":180,"./libs/ColorSafeStringify.mjs":182,"./libs/TinyAfterScrollWatcher.mjs":183,"./libs/TinyClipboard.mjs":184,"./libs/TinyColorConverter.mjs":185,"./libs/TinyDomReadyManager.mjs":186,"./libs/TinyDragDropDetector.mjs":187,"./libs/TinyDragger.mjs":188,"./libs/TinyEvents.mjs":189,"./libs/TinyHtml.mjs":190,"./libs/TinyIframeEvents.mjs":191,"./libs/TinyLocalStorage.mjs":192,"./libs/TinyNewWinEvents.mjs":193,"./libs/TinyNotifications.mjs":194,"./libs/TinyNotifyCenter.mjs":195,"./libs/TinyPromiseQueue.mjs":196,"./libs/TinyRateLimiter.mjs":197,"./libs/TinySmartScroller.mjs":198,"./libs/TinyTextRangeEditor.mjs":199,"./libs/TinyTextarea.mjs":200,"./libs/TinyTimeout.mjs":201,"./libs/TinyToastNotify.mjs":202,"./libs/UltraRandomMsgGen.mjs":203}],182:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"dup":163}],183:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _scrollTarget = /*#__PURE__*/new WeakMap();
var _lastScrollTime = /*#__PURE__*/new WeakMap();
var _afterScrollQueue = /*#__PURE__*/new WeakMap();
var _inactivityTime = /*#__PURE__*/new WeakMap();
var _externalScrollListeners = /*#__PURE__*/new WeakMap();
var _onStopListeners = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _TinyAfterScrollWatcher_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {(() => void)} FnData - Function with no arguments and no return value
 */
/**
 * A function that handles a scroll event.
 * It receives a standard `Event` object when a scroll occurs.
 *
 * @typedef {(ev: Event) => void} OnScrollFunc
 */
/**
 * A scroll tracker that queues functions to be executed
 * after the user stops scrolling a specific element or the window.
 */
var TinyAfterScrollWatcher = /*#__PURE__*/function () {
  /**
   * @param {Element|Window} scrollTarget - The element or window to track scrolling on
   * @param {number} [inactivityTime=100] - Time in milliseconds to wait after scroll ends before executing the queue
   * @throws {TypeError} If scrollTarget is not a valid Element or Window
   * @throws {TypeError} If inactivityTime is not a positive number
   */
  function TinyAfterScrollWatcher() {
    var _this = this;
    var scrollTarget = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var inactivityTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    _classCallCheck(this, TinyAfterScrollWatcher);
    /**
     * Continuously checks whether the user has stopped scrolling,
     * and if so, runs all queued functions.
     */
    _classPrivateMethodInitSpec(this, _TinyAfterScrollWatcher_brand);
    /** @type {Element|Window} */
    _classPrivateFieldInitSpec(this, _scrollTarget, void 0);
    /** @type {null|NodeJS.Timeout} */
    _classPrivateFieldInitSpec(this, _lastScrollTime, null);
    /** @type {FnData[]} */
    _classPrivateFieldInitSpec(this, _afterScrollQueue, []);
    /** @type {number} */
    _classPrivateFieldInitSpec(this, _inactivityTime, 100);
    /** @type {Set<OnScrollFunc>} */
    _classPrivateFieldInitSpec(this, _externalScrollListeners, new Set());
    /** @type {Set<FnData>} */
    _classPrivateFieldInitSpec(this, _onStopListeners, new Set());
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _destroyed, false);
    _defineProperty(this, "_checkTimer", function () {
      if (_classPrivateFieldGet(_lastScrollTime, _this)) clearTimeout(_classPrivateFieldGet(_lastScrollTime, _this));
      _classPrivateFieldSet(_lastScrollTime, _this, setTimeout(function () {
        _classPrivateFieldSet(_lastScrollTime, _this, null);
        _assertClassBrand(_TinyAfterScrollWatcher_brand, _this, _checkQueue).call(_this);
      }, _classPrivateFieldGet(_inactivityTime, _this)));
    });
    if (!(scrollTarget instanceof Element) && !(scrollTarget instanceof Window)) throw new TypeError('scrollTarget must be an Element or the Window object.');
    _classPrivateFieldSet(_scrollTarget, this, scrollTarget);
    this._checkTimer = this._checkTimer.bind(this);
    _classPrivateFieldGet(_scrollTarget, this).addEventListener('scroll', this._checkTimer);
    _classPrivateFieldSet(_inactivityTime, this, inactivityTime);
  }
  return _createClass(TinyAfterScrollWatcher, [{
    key: "inactivityTime",
    get:
    /**
     * Gets the current inactivity time in milliseconds.
     * @returns {number}
     */
    function get() {
      return _classPrivateFieldGet(_inactivityTime, this);
    }
    /**
     * Sets a new inactivity time.
     * Must be a positive number (in milliseconds).
     * @param {number} value
     * @throws {Error} If value is not a positive number
     */,
    set: function set(value) {
      if (typeof value !== 'number' || value <= 0 || !Number.isFinite(value)) throw new Error('inactivityTime must be a positive number in milliseconds.');
      _classPrivateFieldSet(_inactivityTime, this, value);
    }
  }, {
    key: "doAfterScroll",
    value:
    /**
     * Adds a function to be executed after scroll has stopped.
     * The scroll is considered "stopped" after the configured inactivity time.
     *
     * @param {() => void} fn - A function to execute once scrolling has stopped.
     * @throws {TypeError} If the argument is not a function.
     */
    function doAfterScroll(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      this.lastScrollTime = Date.now();
      _classPrivateFieldGet(_afterScrollQueue, this).push(fn);
    }
    /**
     * Registers a function to run once after scrolling has stopped,
     * before any afterScrollQueue functions.
     *
     * @param {FnData} fn - A function to execute after scroll stop.
     * @throws {TypeError} If the argument is not a function.
     */
  }, {
    key: "onStop",
    value: function onStop(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      _classPrivateFieldGet(_onStopListeners, this).add(fn);
    }
    /**
     * Removes a previously registered onStop function.
     *
     * @param {FnData} fn - The function to remove.
     * @throws {TypeError} If the argument is not a function.
     */
  }, {
    key: "offStop",
    value: function offStop(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      _classPrivateFieldGet(_onStopListeners, this)["delete"](fn);
    }
    /**
     * Registers an external scroll listener on the tracked element.
     *
     * @param {OnScrollFunc} fn - The scroll listener to add
     * @throws {TypeError} If the argument is not a function.
     */
  }, {
    key: "onScroll",
    value: function onScroll(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      _classPrivateFieldGet(_scrollTarget, this).addEventListener('scroll', fn);
      _classPrivateFieldGet(_externalScrollListeners, this).add(fn);
    }
    /**
     * Removes a previously registered scroll listener from the tracked element.
     *
     * @param {OnScrollFunc} fn - The scroll listener to remove
     * @throws {TypeError} If the argument is not a function.
     */
  }, {
    key: "offScroll",
    value: function offScroll(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      if (_classPrivateFieldGet(_externalScrollListeners, this).has(fn)) {
        _classPrivateFieldGet(_scrollTarget, this).removeEventListener('scroll', fn);
        _classPrivateFieldGet(_externalScrollListeners, this)["delete"](fn);
      }
    }
    /**
     * Destroys the watcher by removing internal listeners and clearing data.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      _classPrivateFieldSet(_destroyed, this, true);
      _classPrivateFieldGet(_scrollTarget, this).removeEventListener('scroll', this._checkTimer);
      var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(_externalScrollListeners, this)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var fn = _step.value;
          _classPrivateFieldGet(_scrollTarget, this).removeEventListener('scroll', fn);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      _classPrivateFieldGet(_externalScrollListeners, this).clear();
      _classPrivateFieldGet(_onStopListeners, this).clear();
    }
  }]);
}();
function _checkQueue() {
  if (_classPrivateFieldGet(_destroyed, this)) return;
  // Runs all onStop first listeners
  var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(_onStopListeners, this)),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _fn = _step2.value;
      if (typeof _fn === 'function') _fn();
    }
    // Then execute the queue afterScrollQueue
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  while (_classPrivateFieldGet(_afterScrollQueue, this).length) {
    var fn = _classPrivateFieldGet(_afterScrollQueue, this).pop();
    if (typeof fn === 'function') fn();
  }
}
var _default = exports["default"] = TinyAfterScrollWatcher;

},{}],184:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _existExecCommand = /*#__PURE__*/new WeakMap();
var _existNavigator = /*#__PURE__*/new WeakMap();
var _copyText = /*#__PURE__*/new WeakMap();
var _copyBlob = /*#__PURE__*/new WeakMap();
/**
 * Utility class to handle clipboard operations for text and blob data.
 * Supports modern Clipboard API, custom platform, and legacy execCommand fallback.
 */
var TinyClipboard = /*#__PURE__*/function () {
  /**
   * Constructs a new TinyClipboard instance.
   * Automatically detects and configures available clipboard APIs.
   */
  function TinyClipboard() {
    _classCallCheck(this, TinyClipboard);
    /**
     * Indicates whether the legacy `document.execCommand()` API is available.
     * Used as a fallback for clipboard operations when modern APIs are not supported.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _existExecCommand, false);
    /**
     * Indicates whether the modern Clipboard API (`navigator.clipboard`) is available.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _existNavigator, false);
    /**
     * Function used to copy plain text to the clipboard.
     * Can be overridden using `setCopyText()`.
     *
     * @type {((text: string) => Promise<void>) | null}
     */
    _classPrivateFieldInitSpec(this, _copyText, null);
    /**
     * Function used to copy a Blob (binary data) to the clipboard.
     * Can be overridden using `setCopyBlob()`.
     *
     * @type {((blob: Blob) => Promise<void>) | null}
     */
    _classPrivateFieldInitSpec(this, _copyBlob, null);
    // Whether the Clipboard API is available.
    if (typeof navigator.clipboard !== 'undefined' && navigator.clipboard !== null) {
      _classPrivateFieldSet(_existNavigator, this, true);
      _classPrivateFieldSet(_copyText, this, function (text) {
        return navigator.clipboard.writeText(text);
      });
      _classPrivateFieldSet(_copyBlob, this, function (blob) {
        return navigator.clipboard.write([new ClipboardItem(_defineProperty({}, blob.type, blob))]);
      });
    }
    /**
     * @type {boolean}
     * Whether the legacy execCommand API is available.
     */
    _classPrivateFieldSet(_existExecCommand, this, typeof document.execCommand !== 'undefined' && document.execCommand !== null);
  }
  /**
   * Override the default text copy behavior.
   * This allows you to provide your own clipboard implementation or
   * integrate with external systems like Capacitor or Electron.
   *
   * @param {(text: string) => Promise<void>} callback - The function to use for copying text.
   * @throws {TypeError} If the callback is not a function.
   */
  return _createClass(TinyClipboard, [{
    key: "setCopyText",
    value: function setCopyText(callback) {
      if (typeof callback !== 'function') throw new TypeError('setCopyText expected a function that returns Promise<void>.');
      _classPrivateFieldSet(_copyText, this, callback);
    }
    /**
     * Override the default blob copy behavior.
     * This allows you to provide a custom clipboard handling method for blob data.
     *
     * @param {(blob: Blob) => Promise<void>} callback - The function to use for copying blob data.
     * @throws {TypeError} If the callback is not a function.
     */
  }, {
    key: "setCopyBlob",
    value: function setCopyBlob(callback) {
      if (typeof callback !== 'function') throw new TypeError('setCopyBlob expected a function that returns Promise<void>.');
      _classPrivateFieldSet(_copyBlob, this, callback);
    }
    /**
     * Copy a plain text string to the clipboard.
     * Uses modern or legacy fallback.
     *
     * @param {string} text - The text string to be copied.
     * @returns {Promise<void>} A promise resolving when the text is copied or boolean for legacy.
     */
  }, {
    key: "copyText",
    value: function copyText(text) {
      if (typeof text !== 'string') throw new TypeError('copyText expected a string.');
      // Clipboard API
      if (_classPrivateFieldGet(_copyText, this)) return _classPrivateFieldGet(_copyText, this).call(this, text);
      // Classic API
      else if (_classPrivateFieldGet(_existExecCommand, this)) {
        var host = document.body;
        var copyInput = document.createElement('input');
        copyInput.style.position = 'fixed';
        copyInput.style.opacity = '0';
        copyInput.value = text;
        host.append(copyInput);
        copyInput.select();
        copyInput.setSelectionRange(0, 99999);
        document.execCommand('Copy');
        copyInput.remove();
        return new Promise(function (resolve) {
          return resolve(undefined);
        });
      }
      throw new Error('Clipboard API not found!');
    }
    /**
     * Copy a Blob (binary data) to the clipboard.
     *
     * @param {Blob} blob - The blob object to copy.
     * @returns {Promise<void>} A promise that resolves when the blob is copied or null on fallback.
     */
  }, {
    key: "copyBlob",
    value: function copyBlob(blob) {
      var _this = this;
      if (!(blob instanceof Blob)) throw new TypeError('copyBlob expected a Blob instance.');
      return new Promise(function (resolve, reject) {
        if (_classPrivateFieldGet(_copyBlob, _this)) {
          return _classPrivateFieldGet(_copyBlob, _this).call(_this, blob).then(resolve)["catch"](reject);
        }
        throw new Error('Clipboard API not found!');
      });
    }
    /**
     * Internal: Handle getting blob data from a clipboard item.
     *
     * @private
     * @param {string} type - The MIME type to fetch.
     * @param {ClipboardItem} clipboardItem - Clipboard item instance.
     * @returns {Promise<Blob>} A promise that resolves with the Blob.
     */
  }, {
    key: "_handleBlob",
    value: function _handleBlob(type, clipboardItem) {
      return clipboardItem.getType(type);
    }
    /**
     * Internal: Handle getting plain text from a clipboard item.
     *
     * @private
     * @param {string} type - The MIME type (should be 'text/plain').
     * @param {ClipboardItem} clipboardItem - Clipboard item instance.
     * @returns {Promise<string>} A promise that resolves with the text content.
     */
  }, {
    key: "_handleText",
    value: function _handleText(type, clipboardItem) {
      return this._handleBlob(type, clipboardItem).then(function (blob) {
        return blob.text();
      });
    }
    /**
     * Read clipboard data based on filters like type, mime, index.
     *
     * @param {number|null} [index=0] - Item index or null for all.
     * @param {'text'|'custom'|null} [type=null] - Data type to filter.
     * @param {string|null} [mimeFormat=null] - MIME type or prefix.
     * @param {boolean} [fixValue=false] - If true, exact match on MIME type.
     * @returns {Promise<Blob|string|Array<Blob|string>|null>} A promise resolving with matching data.
     */
  }, {
    key: "_readData",
    value: function _readData() {
      var _this2 = this;
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var mimeFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var fixValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      return new Promise(function (resolve, reject) {
        _this2._read(index).then(function (items) {
          if (!items) return resolve(null);
          /** @type {Array<Blob|string>} */
          var finalResult = [];
          // Complete task
          var continueLoop = true;
          /**
           * @param {string} mimeType
           * @param {ClipboardItem} item
           */
          var completeTask = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(mimeType, item) {
              var result, _result, _result2;
              return _regenerator().w(function (_context) {
                while (1) switch (_context.n) {
                  case 0:
                    if (continueLoop) {
                      _context.n = 1;
                      break;
                    }
                    return _context.a(2);
                  case 1:
                    if (!((type === null || type === 'custom') && typeof mimeFormat === 'string' && (!fixValue && mimeType.startsWith(mimeFormat) || fixValue && mimeType === mimeFormat))) {
                      _context.n = 3;
                      break;
                    }
                    continueLoop = false;
                    _context.n = 2;
                    return _this2._handleBlob(mimeType, item);
                  case 2:
                    result = _context.v;
                    if (result) finalResult.push(result);
                    _context.n = 7;
                    break;
                  case 3:
                    if (!((type === null || type === 'text') && mimeType === 'text/plain')) {
                      _context.n = 5;
                      break;
                    }
                    continueLoop = false;
                    _context.n = 4;
                    return _this2._handleText(mimeType, item);
                  case 4:
                    _result = _context.v;
                    if (_result) finalResult.push(_result);
                    _context.n = 7;
                    break;
                  case 5:
                    if (!(type === null)) {
                      _context.n = 7;
                      break;
                    }
                    continueLoop = false;
                    _context.n = 6;
                    return _this2._handleBlob(mimeType, item);
                  case 6:
                    _result2 = _context.v;
                    if (_result2) finalResult.push(_result2);
                  case 7:
                    return _context.a(2);
                }
              }, _callee);
            }));
            return function completeTask(_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }();
          /** @type {Promise<void>[]} */
          var promises = [];
          /**
           * Read Item
           * @param {ClipboardItem | ClipboardItems} item
           */
          var readItem = function readItem(item) {
            if (!(item instanceof ClipboardItem)) throw new Error('Expected ClipboardItem when reading data.');
            for (var tIndex in item.types) promises.push(completeTask(item.types[tIndex], item));
          };
          // Specific Item
          if (typeof index === 'number' && !Number.isNaN(index) && Number.isFinite(index) && index > -1) {
            readItem(items);
            Promise.all(promises).then(function () {
              if (finalResult[0]) resolve(finalResult[0]);else resolve(null);
            })["catch"](reject);
          }
          // All
          else if (Array.isArray(items)) {
            for (var tIndex in items) readItem(items[tIndex]);
            Promise.all(promises).then(function () {
              return resolve(finalResult);
            })["catch"](reject);
          }
        })
        // Fail
        ["catch"](reject);
      });
    }
    /**
     * Read plain text from the clipboard (single item by index).
     *
     * @param {number} [index=0] - The index of the clipboard item to read.
     * @returns {Promise<string|null>} A promise that resolves to the clipboard text or null.
     */
  }, {
    key: "readText",
    value: (function () {
      var _readText = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var index,
          value,
          _args2 = arguments;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              index = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 0;
              _context2.n = 1;
              return this._readData(index, 'text');
            case 1:
              value = _context2.v;
              if (!(typeof value !== 'string')) {
                _context2.n = 2;
                break;
              }
              throw new Error('Failed to read text: expected string result.');
            case 2:
              return _context2.a(2, value);
          }
        }, _callee2, this);
      }));
      function readText() {
        return _readText.apply(this, arguments);
      }
      return readText;
    }()
    /**
     * Read custom clipboard data based on MIME type from a specific index.
     *
     * @param {string|null} [mimeFormat=null] - MIME prefix to match (e.g., "image/").
     * @param {boolean} [fixValue=false] - If true, matches exact MIME instead of prefix.
     * @param {number} [index=0] - Clipboard item index.
     * @returns {Promise<Blob|null>} A promise resolving with a blob or null.
     */
    )
  }, {
    key: "readCustom",
    value: (function () {
      var _readCustom = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var mimeFormat,
          fixValue,
          index,
          value,
          _args3 = arguments;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              mimeFormat = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : null;
              fixValue = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;
              index = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : 0;
              _context3.n = 1;
              return this._readData(index, 'custom', mimeFormat, fixValue);
            case 1:
              value = _context3.v;
              if (value instanceof Blob) {
                _context3.n = 2;
                break;
              }
              throw new Error('Failed to read custom data: expected Blob.');
            case 2:
              return _context3.a(2, value);
          }
        }, _callee3, this);
      }));
      function readCustom() {
        return _readCustom.apply(this, arguments);
      }
      return readCustom;
    }()
    /**
     * Read all available plain text entries from the clipboard.
     *
     * @returns {Promise<string[]>} A promise resolving to an array of strings or null.
     */
    )
  }, {
    key: "readAllTexts",
    value: (function () {
      var _readAllTexts = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var values;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return this._readData(null, 'text');
            case 1:
              values = _context4.v;
              if (Array.isArray(values)) {
                _context4.n = 2;
                break;
              }
              throw new Error('Expected array of strings when reading all texts.');
            case 2:
              if (values.every(function (value) {
                return typeof value === 'string';
              })) {
                _context4.n = 3;
                break;
              }
              throw new Error('Some values returned were not strings.');
            case 3:
              return _context4.a(2, values);
          }
        }, _callee4, this);
      }));
      function readAllTexts() {
        return _readAllTexts.apply(this, arguments);
      }
      return readAllTexts;
    }()
    /**
     * Read all clipboard data matching a specific custom MIME type.
     *
     * @param {string|null} [mimeFormat=null] - MIME prefix or exact type.
     * @param {boolean} [fixValue=false] - Match prefix or exact MIME.
     * @returns {Promise<Blob[]>} A promise resolving with array of Blobs or null.
     */
    )
  }, {
    key: "readAllCustom",
    value: (function () {
      var _readAllCustom = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var mimeFormat,
          fixValue,
          values,
          _args5 = arguments;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              mimeFormat = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : null;
              fixValue = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : false;
              _context5.n = 1;
              return this._readData(null, 'custom', mimeFormat, fixValue);
            case 1:
              values = _context5.v;
              if (Array.isArray(values)) {
                _context5.n = 2;
                break;
              }
              throw new Error('Expected array of blobs when reading all custom items.');
            case 2:
              if (values.every(function (value) {
                return value instanceof Blob;
              })) {
                _context5.n = 3;
                break;
              }
              throw new Error('Some values returned were not Blob instances.');
            case 3:
              return _context5.a(2, values);
          }
        }, _callee5, this);
      }));
      function readAllCustom() {
        return _readAllCustom.apply(this, arguments);
      }
      return readAllCustom;
    }()
    /**
     * Read all clipboard data as Blob or text depending on type.
     *
     * @param {'text'|'custom'|null} [type=null] - The type of data to retrieve.
     * @param {string|null} [mimeFormat=null] - The MIME type or prefix to match.
     * @returns {Promise<Array<Blob|string>>} A promise resolving with matching data array.
     */
    )
  }, {
    key: "readAllData",
    value: (function () {
      var _readAllData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var type,
          mimeFormat,
          value,
          _args6 = arguments;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              type = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : null;
              mimeFormat = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : null;
              _context6.n = 1;
              return this._readData(null, type, mimeFormat);
            case 1:
              value = _context6.v;
              if (Array.isArray(value)) {
                _context6.n = 2;
                break;
              }
              throw new Error('Expected array result when reading all data.');
            case 2:
              return _context6.a(2, value);
          }
        }, _callee6, this);
      }));
      function readAllData() {
        return _readAllData.apply(this, arguments);
      }
      return readAllData;
    }()
    /**
     * Read clipboard data at a specific index or all if null.
     *
     * @param {number|null} index - Index of the item to retrieve or null to get all.
     * @returns {Promise<ClipboardItem|ClipboardItems|null>} A promise resolving with a clipboard item or array of items.
     */
    )
  }, {
    key: "_read",
    value: function _read(index) {
      var _this3 = this;
      return new Promise(function (resolve, reject) {
        if (!_classPrivateFieldGet(_existNavigator, _this3)) reject(new Error('Clipboard API not found!'));
        navigator.clipboard.read().then(function (items) {
          // Index is number
          if (typeof index === 'number') {
            if (Number.isNaN(index) || !Number.isFinite(index) || index < 0) throw new Error("Invalid index value: ".concat(index));
            if (items[index]) resolve(items[index]);
            // Not found
            else resolve(null);
          }
          // Get All
          resolve(items);
        })["catch"](reject);
      });
    }
    /**
     * Read clipboard data at a specific index.
     *
     * @param {number} index - Index of the item to retrieve
     * @returns {Promise<ClipboardItem|null>} A promise resolving with a clipboard item.
     */
  }, {
    key: "readIndex",
    value: (function () {
      var _readIndex = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(index) {
        var value;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              _context7.n = 1;
              return this._read(index);
            case 1:
              value = _context7.v;
              if (!(value !== null && !(value instanceof ClipboardItem))) {
                _context7.n = 2;
                break;
              }
              throw new Error("Value at index ".concat(index, " is not a ClipboardItem."));
            case 2:
              return _context7.a(2, value);
          }
        }, _callee7, this);
      }));
      function readIndex(_x3) {
        return _readIndex.apply(this, arguments);
      }
      return readIndex;
    }()
    /**
     * Read all clipboard content without any filters.
     *
     * @returns {Promise<ClipboardItems>} A promise resolving with all clipboard items.
     */
    )
  }, {
    key: "readAll",
    value: (function () {
      var _readAll = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
        var value, _iterator, _step, item, _t;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              _context8.n = 1;
              return this._read(null);
            case 1:
              value = _context8.v;
              if (Array.isArray(value)) {
                _context8.n = 2;
                break;
              }
              throw new Error('Expected array result from clipboard read.');
            case 2:
              _iterator = _createForOfIteratorHelper(value);
              _context8.p = 3;
              _iterator.s();
            case 4:
              if ((_step = _iterator.n()).done) {
                _context8.n = 6;
                break;
              }
              item = _step.value;
              if (item instanceof ClipboardItem) {
                _context8.n = 5;
                break;
              }
              throw new Error('Invalid item type found in clipboard result.');
            case 5:
              _context8.n = 4;
              break;
            case 6:
              _context8.n = 8;
              break;
            case 7:
              _context8.p = 7;
              _t = _context8.v;
              _iterator.e(_t);
            case 8:
              _context8.p = 8;
              _iterator.f();
              return _context8.f(8);
            case 9:
              return _context8.a(2, value);
          }
        }, _callee8, this, [[3, 7, 8, 9]]);
      }));
      function readAll() {
        return _readAll.apply(this, arguments);
      }
      return readAll;
    }()
    /**
     * Returns whether the legacy `document.execCommand()` API is available.
     * This can be used to determine if a fallback clipboard method is usable.
     *
     * @returns {boolean} True if `document.execCommand` is available.
     */
    )
  }, {
    key: "isExecCommandAvailable",
    value: function isExecCommandAvailable() {
      return _classPrivateFieldGet(_existExecCommand, this);
    }
    /**
     * Returns whether the modern Clipboard API (`navigator.clipboard`) is available.
     * Useful to know if full clipboard features can be accessed.
     *
     * @returns {boolean} True if `navigator.clipboard` is available.
     */
  }, {
    key: "isNavigatorClipboardAvailable",
    value: function isNavigatorClipboardAvailable() {
      return _classPrivateFieldGet(_existNavigator, this);
    }
    /**
     * Returns the function used to copy plain text to the clipboard.
     * This function may be built-in or set manually via `setCopyText`.
     *
     * @returns {((text: string) => Promise<void>) | null} The current text copy function or null if unavailable.
     */
  }, {
    key: "getCopyTextFunc",
    value: function getCopyTextFunc() {
      return _classPrivateFieldGet(_copyText, this);
    }
    /**
     * Returns the function used to copy Blob (binary data) to the clipboard.
     * This function may be built-in or set manually via `setCopyBlob`.
     *
     * @returns {((blob: Blob) => Promise<void>) | null} The current blob copy function or null if unavailable.
     */
  }, {
    key: "getCopyBlobFunc",
    value: function getCopyBlobFunc() {
      return _classPrivateFieldGet(_copyBlob, this);
    }
  }]);
}();
var _default = exports["default"] = TinyClipboard;

},{}],185:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _original = /*#__PURE__*/new WeakMap();
var _rgba = /*#__PURE__*/new WeakMap();
var _checkIsHsl = /*#__PURE__*/new WeakMap();
/**
 * Represents a color in RGBA format.
 * Each element must be a number between 0 and 255.
 * The fourth value represents the alpha (transparency) channel.
 *
 * @typedef {number[]} RgbaColor
 * @property {number} 0 - Red component (0â255)
 * @property {number} 1 - Green component (0â255)
 * @property {number} 2 - Blue component (0â255)
 * @property {number} 3 - Alpha component (0â255)
 */
/**
 * Represents a color in RGB format.
 * Each element must be a number between 0 and 255.
 *
 * @typedef {number[]} RgbColor
 * @property {number} 0 - Red component (0â255)
 * @property {number} 1 - Green component (0â255)
 * @property {number} 2 - Blue component (0â255)
 */
/**
 * Represents a color in HSLA format.
 * The fourth value represents the alpha (transparency) channel.
 *
 * @typedef {number[]} HslaColor
 * @property {number} 0 - Hue (0â360)
 * @property {number} 1 - Saturation (0â100)
 * @property {number} 2 - Lightness (0â100)
 * @property {number} 3 - Alpha component (0â255)
 */
/**
 * Represents a color in HSL format.
 *
 * @typedef {number[]} HslColor
 * @property {number} 0 - Hue (0â360)
 * @property {number} 1 - Saturation (0â100)
 * @property {number} 2 - Lightness (0â100)
 */
/**
 * Represents a hex color.
 *
 * @typedef {string} HexColor
 */
/**
 * A union type representing various accepted color formats.
 * Can be a hex color string, a numeric value, or an array-based RGB/RGBA representation.
 *
 * @typedef {HexColor | number | RgbColor | RgbaColor} ColorTypes
 */
/**
 * @typedef {Object} RgbaResult
 * @property {number} r - Red component (0â255)
 * @property {number} g - Green component (0â255)
 * @property {number} b - Blue component (0â255)
 * @property {number} a - Alpha component (0â255)
 */
/**
 * @typedef {Object} RgbResult
 * @property {number} r - Red component (0â255)
 * @property {number} g - Green component (0â255)
 * @property {number} b - Blue component (0â255)
 */
/**
 * @typedef {Object} HexResult
 * @property {string} hex - Hex color
 */
/**
 * @typedef {Object} HslResult
 * @property {number} h - Hue (0â360)
 * @property {number} s - Saturation (0â100)
 * @property {number} l - Lightness (0â100)
 */
/**
 * A class that allows converting colors between all common formats.
 */
var TinyColorConverter = /*#__PURE__*/function () {
  /**
   * @param {ColorTypes|null} [input=null] - Any valid color (hex, rgb string, rgba string, hsl(a), css name, array or int).
   * @param {boolean} [checkIsHsl=false]
   */
  function TinyColorConverter() {
    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var checkIsHsl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, TinyColorConverter);
    // Class Script
    /** @type {ColorTypes} */
    _classPrivateFieldInitSpec(this, _original, '#000000');
    /** @type {RgbaColor} */
    _classPrivateFieldInitSpec(this, _rgba, [0, 0, 0, 0]);
    _classPrivateFieldInitSpec(this, _checkIsHsl, void 0);
    _classPrivateFieldSet(_checkIsHsl, this, checkIsHsl);
    if (typeof input !== 'undefined' && input !== null) this.setColor(input);
  }
  /**
   * @param {ColorTypes} input - Any valid color (hex, rgb string, rgba string, hsl(a), css name, array or int).
   */
  return _createClass(TinyColorConverter, [{
    key: "setColor",
    value: function setColor(input) {
      _classPrivateFieldSet(_original, this, input);
      var isHsl = _classPrivateFieldGet(_checkIsHsl, this) && Array.isArray(input) && input[0] <= 360 && input[1] <= 100 && input[2] <= 100;
      _classPrivateFieldSet(_rgba, this, TinyColorConverter.parseInput(input, isHsl));
    }
    /**
     * Returns HSLA array.
     * @returns {HslaColor}
     */
  }, {
    key: "toHslaArray",
    value: function toHslaArray() {
      var _classPrivateFieldGet2 = _classPrivateFieldGet(_rgba, this),
        _classPrivateFieldGet3 = _slicedToArray(_classPrivateFieldGet2, 4),
        r = _classPrivateFieldGet3[0],
        g = _classPrivateFieldGet3[1],
        b = _classPrivateFieldGet3[2],
        a = _classPrivateFieldGet3[3];
      return TinyColorConverter.rgbaToHsla(r, g, b, a);
    }
    /**
     * Returns RGB string.
     * @returns {string}
     */
  }, {
    key: "toHslString",
    value: function toHslString() {
      var _classPrivateFieldGet4 = _classPrivateFieldGet(_rgba, this),
        _classPrivateFieldGet5 = _slicedToArray(_classPrivateFieldGet4, 3),
        r = _classPrivateFieldGet5[0],
        g = _classPrivateFieldGet5[1],
        b = _classPrivateFieldGet5[2];
      var _TinyColorConverter$r = TinyColorConverter.rgbaToHsl(r, g, b),
        _TinyColorConverter$r2 = _slicedToArray(_TinyColorConverter$r, 3),
        h = _TinyColorConverter$r2[0],
        s = _TinyColorConverter$r2[1],
        l = _TinyColorConverter$r2[2];
      return "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)");
    }
    /**
     * Returns RGBA string.
     * @returns {string}
     */
  }, {
    key: "toHslaString",
    value: function toHslaString() {
      var _classPrivateFieldGet6 = _classPrivateFieldGet(_rgba, this),
        _classPrivateFieldGet7 = _slicedToArray(_classPrivateFieldGet6, 4),
        r = _classPrivateFieldGet7[0],
        g = _classPrivateFieldGet7[1],
        b = _classPrivateFieldGet7[2],
        a = _classPrivateFieldGet7[3];
      var _TinyColorConverter$r3 = TinyColorConverter.rgbaToHsla(r, g, b, a),
        _TinyColorConverter$r4 = _slicedToArray(_TinyColorConverter$r3, 4),
        h = _TinyColorConverter$r4[0],
        s = _TinyColorConverter$r4[1],
        l = _TinyColorConverter$r4[2],
        a2 = _TinyColorConverter$r4[3];
      return "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(a2 !== null && a2 !== void 0 ? a2 : 1, ")");
    }
    /**
     * Returns RGBA array.
     * @returns {RgbaColor}
     */
  }, {
    key: "toRgbaArray",
    value: function toRgbaArray() {
      return _toConsumableArray(_classPrivateFieldGet(_rgba, this));
    }
    /**
     * Returns RGB string.
     * @returns {string}
     */
  }, {
    key: "toRgbString",
    value: function toRgbString() {
      var _classPrivateFieldGet8 = _classPrivateFieldGet(_rgba, this),
        _classPrivateFieldGet9 = _slicedToArray(_classPrivateFieldGet8, 3),
        r = _classPrivateFieldGet9[0],
        g = _classPrivateFieldGet9[1],
        b = _classPrivateFieldGet9[2];
      return "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")");
    }
    /**
     * Returns RGBA string.
     * @returns {string}
     */
  }, {
    key: "toRgbaString",
    value: function toRgbaString() {
      var _classPrivateFieldGet0 = _classPrivateFieldGet(_rgba, this),
        _classPrivateFieldGet1 = _slicedToArray(_classPrivateFieldGet0, 4),
        r = _classPrivateFieldGet1[0],
        g = _classPrivateFieldGet1[1],
        b = _classPrivateFieldGet1[2],
        a = _classPrivateFieldGet1[3];
      return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a !== null && a !== void 0 ? a : 1, ")");
    }
    /**
     * Returns hex color.
     * @returns {HexColor}
     */
  }, {
    key: "toHex",
    value: function toHex() {
      var _classPrivateFieldGet10 = _classPrivateFieldGet(_rgba, this),
        _classPrivateFieldGet11 = _slicedToArray(_classPrivateFieldGet10, 3),
        r = _classPrivateFieldGet11[0],
        g = _classPrivateFieldGet11[1],
        b = _classPrivateFieldGet11[2];
      return TinyColorConverter.rgbToHex(r, g, b);
    }
    /**
     * Returns color as integer.
     * @returns {number}
     */
  }, {
    key: "toInt",
    value: function toInt() {
      var _classPrivateFieldGet12 = _classPrivateFieldGet(_rgba, this),
        _classPrivateFieldGet13 = _slicedToArray(_classPrivateFieldGet12, 3),
        r = _classPrivateFieldGet13[0],
        g = _classPrivateFieldGet13[1],
        b = _classPrivateFieldGet13[2];
      return TinyColorConverter.rgbToInt(r, g, b);
    }
    /**
     * Returns the original input.
     * @returns {ColorTypes}
     */
  }, {
    key: "getOriginal",
    value: function getOriginal() {
      return _classPrivateFieldGet(_original, this);
    }
  }], [{
    key: "_rca",
    value:
    /**
     * Generates a smooth gradient of colors based on sine wave patterns.
     *
     * @see {@link https://www.npmjs.com/package/rainbow-colors-array} Code Reference
     * @param {number} [len=24] - The number of colors to generate.
     * @param {'rgb'|'hex'|'hsl'} [type='rgb'] - The format of the colors returned: `'rgb'`, `'hex'`, or `'hsl'`.
     * @param {boolean} [pastel=false] - If true, generates pastel tones by adjusting the intensity and offset.
     * @returns {Array<RgbResult|HexResult|HslResult>} An array of color values in the selected format:
     */
    function _rca(len, type, pastel) {
      var eq1 = 127;
      var eq2 = 128;
      if (len === undefined) {
        len = 24;
      }
      if (type === undefined) {
        type = 'rgb';
      }
      if (pastel === true) {
        eq1 = 55;
        eq2 = 200;
      }
      var frequency = Math.PI * 2 / len;
      var cvparr = [];
      for (var i = 0; i < len; ++i) {
        var red = Math.sin(frequency * i + 2) * eq1 + eq2;
        var green = Math.sin(frequency * i + 0) * eq1 + eq2;
        var blue = Math.sin(frequency * i + 4) * eq1 + eq2;
        switch (type) {
          case 'hex':
            cvparr.push({
              hex: this.rgbToHex(Math.round(red), Math.round(green), Math.round(blue))
            });
            break;
          case 'rgb':
            cvparr.push({
              r: red,
              g: green,
              b: blue
            });
            break;
          case 'hsl':
            var _this$rgbaToHsl = this.rgbaToHsl(Math.round(red), Math.round(green), Math.round(blue)),
              _this$rgbaToHsl2 = _slicedToArray(_this$rgbaToHsl, 3),
              h = _this$rgbaToHsl2[0],
              s = _this$rgbaToHsl2[1],
              l = _this$rgbaToHsl2[2];
            cvparr.push({
              h: h,
              s: s,
              l: l
            });
            break;
        }
      }
      return cvparr;
    }
    /**
     * Generates a smooth gradient of colors based on sine wave patterns.
     *
     * @param {number} [len=24] - The number of colors to generate.
     * @param {boolean} [pastel=false] - If true, generates pastel tones by adjusting the intensity and offset.
     * @returns {RgbResult[]} An array of rgb color values.
     */
  }, {
    key: "rcaRgb",
    value: function rcaRgb(len, pastel) {
      return /** @type {RgbResult[]} */TinyColorConverter._rca(len, 'rgb', pastel);
    }
    /**
     * Generates a smooth gradient of colors based on sine wave patterns.
     *
     * @param {number} [len=24] - The number of colors to generate.
     * @param {boolean} [pastel=false] - If true, generates pastel tones by adjusting the intensity and offset.
     * @returns {HslResult[]} An array of hsl color values.
     */
  }, {
    key: "rcaHsl",
    value: function rcaHsl(len, pastel) {
      return /** @type {HslResult[]} */TinyColorConverter._rca(len, 'hsl', pastel);
    }
    /**
     * Generates a smooth gradient of colors based on sine wave patterns.
     *
     * @param {number} [len=24] - The number of colors to generate.
     * @param {boolean} [pastel=false] - If true, generates pastel tones by adjusting the intensity and offset.
     * @returns {HexResult[]} An array of hex color values.
     */
  }, {
    key: "rcaHex",
    value: function rcaHex(len, pastel) {
      return /** @type {HexResult[]} */TinyColorConverter._rca(len, 'hex', pastel);
    }
    /**
     * Generates a random color in hexadecimal format.
     *
     * @returns {HexColor} A hex color string (e.g. `#a3e5f2`).
     */
  }, {
    key: "randomColor",
    value: function randomColor() {
      var hex = Math.floor(Math.random() * 0x1000000).toString(16);
      return "#".concat(hex.padStart(6, '0'));
    }
    /**
     * Parses input into RGBA array.
     * @param {ColorTypes} input
     * @param {boolean} isHsl
     * @returns {RgbaColor}
     */
  }, {
    key: "parseInput",
    value: function parseInput(input, isHsl) {
      if (typeof input === 'string') {
        input = input.trim().toLowerCase();
        if (input.startsWith('#')) return this.hexToRgba(input);
        if (input.startsWith('rgb')) return this.rgbStringToRgbaArray(input);
        if (input.startsWith('hsl')) return this.hslStringToRgbaArray(input);
      }
      if (typeof input === 'number') return this.intToRgba(input);
      if (Array.isArray(input) && (input.length === 3 || input.length === 4) && input.every(function (item) {
        return typeof item === 'number';
      })) {
        if (isHsl) {
          var _input = input,
            _input2 = _slicedToArray(_input, 4),
            h = _input2[0],
            s = _input2[1],
            l = _input2[2],
            a2 = _input2[3];
          if (h <= 360 && s <= 100 && l <= 100) return this.hslToRgba(h, s, l, a2);
        }
        return [].concat(_toConsumableArray(input), [1]).slice(0, 4);
      }
      throw new Error('Unsupported color format.');
    }
    // HSL Color
    /**
     * Converts hsl to integer.
     * @param {number} h - Hue (0â360)
     * @param {number} s - Saturation (0â100)
     * @param {number} l - Lightness (0â100)
     * @returns {number}
     */
  }, {
    key: "hslToInt",
    value: function hslToInt(h, s, l) {
      var _TinyColorConverter$h = TinyColorConverter.hslToRgba(h, s, l),
        _TinyColorConverter$h2 = _slicedToArray(_TinyColorConverter$h, 3),
        r = _TinyColorConverter$h2[0],
        g = _TinyColorConverter$h2[1],
        b = _TinyColorConverter$h2[2];
      return TinyColorConverter.rgbToInt(r, g, b);
    }
    /**
     * Converts hsl to hex.
     * @param {number} h - Hue (0â360)
     * @param {number} s - Saturation (0â100)
     * @param {number} l - Lightness (0â100)
     * @returns {HexColor}
     */
  }, {
    key: "hslToHex",
    value: function hslToHex(h, s, l) {
      var _TinyColorConverter$h3 = TinyColorConverter.hslToRgba(h, s, l),
        _TinyColorConverter$h4 = _slicedToArray(_TinyColorConverter$h3, 3),
        r = _TinyColorConverter$h4[0],
        g = _TinyColorConverter$h4[1],
        b = _TinyColorConverter$h4[2];
      return TinyColorConverter.rgbToHex(r, g, b);
    }
    /**
     * Converts hsl(a) string to RGBA array.
     * @param {string} hsl
     * @returns {RgbaColor}
     */
  }, {
    key: "hslStringToRgbaArray",
    value: function hslStringToRgbaArray(hsl) {
      var _hsl$match;
      var match = (_hsl$match = hsl.match(/[\d.]+/g)) === null || _hsl$match === void 0 ? void 0 : _hsl$match.map(Number);
      if (!match || match.length < 3) return [0, 0, 0, 1];
      var _match = _slicedToArray(match, 4),
        h = _match[0],
        s = _match[1],
        l = _match[2],
        _match$ = _match[3],
        a = _match$ === void 0 ? 1 : _match$;
      return this.hslToRgba(h, s, l, a);
    }
    /**
     * Converts HSL or HSLA to RGBA.
     * @param {number} h - Hue (0â360)
     * @param {number} s - Saturation (0â100)
     * @param {number} l - Lightness (0â100)
     * @param {number} [a=1] - Alpha (0â1)
     * @returns {RgbaColor}
     */
  }, {
    key: "hslToRgba",
    value: function hslToRgba(h, s, l) {
      var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      s /= 100;
      l /= 100;
      /** @type {(n: number) => number} */
      var k = function k(n) {
        return (n + h / 30) % 12;
      };
      var a_ = s * Math.min(l, 1 - l);
      /** @type {(n: number) => number} */
      var f = function f(n) {
        return l - a_ * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
      };
      return [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255), a];
    }
    /**
     * Converts HSL or HSLA to RGB.
     * @param {number} h - Hue (0â360)
     * @param {number} s - Saturation (0â100)
     * @param {number} l - Lightness (0â100)
     * @param {number} [a=1] - Alpha (0â1)
     * @returns {RgbColor}
     */
  }, {
    key: "hslToRgb",
    value: function hslToRgb(h, s, l) {
      var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      return TinyColorConverter.hslToRgba(h, s, l, a).slice(0, 3);
    }
    // Hex Color
    /**
     * Converts hex to integer.
     * @param {HexColor} hex
     * @returns {number}
     */
  }, {
    key: "hexToInt",
    value: function hexToInt(hex) {
      return parseInt(hex.replace(/^#/, ''), 16);
    }
    /**
     * Converts hex string to HSL array.
     * @param {HexColor} hex
     * @returns {HslColor}
     */
  }, {
    key: "hexToHsl",
    value: function hexToHsl(hex) {
      var _TinyColorConverter$h5 = TinyColorConverter.hexToRgba(hex),
        _TinyColorConverter$h6 = _slicedToArray(_TinyColorConverter$h5, 4),
        r = _TinyColorConverter$h6[0],
        g = _TinyColorConverter$h6[1],
        b = _TinyColorConverter$h6[2],
        a = _TinyColorConverter$h6[3];
      return TinyColorConverter.rgbaToHsl(r, g, b, a);
    }
    /**
     * Converts hex string to HSL array.
     * @param {HexColor} hex
     * @returns {HslaColor}
     */
  }, {
    key: "hexToHsla",
    value: function hexToHsla(hex) {
      var _TinyColorConverter$h7 = TinyColorConverter.hexToRgba(hex),
        _TinyColorConverter$h8 = _slicedToArray(_TinyColorConverter$h7, 4),
        r = _TinyColorConverter$h8[0],
        g = _TinyColorConverter$h8[1],
        b = _TinyColorConverter$h8[2],
        a = _TinyColorConverter$h8[3];
      return TinyColorConverter.rgbaToHsla(r, g, b, a);
    }
    /**
     * Converts hex string to RGBA array.
     * @param {HexColor} hex
     * @returns {RgbaColor}
     */
  }, {
    key: "hexToRgba",
    value: function hexToRgba(hex) {
      hex = hex.replace(/^#/, '');
      if (hex.length === 3) hex = hex.split('').map(function (c) {
        return c + c;
      }).join('');
      var intVal = parseInt(hex, 16);
      var r = intVal >> 16 & 255;
      var g = intVal >> 8 & 255;
      var b = intVal & 255;
      return [r, g, b, 1];
    }
    /**
     * Converts HEX to RGB.
     * @param {HexColor} hex
     * @returns {RgbColor}
     */
  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      return this.hexToRgba(hex).slice(0, 3);
    }
    // RGBA Color
    /**
     * Converts RGB to HEX.
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @returns {HexColor}
     */
  }, {
    key: "rgbToHex",
    value: function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(function (v) {
        return v.toString(16).padStart(2, '0');
      }).join('');
    }
    /**
     * Converts RGB to integer.
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @returns {number}
     */
  }, {
    key: "rgbToInt",
    value: function rgbToInt(r, g, b) {
      return r << 16 | g << 8 | b;
    }
    /**
     * Converts RGBA to HSLA.
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} [a=1]
     * @returns {HslaColor}
     */
  }, {
    key: "rgbaToHsla",
    value: function rgbaToHsla(r, g, b) {
      var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      r /= 255;
      g /= 255;
      b /= 255;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h = 0,
        s = 0,
        l = (max + min) / 2;
      var d = max - min;
      if (d !== 0) {
        s = d / (1 - Math.abs(2 * l - 1));
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h *= 60;
      }
      return [Math.round(h), Math.round(s * 100), Math.round(l * 100), a];
    }
    /**
     * Converts RGBA to HSL.
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} [a=1]
     * @returns {HslColor}
     */
  }, {
    key: "rgbaToHsl",
    value: function rgbaToHsl(r, g, b, a) {
      return this.rgbaToHsla(r, g, b, a).slice(0, 3);
    }
    /**
     * Converts rgb(a) string to RGBA array.
     * @param {string} rgb
     * @returns {RgbaColor}
     */
  }, {
    key: "rgbStringToRgbaArray",
    value: function rgbStringToRgbaArray(rgb) {
      var _rgb$match;
      var match = (_rgb$match = rgb.match(/[\d.]+/g)) === null || _rgb$match === void 0 ? void 0 : _rgb$match.map(Number);
      if (!match) return [];
      return [].concat(_toConsumableArray(match), [1]).slice(0, 4);
    }
    // Integer Color
    /**
     * Converts integer color to HSL.
     * @param {number} int
     * @returns {HslColor}
     */
  }, {
    key: "intToHsl",
    value: function intToHsl(_int) {
      var _TinyColorConverter$i = TinyColorConverter.intToRgba(_int),
        _TinyColorConverter$i2 = _slicedToArray(_TinyColorConverter$i, 4),
        r = _TinyColorConverter$i2[0],
        g = _TinyColorConverter$i2[1],
        b = _TinyColorConverter$i2[2],
        a = _TinyColorConverter$i2[3];
      return TinyColorConverter.rgbaToHsl(r, g, b, a);
    }
    /**
     * Converts integer color to HSL.
     * @param {number} int
     * @returns {HslaColor}
     */
  }, {
    key: "intToHsla",
    value: function intToHsla(_int2) {
      var _TinyColorConverter$i3 = TinyColorConverter.intToRgba(_int2),
        _TinyColorConverter$i4 = _slicedToArray(_TinyColorConverter$i3, 4),
        r = _TinyColorConverter$i4[0],
        g = _TinyColorConverter$i4[1],
        b = _TinyColorConverter$i4[2],
        a = _TinyColorConverter$i4[3];
      return TinyColorConverter.rgbaToHsla(r, g, b, a);
    }
    /**
     * Converts integer color to hex.
     * @param {number} int
     * @returns {HexColor}
     */
  }, {
    key: "intToHex",
    value: function intToHex(_int3) {
      return '#' + _int3.toString(16).padStart(6, '0');
    }
    /**
     * Converts an integer (0xRRGGBB) to RGBA.
     * @param {number} value
     * @returns {RgbaColor}
     */
  }, {
    key: "intToRgba",
    value: function intToRgba(value) {
      var r = value >> 16 & 255;
      var g = value >> 8 & 255;
      var b = value & 255;
      return [r, g, b, 1];
    }
  }]);
}();
var _default = exports["default"] = TinyColorConverter;

},{}],186:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _handlers = /*#__PURE__*/new WeakMap();
var _isDomReady = /*#__PURE__*/new WeakMap();
var _isFullyReady = /*#__PURE__*/new WeakMap();
var _promises = /*#__PURE__*/new WeakMap();
var _TinyDomReadyManager_brand = /*#__PURE__*/new WeakSet();
/**
 * A basic function that performs a task when the system is ready.
 * Used for handlers in the readiness queue.
 *
 * @typedef {() => void} Fn
 */
/**
 * A function that determines whether a specific handler should be executed.
 * Should return `true` to allow execution, or `false` to skip the handler.
 *
 * @typedef {() => boolean} FnFilter
 */
/**
 * @typedef {Object} Handler
 * @property {Fn} fn - Function to execute when ready.
 * @property {boolean} once - Whether to execute only once.
 * @property {number} priority - Execution order (higher priority runs first).
 * @property {FnFilter|null} filter - Optional filter function to determine execution.
 * @property {boolean} domOnly - Whether to run as soon as DOM is ready (before full readiness).
 */
var TinyDomReadyManager = /*#__PURE__*/function () {
  function TinyDomReadyManager() {
    _classCallCheck(this, TinyDomReadyManager);
    /**
     * Checks if the DOM is ready and if all Promises have been resolved.
     */
    _classPrivateMethodInitSpec(this, _TinyDomReadyManager_brand);
    /** @type {Handler[]} */
    _classPrivateFieldInitSpec(this, _handlers, []);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _isDomReady, false);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _isFullyReady, false);
    /** @type {Promise<any>[]} */
    _classPrivateFieldInitSpec(this, _promises, []);
  }
  return _createClass(TinyDomReadyManager, [{
    key: "_markDomReady",
    value:
    /**
     * Marks the system as DOM-ready and runs DOM-only handlers.
     * @private
     */
    function _markDomReady() {
      _classPrivateFieldSet(_isDomReady, this, true);
      _assertClassBrand(_TinyDomReadyManager_brand, this, _runHandlers).call(this, true); // Run domOnly
      _assertClassBrand(_TinyDomReadyManager_brand, this, _checkAllReady).call(this); // Then check for full readiness
    }
    /**
     * Initializes the manager using `DOMContentLoaded`.
     */
  }, {
    key: "init",
    value: function init() {
      var _this = this;
      if (_classPrivateFieldGet(_isDomReady, this)) throw new Error('[TinyDomReadyManager] init() has already been called.');
      if (document.readyState === 'interactive' || document.readyState === 'complete') {
        this._markDomReady();
      } else {
        document.addEventListener('DOMContentLoaded', function () {
          return _this._markDomReady();
        });
      }
    }
    /**
     * Adds a Promise to delay full readiness.
     * @param {Promise<any>} promise
     * @throws {TypeError}
     */
  }, {
    key: "addPromise",
    value: function addPromise(promise) {
      if (!(promise instanceof Promise)) throw new TypeError('[TinyDomReadyManager] promise must be a valid Promise.');
      if (_classPrivateFieldGet(_isFullyReady, this)) return;
      _classPrivateFieldGet(_promises, this).push(promise);
      if (_classPrivateFieldGet(_isDomReady, this)) _assertClassBrand(_TinyDomReadyManager_brand, this, _checkAllReady).call(this);
    }
    /**
     * Registers a handler to run either after DOM is ready or after full readiness.
     *
     * @param {Fn} fn - Function to execute.
     * @param {Object} [options]
     * @param {boolean} [options.once=true] - Execute only once.
     * @param {number} [options.priority=0] - Higher priority runs first.
     * @param {FnFilter|null} [options.filter=null] - Optional filter function.
     * @param {boolean} [options.domOnly=false] - If true, executes after DOM ready only.
     * @throws {TypeError} If fn is not a function.
     */
  }, {
    key: "onReady",
    value: function onReady(fn) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$once = _ref.once,
        once = _ref$once === void 0 ? true : _ref$once,
        _ref$priority = _ref.priority,
        priority = _ref$priority === void 0 ? 0 : _ref$priority,
        _ref$filter = _ref.filter,
        filter = _ref$filter === void 0 ? null : _ref$filter,
        _ref$domOnly = _ref.domOnly,
        domOnly = _ref$domOnly === void 0 ? false : _ref$domOnly;
      if (typeof fn !== 'function') throw new TypeError('[TinyDomReadyManager] fn must be a function.');
      var handler = {
        fn: fn,
        once: once,
        priority: priority,
        filter: filter,
        domOnly: domOnly
      };
      if (domOnly && _classPrivateFieldGet(_isDomReady, this)) {
        _assertClassBrand(_TinyDomReadyManager_brand, this, _invokeHandler).call(this, handler);
        if (!once) _classPrivateFieldGet(_handlers, this).push(handler);
        return;
      }
      if (!domOnly && _classPrivateFieldGet(_isFullyReady, this)) {
        _assertClassBrand(_TinyDomReadyManager_brand, this, _invokeHandler).call(this, handler);
      } else {
        _classPrivateFieldGet(_handlers, this).push(handler);
      }
    }
    /**
     * Returns whether the system is fully ready (DOM + Promises).
     * @returns {boolean}
     */
  }, {
    key: "isReady",
    value: function isReady() {
      return _classPrivateFieldGet(_isFullyReady, this);
    }
    /**
     * Returns whether the DOM is ready (DOMContentLoaded has fired).
     * Does not wait for promises.
     * @returns {boolean}
     */
  }, {
    key: "isDomReady",
    value: function isDomReady() {
      return _classPrivateFieldGet(_isDomReady, this);
    }
  }]);
}();
function _checkAllReady() {
  var _this2 = this;
  if (_classPrivateFieldGet(_isDomReady, this)) {
    Promise.all(_classPrivateFieldGet(_promises, this)).then(function () {
      _classPrivateFieldSet(_isFullyReady, _this2, true);
      _assertClassBrand(_TinyDomReadyManager_brand, _this2, _runHandlers).call(_this2, false); // run non-domOnly
    })["catch"](function (err) {
      console.error('[TinyDomReadyManager] Promise rejected:', err);
    });
  }
}
/**
 * Executes handlers by filtering them by `domOnly` flag and sorting by priority.
 * @param {boolean} domOnlyOnly - Whether to run only `domOnly` handlers.
 */
function _runHandlers(domOnlyOnly) {
  var _this3 = this;
  _classPrivateFieldGet(_handlers, this).filter(function (h) {
    return h.domOnly === domOnlyOnly;
  }).sort(function (a, b) {
    return b.priority - a.priority;
  }).forEach(function (handler) {
    return _assertClassBrand(_TinyDomReadyManager_brand, _this3, _invokeHandler).call(_this3, handler);
  });
  _classPrivateFieldSet(_handlers, this, _classPrivateFieldGet(_handlers, this).filter(function (h) {
    return !(h.once && (domOnlyOnly ? h.domOnly : true));
  }));
}
/**
 * Executes a handler if its filter passes.
 * @param {Handler} handler
 */
function _invokeHandler(handler) {
  if (typeof handler.filter === 'function') {
    try {
      if (!handler.filter()) return;
    } catch (err) {
      console.warn('[TinyDomReadyManager] Filter error:', err);
      return;
    }
  }
  try {
    handler.fn();
  } catch (err) {
    console.error('[TinyDomReadyManager] Handler error:', err);
  }
}
var _default = exports["default"] = TinyDomReadyManager;

},{}],187:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _target = /*#__PURE__*/new WeakMap();
var _fullscreen = /*#__PURE__*/new WeakMap();
var _hoverClass = /*#__PURE__*/new WeakMap();
var _onDropCallback = /*#__PURE__*/new WeakMap();
var _onEnterCallback = /*#__PURE__*/new WeakMap();
var _onLeaveCallback = /*#__PURE__*/new WeakMap();
var _isDragging = /*#__PURE__*/new WeakMap();
var _bound = /*#__PURE__*/new WeakMap();
var _TinyDragDropDetector_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {Object} DragAndDropOptions
 * @property {HTMLElement} [target=document.body] - The DOM element where drag listeners will be attached. Defaults to `document.body` if `fullscreen` is true or no target is provided.
 * @property {boolean} [fullscreen=true] - If true, listeners are attached to the entire page (`document.body`). If false, the `target` must be specified.
 * @property {string} [hoverClass="dnd-hover"] - CSS class applied to the target element while files are being dragged over it.
 * @property {(files: FileList, event: DragEvent) => void} [onDrop] - Callback function executed when files are dropped onto the target.
 * @property {(event: DragEvent) => void} [onEnter] - Optional callback triggered when dragging enters the target area.
 * @property {(event: DragEvent) => void} [onLeave] - Optional callback triggered when dragging leaves the target area.
 */
/**
 * TinyDragDropDetector
 *
 * A lightweight utility to detect drag-and-drop file operations on a specific DOM element or the entire page.
 * It handles the drag lifecycle (enter, over, leave, drop) and provides hooks for developers to handle file uploads or UI changes.
 *
 * @class
 */
var TinyDragDropDetector = /*#__PURE__*/function () {
  /**
   * Creates a new instance of TinyDragDropDetector to handle drag-and-drop file detection.
   *
   * @param {DragAndDropOptions} [options={}] - Configuration options for the detector.
   * @throws {TypeError} If `target` is not an HTMLElement.
   * @throws {TypeError} If `fullscreen` is not a boolean.
   * @throws {TypeError} If `hoverClass` is not a string.
   * @throws {TypeError} If `onDrop` is defined but not a function.
   * @throws {TypeError} If `onEnter` is defined but not a function.
   * @throws {TypeError} If `onLeave` is defined but not a function.
   */
  function TinyDragDropDetector() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, TinyDragDropDetector);
    /**
     * Binds the drag-and-drop event listeners to the target element.
     * Automatically called on instantiation.
     * @returns {void}
     */
    _classPrivateMethodInitSpec(this, _TinyDragDropDetector_brand);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _target, void 0);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _fullscreen, void 0);
    /** @type {string} */
    _classPrivateFieldInitSpec(this, _hoverClass, void 0);
    /** @type {(files: FileList, event: DragEvent) => void} */
    _classPrivateFieldInitSpec(this, _onDropCallback, void 0);
    /** @type {(event: DragEvent) => void} */
    _classPrivateFieldInitSpec(this, _onEnterCallback, void 0);
    /** @type {(event: DragEvent) => void} */
    _classPrivateFieldInitSpec(this, _onLeaveCallback, void 0);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _isDragging, void 0);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _bound, void 0);
    var _target2 = options.target,
      _options$fullscreen = options.fullscreen,
      fullscreen = _options$fullscreen === void 0 ? true : _options$fullscreen,
      _options$hoverClass = options.hoverClass,
      hoverClass = _options$hoverClass === void 0 ? 'dnd-hover' : _options$hoverClass,
      onDrop = options.onDrop,
      onEnter = options.onEnter,
      onLeave = options.onLeave;
    // Validate fullscreen
    if (typeof fullscreen !== 'boolean') throw new TypeError('The "fullscreen" option must be a boolean.');
    // Validate target
    var resolvedTarget = fullscreen ? document.body : _target2 || document.body;
    if (!(resolvedTarget instanceof HTMLElement)) throw new TypeError('The "target" option must be an instance of HTMLElement.');
    // Validate hoverClass
    if (typeof hoverClass !== 'string') throw new TypeError('The "hoverClass" option must be a string.');
    // Validate onDrop
    if (typeof onDrop !== 'function') throw new TypeError('The "onDrop" option must be a function.');
    // Validate onEnter
    if (typeof onEnter !== 'function') throw new TypeError('The "onEnter" option must be a function.');
    // Validate onLeave
    if (typeof onLeave !== 'function') throw new TypeError('The "onLeave" option must be a function.');
    // Store properties
    _classPrivateFieldSet(_target, this, resolvedTarget);
    _classPrivateFieldSet(_fullscreen, this, fullscreen);
    _classPrivateFieldSet(_hoverClass, this, hoverClass);
    _classPrivateFieldSet(_onDropCallback, this, onDrop || function () {});
    _classPrivateFieldSet(_onEnterCallback, this, onEnter);
    _classPrivateFieldSet(_onLeaveCallback, this, onLeave);
    _classPrivateFieldSet(_isDragging, this, false);
    _classPrivateFieldSet(_bound, this, false);
    // Bind event handlers
    this._handleDragEnter = this._handleDragEnter.bind(this);
    this._handleDragOver = this._handleDragOver.bind(this);
    this._handleDragLeave = this._handleDragLeave.bind(this);
    this._handleDrop = this._handleDrop.bind(this);
    _assertClassBrand(_TinyDragDropDetector_brand, this, _bindEvents).call(this);
  }
  /**
   * Returns the current target DOM element where the listeners are attached.
   * @returns {HTMLElement}
   */
  return _createClass(TinyDragDropDetector, [{
    key: "getTarget",
    value: function getTarget() {
      return _classPrivateFieldGet(_target, this);
    }
    /**
     * Returns the CSS class applied during drag hover.
     * @returns {string}
     */
  }, {
    key: "getHoverClass",
    value: function getHoverClass() {
      return _classPrivateFieldGet(_hoverClass, this);
    }
    /**
     * Indicates whether the detector is operating in fullscreen mode.
     * @returns {boolean}
     */
  }, {
    key: "isFullScreen",
    value: function isFullScreen() {
      return _classPrivateFieldGet(_fullscreen, this);
    }
    /**
     * Returns whether a drag operation is currently active over the target.
     * @returns {boolean}
     */
  }, {
    key: "isDragging",
    value: function isDragging() {
      return _classPrivateFieldGet(_isDragging, this);
    }
    /**
     * Returns whether the event listeners are currently bound to the target.
     * @returns {boolean}
     */
  }, {
    key: "bound",
    value: function bound() {
      return _classPrivateFieldGet(_bound, this);
    }
  }, {
    key: "_handleDragEnter",
    value:
    /**
     * Handles the `dragenter` event.
     * Adds the hover CSS class and triggers the `onEnter` callback if provided.
     * @private
     * @param {DragEvent} event - The dragenter event.
     * @returns {void}
     */
    function _handleDragEnter(event) {
      event.preventDefault();
      if (!_classPrivateFieldGet(_isDragging, this)) {
        var target = this.getTarget();
        _classPrivateFieldSet(_isDragging, this, true);
        target.classList.add(_classPrivateFieldGet(_hoverClass, this));
        _classPrivateFieldGet(_onEnterCallback, this).call(this, event);
      }
    }
    /**
     * Handles the `dragover` event.
     * Prevents default to allow drop and sets the drop effect.
     * @private
     * @param {DragEvent} event - The dragover event.
     * @returns {void}
     */
  }, {
    key: "_handleDragOver",
    value: function _handleDragOver(event) {
      event.preventDefault(); // Required to allow drop
      if (!event.dataTransfer) {
        console.warn('[TinyDragDropDetector] [handleDragOver] DragOver event missing dataTransfer.');
        return;
      }
      event.dataTransfer.dropEffect = 'copy';
    }
    /**
     * Handles the `dragleave` event.
     * Removes the hover class and triggers the `onLeave` callback if provided.
     * @private
     * @param {DragEvent} event - The dragleave event.
     * @returns {void}
     */
  }, {
    key: "_handleDragLeave",
    value: function _handleDragLeave(event) {
      event.preventDefault();
      var target = this.getTarget();
      // Check if you've completely left the area
      // @ts-ignore
      if (event.relatedTarget === null || !target.contains(event.relatedTarget)) {
        _classPrivateFieldSet(_isDragging, this, false);
        target.classList.remove(_classPrivateFieldGet(_hoverClass, this));
        _classPrivateFieldGet(_onLeaveCallback, this).call(this, event);
      }
    }
    /**
     * Handles the `drop` event.
     * Removes the hover class, resets dragging state, and triggers the `onDrop` callback.
     * @private
     * @param {DragEvent} event - The drop event.
     * @returns {void}
     */
  }, {
    key: "_handleDrop",
    value: function _handleDrop(event) {
      event.preventDefault();
      if (!event.dataTransfer) {
        console.warn('[TinyDragDropDetector] [handleDrop] DragOver event missing dataTransfer.');
        return;
      }
      var target = this.getTarget();
      _classPrivateFieldSet(_isDragging, this, false);
      target.classList.remove(_classPrivateFieldGet(_hoverClass, this));
      var files = event.dataTransfer.files;
      if (files.length > 0) {
        _classPrivateFieldGet(_onDropCallback, this).call(this, files, event);
      }
    }
    /**
     * Destroys the detector instance, unbinding all event listeners and cleaning up.
     * Should be called when the detector is no longer needed to avoid memory leaks.
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _assertClassBrand(_TinyDragDropDetector_brand, this, _unbindEvents).call(this);
      var target = this.getTarget();
      target.classList.remove(_classPrivateFieldGet(_hoverClass, this));
    }
  }]);
}();
function _bindEvents() {
  if (_classPrivateFieldGet(_bound, this)) return;
  var target = this.getTarget();
  target.addEventListener('dragenter', this._handleDragEnter);
  target.addEventListener('dragover', this._handleDragOver);
  target.addEventListener('dragleave', this._handleDragLeave);
  target.addEventListener('drop', this._handleDrop);
  _classPrivateFieldSet(_bound, this, true);
}
/**
 * Removes all previously attached drag-and-drop event listeners from the target.
 * @returns {void}
 */
function _unbindEvents() {
  if (!_classPrivateFieldGet(_bound, this)) return;
  var target = this.getTarget();
  target.removeEventListener('dragenter', this._handleDragEnter);
  target.removeEventListener('dragover', this._handleDragOver);
  target.removeEventListener('dragleave', this._handleDragLeave);
  target.removeEventListener('drop', this._handleDrop);
  _classPrivateFieldSet(_bound, this, false);
}
var _default = exports["default"] = TinyDragDropDetector;

},{}],188:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _TinyHtml = _interopRequireDefault(require("./TinyHtml.mjs"));
var TinyCollision = _interopRequireWildcard(require("../basics/collision.mjs"));
var _objChecker = require("../basics/objChecker.mjs");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @typedef {Object} VibrationPatterns
 * @property {number[]|false} start - Pattern to vibrate on start
 * @property {number[]|false} end - Pattern to vibrate on end
 * @property {number[]|false} collide - Pattern to vibrate on collision
 * @property {number[]|false} move - Pattern to vibrate while moving
 */
/**
 * TinyDragger enables drag-and-drop functionality for a DOM element.
 * It supports jail boundaries, optional collision detection, vibration feedback,
 * automatic reverting, proxy dragging, and event dispatching.
 */
var _enabled = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _offsetY = /*#__PURE__*/new WeakMap();
var _offsetX = /*#__PURE__*/new WeakMap();
var _mirrorElem = /*#__PURE__*/new WeakMap();
var _multiCollision = /*#__PURE__*/new WeakMap();
var _lockInsideJail = /*#__PURE__*/new WeakMap();
var _revertOnDrop = /*#__PURE__*/new WeakMap();
var _dragging = /*#__PURE__*/new WeakMap();
var _collisionByMouse = /*#__PURE__*/new WeakMap();
var _dropInJailOnly = /*#__PURE__*/new WeakMap();
var _lastCollision = /*#__PURE__*/new WeakMap();
var _collidables = /*#__PURE__*/new WeakMap();
var _dragProxy = /*#__PURE__*/new WeakMap();
var _vibration = /*#__PURE__*/new WeakMap();
var _jail = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _dragHiddenClass = /*#__PURE__*/new WeakMap();
var _classDragging = /*#__PURE__*/new WeakMap();
var _classBodyDragging = /*#__PURE__*/new WeakMap();
var _classJailDragging = /*#__PURE__*/new WeakMap();
var _classJailDragDisabled = /*#__PURE__*/new WeakMap();
var _classDragCollision = /*#__PURE__*/new WeakMap();
var _defaultZIndex = /*#__PURE__*/new WeakMap();
var _TinyDragger_brand = /*#__PURE__*/new WeakSet();
var _collisionsMarked = /*#__PURE__*/new WeakMap();
var TinyDragger = /*#__PURE__*/function () {
  /** @typedef {(event: TouchEvent) => void} TouchDragEvent */
  /**
   * @param {HTMLElement|TinyHtml} targetElement - The element to make draggable.
   * @param {Object} [options={}] - Configuration options.
   * @param {HTMLElement} [options.jail] - Optional container to restrict dragging within.
   * @param {boolean} [options.mirrorElem=true] - Use a visual clone instead of dragging the original element.
   * @param {number} [options.defaultZIndex] - Sets the z-index value applied when dragging starts.
   * @param {boolean} [options.collisionByMouse=false] - Use mouse position for collision instead of element rect.
   * @param {string} [options.classDragging='dragging'] - CSS class applied to the clone during dragging.
   * @param {string} [options.classBodyDragging='drag-active'] - CSS class applied to <body> during dragging.
   * @param {string} [options.classJailDragging='jail-drag-active'] - CSS class applied to jail element during drag.
   * @param {string} [options.classJailDragDisabled='jail-drag-disabled'] - CSS class applied to jail element disabled.
   * @param {string} [options.classDragCollision='dragging-collision'] - CSS class applied to collision element.
   * @param {boolean} [options.lockInsideJail=false] - Restrict movement within the jail container.
   * @param {boolean} [options.dropInJailOnly=false] - Restrict drop within the jail container.
   * @param {boolean} [options.multiCollision=false] - Enables returning multiple collided elements.
   * @param {VibrationPatterns|false} [options.vibration=false] - Vibration feedback configuration.
   * @param {boolean} [options.revertOnDrop=false] - Whether to return to original position on drop.
   * @param {string} [options.classHidden='drag-hidden'] - CSS class to hide original element during dragging.
   * @throws {Error} If any option has an invalid type.
   */
  function TinyDragger(targetElement) {
    var _this = this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, TinyDragger);
    /**
     * Handles the start of a drag event.
     * @param {MouseEvent|Touch} event - The initiating event.
     */
    _classPrivateMethodInitSpec(this, _TinyDragger_brand);
    _classPrivateFieldInitSpec(this, _enabled, true);
    _classPrivateFieldInitSpec(this, _destroyed, false);
    _classPrivateFieldInitSpec(this, _offsetY, 0);
    _classPrivateFieldInitSpec(this, _offsetX, 0);
    _classPrivateFieldInitSpec(this, _mirrorElem, true);
    _classPrivateFieldInitSpec(this, _multiCollision, false);
    _classPrivateFieldInitSpec(this, _lockInsideJail, false);
    _classPrivateFieldInitSpec(this, _revertOnDrop, false);
    _classPrivateFieldInitSpec(this, _dragging, false);
    _classPrivateFieldInitSpec(this, _collisionByMouse, false);
    _classPrivateFieldInitSpec(this, _dropInJailOnly, false);
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _lastCollision, null);
    /** @type {HTMLElement[]} */
    _classPrivateFieldInitSpec(this, _collidables, []);
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _dragProxy, null);
    /** @type {VibrationPatterns} */
    _classPrivateFieldInitSpec(this, _vibration, {
      start: false,
      end: false,
      collide: false,
      move: false
    });
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _jail, null);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _target, void 0);
    _classPrivateFieldInitSpec(this, _dragHiddenClass, 'drag-hidden');
    _classPrivateFieldInitSpec(this, _classDragging, 'dragging');
    _classPrivateFieldInitSpec(this, _classBodyDragging, 'drag-active');
    _classPrivateFieldInitSpec(this, _classJailDragging, 'jail-drag-active');
    _classPrivateFieldInitSpec(this, _classJailDragDisabled, 'jail-drag-disabled');
    _classPrivateFieldInitSpec(this, _classDragCollision, 'dragging-collision');
    _classPrivateFieldInitSpec(this, _defaultZIndex, 9999);
    /** @type {HTMLElement[]} */
    _classPrivateFieldInitSpec(this, _collisionsMarked, []);
    var targetElem = !(targetElement instanceof _TinyHtml["default"]) ? targetElement : targetElement.get(0);
    if (!(targetElem instanceof HTMLElement)) throw new Error('TinyDragger requires a valid target HTMLElement to initialize.');
    _classPrivateFieldSet(_target, this, targetElem);
    // === Validations ===
    if (options.jail !== undefined && !(options.jail instanceof HTMLElement)) throw new Error('The "jail" option must be an HTMLElement if provided.');
    if (options.defaultZIndex !== undefined) this.setDefaultZIndex(options.defaultZIndex);
    if (options.vibration !== undefined && options.vibration !== false && !(0, _objChecker.isJsonObject)(options.vibration)) throw new Error('The "vibration" option must be an object or false.');
    /**
     * @param {any} val
     * @param {string} name
     */
    var validateBoolean = function validateBoolean(val, name) {
      if (val !== undefined && typeof val !== 'boolean') {
        throw new Error("The \"".concat(name, "\" option must be a boolean."));
      }
    };
    /**
     * @param {any} val
     * @param {string} name
     */
    var validateString = function validateString(val, name) {
      if (val !== undefined && typeof val !== 'string') {
        throw new Error("The \"".concat(name, "\" option must be a string."));
      }
    };
    validateBoolean(options.mirrorElem, 'mirrorElem');
    validateBoolean(options.collisionByMouse, 'collisionByMouse');
    validateBoolean(options.lockInsideJail, 'lockInsideJail');
    validateBoolean(options.dropInJailOnly, 'dropInJailOnly');
    validateBoolean(options.revertOnDrop, 'revertOnDrop');
    validateBoolean(options.multiCollision, 'multiCollision');
    validateString(options.classDragging, 'classDragging');
    validateString(options.classBodyDragging, 'classBodyDragging');
    validateString(options.classJailDragging, 'classJailDragging');
    validateString(options.classJailDragDisabled, 'classJailDragDisabled');
    validateString(options.classDragCollision, 'classDragCollision');
    validateString(options.classHidden, 'classHidden');
    if (options.jail instanceof HTMLElement) _classPrivateFieldSet(_jail, this, options.jail);
    /** @type {VibrationPatterns} */
    var vibrationTemplate = {
      start: false,
      end: false,
      collide: false,
      move: false
    };
    _classPrivateFieldSet(_vibration, this, Object.assign(vibrationTemplate, (0, _objChecker.isJsonObject)(options.vibration) ? options.vibration : {}));
    if (typeof options.classDragging === 'string') _classPrivateFieldSet(_classDragging, this, options.classDragging);
    if (typeof options.classBodyDragging === 'string') _classPrivateFieldSet(_classBodyDragging, this, options.classBodyDragging);
    if (typeof options.classJailDragging === 'string') _classPrivateFieldSet(_classJailDragging, this, options.classJailDragging);
    if (typeof options.classJailDragDisabled === 'string') _classPrivateFieldSet(_classJailDragDisabled, this, options.classJailDragDisabled);
    if (typeof options.classHidden === 'string') _classPrivateFieldSet(_dragHiddenClass, this, options.classHidden);
    if (typeof options.classDragCollision === 'string') _classPrivateFieldSet(_classDragCollision, this, options.classDragCollision);
    if (typeof options.collisionByMouse === 'boolean') _classPrivateFieldSet(_collisionByMouse, this, options.collisionByMouse);
    if (typeof options.mirrorElem === 'boolean') _classPrivateFieldSet(_mirrorElem, this, options.mirrorElem);
    if (typeof options.revertOnDrop === 'boolean') _classPrivateFieldSet(_revertOnDrop, this, options.revertOnDrop);
    if (typeof options.lockInsideJail === 'boolean') _classPrivateFieldSet(_lockInsideJail, this, options.lockInsideJail);
    if (typeof options.dropInJailOnly === 'boolean') _classPrivateFieldSet(_dropInJailOnly, this, options.dropInJailOnly);
    if (typeof options.multiCollision === 'boolean') _classPrivateFieldSet(_multiCollision, this, options.multiCollision);
    /** @private */
    this._onMouseDown = _assertClassBrand(_TinyDragger_brand, this, _startDrag).bind(this);
    /** @private */
    this._onMouseMove = _assertClassBrand(_TinyDragger_brand, this, _drag).bind(this);
    /** @private */
    this._onMouseUp = _assertClassBrand(_TinyDragger_brand, this, _endDrag).bind(this);
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchStart = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _startDrag).call(_this, e.touches[0]);
    };
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchMove = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _drag).call(_this, e.touches[0]);
    };
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchEnd = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _endDrag).call(_this, e.changedTouches[0]);
    };
    _classPrivateFieldGet(_target, this).addEventListener('mousedown', this._onMouseDown);
    _classPrivateFieldGet(_target, this).addEventListener('touchstart', this._onTouchStart, {
      passive: false
    });
  }
  /**
   * Enables the drag functionality.
   */
  return _createClass(TinyDragger, [{
    key: "enable",
    value: function enable() {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.add(_classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_enabled, this, true);
    }
    /**
     * Disables the drag functionality.
     */
  }, {
    key: "disable",
    value: function disable() {
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_enabled, this, false);
    }
    /**
     * Adds an element to be considered for collision detection.
     * @param {HTMLElement} element - The element to track collisions with.
     * @throws {Error} If the element is not a valid HTMLElement.
     */
  }, {
    key: "addCollidable",
    value: function addCollidable(element) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(element instanceof HTMLElement)) throw new Error('addCollidable expects an HTMLElement as argument.');
      if (!_classPrivateFieldGet(_collidables, this).includes(element)) _classPrivateFieldGet(_collidables, this).push(element);
    }
    /**
     * Removes a collidable element from the tracking list.
     * @param {HTMLElement} element - The element to remove.
     * @throws {Error} If the element is not a valid HTMLElement.
     */
  }, {
    key: "removeCollidable",
    value: function removeCollidable(element) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(element instanceof HTMLElement)) throw new Error('removeCollidable expects an HTMLElement as argument.');
      _classPrivateFieldSet(_collidables, this, _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return el !== element;
      }));
    }
    /**
     * Sets vibration patterns for drag events.
     * @param {Object} [param0={}] - Vibration pattern configuration.
     * @param {number[]|false} [param0.startPattern=false] - Vibration on drag start.
     * @param {number[]|false} [param0.endPattern=false] - Vibration on drag end.
     * @param {number[]|false} [param0.collidePattern=false] - Vibration on collision.
     * @param {number[]|false} [param0.movePattern=false] - Vibration during movement.
     * @throws {Error} If any pattern is not false or an array of numbers.
     */
  }, {
    key: "setVibrationPattern",
    value: function setVibrationPattern() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$startPattern = _ref.startPattern,
        startPattern = _ref$startPattern === void 0 ? false : _ref$startPattern,
        _ref$endPattern = _ref.endPattern,
        endPattern = _ref$endPattern === void 0 ? false : _ref$endPattern,
        _ref$collidePattern = _ref.collidePattern,
        collidePattern = _ref$collidePattern === void 0 ? false : _ref$collidePattern,
        _ref$movePattern = _ref.movePattern,
        movePattern = _ref$movePattern === void 0 ? false : _ref$movePattern;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      /** @param {any} value */
      var isValidPattern = function isValidPattern(value) {
        return value === false || Array.isArray(value) && value.every(function (n) {
          return typeof n === 'number';
        });
      };
      if (!isValidPattern(startPattern)) throw new Error('Invalid "startPattern": must be false or an array of numbers.');
      if (!isValidPattern(endPattern)) throw new Error('Invalid "endPattern": must be false or an array of numbers.');
      if (!isValidPattern(collidePattern)) throw new Error('Invalid "collidePattern": must be false or an array of numbers.');
      if (!isValidPattern(movePattern)) throw new Error('Invalid "movePattern": must be false or an array of numbers.');
      _classPrivateFieldSet(_vibration, this, {
        start: startPattern,
        end: endPattern,
        collide: collidePattern,
        move: movePattern
      });
    }
    /**
     * Disables all vibration feedback.
     */
  }, {
    key: "disableVibration",
    value: function disableVibration() {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      _classPrivateFieldSet(_vibration, this, {
        start: false,
        end: false,
        collide: false,
        move: false
      });
    }
    /**
     * Calculates the cursor offset relative to the top-left of the target element.
     * @param {MouseEvent|Touch} event - The mouse or touch event.
     * @returns {{x: number, y: number}} The offset in pixels.
     * @throws {Error} If event is not a MouseEvent or Touch with clientX/clientY.
     */
  }, {
    key: "getOffset",
    value: function getOffset(event) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(event instanceof MouseEvent) && !(event instanceof Touch) || typeof event.clientX !== 'number' || typeof event.clientY !== 'number') throw new Error('getOffset expects an event with valid clientX and clientY coordinates.');
      var targetRect = _classPrivateFieldGet(_target, this).getBoundingClientRect();
      var _TinyHtml$borderWidth = _TinyHtml["default"].borderWidth(_classPrivateFieldGet(_target, this)),
        borderLeft = _TinyHtml$borderWidth.left,
        borderTop = _TinyHtml$borderWidth.top;
      return {
        x: event.clientX - targetRect.left + borderLeft,
        y: event.clientY - targetRect.top + borderTop
      };
    }
  }, {
    key: "checkDragCollision",
    value:
    /**
     * Handles dragging collision.
     * @param {MouseEvent|Touch} event - The drag event.
     */
    function checkDragCollision(event) {
      var _this2 = this;
      var _this$execCollision = this.execCollision(event),
        collidedElements = _this$execCollision.collidedElements;
      var first = collidedElements[0] || null;
      // Removes old marking if necessary
      if (_classPrivateFieldGet(_lastCollision, this) && !collidedElements.includes(_classPrivateFieldGet(_lastCollision, this))) {
        _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
      }
      // Adds Marking for All Colluded
      collidedElements.forEach(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this2, _addCollision).call(_this2, el);
      });
      // Removes markings from who no longer collided
      _classPrivateFieldGet(_collidables, this).forEach(function (el) {
        if (!collidedElements.includes(el)) {
          el.classList.remove(_classPrivateFieldGet(_classDragCollision, _this2));
        }
      });
      if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).collide) && collidedElements.length > 0) {
        navigator.vibrate(_classPrivateFieldGet(_vibration, this).collide);
      }
      _classPrivateFieldSet(_lastCollision, this, first);
    }
    /**
     * Handles dragging movement.
     * @param {MouseEvent|Touch} event - The drag event.
     */
  }, {
    key: "execCollision",
    value:
    /**
     * Handles the collision of a drag.
     * @param {MouseEvent|Touch} event - The release event.
     * @returns {{ inJail: boolean; collidedElements: (HTMLElement | null)[] }}
     */
    function execCollision(event) {
      var _classPrivateFieldGet2;
      if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragProxy, this)) return {
        inJail: false,
        collidedElements: []
      };
      var collidedElements = [];
      var inJail = true;
      var jailRect = (_classPrivateFieldGet2 = _classPrivateFieldGet(_jail, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.getBoundingClientRect();
      if (_classPrivateFieldGet(_collisionByMouse, this)) {
        var x = event.clientX;
        var y = event.clientY;
        if (_classPrivateFieldGet(_dropInJailOnly, this) && _classPrivateFieldGet(_jail, this) && jailRect) {
          inJail = x >= jailRect.left && x <= jailRect.right && y >= jailRect.top && y <= jailRect.bottom;
        }
        collidedElements = inJail ? _classPrivateFieldGet(_multiCollision, this) ? this.getAllCollidedElements(x, y) : [this.getCollidedElement(x, y)].filter(Boolean) : [];
      } else {
        var rect = _classPrivateFieldGet(_dragProxy, this).getBoundingClientRect();
        if (_classPrivateFieldGet(_dropInJailOnly, this) && _classPrivateFieldGet(_jail, this) && jailRect) {
          inJail = rect.left >= jailRect.left && rect.right <= jailRect.right && rect.top >= jailRect.top && rect.bottom <= jailRect.bottom;
        }
        collidedElements = inJail ? _classPrivateFieldGet(_multiCollision, this) ? this.getAllCollidedElementsByRect(rect) : [this.getCollidedElementByRect(rect)].filter(Boolean) : [];
      }
      return {
        inJail: inJail,
        collidedElements: collidedElements
      };
    }
    /**
     * Handles the end of a drag.
     * @param {MouseEvent|Touch} event - The release event.
     */
  }, {
    key: "getAllCollidedElementsByRect",
    value:
    /**
     * Returns all elements currently colliding with the given rectangle.
     *
     * @param {DOMRect} rect - Bounding rectangle of the dragged proxy.
     * @returns {HTMLElement[]} A list of all collided elements.
     * @throws {Error} If the input is not a valid DOMRect with numeric bounds.
     */
    function getAllCollidedElementsByRect(rect) {
      var _this3 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(rect instanceof DOMRect) || typeof rect.left !== 'number' || typeof rect.right !== 'number' || typeof rect.top !== 'number' || typeof rect.bottom !== 'number') throw new Error('getCollidedElementByRect expects a valid DOMRect object.');
      return _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this3, _getCollidedElementByRect).call(_this3, el, rect);
      });
    }
    /**
     * Detects collision based on rectangle intersection.
     * @param {DOMRect} rect - Bounding rectangle of the dragged proxy.
     * @returns {HTMLElement|null} The collided element or null.
     * @throws {Error} If rect is not a DOMRect with valid numeric properties.
     */
  }, {
    key: "getCollidedElementByRect",
    value: function getCollidedElementByRect(rect) {
      var _this4 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(rect instanceof DOMRect) || typeof rect.left !== 'number' || typeof rect.right !== 'number' || typeof rect.top !== 'number' || typeof rect.bottom !== 'number') throw new Error('getCollidedElementByRect expects a valid DOMRect object.');
      return _classPrivateFieldGet(_collidables, this).find(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this4, _getCollidedElementByRect).call(_this4, el, rect);
      }) || null;
    }
    /**
     * Checks whether a given (x, y) coordinate is inside the bounding rectangle of an element.
     *
     * @param {HTMLElement} el - The element to test for collision.
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {boolean} True if the point is within the element's bounds.
     */
  }, {
    key: "getAllCollidedElements",
    value:
    /**
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {HTMLElement[]} The collided element or null.
     */
    function getAllCollidedElements(x, y) {
      var _this5 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (typeof x !== 'number' || typeof y !== 'number') throw new Error('getCollidedElement expects numeric x and y coordinates.');
      return _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this5, _getCollidedElement).call(_this5, el, x, y);
      });
    }
    /**
     * Detects collision with a point using element bounding rectangles.
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {HTMLElement|null} The collided element or null.
     */
  }, {
    key: "getCollidedElement",
    value: function getCollidedElement(x, y) {
      var _this6 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (typeof x !== 'number' || typeof y !== 'number') throw new Error('getCollidedElement expects numeric x and y coordinates.');
      return _classPrivateFieldGet(_collidables, this).find(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this6, _getCollidedElement).call(_this6, el, x, y);
      }) || null;
    }
    /**
     * Dispatches a custom event from the target element.
     * @param {string} type - The event name.
     */
  }, {
    key: "getDragging",
    value:
    /**
     * Gets whether dragging is currently active.
     * @returns {boolean}
     */
    function getDragging() {
      return _classPrivateFieldGet(_dragging, this);
    }
    /**
     * Gets whether movement is restricted inside the jail container.
     * @returns {boolean}
     */
  }, {
    key: "getLockInsideJail",
    value: function getLockInsideJail() {
      return _classPrivateFieldGet(_lockInsideJail, this);
    }
    /**
     * Sets whether movement is restricted inside the jail container.
     * @param {boolean} value
     */
  }, {
    key: "setLockInsideJail",
    value: function setLockInsideJail(value) {
      if (typeof value !== 'boolean') throw new Error('lockInsideJail must be a boolean.');
      _classPrivateFieldSet(_lockInsideJail, this, value);
    }
    /**
     * Gets whether the element should revert to original position on drop.
     * @returns {boolean}
     */
  }, {
    key: "getRevertOnDrop",
    value: function getRevertOnDrop() {
      return _classPrivateFieldGet(_revertOnDrop, this);
    }
    /**
     * Sets whether the element should revert to original position on drop.
     * @param {boolean} value
     */
  }, {
    key: "setRevertOnDrop",
    value: function setRevertOnDrop(value) {
      if (typeof value !== 'boolean') throw new Error('revertOnDrop must be a boolean.');
      _classPrivateFieldSet(_revertOnDrop, this, value);
    }
    /**
     * Gets whether collision detection uses mouse position.
     * @returns {boolean}
     */
  }, {
    key: "getCollisionByMouse",
    value: function getCollisionByMouse() {
      return _classPrivateFieldGet(_collisionByMouse, this);
    }
    /**
     * Sets whether collision detection uses mouse position.
     * @param {boolean} value
     */
  }, {
    key: "setCollisionByMouse",
    value: function setCollisionByMouse(value) {
      if (typeof value !== 'boolean') throw new Error('collisionByMouse must be a boolean.');
      _classPrivateFieldSet(_collisionByMouse, this, value);
    }
    /**
     * Gets whether dropping is restricted inside the jail container.
     * @returns {boolean}
     */
  }, {
    key: "getDropInJailOnly",
    value: function getDropInJailOnly() {
      return _classPrivateFieldGet(_dropInJailOnly, this);
    }
    /**
     * Sets whether dropping is restricted inside the jail container.
     * @param {boolean} value
     */
  }, {
    key: "setDropInJailOnly",
    value: function setDropInJailOnly(value) {
      if (typeof value !== 'boolean') throw new Error('dropInJailOnly must be a boolean.');
      _classPrivateFieldSet(_dropInJailOnly, this, value);
    }
    /**
     * Returns the current default z-index used for draggable items.
     * @returns {number}
     */
  }, {
    key: "getDefaultZIndex",
    value: function getDefaultZIndex() {
      return _classPrivateFieldGet(_defaultZIndex, this);
    }
    /**
     * Sets a new default z-index for draggable items.
     * @param {number} newZIndex
     */
  }, {
    key: "setDefaultZIndex",
    value: function setDefaultZIndex(newZIndex) {
      if (typeof newZIndex !== 'number' || !Number.isFinite(newZIndex)) throw new TypeError('Z-index must be a finite number.');
      _classPrivateFieldSet(_defaultZIndex, this, newZIndex);
    }
    /**
     * Returns whether the draggable element is mirrored or the original.
     * @returns {boolean}
     */
  }, {
    key: "isMirrorEnabled",
    value: function isMirrorEnabled() {
      return _classPrivateFieldGet(_mirrorElem, this);
    }
    /**
     * Sets whether the draggable element should be a mirror or the original.
     * @param {boolean} useMirror
     */
  }, {
    key: "setMirrorEnabled",
    value: function setMirrorEnabled(useMirror) {
      if (typeof useMirror !== 'boolean') throw new TypeError('Mirror setting must be a boolean.');
      _classPrivateFieldSet(_mirrorElem, this, useMirror);
    }
    /**
     * Returns the original target element being dragged.
     * @returns {HTMLElement}
     */
  }, {
    key: "getTarget",
    value: function getTarget() {
      return _classPrivateFieldGet(_target, this);
    }
    /**
     * Returns the current jail container (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getJail",
    value: function getJail() {
      return _classPrivateFieldGet(_jail, this);
    }
    /**
     * Returns the current proxy element being dragged (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getDragProxy",
    value: function getDragProxy() {
      return _classPrivateFieldGet(_dragProxy, this);
    }
    /**
     * Returns the last collided element (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getLastCollision",
    value: function getLastCollision() {
      return _classPrivateFieldGet(_lastCollision, this);
    }
    /**
     * Returns all registered collidable elements.
     * @returns {HTMLElement[]}
     */
  }, {
    key: "getCollidables",
    value: function getCollidables() {
      return _toConsumableArray(_classPrivateFieldGet(_collidables, this));
    }
    /**
     * Returns the CSS class used to hide the target during drag.
     * @returns {string}
     */
  }, {
    key: "getDragHiddenClass",
    value: function getDragHiddenClass() {
      return _classPrivateFieldGet(_dragHiddenClass, this);
    }
    /**
     * Returns the CSS class applied to the clone during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassDragging",
    value: function getClassDragging() {
      return _classPrivateFieldGet(_classDragging, this);
    }
    /**
     * Returns the CSS class applied to <body> during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassBodyDragging",
    value: function getClassBodyDragging() {
      return _classPrivateFieldGet(_classBodyDragging, this);
    }
    /**
     * Returns the CSS class applied to the jail during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassJailDragging",
    value: function getClassJailDragging() {
      return _classPrivateFieldGet(_classJailDragging, this);
    }
    /**
     * Returns the CSS class applied to the jail when dragging is disabled.
     * @returns {string}
     */
  }, {
    key: "getClassJailDragDisabled",
    value: function getClassJailDragDisabled() {
      return _classPrivateFieldGet(_classJailDragDisabled, this);
    }
    /**
     * Returns the CSS class applied to a collided element.
     * @returns {string}
     */
  }, {
    key: "getClassDragCollision",
    value: function getClassDragCollision() {
      return _classPrivateFieldGet(_classDragCollision, this);
    }
    /**
     * Returns the full vibration configuration.
     * @returns {VibrationPatterns}
     */
  }, {
    key: "getVibrations",
    value: function getVibrations() {
      return _objectSpread({}, _classPrivateFieldGet(_vibration, this));
    }
    /**
     * Returns the vibration pattern for drag start.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getStartVibration",
    value: function getStartVibration() {
      return _classPrivateFieldGet(_vibration, this).start;
    }
    /**
     * Returns the vibration pattern for drag end.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getEndVibration",
    value: function getEndVibration() {
      return _classPrivateFieldGet(_vibration, this).end;
    }
    /**
     * Returns the vibration pattern for collisions.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getCollideVibration",
    value: function getCollideVibration() {
      return _classPrivateFieldGet(_vibration, this).collide;
    }
    /**
     * Returns the vibration pattern during movement.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getMoveVibration",
    value: function getMoveVibration() {
      return _classPrivateFieldGet(_vibration, this).move;
    }
    /**
     * Returns whether the dragger is currently enabled.
     * @returns {boolean}
     */
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return _classPrivateFieldGet(_enabled, this);
    }
    /**
     * Internal method to verify if the instance has been destroyed.
     * Throws an error if any operation is attempted after destruction.
     */
  }, {
    key: "destroy",
    value:
    /**
     * Completely disables drag-and-drop and cleans up all event listeners.
     * Does NOT remove the original HTML element.
     */
    function destroy() {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      this.disable();
      _classPrivateFieldGet(_target, this).removeEventListener('mousedown', this._onMouseDown);
      _classPrivateFieldGet(_target, this).removeEventListener('touchstart', this._onTouchStart);
      document.removeEventListener('mousemove', this._onMouseMove);
      document.removeEventListener('mouseup', this._onMouseUp);
      document.removeEventListener('touchmove', this._onTouchMove);
      document.removeEventListener('touchend', this._onTouchEnd);
      if (_classPrivateFieldGet(_lastCollision, this)) _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
      if (_classPrivateFieldGet(_dragProxy, this)) {
        if (_classPrivateFieldGet(_mirrorElem, this)) _classPrivateFieldGet(_dragProxy, this).remove();else Object.assign(_classPrivateFieldGet(_dragProxy, this).style, {
          position: '',
          pointerEvents: '',
          left: '',
          top: '',
          width: '',
          height: '',
          zIndex: ''
        });
        _classPrivateFieldSet(_dragProxy, this, null);
      }
      _classPrivateFieldSet(_collidables, this, []);
      _classPrivateFieldSet(_dragging, this, false);
      _classPrivateFieldSet(_lastCollision, this, null);
      if (_classPrivateFieldGet(_mirrorElem, this)) _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_dragHiddenClass, this));
      _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_classDragging, this));
      document.body.classList.remove(_classPrivateFieldGet(_classBodyDragging, this));
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragging, this), _classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_destroyed, this, true);
    }
  }]);
}();
function _startDrag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_enabled, this) || !_classPrivateFieldGet(_target, this).parentElement) return;
  if (_classPrivateFieldGet(_mirrorElem, this)) {
    var dragProxy = _classPrivateFieldGet(_target, this).cloneNode(true);
    if (!(dragProxy instanceof HTMLElement)) throw new Error('[TinyDragger] INVALID DRAG ELEMENT!');
    _classPrivateFieldSet(_dragProxy, this, dragProxy);
  } else _classPrivateFieldSet(_dragProxy, this, _classPrivateFieldGet(_target, this));
  _classPrivateFieldSet(_dragging, this, true);
  var rect = _classPrivateFieldGet(_target, this).getBoundingClientRect();
  Object.assign(_classPrivateFieldGet(_dragProxy, this).style, {
    position: 'absolute',
    pointerEvents: 'none',
    left: "".concat(_classPrivateFieldGet(_target, this).offsetLeft, "px"),
    top: "".concat(_classPrivateFieldGet(_target, this).offsetTop, "px"),
    width: "".concat(rect.width, "px"),
    height: "".concat(rect.height, "px"),
    zIndex: _classPrivateFieldGet(_defaultZIndex, this)
  });
  if (_classPrivateFieldGet(_mirrorElem, this)) {
    _classPrivateFieldGet(_target, this).classList.add(_classPrivateFieldGet(_dragHiddenClass, this));
    _classPrivateFieldGet(_target, this).parentElement.appendChild(_classPrivateFieldGet(_dragProxy, this));
  }
  var _this$getOffset = this.getOffset(event),
    offsetX = _this$getOffset.x,
    offsetY = _this$getOffset.y;
  _classPrivateFieldSet(_offsetX, this, offsetX);
  _classPrivateFieldSet(_offsetY, this, offsetY);
  _classPrivateFieldGet(_dragProxy, this).classList.add(_classPrivateFieldGet(_classDragging, this));
  document.body.classList.add(_classPrivateFieldGet(_classBodyDragging, this));
  if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.add(_classPrivateFieldGet(_classJailDragging, this));
  document.addEventListener('mousemove', this._onMouseMove);
  document.addEventListener('mouseup', this._onMouseUp);
  document.addEventListener('touchmove', this._onTouchMove, {
    passive: false
  });
  document.addEventListener('touchend', this._onTouchEnd);
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).start)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).start);
  }
  this.checkDragCollision(event);
  _assertClassBrand(_TinyDragger_brand, this, _dispatchEvent).call(this, 'drag');
}
/**
 * Marks an element as currently collided by adding the collision CSS class.
 * The element is stored in an internal list for easy removal later.
 *
 * @param {HTMLElement|null} el - The element to mark as collided.
 */
function _addCollision(el) {
  if (!el) return;
  el.classList.add(_classPrivateFieldGet(_classDragCollision, this));
  _classPrivateFieldGet(_collisionsMarked, this).push(el);
}
/**
 * Removes the collision CSS class from all previously marked elements.
 * Also clears the last single collision element, if set.
 *
 */
function _removeCollision() {
  while (_classPrivateFieldGet(_collisionsMarked, this).length > 0) {
    var el = _classPrivateFieldGet(_collisionsMarked, this).shift();
    if (el) el.classList.remove(_classPrivateFieldGet(_classDragCollision, this));
  }
  if (!_classPrivateFieldGet(_lastCollision, this)) return;
  _classPrivateFieldGet(_lastCollision, this).classList.remove(_classPrivateFieldGet(_classDragCollision, this));
}
function _drag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragging, this) || !_classPrivateFieldGet(_enabled, this) || !_classPrivateFieldGet(_dragProxy, this)) return;
  var parent = _classPrivateFieldGet(_dragProxy, this).offsetParent || document.body;
  var parentRect = parent.getBoundingClientRect();
  var x = event.clientX - parentRect.left - _classPrivateFieldGet(_offsetX, this);
  var y = event.clientY - parentRect.top - _classPrivateFieldGet(_offsetY, this);
  if (_classPrivateFieldGet(_lockInsideJail, this) && _classPrivateFieldGet(_jail, this)) {
    var jailRect = _classPrivateFieldGet(_jail, this).getBoundingClientRect();
    var targetRect = _classPrivateFieldGet(_dragProxy, this).getBoundingClientRect();
    var jailLeft = jailRect.left - parentRect.left;
    var jailTop = jailRect.top - parentRect.top;
    var _TinyHtml$borderWidth2 = _TinyHtml["default"].borderWidth(_classPrivateFieldGet(_jail, this)),
      borderX = _TinyHtml$borderWidth2.x,
      borderY = _TinyHtml$borderWidth2.y;
    var maxX = jailLeft + jailRect.width - targetRect.width - borderY;
    var maxY = jailTop + jailRect.height - targetRect.height - borderX;
    x = Math.max(jailLeft, Math.min(x, maxX));
    y = Math.max(jailTop, Math.min(y, maxY));
  }
  _classPrivateFieldGet(_dragProxy, this).style.position = 'absolute';
  _classPrivateFieldGet(_dragProxy, this).style.left = "".concat(x, "px");
  _classPrivateFieldGet(_dragProxy, this).style.top = "".concat(y, "px");
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).move)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).move);
  }
  this.checkDragCollision(event);
  _assertClassBrand(_TinyDragger_brand, this, _dispatchEvent).call(this, 'dragging');
}
function _endDrag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragging, this)) return;
  _classPrivateFieldSet(_dragging, this, false);
  if (!_classPrivateFieldGet(_dragProxy, this)) return;
  _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_classDragging, this));
  document.body.classList.remove(_classPrivateFieldGet(_classBodyDragging, this));
  if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragging, this));
  document.removeEventListener('mousemove', this._onMouseMove);
  document.removeEventListener('mouseup', this._onMouseUp);
  document.removeEventListener('touchmove', this._onTouchMove);
  document.removeEventListener('touchend', this._onTouchEnd);
  var _this$execCollision2 = this.execCollision(event),
    collidedElements = _this$execCollision2.collidedElements;
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).end)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).end);
  }
  var newX = _classPrivateFieldGet(_dragProxy, this).style.left;
  var newY = _classPrivateFieldGet(_dragProxy, this).style.top;
  if (_classPrivateFieldGet(_dragProxy, this)) {
    if (_classPrivateFieldGet(_mirrorElem, this)) _classPrivateFieldGet(_dragProxy, this).remove();else Object.assign(_classPrivateFieldGet(_dragProxy, this).style, {
      position: '',
      pointerEvents: '',
      left: '',
      top: '',
      width: '',
      height: '',
      zIndex: ''
    });
    _classPrivateFieldSet(_dragProxy, this, null);
  }
  if (_classPrivateFieldGet(_lastCollision, this)) _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
  _classPrivateFieldSet(_lastCollision, this, null);
  if (_classPrivateFieldGet(_mirrorElem, this)) _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_dragHiddenClass, this));
  if (!_classPrivateFieldGet(_revertOnDrop, this)) {
    _classPrivateFieldGet(_target, this).style.left = newX;
    _classPrivateFieldGet(_target, this).style.top = newY;
  }
  var dropEvent = new CustomEvent('drop', {
    detail: {
      targets: collidedElements,
      first: collidedElements[0] || null
    }
  });
  _classPrivateFieldGet(_target, this).dispatchEvent(dropEvent);
}
/**
 * Checks if the provided element intersects with the given bounding rectangle.
 *
 * @param {HTMLElement} el - The element to test for collision.
 * @param {DOMRect} rect - The bounding rectangle to check against.
 * @returns {boolean} True if the element intersects with the rectangle.
 */
function _getCollidedElementByRect(el, rect) {
  var elRect = el.getBoundingClientRect();
  return !(rect.right < elRect.left || rect.left > elRect.right || rect.bottom < elRect.top || rect.top > elRect.bottom);
}
function _getCollidedElement(el, x, y) {
  var rect = el.getBoundingClientRect();
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}
function _dispatchEvent(type) {
  var event = new CustomEvent(type);
  _classPrivateFieldGet(_target, this).dispatchEvent(event);
}
function _checkDestroy() {
  if (_classPrivateFieldGet(_destroyed, this)) throw new Error('This TinyDragger instance has been destroyed and can no longer be used.');
}
_defineProperty(TinyDragger, "Utils", _objectSpread(_objectSpread({}, TinyCollision), {}, {
  TinyHtml: _TinyHtml["default"]
}));
var _default = exports["default"] = TinyDragger;

},{"../basics/collision.mjs":171,"../basics/objChecker.mjs":175,"./TinyHtml.mjs":190}],189:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _listeners = /*#__PURE__*/new WeakMap();
var _maxListeners = /*#__PURE__*/new WeakMap();
var _throwMaxListeners = /*#__PURE__*/new WeakMap();
var _TinyEvents_brand = /*#__PURE__*/new WeakSet();
/**
 * A generic event listener callback function.
 *
 * @callback handler
 * @param {...any} payload - The data payload passed when the event is triggered.
 * @returns {void}
 */
/**
 * TinyEvents provides a minimalistic event emitter system similar to Node.js's EventEmitter,
 * enabling components to subscribe to, emit, and manage events and their listeners.
 *
 * Features include:
 * - Adding/removing event listeners (`on`, `off`, `offAll`, `offAllTypes`)
 * - One-time listeners (`once`)
 * - Emitting events (`emit`)
 * - Listener inspection and limits (`listenerCount`, `listeners`, `eventNames`)
 * - Maximum listener control (`setMaxListeners`, `getMaxListeners`)
 *
 * This class is useful for lightweight, dependency-free publish/subscribe event handling
 * within modular JavaScript applications.
 *
 * @class
 */
var TinyEvents = /*#__PURE__*/function () {
  function TinyEvents() {
    _classCallCheck(this, TinyEvents);
    ///////////////////////////////////////////////////
    /**
     * Internal method to prepend a listener with options.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     * @param {Object} [settings={}] - Optional settings.
     * @param {boolean} [settings.once=false] - If the listener should be executed once.
     */
    _classPrivateMethodInitSpec(this, _TinyEvents_brand);
    /** @type {Map<string, { handler: handler; config: { once: boolean } }[]>} */
    _classPrivateFieldInitSpec(this, _listeners, new Map());
    /** @type {number} */
    _classPrivateFieldInitSpec(this, _maxListeners, 10);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _throwMaxListeners, false);
  }
  return _createClass(TinyEvents, [{
    key: "setThrowOnMaxListeners",
    value:
    /**
     * Enables or disables throwing an error when the maximum number of listeners is exceeded.
     *
     * @param {boolean} shouldThrow - If true, an error will be thrown when the max is exceeded.
     */
    function setThrowOnMaxListeners(shouldThrow) {
      if (typeof shouldThrow !== 'boolean') throw new TypeError('setThrowOnMaxListeners(value): value must be a boolean');
      _classPrivateFieldSet(_throwMaxListeners, this, shouldThrow);
    }
    /**
     * Checks whether an error will be thrown when the max listener limit is exceeded.
     *
     * @returns {boolean} True if an error will be thrown, false if only a warning is shown.
     */
  }, {
    key: "getThrowOnMaxListeners",
    value: function getThrowOnMaxListeners() {
      return _classPrivateFieldGet(_throwMaxListeners, this);
    }
  }, {
    key: "prependListener",
    value:
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     */
    function prependListener(event, handler) {
      if (typeof event !== 'string') throw new TypeError('prepend(event, handler): event name must be a string');
      if (typeof handler !== 'function') throw new TypeError('prepend(event, handler): handler must be a function');
      _assertClassBrand(_TinyEvents_brand, this, _prepend).call(this, event, handler);
    }
    /**
     * Adds a one-time listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     * @returns {handler} - The wrapped handler used internally.
     */
  }, {
    key: "prependListenerOnce",
    value: function prependListenerOnce(event, handler) {
      var _this = this;
      if (typeof event !== 'string') throw new TypeError('prependOnceListener(event, handler): event name must be a string');
      if (typeof handler !== 'function') throw new TypeError('prependOnceListener(event, handler): handler must be a function');
      /** @type {handler} */
      var _wrapped = function wrapped() {
        _this.off(event, _wrapped);
        handler.apply(void 0, arguments);
      };
      _assertClassBrand(_TinyEvents_brand, this, _prepend).call(this, event, _wrapped, {
        once: true
      });
      return _wrapped;
    }
    ////////////////////////////////////////////////////////////
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     * @param {Object} [settings={}] - Optional settings.
     * @param {boolean} [settings.once=false] - This is a once event.
     */
  }, {
    key: "on",
    value:
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     */
    function on(event, handler) {
      if (typeof event !== 'string') throw new TypeError('on(event, handler): event name must be a string');
      if (typeof handler !== 'function') throw new TypeError('on(event, handler): handler must be a function');
      return _assertClassBrand(_TinyEvents_brand, this, _on).call(this, event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - The callback function to run on event.
     * @returns {handler} - The wrapped version of the handler.
     */
  }, {
    key: "once",
    value: function once(event, handler) {
      var _this2 = this;
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      if (typeof handler !== 'function') throw new TypeError('once(event, handler): handler must be a function');
      /** @type {handler} */
      var _wrapped2 = function wrapped(e) {
        _this2.off(event, _wrapped2);
        if (typeof handler === 'function') handler(e);
      };
      _assertClassBrand(_TinyEvents_brand, this, _on).call(this, event, _wrapped2, {
        once: true
      });
      return _wrapped2;
    }
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     */
  }, {
    key: "appendListener",
    value: function appendListener(event, handler) {
      return this.on(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - The callback function to run on event.
     * @returns {handler} - The wrapped version of the handler.
     */
  }, {
    key: "appendListenerOnce",
    value: function appendListenerOnce(event, handler) {
      return this.once(event, handler);
    }
    ///////////////////////////////////////////////
    /**
     * Removes a previously registered event listener.
     *
     * @param {string} event - The name of the event to remove the handler from.
     * @param {handler} handler - The specific callback function to remove.
     */
  }, {
    key: "off",
    value: function off(event, handler) {
      if (typeof event !== 'string') throw new TypeError('off(event, handler): event name must be a string');
      if (typeof handler !== 'function') throw new TypeError('off(event, handler): handler must be a function');
      var listeners = _classPrivateFieldGet(_listeners, this).get(event);
      if (!Array.isArray(listeners)) return;
      var index = listeners.findIndex(function (listener) {
        return listener.handler === handler;
      });
      if (index !== -1) listeners.splice(index, 1);
      // Optionally clean up empty arrays (optional)
      if (listeners.length === 0) _classPrivateFieldGet(_listeners, this)["delete"](event);
    }
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {string} event - The event type to remove (e.g. 'onScrollBoundary').
     */
  }, {
    key: "offAll",
    value: function offAll(event) {
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      _classPrivateFieldGet(_listeners, this)["delete"](event);
    }
    /**
     * Removes all event listeners of all types from the element.
     */
  }, {
    key: "offAllTypes",
    value: function offAllTypes() {
      _classPrivateFieldGet(_listeners, this).clear();
    }
    /////////////////////////////////////////////
    /**
     * Returns the number of listeners for a given event.
     *
     * @param {string} event - The name of the event.
     * @returns {number} Number of listeners for the event.
     */
  }, {
    key: "listenerCount",
    value: function listenerCount(event) {
      if (typeof event !== 'string') throw new TypeError('listenerCount(event): event name must be a string');
      var listeners = _classPrivateFieldGet(_listeners, this).get(event);
      return Array.isArray(listeners) ? listeners.length : 0;
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {handler[]} Array of listener functions.
     */
  }, {
    key: "listeners",
    value: function listeners(event) {
      if (typeof event !== 'string') throw new TypeError('listeners(event): event name must be a string');
      var listeners = _classPrivateFieldGet(_listeners, this).get(event);
      return Array.isArray(listeners) ? _toConsumableArray(listeners).filter(function (listener) {
        return !listener.config.once;
      }).map(function (listener) {
        return listener.handler;
      }) : [];
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {handler[]} Array of listener functions.
     */
  }, {
    key: "onceListeners",
    value: function onceListeners(event) {
      if (typeof event !== 'string') throw new TypeError('onceListeners(event): event name must be a string');
      var listeners = _classPrivateFieldGet(_listeners, this).get(event);
      return Array.isArray(listeners) ? _toConsumableArray(listeners).filter(function (listener) {
        return listener.config.once;
      }).map(function (listener) {
        return listener.handler;
      }) : [];
    }
    /**
     * Returns a copy of the internal listeners array for the specified event,
     * including wrapper functions like those used by `.once()`.
     * @param {string | symbol} event - The event name.
     * @returns {handler[]} An array of raw listener functions.
     */
  }, {
    key: "allListeners",
    value: function allListeners(event) {
      if (typeof event !== 'string') throw new TypeError('allListeners(event): event name must be a string');
      var listeners = _classPrivateFieldGet(_listeners, this).get(event);
      return Array.isArray(listeners) ? _toConsumableArray(listeners).map(function (listener) {
        return listener.handler;
      }) : [];
    }
    /**
     * Returns an array of event names for which there are registered listeners.
     *
     * @returns {string[]} Array of registered event names.
     */
  }, {
    key: "eventNames",
    value: function eventNames() {
      return _toConsumableArray(_classPrivateFieldGet(_listeners, this).keys());
    }
    /**
     * Emits an event, triggering all registered handlers for that event.
     *
     * @param {string} event - The event name to emit.
     * @param {...any} payload - Optional data to pass to each handler.
     * @returns {boolean} True if any listeners were called, false otherwise.
     */
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }
      if (typeof event !== 'string') throw new TypeError('emit(event, data): event name must be a string');
      var listeners = _classPrivateFieldGet(_listeners, this).get(event);
      if (!Array.isArray(listeners) || listeners.length === 0) return false;
      // Call all listeners with the provided data
      listeners.forEach(function (listener) {
        return listener.handler.apply(listener, payload);
      });
      return true;
    }
    ///////////////////////////////////
    /**
     * Sets the maximum number of listeners per event before a warning is shown.
     *
     * @param {number} n - The maximum number of listeners.
     */
  }, {
    key: "setMaxListeners",
    value: function setMaxListeners(n) {
      if (!Number.isInteger(n) || n < 0) throw new TypeError('setMaxListeners(n): n must be a non-negative integer');
      _classPrivateFieldSet(_maxListeners, this, n);
    }
    /**
     * Gets the maximum number of listeners allowed per event.
     *
     * @returns {number} The maximum number of listeners.
     */
  }, {
    key: "getMaxListeners",
    value: function getMaxListeners() {
      return _classPrivateFieldGet(_maxListeners, this);
    }
  }]);
}();
function _prepend(event, handler) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    _ref$once = _ref.once,
    once = _ref$once === void 0 ? false : _ref$once;
  var eventData = _classPrivateFieldGet(_listeners, this).get(event);
  if (!Array.isArray(eventData)) {
    eventData = [];
    _classPrivateFieldGet(_listeners, this).set(event, eventData);
  }
  eventData.unshift({
    handler: handler,
    config: {
      once: once
    }
  });
  var max = _classPrivateFieldGet(_maxListeners, this);
  if (max > 0 && eventData.length > max) {
    var warnMessage = "Possible memory leak detected. ".concat(eventData.length, " \"").concat(event, "\" listeners added. ") + "Use setMaxListeners() to increase limit.";
    if (!_classPrivateFieldGet(_throwMaxListeners, this)) console.warn(warnMessage);else throw new Error(warnMessage);
  }
}
function _on(event, handler) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    _ref2$once = _ref2.once,
    once = _ref2$once === void 0 ? false : _ref2$once;
  var eventData = _classPrivateFieldGet(_listeners, this).get(event);
  if (!Array.isArray(eventData)) {
    eventData = [];
    _classPrivateFieldGet(_listeners, this).set(event, eventData);
  }
  eventData.push({
    handler: handler,
    config: {
      once: once
    }
  });
  // Warn if listener count exceeds the max allowed
  var max = _classPrivateFieldGet(_maxListeners, this);
  if (max > 0 && eventData.length > max) {
    var warnMessage = "Possible memory leak detected. ".concat(eventData.length, " \"").concat(event, "\" listeners added. ") + "Use setMaxListeners() to increase limit.";
    if (!_classPrivateFieldGet(_throwMaxListeners, this)) console.warn(warnMessage);else throw new Error(warnMessage);
  }
}
var _default = exports["default"] = TinyEvents;

},{}],190:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var TinyCollision = _interopRequireWildcard(require("../basics/collision.mjs"));
var _TinyHtml;
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var areElsColliding = TinyCollision.areElsColliding,
  areElsPerfColliding = TinyCollision.areElsPerfColliding,
  areElsCollTop = TinyCollision.areElsCollTop,
  areElsCollBottom = TinyCollision.areElsCollBottom,
  areElsCollLeft = TinyCollision.areElsCollLeft,
  areElsCollRight = TinyCollision.areElsCollRight;
/**
 * Callback invoked on each animation frame with the current scroll position,
 * normalized animation time (`0` to `1`), and a completion flag.
 *
 * @typedef {(progress: { x: number, y: number, isComplete: boolean, time: number }) => void} OnScrollAnimation
 */
/**
 * A list of supported easing function names for smooth animations.
 *
 * @typedef {'linear' | 'easeInQuad' | 'easeOutQuad' | 'easeInOutQuad' | 'easeInCubic' | 'easeOutCubic' | 'easeInOutCubic'} Easings
 */
/**
 * Represents a raw Node element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {Node|TinyHtml|null} TinyNode
 */
/**
 * Represents a raw DOM element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {Element|TinyHtml} TinyElement
 */
/**
 * Represents a raw DOM html element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {HTMLElement|TinyHtml} TinyHtmlElement
 */
/**
 * Represents a raw DOM event target element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {EventTarget|TinyHtml} TinyEventTarget
 */
/**
 * Represents a raw DOM input element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {InputElement|TinyHtml} TinyInputElement
 */
/**
 * Represents a raw DOM element/window or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {ElementAndWindow|TinyHtml} TinyElementAndWindow
 */
/**
 * Represents a value that can be either a DOM Element or the global Window object.
 * Useful for functions that operate generically on scrollable or measurable targets.
 *
 * @typedef {Element|Window} ElementAndWindow
 */
/**
 * Represents a raw DOM element/window/document or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {ElementAndWinAndDoc|TinyHtml} TinyElementAndWinAndDoc
 */
/**
 * Represents a value that can be either a DOM Element, or the global Window object, or the document object.
 * Useful for functions that operate generically on scrollable or measurable targets.
 *
 * @typedef {Element|Window|Document} ElementAndWinAndDoc
 */
/**
 * Represents a raw DOM element with document or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {ElementWithDoc|TinyHtml} TinyElementWithDoc
 */
/**
 * Represents a value that can be either a DOM Element, or the document object.
 * Useful for functions that operate generically on measurable targets.
 *
 * @typedef {Element|Document} ElementWithDoc
 */
/**
 * A parameter type used for filtering or matching elements.
 * It can be:
 * - A string (CSS selector),
 * - A raw DOM element,
 * - An array of raw DOM elements,
 * - A filtering function that receives an index and element,
 *   and returns true if it matches.
 *
 * @typedef {string|Element|Element[]|((index: number, el: Element) => boolean)} WinnowRequest
 */
/**
 * Elements accepted as constructor values for TinyHtml.
 * These include common DOM elements and root containers.
 *
 * @typedef {Window|Element|Document|Text} ConstructorElValues
 */
/**
 * Options passed to `addEventListener` or `removeEventListener`.
 * Can be a boolean or an object of type `AddEventListenerOptions`.
 *
 * @typedef {boolean|AddEventListenerOptions} EventRegistryOptions
 */
/**
 * Structure describing a registered event callback and its options.
 *
 * @typedef {Object} EventRegistryItem
 * @property {EventListenerOrEventListenerObject|null} handler - The function to be executed when the event is triggered.
 * @property {EventRegistryOptions} [options] - Optional configuration passed to the listener.
 */
/**
 * Maps event names (e.g., `"click"`, `"keydown"`) to a list of registered handlers and options.
 *
 * @typedef {Record<string, EventRegistryItem[]>} EventRegistryList
 */
/**
 * WeakMap storing all event listeners per element.
 * Each element has a registry mapping event names to their handler lists.
 *
 * @type {WeakMap<ConstructorElValues|EventTarget, EventRegistryList>}
 */
var __eventRegistry = new WeakMap();
/**
 * A key-value store associated with a specific DOM element.
 * Keys are strings, and values can be of any type.
 *
 * @typedef {Record<string, *>} ElementDataStore
 */
/**
 * WeakMap to hold private data for elements
 *
 * @type {WeakMap<ConstructorElValues, ElementDataStore>}
 */
var __elementDataMap = new WeakMap();
/**
 * Stores directional collision locks separately.
 * Each direction has its own WeakMap to allow independent locking.
 *
 * @type {{
 *   top: WeakMap<Element, true>,
 *   bottom: WeakMap<Element, true>,
 *   left: WeakMap<Element, true>,
 *   right: WeakMap<Element, true>
 * }}
 */
var __elemCollision = {
  top: new WeakMap(),
  bottom: new WeakMap(),
  left: new WeakMap(),
  right: new WeakMap()
};
/**
 * Possible directions from which a collision was detected and locked.
 *
 * @typedef {'top'|'bottom'|'left'|'right'} CollisionDirLock
 */
/**
 * @typedef {Object} HtmlElBoxSides
 * @property {number} x - Total horizontal size (left + right)
 * @property {number} y - Total vertical size (top + bottom)
 * @property {number} left
 * @property {number} right
 * @property {number} top
 * @property {number} bottom
 */
/**
 * @typedef {string | number | Date | boolean | null} SetValueBase - Primitive types accepted as input values.
 */
/**
 * @typedef {'string' | 'date' | 'number'} GetValueTypes
 * Types of value extractors supported by TinyHtml._valTypes.
 */
/**
 * @typedef {SetValueBase|SetValueBase[]} SetValueList - A single value or an array of values to be assigned to the input element.
 */
/**
 * A list of HTML form elements that can have a `.value` property used by TinyHtml.
 * Includes common input types used in forms.
 *
 * @typedef {HTMLInputElement|HTMLSelectElement|HTMLTextAreaElement|HTMLOptionElement} InputElement
 */
/**
 * Represents a parsed HTML element in JSON-like array form.
 *
 * @typedef {[
 *   tagName: string, // The tag name of the element (e.g., 'div', 'img')
 *   attributes: Record<string, string>, // All element attributes as key-value pairs
 *   ...children: (string | HtmlParsed)[] // Text or nested elements
 * ]} HtmlParsed
 */
/**
 * TinyHtml is a utility class that provides static and instance-level methods
 * for precise dimension and position computations on HTML elements.
 * It mimics some jQuery functionalities while using native browser APIs.
 *
 * Inspired by the jQuery project's open source implementations of element dimension
 * and offset utilities. This class serves as a lightweight alternative using modern DOM APIs.
 *
 * @class
 */
var _el = /*#__PURE__*/new WeakMap();
var TinyHtml = /*#__PURE__*/function () {
  /**
   * Creates an instance of TinyHtml for a specific Element.
   * Useful when you want to operate repeatedly on the same element using instance methods.
   * @param {ConstructorElValues|ConstructorElValues[]|NodeListOf<Element>|HTMLCollectionOf<Element>|NodeListOf<HTMLElement>} el - The element to wrap and manipulate.
   */
  function TinyHtml(el) {
    _classCallCheck(this, TinyHtml);
    //////////////////////////////////////////////////////////////////
    /** @type {ElementDataStore} */
    _defineProperty(this, "_data", {});
    //////////////////////////////////////////////////////
    /**
     * The target HTML element for instance-level operations.
     * @type {ConstructorElValues[]}
     */
    _classPrivateFieldInitSpec(this, _el, void 0);
    if (el instanceof TinyHtml) throw new Error("[TinyHtml] You are trying to put a TinyHtml inside another TinyHtml in constructor.");
    /** @param {any[]} els */
    var elCheck = function elCheck(els) {
      if (!els.every(function (el) {
        return el instanceof Element || el instanceof Window || el instanceof Document || el instanceof Text;
      })) throw new Error("[TinyHtml] Invalid Target in constructor.");
    };
    if (Array.isArray(el)) {
      elCheck(el);
      _classPrivateFieldSet(_el, this, el);
    } else if (el instanceof NodeList || el instanceof HTMLCollection) {
      var els = _toConsumableArray(el);
      elCheck(els);
      _classPrivateFieldSet(_el, this, els);
    } else {
      var _els = [el];
      elCheck(_els);
      // @ts-ignore
      _classPrivateFieldSet(_el, this, _els);
    }
  }
  /**
   * Checks whether the given object is a window.
   * @param {*} obj - The object to test.
   * @returns {obj is Window} - True if it's a Window.
   */
  return _createClass(TinyHtml, [{
    key: "querySelector",
    value:
    /**
     * Queries the element for the first element matching the CSS selector and wraps it in a TinyHtml instance.
     *
     * @param {string} selector - A valid CSS selector string.
     * @returns {TinyHtml|null} A TinyHtml instance wrapping the matched element.
     */
    function querySelector(selector) {
      return TinyHtml.query(selector, TinyHtml._preElem(this, 'query'));
    }
    /**
     * Queries the document for all elements matching the CSS selector and wraps them in TinyHtml instances.
     *
     * @param {string} selector - A valid CSS selector string.
     * @param {Document|Element} elem - Target element.
     * @returns {TinyHtml} An array of TinyHtml instances wrapping the matched elements.
     */
  }, {
    key: "querySelectorAll",
    value:
    /**
     * Queries the element for all elements matching the CSS selector and wraps them in TinyHtml instances.
     *
     * @param {string} selector - A valid CSS selector string.
     * @returns {TinyHtml} An array of TinyHtml instances wrapping the matched elements.
     */
    function querySelectorAll(selector) {
      return TinyHtml.queryAll(selector, TinyHtml._preElem(this, 'queryAll'));
    }
    /**
     * Retrieves an element by its ID and wraps it in a TinyHtml instance.
     *
     * @param {string} selector - The ID of the element to retrieve.
     * @returns {TinyHtml|null} A TinyHtml instance wrapping the found element.
     */
  }, {
    key: "getElementsByClassName",
    value:
    /**
     * Retrieves all elements with the specified class name and wraps them in TinyHtml instances.
     *
     * @param {string} selector - The class name to search for.
     * @returns {TinyHtml} An array of TinyHtml instances wrapping the found elements.
     */
    function getElementsByClassName(selector) {
      return TinyHtml.getByClassName(selector, TinyHtml._preElem(this, 'getByClassName'));
    }
    /**
     * Retrieves all elements with the specified name attribute and wraps them in TinyHtml instances.
     *
     * @param {string} selector - The name attribute to search for.
     * @returns {TinyHtml} An array of TinyHtml instances wrapping the found elements.
     */
  }, {
    key: "getElementsByTagNameNS",
    value:
    /**
     * Retrieves all elements with the specified local tag name within the given namespace URI,
     * and wraps them in TinyHtml instances.
     *
     * @param {string} localName - The local name (tag) of the elements to search for.
     * @param {string|null} [namespaceURI='http://www.w3.org/1999/xhtml'] - The namespace URI to search within.
     * @returns {TinyHtml} An array of TinyHtml instances wrapping the found elements.
     */
    function getElementsByTagNameNS(localName) {
      var namespaceURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http://www.w3.org/1999/xhtml';
      return TinyHtml.getByTagNameNS(localName, namespaceURI, TinyHtml._preElem(this, 'getByTagNameNS'));
    }
    //////////////////////////////////////////////////////////////////
    /**
     * Returns the current target held by this instance.
     *
     * @param {number} index - The index of the element to retrieve.
     * @returns {ConstructorElValues} - The instance's target element.
     */
  }, {
    key: "get",
    value: function get(index) {
      if (typeof index !== 'number') throw new TypeError('The index must be a number.');
      if (!_classPrivateFieldGet(_el, this)[index]) throw new Error("No element found at index ".concat(index, "."));
      return _classPrivateFieldGet(_el, this)[index];
    }
    /**
     * Extracts a single DOM element from the internal list at the specified index.
     *
     * @param {number} index - The index of the element to extract.
     * @returns {TinyHtml} A new TinyHtml instance wrapping the extracted element.
     */
  }, {
    key: "extract",
    value: function extract(index) {
      if (typeof index !== 'number') throw new TypeError('The index must be a number.');
      if (!_classPrivateFieldGet(_el, this)[index]) throw new Error("Cannot extract: no element exists at index ".concat(index, "."));
      return new TinyHtml(_classPrivateFieldGet(_el, this)[index]);
    }
    /**
     * Checks whether the element exists at the given index.
     *
     * @param {number} index - The index to check.
     * @returns {boolean} - True if the element exists; otherwise, false.
     */
  }, {
    key: "exists",
    value: function exists(index) {
      if (typeof index !== 'number') throw new TypeError('The index must be a number.');
      if (!_classPrivateFieldGet(_el, this)[index]) return false;
      return true;
    }
    /**
     * Returns the current targets held by this instance.
     *
     * @returns {ConstructorElValues[]} - The instance's targets element.
     */
  }, {
    key: "getAll",
    value: function getAll() {
      return _toConsumableArray(_classPrivateFieldGet(_el, this));
    }
    /**
     * Returns the current Element held by this instance.
     *
     * @param {string} where - The method name or context calling this.
     * @param {number} index - The index of the element to retrieve.
     * @returns {ConstructorElValues} - The instance's element.
     * @readonly
     */
  }, {
    key: "_getElement",
    value: function _getElement(where, index) {
      if (!(_classPrivateFieldGet(_el, this)[index] instanceof Element) && !(_classPrivateFieldGet(_el, this)[index] instanceof Window) && !(_classPrivateFieldGet(_el, this)[index] instanceof Document) && !(_classPrivateFieldGet(_el, this)[index] instanceof Text)) throw new Error("[TinyHtml] Invalid Element in ".concat(where, "()."));
      return _classPrivateFieldGet(_el, this)[index];
    }
    /**
     * Returns the current Elements held by this instance.
     *
     * @param {string} where - The method name or context calling this.
     * @returns {ConstructorElValues[]} - The instance's elements.
     * @readonly
     */
  }, {
    key: "_getElements",
    value: function _getElements(where) {
      if (!_classPrivateFieldGet(_el, this).every(function (el) {
        return el instanceof Element || el instanceof Window || el instanceof Document || el instanceof Text;
      })) throw new Error("[TinyHtml] Invalid Element in ".concat(where, "()."));
      return _toConsumableArray(_classPrivateFieldGet(_el, this));
    }
    //////////////////////////////////////////////////////
    /**
     * Prepares and validates multiple elements against allowed types.
     *
     * @param {TinyElement | EventTarget | null | (TinyElement | EventTarget | null)[]} elems - The input elements to validate.
     * @param {string} where - The method name or context calling this.
     * @param {any[]} TheTinyElements - The list of allowed constructors (e.g., Element, Document).
     * @param {string[]} elemName - The list of expected element names for error reporting.
     * @returns {any[]} - A flat array of validated elements.
     * @throws {Error} - If any element is not an instance of one of the allowed types.
     * @readonly
     */
  }, {
    key: "not",
    value:
    /**
     * Returns only the elements **not** matching the given selector or function.
     *
     * @param {WinnowRequest} selector
     * @returns {Element[]}
     */
    function not(selector) {
      return TinyHtml.not(this, selector);
    }
    /**
     * Finds elements matching a selector within a context.
     *
     * @param {TinyElement|TinyElement[]} context
     * @param {string} selector
     * @returns {Element[]}
     */
  }, {
    key: "find",
    value:
    /**
     * Finds elements in your element matching a selector within a context.
     *
     * @param {string} selector
     * @returns {Element[]}
     */
    function find(selector) {
      return TinyHtml.find(this, selector);
    }
    /**
     * Checks if at least one element matches the selector.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {WinnowRequest} selector
     * @returns {boolean}
     */
  }, {
    key: "is",
    value:
    /**
     * Checks if the element matches the selector.
     *
     * @param {WinnowRequest} selector
     * @returns {boolean}
     */
    function is(selector) {
      return TinyHtml.is(this, selector);
    }
    /**
     * Returns elements from the current list that contain the given target(s).
     * @param {TinyElement|TinyElement[]} roots - A single element or an array of elements (DOM or TinyHtml).
     * @param {string|TinyElement|TinyElement[]} target - Selector or DOM element(s).
     * @returns {Element[]} Elements that contain the target.
     */
  }, {
    key: "has",
    value:
    /**
     * Return if the element has the target(s).
     * @param {string|TinyElement|TinyElement[]} target - Selector or DOM element(s).
     * @returns {boolean} Elements that contain the target.
     */
    function has(target) {
      return TinyHtml.has(this, target).length > 0;
    }
    /**
     * Finds the closest ancestor (including self) that matches the selector.
     *
     * @param {TinyElement|TinyElement[]} els - A single element or an array of elements (DOM or TinyHtml).
     * @param {string|Element} selector - A selector string or DOM element to match.
     * @param {Element|null} [context] - An optional context to stop searching.
     * @returns {Element[]}
     */
  }, {
    key: "closest",
    value:
    /**
     * Finds the closest ancestor (including self) that matches the selector.
     *
     * @param {string|Element} selector - A selector string or DOM element to match.
     * @param {Element|null} [context] - An optional context to stop searching.
     * @returns {Element[]}
     */
    function closest(selector, context) {
      return TinyHtml.closest(this, selector, context);
    }
    /**
     * Compares two DOM elements to determine if they refer to the same node in the document.
     *
     * This performs a strict equality check (`===`) between the two elements.
     *
     * @param {TinyNode} elem - The first DOM element to compare.
     * @param {TinyNode} otherElem - The second DOM element to compare.
     * @returns {boolean} `true` if both elements are the same DOM node; otherwise, `false`.
     */
  }, {
    key: "isSameDom",
    value:
    /**
     * Compares two DOM elements to determine if they refer to the same node in the document.
     *
     * This performs a strict equality check (`===`) between the two elements.
     *
     * @param {TinyNode} elem - The DOM element to compare.
     * @returns {boolean} `true` if both elements are the same DOM node; otherwise, `false`.
     */
    function isSameDom(elem) {
      return TinyHtml.isSameDom(this, elem);
    }
  }, {
    key: "data",
    value:
    /**
     * Retrieves data associated with a DOM element.
     *
     * If a `key` is provided, the corresponding value is returned.
     * If no `key` is given, a shallow copy of all stored data is returned.
     *
     * @param {string} [key] - The specific key to retrieve from the data store.
     * @param {boolean} [isPrivate=false] - Whether to access the private data store.
     * @returns {ElementDataStore|undefined|any} - The stored value, all data, or undefined if the key doesn't exist.
     */
    function data(key, isPrivate) {
      return TinyHtml.data(this, key, isPrivate);
    }
    /**
     * Stores a value associated with a specific key for a DOM element.
     *
     * @param {TinyElement} el - The DOM element.
     * @param {string} key - The key under which the data will be stored.
     * @param {any} value - The value to store.
     * @param {boolean} [isPrivate=false] - Whether to store the data in the private store.
     * @returns {TinyElement}
     */
  }, {
    key: "setData",
    value:
    /**
     * Stores a value associated with a specific key for a DOM element.
     *
     * @param {string} key - The key under which the data will be stored.
     * @param {any} value - The value to store.
     * @param {boolean} [isPrivate=false] - Whether to store the data in the private store.
     * @returns {TinyElement}
     */
    function setData(key, value) {
      var isPrivate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return TinyHtml.setData(this, key, value, isPrivate);
    }
    //////////////////////////////////////////////////////
    /**
     * Get the sibling element in a given direction.
     *
     * @param {TinyNode} el
     * @param {"previousSibling"|"nextSibling"} direction
     * @param {string} where
     * @returns {ChildNode|null}
     * @readonly
     */
  }, {
    key: "parent",
    value:
    /**
     * Returns the direct parent node of the given element, excluding document fragments.
     *
     * @returns {ParentNode|null} The parent node or null if not found.
     */
    function parent() {
      return TinyHtml.parent(this);
    }
    /**
     * Returns all ancestor nodes of the given element, optionally stopping before a specific ancestor.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of ancestor nodes.
     */
  }, {
    key: "parents",
    value:
    /**
     * Returns all ancestor nodes of the given element, optionally stopping before a specific ancestor.
     *
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of ancestor nodes.
     */
    function parents(until) {
      return TinyHtml.parents(this, until);
    }
    /**
     * Returns the next sibling of the given element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @returns {ChildNode|null} The next sibling or null if none found.
     */
  }, {
    key: "next",
    value:
    /**
     * Returns the next sibling of the given element.
     *
     * @returns {ChildNode|null} The next sibling or null if none found.
     */
    function next() {
      return TinyHtml.next(this);
    }
    /**
     * Returns the previous sibling of the given element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @returns {ChildNode|null} The previous sibling or null if none found.
     */
  }, {
    key: "prev",
    value:
    /**
     * Returns the previous sibling of the given element.
     *
     * @returns {ChildNode|null} The previous sibling or null if none found.
     */
    function prev() {
      return TinyHtml.prev(this);
    }
    /**
     * Returns all next sibling nodes after the given element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @returns {ChildNode[]} An array of next sibling nodes.
     */
  }, {
    key: "nextAll",
    value:
    /**
     * Returns all next sibling nodes after the given element.
     *
     * @returns {ChildNode[]} An array of next sibling nodes.
     */
    function nextAll() {
      return TinyHtml.nextAll(this);
    }
    /**
     * Returns all previous sibling nodes before the given element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @returns {ChildNode[]} An array of previous sibling nodes.
     */
  }, {
    key: "prevAll",
    value:
    /**
     * Returns all previous sibling nodes before the given element.
     *
     * @returns {ChildNode[]} An array of previous sibling nodes.
     */
    function prevAll() {
      return TinyHtml.prevAll(this);
    }
    /**
     * Returns all next sibling nodes up to (but not including) the node matched by a selector or element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of next sibling nodes.
     */
  }, {
    key: "nextUntil",
    value:
    /**
     * Returns all next sibling nodes up to (but not including) the node matched by a selector or element.
     *
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of next sibling nodes.
     */
    function nextUntil(until) {
      return TinyHtml.nextUntil(this, until);
    }
    /**
     * Returns all previous sibling nodes up to (but not including) the node matched by a selector or element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of previous sibling nodes.
     */
  }, {
    key: "prevUntil",
    value:
    /**
     * Returns all previous sibling nodes up to (but not including) the node matched by a selector or element.
     *
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of previous sibling nodes.
     */
    function prevUntil(until) {
      return TinyHtml.prevUntil(this, until);
    }
    /**
     * Returns all sibling nodes of the given element, excluding itself.
     *
     * @param {TinyNode} el - The DOM node to find siblings of.
     * @returns {ChildNode[]} An array of sibling nodes.
     */
  }, {
    key: "siblings",
    value:
    /**
     * Returns all sibling nodes of the given element, excluding itself.
     *
     * @returns {ChildNode[]} An array of sibling nodes.
     */
    function siblings() {
      return TinyHtml.siblings(this);
    }
    /**
     * Returns all child nodes of the given element.
     *
     * @param {TinyNode} el - The DOM node to get children from.
     * @returns {ChildNode[]} An array of child nodes.
     */
  }, {
    key: "children",
    value:
    /**
     * Returns all child nodes of the given element.
     *
     * @returns {ChildNode[]} An array of child nodes.
     */
    function children() {
      return TinyHtml.children(this);
    }
    /**
     * Returns the contents of the given node. For `<template>` it returns its content; for `<iframe>`, the document.
     *
     * @param {TinyNode} el - The DOM node to get contents from.
     * @returns {(ChildNode|DocumentFragment)[]|Document[]} An array of child nodes or the content document of an iframe.
     */
  }, {
    key: "contents",
    value:
    /**
     * Returns the contents of the given node. For `<template>` it returns its content; for `<iframe>`, the document.
     *
     * @returns {(ChildNode|DocumentFragment)[]|Document[]} An array of child nodes or the content document of an iframe.
     */
    function contents() {
      return TinyHtml.contents(this);
    }
    /**
     * Clone each element.
     * @param {TinyNode|TinyNode[]} el
     * @param {boolean} [deep=true]
     * @returns {Node[]}
     */
  }, {
    key: "clone",
    value:
    /**
     * Clone the element.
     * @param {boolean} [deep=true]
     * @returns {Node}
     */
    function clone(deep) {
      return TinyHtml.clone(this, deep)[0];
    }
    /**
     * Normalize and validate nodes before DOM insertion.
     * Converts TinyNode-like structures or strings into DOM-compatible nodes.
     * @type {(where: string, ...nodes: (TinyNode | TinyNode[] | string)[]) => (Node | string)[]}
     * @readonly
     */
  }, {
    key: "append",
    value:
    /**
     * Appends child elements or strings to the end of the target element(s).
     *
     * @param {...(TinyNode | TinyNode[] | string)} children - The child elements or text to append.
     * @returns {TinyElement}
     */
    function append() {
      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
        children[_key] = arguments[_key];
      }
      return TinyHtml.append.apply(TinyHtml, [this].concat(children));
    }
    /**
     * Prepends child elements or strings to the beginning of the target element(s).
     *
     * @param {TinyElement} el - The target element(s) to receive children.
     * @param {...(TinyNode | TinyNode[] | string)} children - The child elements or text to prepend.
     * @returns {TinyElement}
     */
  }, {
    key: "prepend",
    value:
    /**
     * Prepends child elements or strings to the beginning of the target element(s).
     *
     * @param {...(TinyNode | TinyNode[] | string)} children - The child elements or text to prepend.
     * @returns {TinyElement}
     */
    function prepend() {
      for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        children[_key2] = arguments[_key2];
      }
      return TinyHtml.prepend.apply(TinyHtml, [this].concat(children));
    }
    /**
     * Inserts elements or strings immediately before the target element(s) in the DOM.
     *
     * @param {TinyElement} el - The target element(s) before which new content is inserted.
     * @param {...(TinyNode | TinyNode[] | string)} children - Elements or text to insert before the target.
     * @returns {TinyElement}
     */
  }, {
    key: "before",
    value:
    /**
     * Inserts elements or strings immediately before the target element(s) in the DOM.
     *
     * @param {...(TinyNode | TinyNode[] | string)} children - Elements or text to insert before the target.
     * @returns {TinyElement}
     */
    function before() {
      for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        children[_key3] = arguments[_key3];
      }
      return TinyHtml.before.apply(TinyHtml, [this].concat(children));
    }
    /**
     * Inserts elements or strings immediately after the target element(s) in the DOM.
     *
     * @param {TinyElement} el - The target element(s) after which new content is inserted.
     * @param {...(TinyNode | TinyNode[] | string)} children - Elements or text to insert after the target.
     * @returns {TinyElement}
     */
  }, {
    key: "after",
    value:
    /**
     * Inserts elements or strings immediately after the target element(s) in the DOM.
     *
     * @param {...(TinyNode | TinyNode[] | string)} children - Elements or text to insert after the target.
     * @returns {TinyElement}
     */
    function after() {
      for (var _len4 = arguments.length, children = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        children[_key4] = arguments[_key4];
      }
      return TinyHtml.after.apply(TinyHtml, [this].concat(children));
    }
    /**
     * Replaces the target element(s) in the DOM with new elements or text.
     *
     * @param {TinyElement} el - The element(s) to be replaced.
     * @param {...(TinyNode | TinyNode[] | string)} newNodes - New elements or text to replace the target.
     * @returns {TinyElement}
     */
  }, {
    key: "replaceWith",
    value:
    /**
     * Replaces the target element(s) in the DOM with new elements or text.
     *
     * @param {...(TinyNode | TinyNode[] | string)} newNodes - New elements or text to replace the target.
     * @returns {TinyElement}
     */
    function replaceWith() {
      for (var _len5 = arguments.length, newNodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        newNodes[_key5] = arguments[_key5];
      }
      return TinyHtml.replaceWith.apply(TinyHtml, [this].concat(newNodes));
    }
    /**
     * Appends the given element(s) to each target element in sequence.
     *
     * @param {TinyNode | TinyNode[]} el - The element(s) to append.
     * @param {TinyNode | TinyNode[]} targets - Target element(s) where content will be appended.
     * @returns {TinyNode|TinyNode[]}
     */
  }, {
    key: "appendTo",
    value:
    /**
     * Appends the given element(s) to each target element in sequence.
     *
     * @param {TinyNode | TinyNode[]} targets - Target element(s) where content will be appended.
     * @returns {TinyNode|TinyNode[]}
     */
    function appendTo(targets) {
      return TinyHtml.appendTo(this, targets);
    }
    /**
     * Prepends the given element(s) to each target element in sequence.
     *
     * @param {TinyElement | TinyElement[]} el - The element(s) to prepend.
     * @param {TinyElement | TinyElement[]} targets - Target element(s) where content will be prepended.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "prependTo",
    value:
    /**
     * Prepends the given element(s) to each target element in sequence.
     *
     * @param {TinyElement | TinyElement[]} targets - Target element(s) where content will be prepended.
     * @returns {TinyElement|TinyElement[]}
     */
    function prependTo(targets) {
      return TinyHtml.prependTo(this, targets);
    }
    /**
     * Inserts the element before a child of a given target, or before the target itself.
     *
     * @param {TinyNode | TinyNode[]} el - The element(s) to insert.
     * @param {TinyNode | TinyNode[]} target - The reference element where insertion happens.
     * @param {TinyNode | TinyNode[] | null} [child=null] - Optional child to insert before, defaults to target.
     * @returns {TinyNode|TinyNode[]}
     */
  }, {
    key: "insertBefore",
    value:
    /**
     * Inserts the element before a child of a given target, or before the target itself.
     *
     * @param {TinyNode | TinyNode[]} target - The reference element where insertion happens.
     * @param {TinyNode | TinyNode[] | null} [child=null] - Optional child to insert before, defaults to target.
     * @returns {TinyNode|TinyNode[]}
     */
    function insertBefore(target, child) {
      return TinyHtml.insertBefore(this, target, child);
    }
    /**
     * Inserts the element after a child of a given target, or after the target itself.
     *
     * @param {TinyNode | TinyNode[]} el - The element(s) to insert.
     * @param {TinyNode | TinyNode[]} target - The reference element where insertion happens.
     * @param {TinyNode | TinyNode[] | null} [child=null] - Optional child to insert after, defaults to target.
     * @returns {TinyNode|TinyNode[]}
     */
  }, {
    key: "insertAfter",
    value:
    /**
     * Inserts the element after a child of a given target, or after the target itself.
     *
     * @param {TinyNode | TinyNode[]} target - The reference element where insertion happens.
     * @param {TinyNode | TinyNode[] | null} [child=null] - Optional child to insert after, defaults to target.
     * @returns {TinyNode|TinyNode[]}
     */
    function insertAfter(target, child) {
      return TinyHtml.insertAfter(this, target, child);
    }
    /**
     * Replaces all target elements with the provided element(s).
     * If multiple targets exist, the inserted elements are cloned accordingly.
     *
     * @param {TinyNode | TinyNode[]} el - The new element(s) to insert.
     * @param {TinyNode | TinyNode[]} targets - The elements to be replaced.
     * @returns {TinyNode|TinyNode[]}
     */
  }, {
    key: "replaceAll",
    value:
    /**
     * Replaces all target elements with the provided element(s).
     * If multiple targets exist, the inserted elements are cloned accordingly.
     *
     * @param {TinyNode | TinyNode[]} targets - The elements to be replaced.
     * @returns {TinyNode|TinyNode[]}
     */
    function replaceAll(targets) {
      return TinyHtml.replaceAll(this, targets);
    }
  }, {
    key: "size",
    get:
    /**
     * Returns the number of elements currently stored in the internal element list.
     *
     * @returns {number} The total count of elements.
     */
    function get() {
      return _classPrivateFieldGet(_el, this).length;
    }
  }, {
    key: "css",
    value:
    /**
     * Returns the full computed CSS styles for the given element.
     *
     * @returns {CSSStyleDeclaration} The computed style object for the element.
     */
    function css() {
      return TinyHtml.css(this);
    }
    /**
     * Returns the value of a specific computed CSS property from the given element as a string.
     *
     * @param {TinyElement} el - The element to retrieve the style property from.
     * @param {string} prop - The name of the CSS property (camelCase or kebab-case).
     * @returns {string|null} The value of the CSS property as a string, or null if not found or invalid.
     */
  }, {
    key: "cssString",
    value:
    /**
     * Returns the value of a specific computed CSS property from the given element as a string.
     *
     * @param {string} prop - The name of the CSS property (camelCase or kebab-case).
     * @returns {string|null} The value of the CSS property as a string, or null if not found or invalid.
     */
    function cssString(prop) {
      return TinyHtml.cssString(this, prop);
    }
    /**
     * Returns a subset of computed CSS styles based on the given list of properties.
     *
     * @param {TinyElement} el - The element to retrieve styles from.
     * @param {string[]} prop - An array of CSS property names to retrieve.
     * @returns {Partial<CSSStyleDeclaration>} An object containing the requested styles.
     */
  }, {
    key: "cssList",
    value:
    /**
     * Returns a subset of computed CSS styles based on the given list of properties.
     *
     * @param {string[]} prop - An array of CSS property names to retrieve.
     * @returns {Partial<CSSStyleDeclaration>} An object containing the requested styles.
     */
    function cssList(prop) {
      return TinyHtml.cssList(this, prop);
    }
    /**
     * Returns the computed CSS float value of a property.
     * @param {TinyElement} el - The element to inspect.
     * @param {string} prop - The CSS property.
     * @returns {number} - The parsed float value.
     */
  }, {
    key: "cssFloat",
    value:
    /**
     * Returns the computed CSS float value of a property.
     * @param {string} prop - The CSS property.
     * @returns {number} - The parsed float value.
     */
    function cssFloat(prop) {
      return TinyHtml.cssFloat(this, prop);
    }
    /**
     * Returns computed float values of multiple CSS properties.
     * @param {TinyElement} el - The element to inspect.
     * @param {string[]} prop - An array of CSS properties.
     * @returns {Record<string, number>} - Map of property to float value.
     */
  }, {
    key: "cssFloats",
    value:
    /**
     * Returns computed float values of multiple CSS properties.
     * @param {string[]} prop - An array of CSS properties.
     * @returns {Record<string, number>} - Map of property to float value.
     */
    function cssFloats(prop) {
      return TinyHtml.cssFloats(this, prop);
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Stores camelCase to kebab-case CSS property aliases.
     *
     * Used to normalize property names when interacting with `element.style` or `getComputedStyle`.
     *
     * â ï¸ This object should not be modified directly. Use `TinyHtml.cssPropAliases` instead to ensure reverse mappings stay in sync.
     *
     * Example of how to add a new alias:
     *
     * ```js
     * TinyHtml.cssPropAliases.tinyPudding = 'tiny-pudding';
     * ```
     *
     * This will automatically update `TinyHtml.cssPropRevAliases['tiny-pudding']` with `'tinyPudding'`.
     *
     * @type {Record<string | symbol, string>}
     */
  }, {
    key: "setStyle",
    value:
    /**
     * Sets one or more CSS inline style properties on the given element(s).
     *
     * - If `prop` is a string, the `value` will be applied to that property.
     * - If `prop` is an object, each key-value pair will be applied as a CSS property and value.
     *
     * @param {string|Object} prop - The property name or an object with key-value pairs
     * @param {string|null} [value=null] - The value to set (if `prop` is a string)
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
    function setStyle(prop, value) {
      return TinyHtml.setStyle(this, prop, value);
    }
    /**
     * Gets the value of a specific inline style property.
     *
     * Returns only the value set directly via the `style` attribute.
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - A single element to inspect.
     * @param {string} prop - The style property name to retrieve.
     * @returns {string} The style value of the specified property.
     */
  }, {
    key: "getStyle",
    value:
    /**
     * Gets the value of a specific inline style property.
     *
     * Returns only the value set directly via the `style` attribute.
     *
     * @param {string} prop - The style property name to retrieve.
     * @returns {string} The style value of the specified property.
     */
    function getStyle(prop) {
      return TinyHtml.getStyle(this, prop);
    }
    /**
     * Gets all inline styles defined directly on the element (`style` attribute).
     *
     * Returns an object with all property-value pairs in kebab-case format.
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - A single element to inspect.
     * @param {Object} [settings={}] - Optional configuration settings.
     * @param {boolean} [settings.camelCase=false] - If `true`, the property names will be converted to camelCase.
     * @param {boolean} [settings.rawAttr=false] - If `true`, reads the style string from the `style` attribute instead of using the style object.
     * @returns {Record<string, string>} All inline styles as an object.
     *
     * @throws {TypeError} If `camelCase` or `rawAttr` is not a boolean.
     */
  }, {
    key: "style",
    value:
    /**
     * Gets all inline styles defined directly on the element (`style` attribute).
     *
     * Returns an object with all property-value pairs in kebab-case format.
     *
     * @param {Object} [settings={}] - Optional configuration settings.
     * @param {boolean} [settings.camelCase=false] - If `true`, the property names will be converted to camelCase.
     * @param {boolean} [settings.rawAttr=false] - If `true`, reads the style string from the `style` attribute instead of using the style object.
     * @returns {Record<string, string>} All inline styles as an object.
     */
    function style(settings) {
      return TinyHtml.style(this, settings);
    }
    /**
     * Removes one or more inline CSS properties from the given element(s).
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - A single element or an array of elements.
     * @param {string|string[]} prop - A property name or an array of property names to remove.
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
  }, {
    key: "removeStyle",
    value:
    /**
     * Removes one or more inline CSS properties from the given element(s).
     *
     * @param {string|string[]} prop - A property name or an array of property names to remove.
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
    function removeStyle(prop) {
      return TinyHtml.removeStyle(this, prop);
    }
    /**
     * Toggles a CSS property value between two given values.
     *
     * The current computed value is compared to `val1`. If it matches, the property is set to `val2`. Otherwise, it is set to `val1`.
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - A single element or an array of elements.
     * @param {string} prop - The CSS property to toggle.
     * @param {string} val1 - The first value (used as "current" check).
     * @param {string} val2 - The second value (used as the "alternative").
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
  }, {
    key: "toggleStyle",
    value:
    /**
     * Toggles a CSS property value between two given values.
     *
     * The current computed value is compared to `val1`. If it matches, the property is set to `val2`. Otherwise, it is set to `val1`.
     *
     * @param {string} prop - The CSS property to toggle.
     * @param {string} val1 - The first value (used as "current" check).
     * @param {string} val2 - The second value (used as the "alternative").
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
    function toggleStyle(prop, val1, val2) {
      return TinyHtml.toggleStyle(this, prop, val1, val2);
    }
    /**
     * Removes all inline styles (`style` attribute) from the given element(s).
     *
     * @param {TinyElement|TinyElement[]} el - A single element or an array of elements.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "clearStyle",
    value:
    /**
     * Removes all inline styles (`style` attribute) from the given element(s).
     * @returns {TinyElement|TinyElement[]}
     */
    function clearStyle() {
      return TinyHtml.clearStyle(this);
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Focus the element.
     *
     * @param {TinyHtmlElement} el - The element or a selector string.
     * @returns {TinyHtmlElement}
     */
  }, {
    key: "focus",
    value:
    /**
     * Focus the element.
     * @returns {TinyHtmlElement}
     */
    function focus() {
      return TinyHtml.focus(this);
    }
    /**
     * Blur the element.
     *
     * @param {TinyHtmlElement} el - The element or a selector string.
     * @returns {TinyHtmlElement}
     */
  }, {
    key: "blur",
    value:
    /**
     * Blur the element.
     * @returns {TinyHtmlElement}
     */
    function blur() {
      return TinyHtml.blur(this);
    }
    /**
     * Interprets a value as a boolean `true` if it matches a common truthy representation.
     *
     * This method checks if the input is any of the common forms used to represent `true`,
     * such as the string `'true'`, `'1'`, `'on'`, the boolean `true`, or the number `1`.
     *
     * @param {string|boolean|number} [value] - The value to interpret as boolean.
     * @returns {boolean} `true` if the value represents a truthy state, otherwise `false`.
     */
  }, {
    key: "getDimension",
    value:
    /**
     * Gets the width or height of an element based on the box model.
     * @param {"width"|"height"} type - Dimension type.
     * @param {"content"|"padding"|"border"|"margin"} extra - Box model context.
     * @returns {number} - Computed dimension.
     */
    function getDimension(type, extra) {
      return TinyHtml.getDimension(this, type, extra);
    }
    /**
     * Sets the height of the element.
     * @param {TinyHtmlElement} el - Target element.
     * @param {string|number} value - Height value.
     * @throws {TypeError} If `value` is neither a string nor number.
     * @returns {TinyHtmlElement}
     */
  }, {
    key: "setHeight",
    value:
    /**
     * Sets the height of the element.
     * @param {string|number} value - Height value.
     * @returns {TinyHtmlElement}
     */
    function setHeight(value) {
      return TinyHtml.setHeight(this, value);
    }
    /**
     * Sets the width of the element.
     * @param {TinyHtmlElement} el - Target element.
     * @param {string|number} value - Width value.
     * @throws {TypeError} If `value` is neither a string nor number.
     * @returns {TinyHtmlElement}
     */
  }, {
    key: "setWidth",
    value:
    /**
     * Sets the width of the element.
     * @param {string|number} value - Width value.
     * @returns {TinyHtmlElement}
     */
    function setWidth(value) {
      return TinyHtml.setWidth(this, value);
    }
    /**
     * Returns content box height.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @returns {number}
     */
  }, {
    key: "height",
    value:
    /**
     * Returns content box height.
     * @returns {number}
     */
    function height() {
      return TinyHtml.height(this);
    }
    /**
     * Returns content box width.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @returns {number}
     */
  }, {
    key: "width",
    value:
    /**
     * Returns content box width.
     * @returns {number}
     */
    function width() {
      return TinyHtml.width(this);
    }
    /**
     * Returns padding box height.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @returns {number}
     */
  }, {
    key: "innerHeight",
    value:
    /**
     * Returns padding box height.
     * @returns {number}
     */
    function innerHeight() {
      return TinyHtml.innerHeight(this);
    }
    /**
     * Returns padding box width.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @returns {number}
     */
  }, {
    key: "innerWidth",
    value:
    /**
     * Returns padding box width.
     * @returns {number}
     */
    function innerWidth() {
      return TinyHtml.innerWidth(this);
    }
    /**
     * Returns outer height of the element, optionally including margin.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @param {boolean} [includeMargin=false] - Whether to include margin.
     * @returns {number}
     */
  }, {
    key: "outerHeight",
    value:
    /**
     * Returns outer height of the element, optionally including margin.
     * @param {boolean} [includeMargin=false] - Whether to include margin.
     * @returns {number}
     */
    function outerHeight(includeMargin) {
      return TinyHtml.outerHeight(this, includeMargin);
    }
    /**
     * Returns outer width of the element, optionally including margin.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @param {boolean} [includeMargin=false] - Whether to include margin.
     * @returns {number}
     */
  }, {
    key: "outerWidth",
    value:
    /**
     * Returns outer width of the element, optionally including margin.
     * @param {boolean} [includeMargin=false] - Whether to include margin.
     * @returns {number}
     */
    function outerWidth(includeMargin) {
      return TinyHtml.outerWidth(this, includeMargin);
    }
    //////////////////////////////////////////////////
    /**
     * Applies an animation to one or multiple TinyElement instances.
     *
     * @param {TinyElement|TinyElement[]} el - A single TinyElement or an array of TinyElements to animate.
     * @param {Keyframe[] | PropertyIndexedKeyframes | null} keyframes - The keyframes used to define the animation.
     * @param {number | KeyframeAnimationOptions} [ops] - Timing or configuration options for the animation.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "animate",
    value:
    /**
     * Applies an animation to one or multiple TinyElement instances.
     *
     * @param {Keyframe[] | PropertyIndexedKeyframes | null} keyframes - The keyframes used to define the animation.
     * @param {number | KeyframeAnimationOptions} [ops] - Timing or configuration options for the animation.
     * @returns {TinyElement|TinyElement[]}
     */
    function animate(keyframes, ops) {
      return TinyHtml.animate(this, keyframes, ops);
    }
    /**
     * Gets the offset of the element relative to the document.
     * @param {TinyElement} el - Target element.
     * @returns {{top: number, left: number}}
     */
  }, {
    key: "offset",
    value:
    /**
     * Gets the offset of the element relative to the document.
     * @returns {{top: number, left: number}}
     */
    function offset() {
      return TinyHtml.offset(this);
    }
    /**
     * Gets the position of the element relative to its offset parent.
     * @param {TinyHtmlElement} el - Target element.
     * @returns {{top: number, left: number}}
     */
  }, {
    key: "position",
    value:
    /**
     * Gets the position of the element relative to its offset parent.
     * @returns {{top: number, left: number}}
     */
    function position() {
      return TinyHtml.position(this);
    }
    /**
     * Gets the closest positioned ancestor element.
     * @param {TinyHtmlElement} el - Target element.
     * @returns {HTMLElement} - Offset parent element.
     */
  }, {
    key: "offsetParent",
    value:
    /**
     * Gets the closest positioned ancestor element.
     * @returns {HTMLElement} - Offset parent element.
     */
    function offsetParent() {
      return TinyHtml.offsetParent(this);
    }
    /**
     * Gets the vertical scroll position.
     * @param {TinyElementAndWindow} el - Element or window.
     * @returns {number}
     */
  }, {
    key: "scrollTop",
    value:
    /**
     * Gets the vertical scroll position.
     * @returns {number}
     */
    function scrollTop() {
      return TinyHtml.scrollTop(this);
    }
    /**
     * Gets the horizontal scroll position.
     * @param {TinyElementAndWindow} el - Element or window.
     * @returns {number}
     */
  }, {
    key: "scrollLeft",
    value:
    /**
     * Gets the horizontal scroll position.
     * @returns {number}
     */
    function scrollLeft() {
      return TinyHtml.scrollLeft(this);
    }
    /**
     * Collection of easing functions used for scroll and animation calculations.
     * Each function receives a normalized time value (`t` from 0 to 1) and returns the eased progress.
     *
     * @type {Record<string, (t: number) => number>}
     */
  }, {
    key: "scrollToXY",
    value:
    /**
     * Smoothly scrolls one or more elements (or the window) to the specified X and Y coordinates
     * using a custom duration and easing function.
     *
     * If `duration` or a valid `easing` is not provided, the scroll will be performed immediately.
     *
     * @param {Object} [settings={}] - Configuration object for the scroll animation.
     * @param {number} [settings.targetX] - The horizontal scroll target in pixels.
     * @param {number} [settings.targetY] - The vertical scroll target in pixels.
     * @param {number} [settings.duration] - The duration of the animation in milliseconds.
     * @param {Easings} [settings.easing] - The easing function name to use for the scroll animation.
     * @param {OnScrollAnimation} [settings.onAnimation] - Optional callback invoked on each animation
     *   frame with the current scroll position, normalized animation time (`0` to `1`), and a completion flag.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
    function scrollToXY() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        targetX = _ref.targetX,
        targetY = _ref.targetY,
        duration = _ref.duration,
        easing = _ref.easing,
        onAnimation = _ref.onAnimation;
      return TinyHtml.scrollToXY(this, {
        targetX: targetX,
        targetY: targetY,
        duration: duration,
        easing: easing,
        onAnimation: onAnimation
      });
    }
    /**
     * Sets the vertical scroll position.
     * @param {TinyElementAndWindow|TinyElementAndWindow[]} el - Element or window.
     * @param {number} value - Scroll top value.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
  }, {
    key: "setScrollTop",
    value:
    /**
     * Sets the vertical scroll position.
     * @param {number} value - Scroll top value.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
    function setScrollTop(value) {
      return TinyHtml.setScrollTop(this, value);
    }
    /**
     * Sets the horizontal scroll position.
     * @param {TinyElementAndWindow|TinyElementAndWindow[]} el - Element or window.
     * @param {number} value - Scroll left value.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
  }, {
    key: "setScrollLeft",
    value:
    /**
     * Sets the horizontal scroll position.
     * @param {number} value - Scroll left value.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
    function setScrollLeft(value) {
      return TinyHtml.setScrollLeft(this, value);
    }
    /**
     * Returns the total border width and individual sides from `border{Side}Width` CSS properties.
     *
     * @param {TinyElement} el - The target DOM element.
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border widths, and each side individually.
     */
  }, {
    key: "borderWidth",
    value:
    /**
     * Returns the total border width and individual sides from `border{Side}Width` CSS properties.
     *
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border widths, and each side individually.
     */
    function borderWidth() {
      return TinyHtml.borderWidth(this);
    }
    /**
     * Returns the total border size and individual sides from `border{Side}` CSS properties.
     *
     * @param {TinyElement} el - The target DOM element.
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border sizes, and each side individually.
     */
  }, {
    key: "border",
    value:
    /**
     * Returns the total border size and individual sides from `border{Side}` CSS properties.
     *
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border sizes, and each side individually.
     */
    function border() {
      return TinyHtml.border(this);
    }
    /**
     * Returns the total margin and individual sides from `margin{Side}` CSS properties.
     *
     * @param {TinyElement} el - The target DOM element.
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) margins, and each side individually.
     */
  }, {
    key: "margin",
    value:
    /**
     * Returns the total margin and individual sides from `margin{Side}` CSS properties.
     *
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) margins, and each side individually.
     */
    function margin() {
      return TinyHtml.margin(this);
    }
    /**
     * Returns the total padding and individual sides from `padding{Side}` CSS properties.
     *
     * @param {TinyElement} el - The target DOM element.
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) paddings, and each side individually.
     */
  }, {
    key: "padding",
    value:
    /**
     * Returns the total padding and individual sides from `padding{Side}` CSS properties.
     *
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) paddings, and each side individually.
     */
    function padding() {
      return TinyHtml.padding(this);
    }
    /////////////////////////////////////////////
    /**
     * Adds one or more CSS class names to the element.
     * @type {(el: TinyElement|TinyElement[], ...tokens: string[]) => (TinyElement|TinyElement[])} - One or more class names to add.
     */
  }, {
    key: "addClass",
    value:
    /**
     * Adds one or more CSS class names to the element.
     * @type {(...tokens: string[]) => (TinyElement|TinyElement[])} - One or more class names to add.
     */
    function addClass() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return TinyHtml.addClass.apply(TinyHtml, [this].concat(args));
    }
    /**
     * Removes one or more CSS class names from the element.
     * @type {(el: TinyElement|TinyElement[], ...tokens: string[]) => (TinyElement|TinyElement[])} - One or more class names to remove.
     */
  }, {
    key: "removeClass",
    value:
    /**
     * Removes one or more CSS class names from the element.
     * @type {(...tokens: string[]) => (TinyElement|TinyElement[])} - One or more class names to remove.
     */
    function removeClass() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return TinyHtml.removeClass.apply(TinyHtml, [this].concat(args));
    }
    /**
     * Replaces an existing class name with a new one.
     * @param {TinyElement|TinyElement[]} el - Target element.
     * @param {string} token - The class name to be replaced.
     * @param {string} newToken - The new class name to apply.
     * @returns {boolean[]} Whether the replacement was successful.
     * @throws {TypeError} If either argument is not a string.
     */
  }, {
    key: "replaceClass",
    value:
    /**
     * Replaces an existing class name with a new one.
     * @param {string} token - The class name to be replaced.
     * @param {string} newToken - The new class name to apply.
     * @returns {boolean} Whether the replacement was successful.
     * @throws {TypeError} If either argument is not a string.
     */
    function replaceClass(token, newToken) {
      return TinyHtml.replaceClass(this, token, newToken)[0];
    }
    /**
     * Returns the class name at the specified index.
     * @param {TinyElement} el - Target element.
     * @param {number} index - The index of the class name.
     * @returns {string|null} The class name at the index or null if not found.
     * @throws {TypeError} If the index is not a number.
     */
  }, {
    key: "classItem",
    value:
    /**
     * Returns the class name at the specified index.
     * @param {number} index - The index of the class name.
     * @returns {string|null} The class name at the index or null if not found.
     * @throws {TypeError} If the index is not a number.
     */
    function classItem(index) {
      return TinyHtml.classItem(this, index);
    }
    /**
     * Toggles a class name on the element with an optional force boolean.
     * @param {TinyElement|TinyElement[]} el - Target element.
     * @param {string} token - The class name to toggle.
     * @param {boolean} [force] - If true, adds the class; if false, removes it.
     * @returns {boolean[]} Whether the class is present after the toggle.
     * @throws {TypeError} If token is not a string or force is not a boolean.
     */
  }, {
    key: "toggleClass",
    value:
    /**
     * Toggles a class name on the element with an optional force boolean.
     * @param {string} token - The class name to toggle.
     * @param {boolean} force - If true, adds the class; if false, removes it.
     * @returns {boolean} Whether the class is present after the toggle.
     * @throws {TypeError} If token is not a string or force is not a boolean.
     */
    function toggleClass(token, force) {
      return TinyHtml.toggleClass(this, token, force)[0];
    }
    /**
     * Checks if the element contains the given class name.
     * @param {TinyElement} el - Target element.
     * @param {string} token - The class name to check.
     * @returns {boolean} True if the class is present, false otherwise.
     * @throws {TypeError} If token is not a string.
     */
  }, {
    key: "hasClass",
    value:
    /**
     * Checks if the element contains the given class name.
     * @param {string} token - The class name to check.
     * @returns {boolean} True if the class is present, false otherwise.
     * @throws {TypeError} If token is not a string.
     */
    function hasClass(token) {
      return TinyHtml.hasClass(this, token);
    }
    /**
     * Returns the number of classes applied to the element.
     * @param {TinyElement} el - Target element.
     * @returns {number} The number of classes.
     */
  }, {
    key: "classLength",
    value:
    /**
     * Returns the number of classes applied to the element.
     * @returns {number} The number of classes.
     */
    function classLength() {
      return TinyHtml.classLength(this);
    }
    /**
     * Returns all class names as an array of strings.
     * @param {TinyElement} el - Target element.
     * @returns {string[]} An array of class names.
     */
  }, {
    key: "classList",
    value:
    /**
     * Returns all class names as an array of strings.
     * @returns {string[]} An array of class names.
     */
    function classList() {
      return TinyHtml.classList(this);
    }
    /////////////////////////////////////////
    /**
     * Returns the tag name of the element.
     * @param {TinyElement} el - Target element.
     * @returns {string} The tag name in uppercase.
     */
  }, {
    key: "tagName",
    value:
    /**
     * Returns the tag name of the element.
     * @returns {string} The tag name in uppercase.
     */
    function tagName() {
      return TinyHtml.tagName(this);
    }
    /**
     * Returns the ID of the element.
     * @param {TinyElement} el - Target element.
     * @returns {string} The element's ID.
     */
  }, {
    key: "id",
    value:
    /**
     * Returns the ID of the element.
     * @returns {string} The element's ID.
     */
    function id() {
      return TinyHtml.id(this);
    }
    /**
     * Returns the text content of the element.
     * @param {TinyElement} el - Target element.
     * @returns {string|null} The text content or null if none.
     */
  }, {
    key: "text",
    value:
    /**
     * Returns the text content of the element.
     * @returns {string|null} The text content or null if none.
     */
    function text() {
      return TinyHtml.text(this);
    }
    /**
     * Set text content of elements.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} value
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "setText",
    value:
    /**
     * Set text content of the element.
     * @param {string} value
     * @returns {TinyElement|TinyElement[]}
     */
    function setText(value) {
      return TinyHtml.setText(this, value);
    }
    /**
     * Remove all child nodes from each element.
     * @param {TinyElement|TinyElement[]} el
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "empty",
    value:
    /**
     * Remove all child nodes of the element.
     * @returns {TinyElement|TinyElement[]}
     */
    function empty() {
      return TinyHtml.empty(this);
    }
    /**
     * Get the innerHTML of the element.
     * @param {TinyElement} el
     * @param {GetHTMLOptions} [ops]
     * @returns {string}
     */
  }, {
    key: "html",
    value:
    /**
     * Get the innerHTML of the element.
     * @param {GetHTMLOptions} [ops]
     * @returns {string}
     */
    function html(ops) {
      return TinyHtml.html(this, ops);
    }
    /**
     * Set the innerHTML of each element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} value
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "setHtml",
    value:
    /**
     * Set the innerHTML of the element.
     * @param {string} value
     * @returns {TinyElement|TinyElement[]}
     */
    function setHtml(value) {
      return TinyHtml.setHtml(this, value);
    }
    /** @readonly */
  }, {
    key: "setVal",
    value:
    /**
     * Sets the value of the current HTML value element (input, select, textarea, etc.).
     * Accepts strings, numbers, booleans or arrays of these values, or a callback function that computes them.
     *
     * @param {SetValueList|((el: InputElement, val: SetValueList) => SetValueList)} value - The value to assign or a function that returns it.
     * @returns {TinyInputElement|TinyInputElement[]}
     * @throws {Error} If the computed value is not a valid string or boolean.
     */
    function setVal(value) {
      return TinyHtml.setVal(this, value);
    }
    /**
     * Maps value types to their corresponding getter functions.
     * Each function extracts a value of a specific type from a compatible HTMLInputElement.
     * @readonly
     */
  }, {
    key: "_val",
    value:
    /**
     * Retrieves the raw value from the HTML input element.
     * If a custom value hook exists, it will be used first.
     *
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @param {string} where - The context/method name using this validation.
     * @returns {any} The raw value retrieved from the element or hook.
     * @readonly
     */
    function _val(where, type) {
      return TinyHtml._val(this, where, type);
    }
    /**
     * Gets the value of the current HTML value element.
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {SetValueList} The normalized value, with carriage returns removed.
     */
  }, {
    key: "val",
    value:
    /**
     * Gets the value of the current HTML value element.
     *
     * @returns {SetValueList} The normalized value, with carriage returns removed.
     */
    function val() {
      return TinyHtml.val(this);
    }
    /**
     * Gets the text of the current HTML value element (for text).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {string} The text value.
     * @throws {Error} If the element is not a string value.
     */
  }, {
    key: "valTxt",
    value:
    /**
     * Gets the text of the current HTML value element (for text).
     *
     * @returns {string} The text value.
     * @throws {Error} If the element is not a string value.
     */
    function valTxt() {
      return TinyHtml.valTxt(this);
    }
    /**
     * Internal helper to get a value from an input expected to return an array.
     *
     * @param {TinyInputElement} el - Target element.
     * @param {string} where - The method name or context using this validation (for error reporting).
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @returns {SetValueBase[]} - The validated value as an array.
     * @throws {Error} If the returned value is not an array.
     * @readonly
     */
  }, {
    key: "_valArr",
    value:
    /**
     * Internal helper to get a value from an input expected to return an array.
     *
     * @param {string} where - The method name or context using this validation (for error reporting).
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @returns {SetValueBase[]} - The validated value as an array.
     * @throws {Error} If the returned value is not an array.
     * @readonly
     */
    function _valArr(where, type) {
      return TinyHtml._valArr(this, where, type);
    }
    /**
     * Gets the raw value as a generic array of the current HTML value element (for select).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {SetValueBase[]} - The value cast as a generic array.
     * @throws {Error} If the value is not a valid array.
     */
  }, {
    key: "valArr",
    value:
    /**
     * Gets the raw value as a generic array of the current HTML value element (for select).
     *
     * @returns {SetValueBase[]} - The value cast as a generic array.
     * @throws {Error} If the value is not a valid array.
     */
    function valArr() {
      return TinyHtml.valArr(this);
    }
    /**
     * Gets the current value parsed as a number (for number/text).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {number} The numeric value.
     * @throws {Error} If the element is not a number-compatible input or value is NaN.
     */
  }, {
    key: "valNb",
    value:
    /**
     * Gets the current value parsed as a number (for number/text).
     *
     * @returns {number} The numeric value.
     * @throws {Error} If the element is not a number-compatible input or value is NaN.
     */
    function valNb() {
      return TinyHtml.valNb(this);
    }
    /**
     * Gets the current value parsed as a Date (for time/date).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {Date} The date value.
     * @throws {Error} If the element is not a date-compatible input.
     */
  }, {
    key: "valDate",
    value:
    /**
     * Gets the current value parsed as a Date (for time/date).
     *
     * @returns {Date} The date value.
     * @throws {Error} If the element is not a date-compatible input.
     */
    function valDate() {
      return TinyHtml.valDate(this);
    }
    /**
     * Checks if the input element is boolean (for checkboxes/radios).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {boolean} True if the input is considered checked (value === "on"), false otherwise.
     * @throws {Error} If the element is not a checkbox/radio input.
     */
  }, {
    key: "valBool",
    value:
    /**
     * Checks if the input element is boolean (for checkboxes/radios).
     *
     * @returns {boolean} True if the input is considered checked (value === "on"), false otherwise.
     * @throws {Error} If the element is not a checkbox/radio input.
     */
    function valBool() {
      return TinyHtml.valBool(this);
    }
    ////////////////////////////////////////////
    /**
     * Registers a listener for the "paste" event to extract files and text from the clipboard (e.g., when the user presses Ctrl+V).
     *
     * This method allows reacting to pasted content by providing separate callbacks for files and plain text.
     * Useful for building file upload areas, rich-text editors, or input enhancements.
     *
     * @param {TinyElementWithDoc|TinyElementWithDoc[]} el - The target element(s) where the "paste" event will be listened.
     * @param {Object} [settings={}] - Optional callbacks to handle clipboard content.
     * @param {(data: DataTransferItem, file: File) => void} [settings.onFilePaste] - Called for each file pasted from the clipboard (e.g., images).
     * @param {(data: DataTransferItem, text: string) => void} [settings.onTextPaste] - Called when plain text is pasted from the clipboard.
     * @returns {EventListenerOrEventListenerObject} The internal "paste" event handler used.
     */
  }, {
    key: "listenForPaste",
    value:
    /**
     * Registers a listener for the "paste" event to extract files and text from the clipboard (e.g., when the user presses Ctrl+V).
     *
     * This method allows reacting to pasted content by providing separate callbacks for files and plain text.
     * Useful for building file upload areas, rich-text editors, or input enhancements.
     *
     * @param {Object} [settings={}] - Optional callbacks to handle clipboard content.
     * @param {(data: DataTransferItem, file: File) => void} [settings.onFilePaste] - Called for each file pasted from the clipboard (e.g., images).
     * @param {(data: DataTransferItem, text: string) => void} [settings.onTextPaste] - Called when plain text is pasted from the clipboard.
     * @returns {EventListenerOrEventListenerObject} The internal "paste" event handler used.
     */
    function listenForPaste() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        onFilePaste = _ref2.onFilePaste,
        onTextPaste = _ref2.onTextPaste;
      return TinyHtml.listenForPaste(this, {
        onFilePaste: onFilePaste,
        onTextPaste: onTextPaste
      });
    }
    /**
     * Checks if the element has a listener for a specific event.
     *
     * @param {TinyEventTarget} el - The element to check.
     * @param {string} event - The event name to check.
     * @returns {boolean}
     */
  }, {
    key: "hasEventListener",
    value:
    /**
     * Checks if the element has a listener for a specific event.
     *
     * @param {string} event - The event name to check.
     * @returns {boolean}
     */
    function hasEventListener(event) {
      return TinyHtml.hasEventListener(this, event);
    }
    /**
     * Checks if the element has the exact handler registered for a specific event.
     *
     * @param {TinyEventTarget} el - The element to check.
     * @param {string} event - The event name to check.
     * @param {EventListenerOrEventListenerObject} handler - The handler function to check.
     * @returns {boolean}
     */
  }, {
    key: "hasExactEventListener",
    value:
    /**
     * Checks if the element has the exact handler registered for a specific event.
     *
     * @param {string} event - The event name to check.
     * @param {EventListenerOrEventListenerObject} handler - The handler function to check.
     * @returns {boolean}
     */
    function hasExactEventListener(event, handler) {
      return TinyHtml.hasExactEventListener(this, event, handler);
    }
    /**
     * Registers an event listener on the specified element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target to listen on.
     * @param {string} event - The event type (e.g. 'click', 'keydown').
     * @param {EventListenerOrEventListenerObject|null} handler - The callback function to run on event.
     * @param {EventRegistryOptions} [options] - Optional event listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "on",
    value:
    /**
     * Registers an event listener on the specified element.
     *
     * @param {string} event - The event type (e.g. 'click', 'keydown').
     * @param {EventListenerOrEventListenerObject|null} handler - The callback function to run on event.
     * @param {EventRegistryOptions} [options] - Optional event listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function on(event, handler, options) {
      return TinyHtml.on(this, event, handler, options);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target to listen on.
     * @param {string} event - The event type (e.g. 'click', 'keydown').
     * @param {EventListenerOrEventListenerObject} handler - The callback function to run on event.
     * @param {EventRegistryOptions} [options={}] - Optional event listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "once",
    value:
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - The event type (e.g. 'click', 'keydown').
     * @param {EventListenerOrEventListenerObject} handler - The callback function to run on event.
     * @param {EventRegistryOptions} [options={}] - Optional event listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function once(event, handler) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return TinyHtml.once(this, event, handler, options);
    }
    /**
     * Removes a specific event listener from an element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target element.
     * @param {string} event - The event type.
     * @param {EventListenerOrEventListenerObject|null} handler - The function originally bound to the event.
     * @param {boolean|EventListenerOptions} [options] - Optional listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "off",
    value:
    /**
     * Removes a specific event listener from an element.
     *
     * @param {string} event - The event type.
     * @param {EventListenerOrEventListenerObject|null} handler - The function originally bound to the event.
     * @param {boolean|EventListenerOptions} [options] - Optional listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function off(event, handler, options) {
      return TinyHtml.off(this, event, handler, options);
    }
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target element.
     * @param {string} event - The event type to remove (e.g. 'click').
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "offAll",
    value:
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {string} event - The event type to remove (e.g. 'click').
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function offAll(event) {
      return TinyHtml.offAll(this, event);
    }
    /**
     * Removes all event listeners of all types from the element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target element.
     * @param {((handler: EventListenerOrEventListenerObject|null, event: string) => boolean)|null} [filterFn=null] -
     *        Optional filter function to selectively remove specific handlers.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "offAllTypes",
    value:
    /**
     * Removes all event listeners of all types from the element.
     *
     * @param {((handler: EventListenerOrEventListenerObject|null, event: string) => boolean)|null} [filterFn=null] -
     *        Optional filter function to selectively remove specific handlers.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function offAllTypes() {
      var filterFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return TinyHtml.offAllTypes(this, filterFn);
    }
    /**
     * Triggers all handlers associated with a specific event on the given element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - Target element where the event should be triggered.
     * @param {string} event - Name of the event to trigger.
     * @param {Event|CustomEvent|CustomEventInit} [payload] - Optional event object or data to pass.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "trigger",
    value:
    /**
     * Triggers all handlers associated with a specific event on the given element.
     *
     * @param {string} event - Name of the event to trigger.
     * @param {Event|CustomEvent|CustomEventInit} [payload] - Optional event object or data to pass.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function trigger(event) {
      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return TinyHtml.trigger(this, event, payload);
    }
    ///////////////////////////////////////////////////////////////
    /**
     * Internal property name normalization map (similar to jQuery's `propFix`).
     * Maps attribute-like names to their JavaScript DOM property equivalents.
     *
     * Example: `'for'` â `'htmlFor'`, `'class'` â `'className'`.
     *
     * â ï¸ Do not modify this object directly. Use `TinyHtml.propFix` to ensure reverse mapping (`attrFix`) remains in sync.
     *
     * @type {Record<string | symbol, string>}
     */
  }, {
    key: "attr",
    value:
    /**
     * Get an attribute on an element.
     * @param {string} name
     * @returns {string|null}
     */
    function attr(name) {
      return TinyHtml.attr(this, name);
    }
    /**
     * Set an attribute on an element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name
     * @param {string|null} [value=null]
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "setAttr",
    value:
    /**
     * Set an attribute on an element.
     * @param {string} name
     * @param {string|null} [value=null]
     * @returns {TinyElement|TinyElement[]}
     */
    function setAttr(name, value) {
      return TinyHtml.setAttr(this, name, value);
    }
    /**
     * Remove attribute(s) from an element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name Space-separated list of attributes.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "removeAttr",
    value:
    /**
     * Remove attribute(s) from an element.
     * @param {string} name Space-separated list of attributes.
     * @returns {TinyElement|TinyElement[]}
     */
    function removeAttr(name) {
      return TinyHtml.removeAttr(this, name);
    }
    /**
     * Check if an attribute exists on an element.
     * @param {TinyElement} el
     * @param {string} name
     * @returns {boolean}
     */
  }, {
    key: "hasAttr",
    value:
    /**
     * Check if an attribute exists on an element.
     * @param {string} name
     * @returns {boolean}
     */
    function hasAttr(name) {
      return TinyHtml.hasAttr(this, name);
    }
    /**
     * Check if a property exists.
     * @param {TinyElement} el
     * @param {string} name
     * @returns {boolean}
     */
  }, {
    key: "hasProp",
    value:
    /**
     * Check if a property exists.
     * @param {string} name
     * @returns {boolean}
     */
    function hasProp(name) {
      return TinyHtml.hasProp(this, name);
    }
    /**
     * Set a property on an element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "addProp",
    value:
    /**
     * Set a property on an element.
     * @param {string} name
     * @returns {TinyElement|TinyElement[]}
     */
    function addProp(name) {
      return TinyHtml.addProp(this, name);
    }
    /**
     * Remove a property from an element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "removeProp",
    value:
    /**
     * Remove a property from an element.
     * @param {string} name
     * @returns {TinyElement|TinyElement[]}
     */
    function removeProp(name) {
      return TinyHtml.removeProp(this, name);
    }
    /**
     * Toggle a boolean property.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name
     * @param {boolean} [force]
     */
  }, {
    key: "toggleProp",
    value:
    /**
     * Toggle a boolean property.
     * @param {string} name
     * @param {boolean} [force]
     */
    function toggleProp(name, force) {
      return TinyHtml.toggleProp(this, name, force);
    }
    /////////////////////////////////////////////////////
    /**
     * Removes an element from the DOM.
     * @param {TinyElement|TinyElement[]} el - The DOM element or selector to remove.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "remove",
    value:
    /**
     * Removes the element from the DOM.
     * @returns {TinyElement|TinyElement[]}
     */
    function remove() {
      return TinyHtml.remove(this);
    }
    /**
     * Returns the index of the first element within its parent or relative to a selector/element.
     *
     * @param {TinyElement} el - The element target
     * @param {string|TinyElement|null} [el2] - Optional target to compare index against.
     * @returns {number}
     */
  }, {
    key: "index",
    value:
    /**
     * Returns the index of the first element within its parent or relative to a selector/element.
     *
     * @param {string|TinyElement|null} [elem] - Optional target to compare index against.
     * @returns {number}
     */
    function index(elem) {
      return TinyHtml.index(this, elem);
    }
    ////////////////////////////////////////////////////////////////////
    /**
     * Creates a new DOMRect object by copying the base rect and applying optional additional dimensions.
     *
     * @param {DOMRect} rect - The base rectangle to be cloned and extended.
     * @param {Partial<DOMRect>} extraRect - Additional dimensions to apply to the base rect (e.g., extra padding or offset).
     * @returns {DOMRect} - A new DOMRect object with the combined dimensions.
     * @readonly
     */
  }, {
    key: "isCollWith",
    value:
    /**
     * Determines if two HTML elements are colliding, using a simple bounding box comparison.
     *
     * @param {TinyElement} el2 - The second element to compare.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} - `true` if the elements are colliding, `false` otherwise.
     */
    function isCollWith(el2, extraRect) {
      return TinyHtml.isCollWith(this, el2, extraRect);
    }
    /**
     * Determines if two HTML elements are colliding using a pixel-perfect collision algorithm.
     *
     * @param {TinyElement} el1 - The first element to compare.
     * @param {TinyElement} el2 - The second element to compare.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} - `true` if the elements are colliding with higher precision, `false` otherwise.
     */
  }, {
    key: "isCollPerfWith",
    value:
    /**
     * Determines if two HTML elements are colliding using a pixel-perfect collision algorithm.
     *
     * @param {TinyElement} el2 - The second element to compare.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} - `true` if the elements are colliding with higher precision, `false` otherwise.
     */
    function isCollPerfWith(el2, extraRect) {
      return TinyHtml.isCollPerfWith(this, el2, extraRect);
    }
    /**
     * Determines whether two elements are colliding with a directional lock mechanism.
     *
     * This function tracks the direction from which an element (`elem1`) initially collided with another,
     * and keeps the collision "locked" until the element exits the collision from the same direction.
     *
     * - If `isColliding` is true and no lock is stored yet, it saves the direction of entry.
     * - If `isColliding` is false but a previous lock exists, it checks if the element has exited
     *   in the same direction it entered to remove the lock.
     *
     * @param {boolean} isColliding - Indicates whether `rect1` and `rect2` are currently colliding.
     * @param {DOMRect} rect1 - The bounding box of the first element.
     * @param {DOMRect} rect2 - The bounding box of the second element.
     * @param {Element} elem1 - The element to track collision state for.
     * @param {CollisionDirLock} lockDirection - The direction from which the collision was first detected.
     * @returns {boolean} Returns `true` if the element is still considered colliding (locked), otherwise `false`.
     * @readonly
     */
  }, {
    key: "isCollWithLock",
    value:
    /**
     * Checks if two DOM elements are colliding on the screen, and locks the collision
     * until the element exits through the same side it entered.
     *
     * @param {TinyElement} el2 - Second DOM element (e.g. a container or boundary element).
     * @param {CollisionDirLock} lockDirection - Direction that must be respected to unlock the collision.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} True if collision is still active.
     */
    function isCollWithLock(el2, lockDirection, extraRect) {
      return TinyHtml.isCollWithLock(this, el2, lockDirection, extraRect);
    }
    /**
     * Checks if two DOM elements are colliding on the screen, and locks the collision
     * until the element exits through the same side it entered.
     *
     * @param {TinyElement} el1 - First DOM element (e.g. draggable or moving element).
     * @param {TinyElement} el2 - Second DOM element (e.g. a container or boundary element).
     * @param {CollisionDirLock} lockDirection - Direction that must be respected to unlock the collision.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} True if collision is still active.
     */
  }, {
    key: "isCollPerfWithLock",
    value:
    /**
     * Checks if two DOM elements are colliding on the screen, and locks the collision
     * until the element exits through the same side it entered.
     *
     * @param {TinyElement} el2 - Second DOM element (e.g. a container or boundary element).
     * @param {CollisionDirLock} lockDirection - Direction that must be respected to unlock the collision.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} True if collision is still active.
     */
    function isCollPerfWithLock(el2, lockDirection, extraRect) {
      return TinyHtml.isCollPerfWithLock(this, el2, lockDirection, extraRect);
    }
    /**
     * Resets all collision locks for a specific element (for all directions).
     *
     * @param {TinyElement} el - The element whose locks should be removed.
     * @returns {boolean} True if at least one lock was removed.
     */
  }, {
    key: "resetCollLock",
    value:
    /**
     * Resets the collision lock for a specific element.
     *
     * This removes any previously stored collision direction for the given element,
     * effectively unlocking its collision state.
     *
     * @returns {boolean} Returns `true` if a lock was removed, `false` if no lock was present.
     */
    function resetCollLock() {
      return TinyHtml.resetCollLock(this);
    }
    /**
     * Resets the collision lock for a specific element and direction.
     *
     * @param {TinyElement} el - The element whose lock should be removed.
     * @param {CollisionDirLock} direction - The direction to clear the lock from.
     * @returns {boolean} True if the lock was removed.
     */
  }, {
    key: "resetCollLockDir",
    value:
    /**
     * Resets the collision lock for a specific element and direction.
     *
     * @param {CollisionDirLock} direction - The direction to clear the lock from.
     * @returns {boolean} True if the lock was removed.
     */
    function resetCollLockDir(direction) {
      return TinyHtml.resetCollLockDir(this, direction);
    }
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Checks if the given element is at least partially visible in the viewport.
     *
     * @param {TinyElement} el - The DOM element to check.
     * @returns {boolean} True if the element is partially in the viewport, false otherwise.
     */
  }, {
    key: "isInViewport",
    value:
    /**
     * Checks if the given element is at least partially visible in the viewport.
     *
     * @returns {boolean} True if the element is partially in the viewport, false otherwise.
     */
    function isInViewport() {
      return TinyHtml.isInViewport(this);
    }
    /**
     * Checks if the given element is fully visible in the viewport (top and bottom).
     *
     * @param {TinyElement} el - The DOM element to check.
     * @returns {boolean} True if the element is fully visible in the viewport, false otherwise.
     */
  }, {
    key: "isScrolledIntoView",
    value:
    /**
     * Checks if the given element is fully visible in the viewport (top and bottom).
     *
     * @returns {boolean} True if the element is fully visible in the viewport, false otherwise.
     */
    function isScrolledIntoView() {
      return TinyHtml.isScrolledIntoView(this);
    }
    /**
     * Checks if the given element is at least partially visible within the boundaries of a container.
     *
     * @param {TinyElement} el - The DOM element to check.
     * @param {TinyElement} cont - The container element acting as the viewport.
     * @returns {boolean} True if the element is partially visible within the container, false otherwise.
     */
  }, {
    key: "isInContainer",
    value:
    /**
     * Checks if the given element is at least partially visible within the boundaries of a container.
     *
     * @param {TinyElement} cont - The container element acting as the viewport.
     * @returns {boolean} True if the element is partially visible within the container, false otherwise.
     */
    function isInContainer(cont) {
      return TinyHtml.isInContainer(this, cont);
    }
    /**
     * Checks if the given element is fully visible within the boundaries of a container (top and bottom).
     *
     * @param {TinyElement} el - The DOM element to check.
     * @param {TinyElement} cont - The container element acting as the viewport.
     * @returns {boolean} True if the element is fully visible within the container, false otherwise.
     */
  }, {
    key: "isFullyInContainer",
    value:
    /**
     * Checks if the given element is fully visible within the boundaries of a container (top and bottom).
     *
     * @param {TinyElement} cont - The container element acting as the viewport.
     * @returns {boolean} True if the element is fully visible within the container, false otherwise.
     */
    function isFullyInContainer(cont) {
      return TinyHtml.isFullyInContainer(this, cont);
    }
    /**
     * Checks if an element has scrollable content.
     *
     * @param {TinyElement} el - The DOM element to check.
     * @returns {{ v: boolean, h: boolean }} - True if scroll is needed in that direction.
     */
  }, {
    key: "hasScroll",
    value:
    /**
     * Checks if an element has scrollable content.
     *
     * @returns {{ v: boolean, h: boolean }} - True if scroll is needed in that direction.
     */
    function hasScroll() {
      return TinyHtml.hasScroll(this);
    }
  }], [{
    key: "fetchHtmlFile",
    value: (
    /**
     * Fetches an HTML file from the given URL, parses it to JSON.
     *
     * @param {string | URL | globalThis.Request} url - The URL of the HTML file.
     * @param {RequestInit} [ops] - Optional fetch configuration (e.g., method, headers, cache, etc).
     * @returns {Promise<HtmlParsed[]>} A promise that resolves with the parsed JSON representation of the HTML structure.
     */
    function () {
      var _fetchHtmlFile = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(url) {
        var ops,
          res,
          contentType,
          html,
          _args = arguments;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              ops = _args.length > 1 && _args[1] !== undefined ? _args[1] : {
                method: 'GET'
              };
              _context.n = 1;
              return fetch(url, ops);
            case 1:
              res = _context.v;
              contentType = res.headers.get('Content-Type') || '';
              if (res.ok) {
                _context.n = 2;
                break;
              }
              throw new Error("Failed to fetch: ".concat(res.status, " ").concat(res.statusText));
            case 2:
              if (contentType.includes('text/html')) {
                _context.n = 3;
                break;
              }
              throw new Error("Invalid content type: ".concat(contentType, " (expected text/html)"));
            case 3:
              _context.n = 4;
              return res.text();
            case 4:
              html = _context.v;
              return _context.a(2, TinyHtml.htmlToJson(html));
          }
        }, _callee);
      }));
      function fetchHtmlFile(_x) {
        return _fetchHtmlFile.apply(this, arguments);
      }
      return fetchHtmlFile;
    }()
    /**
     * Fetches an HTML file from the given URL, parses it to JSON, then converts it to DOM nodes.
     *
     * @param {string} url - The URL of the HTML file.
     * @param {RequestInit} [ops] - Optional fetch configuration (e.g., method, headers, cache, etc).
     * @returns {Promise<(HTMLElement|Text)[]>} A promise that resolves with the DOM nodes.
     */
    )
  }, {
    key: "fetchHtmlNodes",
    value: (function () {
      var _fetchHtmlNodes = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(url, ops) {
        var json;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return TinyHtml.fetchHtmlFile(url, ops);
            case 1:
              json = _context2.v;
              return _context2.a(2, TinyHtml.jsonToNodes(json));
          }
        }, _callee2);
      }));
      function fetchHtmlNodes(_x2, _x3) {
        return _fetchHtmlNodes.apply(this, arguments);
      }
      return fetchHtmlNodes;
    }()
    /**
     * Fetches an HTML file from the given URL, parses it to JSON, then converts it to TinyHtml instances.
     *
     * @param {string} url - The URL of the HTML file.
     * @param {RequestInit} [ops] - Optional fetch configuration (e.g., method, headers, cache, etc).
     * @returns {Promise<TinyHtml[]>} A promise that resolves with the TinyHtml instances.
     */
    )
  }, {
    key: "fetchHtmlTinyElems",
    value: (function () {
      var _fetchHtmlTinyElems = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(url, ops) {
        var nodes;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return TinyHtml.fetchHtmlNodes(url, ops);
            case 1:
              nodes = _context3.v;
              return _context3.a(2, TinyHtml.toTinyElm(nodes));
          }
        }, _callee3);
      }));
      function fetchHtmlTinyElems(_x4, _x5) {
        return _fetchHtmlTinyElems.apply(this, arguments);
      }
      return fetchHtmlTinyElems;
    }()
    /**
     * Converts the content of a <template> to an array of HtmlParsed.
     *
     * @param {HTMLTemplateElement} nodes
     * @returns {HtmlParsed[]}
     */
    )
  }, {
    key: "templateToJson",
    value: function templateToJson(nodes) {
      return TinyHtml.htmlToJson(_toConsumableArray(nodes.content.childNodes).map(function (node) {
        return node instanceof Element ? node.getHTML() : node instanceof Text ? node.textContent : '';
      }).join(''));
    }
    /**
     * Converts the content of a <template> to real DOM nodes.
     *
     * @param {HTMLTemplateElement} nodes
     * @returns {(Element|Text)[]}
     */
  }, {
    key: "templateToNodes",
    value: function templateToNodes(nodes) {
      /** @type {(Element|Text)[]} */
      var result = [];
      _toConsumableArray(nodes.content.cloneNode(true).childNodes).map(function (node) {
        if (!(node instanceof Element) && !(node instanceof Text) && !(node instanceof Comment)) throw new Error("Expected only Element nodes in <template>, but found: ".concat(node.constructor.name));
        if (!(node instanceof Comment)) result.push(node);
      });
      return result;
    }
    /**
     * Converts the content of a <template> to an array of TinyHtml elements.
     *
     * @param {HTMLTemplateElement} nodes
     * @returns {TinyHtml[]}
     */
  }, {
    key: "templateToTinyElems",
    value: function templateToTinyElems(nodes) {
      return TinyHtml.toTinyElm(TinyHtml.templateToNodes(nodes));
    }
    /**
     * Parses a full HTML string into a JSON-like structure.
     *
     * @param {string} htmlString - Full HTML markup as a string.
     * @returns {HtmlParsed[]} An array of parsed HTML elements in structured format.
     */
  }, {
    key: "htmlToJson",
    value: function htmlToJson(htmlString) {
      var container = document.createElement('div');
      container.innerHTML = htmlString.trim();
      var result = [];
      /**
       * @param {Node} el
       * @returns {*}
       */
      var _parseElement = function parseElement(el) {
        if (el instanceof Comment) return null;
        if (el instanceof Text) {
          var _el$textContent;
          var text = (_el$textContent = el.textContent) === null || _el$textContent === void 0 ? void 0 : _el$textContent.trim();
          return text ? text : null;
        }
        if (!(el instanceof Element)) return null;
        var tag = el.tagName.toLowerCase();
        /** @type {Record<string, string>} */
        var props = {};
        var _iterator = _createForOfIteratorHelper(el.attributes),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var attr = _step.value;
            props[TinyHtml.getPropName(attr.name)] = attr.value;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var children = Array.from(el.childNodes).map(_parseElement).filter(Boolean);
        return children.length > 0 ? [tag, props].concat(_toConsumableArray(children)) : [tag, props];
      };
      var _iterator2 = _createForOfIteratorHelper(container.childNodes),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          var parsed = _parseElement(child);
          if (parsed) result.push(parsed);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      container.innerHTML = '';
      return result;
    }
    /**
     * Converts a JSON-like HTML structure back to DOM Elements.
     *
     * @param {HtmlParsed[]} jsonArray - Parsed JSON format of HTML.
     * @returns {(HTMLElement|Text)[]} List of DOM nodes.
     */
  }, {
    key: "jsonToNodes",
    value: function jsonToNodes(jsonArray) {
      /**
       * @param {HtmlParsed|string} nodeData
       * @returns {HTMLElement|Text}
       */
      var _createElement = function createElement(nodeData) {
        if (typeof nodeData === 'string') {
          return document.createTextNode(nodeData);
        }
        if (!Array.isArray(nodeData)) return document.createTextNode('');
        var _nodeData = _toArray(nodeData),
          tag = _nodeData[0],
          props = _nodeData[1],
          children = _nodeData.slice(2);
        var el = document.createElement(tag);
        for (var _i = 0, _Object$entries = Object.entries(props); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];
          el.setAttribute(TinyHtml.getAttrName(key), value);
        }
        var _iterator3 = _createForOfIteratorHelper(children),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var child = _step3.value;
            var childEl = _createElement(child);
            if (childEl instanceof Comment) continue;
            el.appendChild(childEl);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return el;
      };
      return jsonArray.map(_createElement).filter(function (node) {
        return !(node instanceof Comment);
      });
    }
    /**
     * Converts a JSON-like HTML structure back to TinyHtml instances.
     *
     * @param {HtmlParsed[]} jsonArray - Parsed JSON format of HTML.
     * @returns {TinyHtml[]} List of TinyHtml instances.
     */
  }, {
    key: "jsonToTinyElems",
    value: function jsonToTinyElems(jsonArray) {
      return TinyHtml.toTinyElm(TinyHtml.jsonToNodes(jsonArray));
    }
    /**
     * Creates a new TinyHtml element from a tag name and optional attributes.
     *
     * You can alias this method for convenience:
     * ```js
     * const createElement = TinyHtml.createFrom;
     * const myDiv = createElement('div', { class: 'box' });
     * ```
     *
     * @param {string} tagName - The HTML tag name (e.g., 'div', 'span', 'button').
     * @param {Record<string, string|null>} [attrs] - Optional key-value pairs representing HTML attributes.
     *                                                If the value is `null`, the attribute will still be set with an empty value.
     * @returns {TinyHtml} - A new instance of TinyHtml representing the created element.
     * @throws {TypeError} - If `tagName` is not a string, or `attrs` is not a plain object when defined.
     */
  }, {
    key: "createFrom",
    value: function createFrom(tagName, attrs) {
      if (typeof tagName !== 'string') throw new TypeError('The "tagName" must be a string.');
      if (typeof attrs !== 'undefined' && _typeof(attrs) !== 'object') throw new TypeError('The "attrs" must be a object.');
      var elem = TinyHtml.createElement(tagName);
      if (_typeof(attrs) === 'object') {
        for (var attrName in attrs) {
          elem.setAttr(attrName, attrs[attrName]);
        }
      }
      return elem;
    }
    /**
     * Creates a new DOM element with the specified tag name and options, then wraps it in a TinyHtml instance.
     *
     * @param {string} tagName - The tag name of the element to create (e.g., 'div', 'span').
     * @param {ElementCreationOptions} [ops] - Optional settings for creating the element.
     * @returns {TinyHtml} A TinyHtml instance wrapping the newly created DOM element.
     * @throws {TypeError} If tagName is not a string or ops is not an object.
     */
  }, {
    key: "createElement",
    value: function createElement(tagName, ops) {
      if (typeof tagName !== 'string') throw new TypeError("[TinyHtml] createElement(): The tagName must be a string.");
      if (typeof ops !== 'undefined' && _typeof(ops) !== 'object') throw new TypeError("[TinyHtml] createElement(): The ops must be a object.");
      return new TinyHtml(document.createElement(tagName, ops));
    }
    /**
     * Creates a new TinyHtml instance that wraps a DOM TextNode.
     *
     * This method is useful when you want to insert raw text content into the DOM
     * without it being interpreted as HTML. The returned instance behaves like any
     * other TinyHtml element and can be appended or manipulated as needed.
     *
     * @param {string} value - The plain text content to be wrapped in a TextNode.
     * @returns {TinyHtml} A TinyHtml instance wrapping the newly created DOM TextNode.
     * @throws {TypeError} If the provided value is not a string.
     */
  }, {
    key: "createTextNode",
    value: function createTextNode(value) {
      if (typeof value !== 'string') throw new TypeError("[TinyHtml] createTextNode(): The value must be a string.");
      return new TinyHtml(document.createTextNode(value));
    }
    /**
     * Creates an HTMLElement or TextNode from an HTML string.
     * Supports both elements and plain text.
     *
     * @param {string} htmlString - The HTML string to convert.
     * @returns {TinyHtml} - A single HTMLElement or TextNode.
     */
  }, {
    key: "createElementFromHTML",
    value: function createElementFromHTML(htmlString) {
      var template = document.createElement('template');
      htmlString = htmlString.trim();
      // If it's only text (e.g., no "<" tag), return a TextNode
      if (!htmlString.startsWith('<')) {
        return TinyHtml.createTextNode(htmlString);
      }
      template.innerHTML = htmlString;
      if (!(template.content.firstChild instanceof Element)) throw new Error('The HTML string must contain a valid HTML element.');
      return new TinyHtml(template.content.firstChild);
    }
    /**
     * Queries the document for the first element matching the CSS selector and wraps it in a TinyHtml instance.
     *
     * @param {string} selector - A valid CSS selector string.
     * @param {Document|Element} elem - Target element.
     * @returns {TinyHtml|null} A TinyHtml instance wrapping the matched element.
     */
  }, {
    key: "query",
    value: function query(selector) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      var newEl = elem.querySelector(selector);
      if (!newEl) return null;
      return new TinyHtml(newEl);
    }
  }, {
    key: "queryAll",
    value: function queryAll(selector) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      return new TinyHtml(elem.querySelectorAll(selector));
    }
  }, {
    key: "getById",
    value: function getById(selector) {
      var newEl = document.getElementById(selector);
      if (!newEl) return null;
      return new TinyHtml(newEl);
    }
    /**
     * Retrieves all elements with the specified class name and wraps them in TinyHtml instances.
     *
     * @param {string} selector - The class name to search for.
     * @param {Document|Element} elem - Target element.
     * @returns {TinyHtml} An array of TinyHtml instances wrapping the found elements.
     */
  }, {
    key: "getByClassName",
    value: function getByClassName(selector) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      return new TinyHtml(elem.getElementsByClassName(selector));
    }
  }, {
    key: "getByName",
    value: function getByName(selector) {
      return new TinyHtml(document.getElementsByName(selector));
    }
    /**
     * Retrieves all elements with the specified local tag name within the given namespace URI,
     * and wraps them in TinyHtml instances.
     *
     * @param {string} localName - The local name (tag) of the elements to search for.
     * @param {string|null} [namespaceURI='http://www.w3.org/1999/xhtml'] - The namespace URI to search within.
     * @param {Document|Element} elem - Target element.
     * @returns {TinyHtml} An array of TinyHtml instances wrapping the found elements.
     */
  }, {
    key: "getByTagNameNS",
    value: function getByTagNameNS(localName) {
      var namespaceURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http://www.w3.org/1999/xhtml';
      var elem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
      return new TinyHtml(elem.getElementsByTagNameNS(namespaceURI, localName));
    }
  }, {
    key: "_preElemsTemplate",
    value: function _preElemsTemplate(elems, where, TheTinyElements, elemName) {
      /** @param {(TinyElement|EventTarget|null)[]} item */
      var checkElement = function checkElement(item) {
        /** @type {any[]} */
        var results = [];
        item.map(function (elem) {
          return (elem instanceof TinyHtml ? elem._getElements(where) : [elem]).map(function (result) {
            var allowed = false;
            var _iterator4 = _createForOfIteratorHelper(TheTinyElements),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var TheTinyElement = _step4.value;
                if (result instanceof TheTinyElement) {
                  allowed = true;
                  break;
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            if (!allowed) throw new Error("[TinyHtml] Invalid element of the list \"".concat(elemName.join(','), "\" in ").concat(where, "()."));
            results.push(result);
            return result;
          });
        });
        return results;
      };
      if (!Array.isArray(elems)) return checkElement([elems]);
      return checkElement(elems);
    }
    /**
     * Prepares and validates a single element against allowed types.
     *
     * @param {TinyElement | EventTarget | null | (TinyElement | EventTarget | null)[]} elems - The input element or list to validate.
     * @param {string} where - The method name or context calling this.
     * @param {any[]} TheTinyElements - The list of allowed constructors (e.g., Element, Document).
     * @param {string[]} elemName - The list of expected element names for error reporting.
     * @param {boolean} [canNull=false] - Whether `null` is allowed as a valid value.
     * @returns {any} - The validated element or `null` if allowed.
     * @throws {Error} - If the element is not valid or if multiple elements are provided.
     * @readonly
     */
  }, {
    key: "_preElemTemplate",
    value: function _preElemTemplate(elems, where, TheTinyElements, elemName) {
      var canNull = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      /** @param {(TinyElement|EventTarget|null)[]} item */
      var checkElement = function checkElement(item) {
        var elem = item[0];
        var result = elem instanceof TinyHtml ? elem._getElements(where) : [elem];
        if (result.length > 1) throw new Error("[TinyHtml] Invalid element amount in ".concat(where, "() (Received ").concat(result.length, "/1)."));
        var allowed = false;
        var _iterator5 = _createForOfIteratorHelper(TheTinyElements),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var TheTinyElement = _step5.value;
            if (result[0] instanceof TheTinyElement) {
              allowed = true;
              break;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        if (canNull && (result[0] === null || typeof result[0] === 'undefined')) {
          result[0] = null;
          allowed = true;
        }
        if (!allowed) throw new Error("[TinyHtml] Invalid element of the list \"".concat(elemName.join(','), "\" in ").concat(where, "()."));
        return result[0];
      };
      if (!Array.isArray(elems)) return checkElement([elems]);
      if (elems.length > 1) throw new Error("[TinyHtml] Invalid element amount in ".concat(where, "() (Received ").concat(elems.length, "/1)."));
      return checkElement(elems);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single element or array of elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Element[]} - Always returns an array of elements.
     * @readonly
     */
  }, {
    key: "_preElems",
    value: function _preElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [Element], ['Element']);
    }
    /**
     * Ensures the input is returned as an single element.
     * Useful to normalize operations across multiple or single elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single element or array of elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Element} - Always returns an single element.
     * @readonly
     */
  }, {
    key: "_preElem",
    value: function _preElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Element], ['Element']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single nodes.
     *
     * @param {TinyNode|TinyNode[]} elems - A single node or array of nodes.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Node[]} - Always returns an array of nodes.
     * @readonly
     */
  }, {
    key: "_preNodeElems",
    value: function _preNodeElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [Node], ['Node']);
    }
    /**
     * Ensures the input is returned as an single node.
     * Useful to normalize operations across multiple or single nodes.
     *
     * @param {TinyNode|TinyNode[]} elems - A single node or array of nodes.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Node} - Always returns an single node.
     * @readonly
     */
  }, {
    key: "_preNodeElem",
    value: function _preNodeElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Node], ['Node']);
    }
    /**
     * Ensures the input is returned as an single node.
     * Useful to normalize operations across multiple or single nodes.
     *
     * @param {TinyNode|TinyNode[]} elems - A single node or array of nodes.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Node|null} - Always returns an single node or null.
     * @readonly
     */
  }, {
    key: "_preNodeElemWithNull",
    value: function _preNodeElemWithNull(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Node], ['Node'], true);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single html elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single html element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {HTMLElement[]} - Always returns an array of html elements.
     * @readonly
     */
  }, {
    key: "_preHtmlElems",
    value: function _preHtmlElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [HTMLElement], ['HTMLElement']);
    }
    /**
     * Ensures the input is returned as an single html element.
     * Useful to normalize operations across multiple or single html elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single html element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {HTMLElement} - Always returns an single html element.
     * @readonly
     */
  }, {
    key: "_preHtmlElem",
    value: function _preHtmlElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [HTMLElement], ['HTMLElement']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single event target elements.
     *
     * @param {TinyInputElement|TinyInputElement[]} elems - A single event target element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {InputElement[]} - Always returns an array of event target elements.
     * @readonly
     */
  }, {
    key: "_preInputElems",
    value: function _preInputElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLOptionElement], ['HTMLInputElement', 'HTMLSelectElement', 'HTMLTextAreaElement', 'HTMLOptionElement']);
    }
    /**
     * Ensures the input is returned as an single event target element.
     * Useful to normalize operations across multiple or single event target elements.
     *
     * @param {TinyInputElement|TinyInputElement[]} elems - A single event target element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {InputElement} - Always returns an single event target element.
     * @readonly
     */
  }, {
    key: "_preInputElem",
    value: function _preInputElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLOptionElement], ['HTMLInputElement', 'HTMLSelectElement', 'HTMLTextAreaElement', 'HTMLOptionElement']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single event target elements.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} elems - A single event target element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {EventTarget[]} - Always returns an array of event target elements.
     * @readonly
     */
  }, {
    key: "_preEventTargetElems",
    value: function _preEventTargetElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [EventTarget], ['EventTarget']);
    }
    /**
     * Ensures the input is returned as an single event target element.
     * Useful to normalize operations across multiple or single event target elements.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} elems - A single event target element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {EventTarget} - Always returns an single event target element.
     * @readonly
     */
  }, {
    key: "_preEventTargetElem",
    value: function _preEventTargetElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [EventTarget], ['EventTarget']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single element/window elements.
     *
     * @param {TinyElementAndWindow|TinyElementAndWindow[]} elems - A single element/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementAndWindow[]} - Always returns an array of element/window elements.
     * @readonly
     */
  }, {
    key: "_preElemsAndWindow",
    value: function _preElemsAndWindow(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [Element, Window], ['Element', 'Window']);
    }
    /**
     * Ensures the input is returned as an single element/window element.
     * Useful to normalize operations across multiple or single element/window elements.
     *
     * @param {TinyElementAndWindow|TinyElementAndWindow[]} elems - A single element/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementAndWindow} - Always returns an single element/window element.
     * @readonly
     */
  }, {
    key: "_preElemAndWindow",
    value: function _preElemAndWindow(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Element, Window], ['Element', 'Window']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single element/window/document elements.
     *
     * @param {TinyElementAndWinAndDoc|TinyElementAndWinAndDoc[]} elems - A single element/document/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementAndWindow[]} - Always returns an array of element/document/window elements.
     * @readonly
     */
  }, {
    key: "_preElemsAndWinAndDoc",
    value: function _preElemsAndWinAndDoc(elems, where) {
      var result = TinyHtml._preElemsTemplate(elems, where, [Element, Window, Document], ['Element', 'Window', 'Document']);
      return result.map(function (elem) {
        return !(elem instanceof Document) ? elem : elem.documentElement;
      });
    }
    /**
     * Ensures the input is returned as an single element/window/document element.
     * Useful to normalize operations across multiple or single element/window/document elements.
     *
     * @param {TinyElementAndWinAndDoc|TinyElementAndWinAndDoc[]} elems - A single element/document/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementAndWindow} - Always returns an single element/document/window element.
     * @readonly
     */
  }, {
    key: "_preElemAndWinAndDoc",
    value: function _preElemAndWinAndDoc(elems, where) {
      var result = TinyHtml._preElemTemplate(elems, where, [Element, Window, Document], ['Element', 'Window', 'Document']);
      if (result instanceof Document) return result.documentElement;
      return result;
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single element with document elements.
     *
     * @param {TinyElementWithDoc|TinyElementWithDoc[]} elems - A single element with document element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementWithDoc[]} - Always returns an array of element with document elements.
     * @readonly
     */
  }, {
    key: "_preElemsWithDoc",
    value: function _preElemsWithDoc(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [Element, Document], ['Element', 'Document']);
    }
    /**
     * Ensures the input is returned as an single element with document element.
     * Useful to normalize operations across multiple or single element with document elements.
     *
     * @param {TinyElementWithDoc|TinyElementWithDoc[]} elems - A single element/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementWithDoc} - Always returns an single element/window element.
     * @readonly
     */
  }, {
    key: "_preElemWithDoc",
    value: function _preElemWithDoc(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Element, Document], ['Element', 'Document']);
    }
    /**
     * Normalizes and converts one or more DOM elements (or TinyHtml instances)
     * into an array of `TinyHtml` instances.
     *
     * - If a plain DOM element is passed, it is wrapped into a `TinyHtml` instance.
     * - If a `TinyHtml` instance is already passed, it is preserved.
     * - If an array is passed, all elements inside are converted accordingly.
     *
     * This ensures consistent access to methods of the `TinyHtml` class regardless
     * of the input form.
     *
     * @param {TinyElement|Text|(TinyElement|Text)[]} elems - A single element or an array of elements (DOM or TinyHtml).
     * @returns {TinyHtml[]} An array of TinyHtml instances corresponding to the input elements.
     */
  }, {
    key: "toTinyElm",
    value: function toTinyElm(elems) {
      /** @param {(TinyElement|Text)[]} item */
      var checkElement = function checkElement(item) {
        return item.map(function (elem) {
          return !(elem instanceof TinyHtml) ? new TinyHtml(elem) : elem;
        });
      };
      if (!Array.isArray(elems)) return checkElement([elems]);
      return checkElement(elems);
    }
    /**
     * Extracts native `Element` instances from one or more elements,
     * which can be either raw DOM elements or wrapped in `TinyHtml`.
     *
     * - If a `TinyHtml` instance is passed, its internal DOM element is extracted.
     * - If a raw DOM element is passed, it is returned as-is.
     * - If an array is passed, each element is processed accordingly.
     *
     * This function guarantees that the return value is always an array of
     * raw `Element` objects, regardless of whether the input was
     * a mix of `TinyHtml` or native DOM elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single element or an array of elements (DOM or TinyHtml`).
     * @returns {Element[]} An array of Element instances extracted from the input.
     */
  }, {
    key: "fromTinyElm",
    value: function fromTinyElm(elems) {
      /** @param {TinyElement[]} item */
      var checkElement = function checkElement(item) {
        /** @type {Element[]} */
        var result = [];
        item.map(function (elem) {
          return /** @type {Element[]} */(elem instanceof TinyHtml ? elem._getElements('fromTinyElm') : [elem]).map(function (elem) {
            return result.push(elem);
          });
        });
        return result;
      };
      if (!Array.isArray(elems)) return checkElement([elems]);
      return checkElement(elems);
    }
    /**
     * Filters an array of elements based on a selector, function, element, or array of elements.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {WinnowRequest} qualifier
     * @param {string} where - The context/method name using this validation.
     * @param {boolean} not Whether to invert the result (used for .not())
     * @returns {Element[]}
     */
  }, {
    key: "winnow",
    value: function winnow(elems, qualifier, where) {
      var not = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      if (typeof not !== 'boolean') throw new TypeError('The "not" must be a boolean.');
      if (typeof qualifier === 'function') {
        return TinyHtml._preElems(elems, where).filter(function (el, i) {
          return !!qualifier.call(el, i, el) !== not;
        });
      }
      if (qualifier instanceof Element) {
        return TinyHtml._preElems(elems, where).filter(function (el) {
          return el === qualifier !== not;
        });
      }
      if (Array.isArray(qualifier) || typeof qualifier !== 'string' &&
      // @ts-ignore
      qualifier.length != null) {
        return TinyHtml._preElems(elems, where).filter(function (el) {
          return qualifier.includes(el) !== not;
        });
      }
      // Assume it's a selector string
      var selector = qualifier;
      if (not) selector = ":not(".concat(selector, ")");
      return TinyHtml._preElems(elems, where).filter(function (el) {
        return el.nodeType === 1 && el.matches(selector);
      });
    }
    /**
     * Filters a set of elements by a CSS selector.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {string} selector
     * @param {boolean} not
     * @returns {Element[]}
     */
  }, {
    key: "filter",
    value: function filter(elems, selector) {
      var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (not) selector = ":not(".concat(selector, ")");
      return TinyHtml._preElems(elems, 'filter').filter(function (el) {
        return el.nodeType === 1 && el.matches(selector);
      });
    }
    /**
     * Returns only the elements matching the given selector or function.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {WinnowRequest} selector
     * @returns {Element[]}
     */
  }, {
    key: "filterOnly",
    value: function filterOnly(elems, selector) {
      return TinyHtml.winnow(elems, selector, 'filterOnly', false);
    }
    /**
     * Returns only the elements **not** matching the given selector or function.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {WinnowRequest} selector
     * @returns {Element[]}
     */
  }, {
    key: "not",
    value: function not(elems, selector) {
      return TinyHtml.winnow(elems, selector, 'not', true);
    }
  }, {
    key: "find",
    value: function find(context, selector) {
      var result = [];
      var _iterator6 = _createForOfIteratorHelper(TinyHtml._preElems(context, 'find')),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var el = _step6.value;
          result.push.apply(result, _toConsumableArray(el.querySelectorAll(selector)));
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return _toConsumableArray(new Set(result));
    }
  }, {
    key: "is",
    value: function is(elems, selector) {
      return TinyHtml.winnow(elems, selector, 'is', false).length > 0;
    }
  }, {
    key: "has",
    value: function has(roots, target) {
      var targets = typeof target === 'string' ? _toConsumableArray(document.querySelectorAll(target)) : TinyHtml._preElems(target, 'has');
      return TinyHtml._preElems(roots, 'has').filter(function (root) {
        return targets.some(function (t) {
          return root && root.contains(t);
        });
      });
    }
  }, {
    key: "closest",
    value: function closest(els, selector, context) {
      var matched = [];
      var _iterator7 = _createForOfIteratorHelper(TinyHtml._preElems(els, 'closest')),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var el = _step7.value;
          /** @type {Element | null} */
          var current = el;
          while (current && current !== context) {
            if (current.nodeType === 1 && (typeof selector === 'string' ? current.matches(selector) : current === selector)) {
              matched.push(current);
              break;
            }
            current = current.parentElement;
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return _toConsumableArray(new Set(matched));
    }
  }, {
    key: "isSameDom",
    value: function isSameDom(elem, otherElem) {
      return TinyHtml._preNodeElem(elem, 'isSameDom') === TinyHtml._preNodeElem(otherElem, 'isSameDom');
    }
  }, {
    key: "data",
    value:
    /**
     * Retrieves data associated with a DOM element.
     *
     * If a `key` is provided, the corresponding value is returned.
     * If no `key` is given, a shallow copy of all stored data is returned.
     *
     * @param {TinyElement} el - The DOM element.
     * @param {string|null} [key] - The specific key to retrieve from the data store.
     * @param {boolean} [isPrivate=false] - Whether to access the private data store.
     * @returns {ElementDataStore|undefined|any} - The stored value, all data, or undefined if the key doesn't exist.
     */
    function data(el, key) {
      var isPrivate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // Get or initialize the data object
      var data = TinyHtml._dataSelector[!isPrivate ? 'public' : 'private']('data', el);
      // Getter for all
      if (key === undefined || key === null) return _objectSpread({}, data);
      // Getter for specific key
      if (typeof key !== 'string') throw new TypeError('The key must be a string.');
      return data.hasOwnProperty(key) ? data[key] : undefined;
    }
  }, {
    key: "setData",
    value: function setData(el, key, value) {
      var isPrivate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var data = TinyHtml._dataSelector[!isPrivate ? 'public' : 'private']('setData', el);
      if (typeof key !== 'string') throw new TypeError('The key must be a string.');
      data[key] = value;
      return el;
    }
  }, {
    key: "_getSibling",
    value: function _getSibling(el, direction, where) {
      /** @type {Node|null} */
      var newCurrent = TinyHtml._preNodeElemWithNull(el, where);
      while (newCurrent && (newCurrent = newCurrent[direction]) && newCurrent.nodeType !== 1) {}
      if (!(newCurrent instanceof Node)) return null;
      return /** @type {ChildNode} */newCurrent;
    }
    /**
     * Get all sibling elements excluding the given one.
     *
     * @param {Node|null} start
     * @param {Node|null} [exclude]
     * @returns {ChildNode[]}
     * @readonly
     */
  }, {
    key: "_getSiblings",
    value: function _getSiblings(start, exclude) {
      /** @type {Node|null} */
      var st = start;
      var siblings = [];
      for (; st; st = st.nextSibling) {
        if (st.nodeType === 1 && st !== exclude) {
          siblings.push(st);
        }
      }
      return /** @type {ChildNode[]} */siblings;
    }
    /**
     * Traverse DOM in a direction collecting elements.
     *
     * @param {TinyNode} el
     * @param {"parentNode"|"nextSibling"|"previousSibling"} direction
     * @param {TinyNode|string} [until]
     * @param {string} [where='domDir']
     * @returns {ChildNode[]}
     */
  }, {
    key: "domDir",
    value: function domDir(el, direction, until) {
      var where = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'domDir';
      if (typeof direction !== 'string') throw new TypeError('The "direction" must be a string.');
      var elem = TinyHtml._preNodeElemWithNull(el, where);
      var matched = [];
      // @ts-ignore
      while (elem && (elem = elem[direction])) {
        if (elem.nodeType !== 1) continue;
        if (until && (typeof until === 'string' ?
        // @ts-ignore
        elem.matches(until) : elem === until)) break;
        matched.push(elem);
      }
      return /** @type {ChildNode[]} */matched;
    }
    /**
     * Returns the direct parent node of the given element, excluding document fragments.
     *
     * @param {TinyNode} el - The DOM node to find the parent of.
     * @returns {ParentNode|null} The parent node or null if not found.
     */
  }, {
    key: "parent",
    value: function parent(el) {
      var elem = TinyHtml._preNodeElemWithNull(el, 'parent');
      var parent = elem ? elem.parentNode : null;
      return parent && parent.nodeType !== 11 ? parent : null;
    }
  }, {
    key: "parents",
    value: function parents(el, until) {
      return TinyHtml.domDir(el, 'parentNode', until, 'parents');
    }
  }, {
    key: "next",
    value: function next(el) {
      return TinyHtml._getSibling(el, 'nextSibling', 'next');
    }
  }, {
    key: "prev",
    value: function prev(el) {
      return TinyHtml._getSibling(el, 'previousSibling', 'prev');
    }
  }, {
    key: "nextAll",
    value: function nextAll(el) {
      return TinyHtml.domDir(el, 'nextSibling', undefined, 'nextAll');
    }
  }, {
    key: "prevAll",
    value: function prevAll(el) {
      return TinyHtml.domDir(el, 'previousSibling', undefined, 'prevAll');
    }
  }, {
    key: "nextUntil",
    value: function nextUntil(el, until) {
      return TinyHtml.domDir(el, 'nextSibling', until, 'nextUtil');
    }
  }, {
    key: "prevUntil",
    value: function prevUntil(el, until) {
      return TinyHtml.domDir(el, 'previousSibling', until, 'prevUtil');
    }
  }, {
    key: "siblings",
    value: function siblings(el) {
      var elem = TinyHtml._preNodeElemWithNull(el, 'siblings');
      return TinyHtml._getSiblings(elem && elem.parentNode ? elem.parentNode.firstChild : null, elem);
    }
  }, {
    key: "children",
    value: function children(el) {
      var elem = TinyHtml._preNodeElemWithNull(el, 'children');
      return TinyHtml._getSiblings(elem ? elem.firstChild : null);
    }
  }, {
    key: "contents",
    value: function contents(el) {
      var elem = TinyHtml._preNodeElemWithNull(el, 'contents');
      if (elem instanceof HTMLIFrameElement && elem.contentDocument != null && Object.getPrototypeOf(elem.contentDocument)) {
        return [elem.contentDocument];
      }
      if (elem instanceof HTMLTemplateElement) {
        return Array.from((elem.content || elem).childNodes);
      }
      if (elem) return Array.from(elem.childNodes);
      return [];
    }
  }, {
    key: "clone",
    value: function clone(el) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (typeof deep !== 'boolean') throw new TypeError('The "deep" must be a boolean.');
      return TinyHtml._preNodeElems(el, 'clone').map(function (el) {
        return el.cloneNode(deep);
      });
    }
  }, {
    key: "_appendChecker",
    value: function _appendChecker(where) {
      var results = [];
      for (var _len8 = arguments.length, nodes = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
        nodes[_key8 - 1] = arguments[_key8];
      }
      var nds = [].concat(nodes);
      for (var index in nds) {
        if (typeof nds[index] !== 'string') {
          results.push(TinyHtml._preNodeElem(nds[index], where));
        } else results.push(nds[index]);
      }
      return results;
    }
    /**
     * Appends child elements or strings to the end of the target element(s).
     *
     * @param {TinyElement} el - The target element(s) to receive children.
     * @param {...(TinyNode | TinyNode[] | string)} children - The child elements or text to append.
     * @returns {TinyElement}
     */
  }, {
    key: "append",
    value: function append(el) {
      var elem = TinyHtml._preElem(el, 'append');
      for (var _len9 = arguments.length, children = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
        children[_key9 - 1] = arguments[_key9];
      }
      elem.append.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['append'].concat(children))));
      return el;
    }
  }, {
    key: "prepend",
    value: function prepend(el) {
      var elem = TinyHtml._preElem(el, 'prepend');
      for (var _len0 = arguments.length, children = new Array(_len0 > 1 ? _len0 - 1 : 0), _key0 = 1; _key0 < _len0; _key0++) {
        children[_key0 - 1] = arguments[_key0];
      }
      elem.prepend.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['prepend'].concat(children))));
      return el;
    }
  }, {
    key: "before",
    value: function before(el) {
      var elem = TinyHtml._preElem(el, 'before');
      for (var _len1 = arguments.length, children = new Array(_len1 > 1 ? _len1 - 1 : 0), _key1 = 1; _key1 < _len1; _key1++) {
        children[_key1 - 1] = arguments[_key1];
      }
      elem.before.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['before'].concat(children))));
      return el;
    }
  }, {
    key: "after",
    value: function after(el) {
      var elem = TinyHtml._preElem(el, 'after');
      for (var _len10 = arguments.length, children = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
        children[_key10 - 1] = arguments[_key10];
      }
      elem.after.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['after'].concat(children))));
      return el;
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(el) {
      var elem = TinyHtml._preElem(el, 'replaceWith');
      for (var _len11 = arguments.length, newNodes = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
        newNodes[_key11 - 1] = arguments[_key11];
      }
      elem.replaceWith.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['replaceWith'].concat(newNodes))));
      return el;
    }
  }, {
    key: "appendTo",
    value: function appendTo(el, targets) {
      var elems = TinyHtml._preNodeElems(el, 'appendTo');
      var tars = TinyHtml._preNodeElems(targets, 'appendTo');
      tars.forEach(function (target, i) {
        elems.forEach(function (elem) {
          return target.appendChild(i === tars.length - 1 ? elem : elem.cloneNode(true));
        });
      });
      return el;
    }
  }, {
    key: "prependTo",
    value: function prependTo(el, targets) {
      var elems = TinyHtml._preElems(el, 'prependTo');
      var tars = TinyHtml._preElems(targets, 'prependTo');
      tars.forEach(function (target, i) {
        elems.slice().reverse().forEach(function (elem) {
          return target.prepend(i === tars.length - 1 ? elem : elem.cloneNode(true));
        });
      });
      return el;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(el, target) {
      var child = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var elem = TinyHtml._preNodeElem(el, 'insertBefore');
      var targ = TinyHtml._preNodeElem(target, 'insertBefore');
      var childNode = TinyHtml._preNodeElemWithNull(child, 'insertBefore');
      if (!targ.parentNode) throw new Error('The target element has no parent node to insert before.');
      targ.parentNode.insertBefore(elem, childNode || targ);
      return el;
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(el, target) {
      var child = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var elem = TinyHtml._preNodeElem(el, 'insertAfter');
      var targ = TinyHtml._preNodeElem(target, 'insertBefore');
      var childNode = TinyHtml._preNodeElemWithNull(child, 'insertBefore');
      if (!targ.parentNode) throw new Error('The target element has no parent node to insert after.');
      targ.parentNode.insertBefore(elem, childNode || targ.nextSibling);
      return el;
    }
  }, {
    key: "replaceAll",
    value: function replaceAll(el, targets) {
      var elems = TinyHtml._preNodeElems(el, 'replaceAll');
      var tars = TinyHtml._preNodeElems(targets, 'replaceAll');
      tars.forEach(function (target, i) {
        var parent = target.parentNode;
        elems.forEach(function (elem) {
          if (parent) parent.replaceChild(i === tars.length - 1 ? elem : elem.cloneNode(true), target);
        });
      });
      return el;
    }
  }, {
    key: "isWindow",
    value: function isWindow(obj) {
      return obj != null && obj === obj.window;
    }
    /////////////////////////////////////////////////////
    /**
     * Returns the full computed CSS styles for the given element.
     *
     * @param {TinyElement} el - The element to retrieve styles from.
     * @returns {CSSStyleDeclaration} The computed style object for the element.
     */
  }, {
    key: "css",
    value: function css(el) {
      var elem = TinyHtml._preElem(el, 'css');
      return window.getComputedStyle(elem);
    }
  }, {
    key: "cssString",
    value: function cssString(el, prop) {
      var elem = TinyHtml._preElem(el, 'cssString');
      if (typeof prop !== 'string') throw new TypeError('The prop must be a string.');
      // @ts-ignore
      var val = window.getComputedStyle(elem)[prop];
      return typeof val === 'string' ? val : typeof val === 'number' ? val.toString() : null;
    }
  }, {
    key: "cssList",
    value: function cssList(el, prop) {
      var elem = TinyHtml._preElem(el, 'cssList');
      if (!Array.isArray(prop)) throw new TypeError('The prop must be an array of strings.');
      var css = window.getComputedStyle(elem);
      /** @type {Partial<CSSStyleDeclaration>} */
      var result = {};
      var _iterator8 = _createForOfIteratorHelper(prop),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var p = _step8.value;
          if (typeof p !== 'undefined') {
            // @ts-ignore
            result[p] = css.getPropertyValue(p);
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      return result;
    }
  }, {
    key: "cssFloat",
    value: function cssFloat(el, prop) {
      var elem = TinyHtml._preElem(el, 'cssFloat');
      if (typeof prop !== 'string') throw new TypeError('The prop must be a string.');
      // @ts-ignore
      var val = window.getComputedStyle(elem)[prop];
      return parseFloat(val) || 0;
    }
  }, {
    key: "cssFloats",
    value: function cssFloats(el, prop) {
      var elem = TinyHtml._preElem(el, 'cssFloats');
      if (!Array.isArray(prop)) throw new TypeError('The prop must be an array of strings.');
      var css = window.getComputedStyle(elem);
      /** @type {Record<string, number>} */
      var result = {};
      var _iterator9 = _createForOfIteratorHelper(prop),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var name = _step9.value;
          // @ts-ignore
          result[name] = parseFloat(css[name]) || 0;
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
      return result;
    }
  }, {
    key: "toStyleKc",
    value:
    /**
     * Converts a camelCase string to kebab-case
     * @param {string} str
     * @returns {string}
     */
    function toStyleKc(str) {
      if (typeof TinyHtml.cssPropAliases[str] === 'string') return TinyHtml.cssPropAliases[str];
      return str;
    }
    /**
     * Converts a kebab-case string to camelCase
     * @param {string} str
     * @returns {string}
     */
  }, {
    key: "toStyleCc",
    value: function toStyleCc(str) {
      if (typeof TinyHtml.cssPropRevAliases[str] === 'string') return TinyHtml.cssPropRevAliases[str];
      return str;
    }
    /**
     * Sets one or more CSS inline style properties on the given element(s).
     *
     * - If `prop` is a string, the `value` will be applied to that property.
     * - If `prop` is an object, each key-value pair will be applied as a CSS property and value.
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - The element to inspect.
     * @param {string|Object} prop - The property name or an object with key-value pairs
     * @param {string|null} [value=null] - The value to set (if `prop` is a string)
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
  }, {
    key: "setStyle",
    value: function setStyle(el, prop) {
      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      TinyHtml._preHtmlElems(el, 'setStyle').forEach(function (elem) {
        if (_typeof(prop) === 'object') {
          for (var _i2 = 0, _Object$entries2 = Object.entries(prop); _i2 < _Object$entries2.length; _i2++) {
            var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
              k = _Object$entries2$_i[0],
              v = _Object$entries2$_i[1];
            elem.style.setProperty(TinyHtml.toStyleKc(k), typeof v === 'string' ? v : typeof v === 'number' ? "".concat(v, "px") : String(v));
          }
        } else elem.style.setProperty(TinyHtml.toStyleKc(prop), value);
      });
      return el;
    }
  }, {
    key: "getStyle",
    value: function getStyle(el, prop) {
      return TinyHtml._preHtmlElem(el, 'getStyle').style.getPropertyValue(TinyHtml.toStyleKc(prop));
    }
  }, {
    key: "style",
    value: function style(el) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref3$camelCase = _ref3.camelCase,
        camelCase = _ref3$camelCase === void 0 ? false : _ref3$camelCase,
        _ref3$rawAttr = _ref3.rawAttr,
        rawAttr = _ref3$rawAttr === void 0 ? false : _ref3$rawAttr;
      if (typeof camelCase !== 'boolean') throw new TypeError("\"camelCase\" must be a boolean. Received: ".concat(_typeof(camelCase)));
      if (typeof rawAttr !== 'boolean') throw new TypeError("\"rawAttr\" must be a boolean. Received: ".concat(_typeof(rawAttr)));
      var elem = TinyHtml._preHtmlElem(el, 'style');
      /** @type {Record<string, string>} */
      var result = {};
      if (rawAttr) {
        var raw = elem.getAttribute('style') || '';
        var entries = raw.split(';');
        var _iterator0 = _createForOfIteratorHelper(entries),
          _step0;
        try {
          for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
            var entry = _step0.value;
            var _entry$split = entry.split(':'),
              _entry$split2 = _slicedToArray(_entry$split, 2),
              rawProp = _entry$split2[0],
              rawVal = _entry$split2[1];
            if (!rawProp || !rawVal) continue;
            var prop = rawProp.trim();
            var value = rawVal.trim();
            result[camelCase ? TinyHtml.toStyleCc(prop) : prop] = value;
          }
        } catch (err) {
          _iterator0.e(err);
        } finally {
          _iterator0.f();
        }
      } else {
        var styles = elem.style;
        for (var i = 0; i < styles.length; i++) {
          var _prop = styles[i]; // Already in kebab-case
          var _value = styles.getPropertyValue(_prop);
          result[camelCase ? TinyHtml.toStyleCc(_prop) : _prop] = _value;
        }
      }
      return result;
    }
  }, {
    key: "removeStyle",
    value: function removeStyle(el, prop) {
      TinyHtml._preHtmlElems(el, 'removeStyle').forEach(function (elem) {
        if (Array.isArray(prop)) {
          var _iterator1 = _createForOfIteratorHelper(prop),
            _step1;
          try {
            for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
              var p = _step1.value;
              elem.style.removeProperty(TinyHtml.toStyleKc(p));
            }
          } catch (err) {
            _iterator1.e(err);
          } finally {
            _iterator1.f();
          }
        } else elem.style.removeProperty(TinyHtml.toStyleKc(prop));
      });
      return el;
    }
  }, {
    key: "toggleStyle",
    value: function toggleStyle(el, prop, val1, val2) {
      TinyHtml._preHtmlElems(el, 'toggleStyle').forEach(function (elem) {
        var current = TinyHtml.getStyle(elem, prop).trim();
        var newVal = current === TinyHtml.toStyleKc(val1) ? val2 : val1;
        TinyHtml.setStyle(elem, prop, newVal);
      });
      return el;
    }
  }, {
    key: "clearStyle",
    value: function clearStyle(el) {
      TinyHtml._preElems(el, 'clearStyle').forEach(function (elem) {
        return elem.removeAttribute('style');
      });
      return el;
    }
  }, {
    key: "focus",
    value: function focus(el) {
      var elem = TinyHtml._preHtmlElem(el, 'focus');
      elem.focus();
      return el;
    }
  }, {
    key: "blur",
    value: function blur(el) {
      var elem = TinyHtml._preHtmlElem(el, 'blur');
      elem.blur();
      return el;
    }
  }, {
    key: "boolCheck",
    value: function boolCheck(value) {
      if (typeof value !== 'undefined' && (value === 'true' || value === '1' || value === true || value === 'on' || typeof value === 'number' && value > 0)) {
        return true;
      } else {
        return false;
      }
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Sets the vertical scroll position of the window.
     * @param {number} value - Sets the scroll position.
     */
  }, {
    key: "setWinScrollTop",
    value: function setWinScrollTop(value) {
      if (typeof value !== 'number') throw new TypeError('The value must be a number.');
      TinyHtml.setScrollTop(window, value);
    }
    /**
     * Sets the horizontal scroll position of the window.
     * @param {number} value - Sets the scroll position.
     */
  }, {
    key: "setWinScrollLeft",
    value: function setWinScrollLeft(value) {
      if (typeof value !== 'number') throw new TypeError('The value must be a number.');
      TinyHtml.setScrollLeft(window, value);
    }
    /**
     * Gets the vertical scroll position of the window.
     * @returns {number} - The current scroll top value.
     */
  }, {
    key: "winScrollTop",
    value: function winScrollTop() {
      return window.scrollY || document.documentElement.scrollTop;
    }
    /**
     * Gets the horizontal scroll position of the window.
     * @returns {number} - The current scroll left value.
     */
  }, {
    key: "winScrollLeft",
    value: function winScrollLeft() {
      return window.scrollX || document.documentElement.scrollLeft;
    }
    /**
     * Returns the current height of the viewport.
     * @returns {number} - Viewport height in pixels.
     */
  }, {
    key: "winInnerHeight",
    value: function winInnerHeight() {
      return window.innerHeight || document.documentElement.clientHeight;
    }
    /**
     * Returns the current width of the viewport.
     * @returns {number} - Viewport width in pixels.
     */
  }, {
    key: "winInnerWidth",
    value: function winInnerWidth() {
      return window.innerWidth || document.documentElement.clientWidth;
    }
    /**
     * Checks if the page is currently scrolled to the very top.
     *
     * This method compares the current vertical scroll position with the total document height.
     * It's useful for detecting if the user has reached the top of the page.
     *
     * @returns {boolean} `true` if the page is scrolled to the top, otherwise `false`.
     */
  }, {
    key: "isPageTop",
    value: function isPageTop() {
      return window.scrollY === 0;
    }
    /**
     * Checks if the page is currently scrolled to the very bottom.
     *
     * This method uses the `scrollY` and `innerHeight` properties to determine if the
     * user has reached the end of the document.
     *
     * @returns {boolean} `true` if the page is scrolled to the bottom, otherwise `false`.
     */
  }, {
    key: "isPageBottom",
    value: function isPageBottom() {
      return window.innerHeight + window.scrollY >= document.body.offsetHeight;
    }
    /**
     * Gets the width or height of an element based on the box model.
     * @param {TinyElementAndWinAndDoc} el - The element or window.
     * @param {"width"|"height"} type - Dimension type.
     * @param {"content"|"padding"|"border"|"margin"} [extra='content'] - Box model context.
     * @returns {number} - Computed dimension.
     * @throws {TypeError} If `type` or `extra` is not a string.
     */
  }, {
    key: "getDimension",
    value: function getDimension(el, type) {
      var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'content';
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'getDimension');
      if (typeof type !== 'string') throw new TypeError('The type must be a string.');
      if (typeof extra !== 'string') throw new TypeError('The extra must be a string.');
      var name = type === 'width' ? 'Width' : 'Height';
      if (TinyHtml.isWindow(elem)) {
        return extra === 'margin' ?
        // @ts-ignore
        elem['inner' + name] :
        // @ts-ignore
        elem.document.documentElement['client' + name];
      }
      /** @type {Element} */
      var elHtml = elem;
      if (elHtml.nodeType === 9) {
        // @ts-ignore
        var doc = elHtml.documentElement;
        return Math.max(
        // @ts-ignore
        elHtml.body['scroll' + name], doc['scroll' + name],
        // @ts-ignore
        elHtml.body['offset' + name], doc['offset' + name], doc['client' + name]);
      }
      var size = elHtml.getBoundingClientRect()[type];
      /**
       * Auxiliary function to add measures on one side and the other
       * @param {string} prefix
       */
      function sumSides(prefix) {
        if (type === 'width') {
          return TinyHtml.cssFloat(elHtml, prefix + 'Left') + TinyHtml.cssFloat(elHtml, prefix + 'Right');
        } else {
          return TinyHtml.cssFloat(elHtml, prefix + 'Top') + TinyHtml.cssFloat(elHtml, prefix + 'Bottom');
        }
      }
      switch (extra) {
        case 'content':
          // remove padding + border
          size -= sumSides('padding');
          size -= sumSides('border');
          break;
        case 'padding':
          // remove border only (padding included in the bounding rect)
          size -= sumSides('border');
          break;
        case 'border':
          // bounding rect already includes border + padding, so do not move the size
          break;
        case 'margin':
          // adds margin (margin is out of bounding rect)
          size += sumSides('margin');
          break;
      }
      return size;
    }
  }, {
    key: "setHeight",
    value: function setHeight(el, value) {
      var elem = TinyHtml._preHtmlElem(el, 'setHeight');
      if (typeof value !== 'number' && typeof value !== 'string') throw new TypeError('The value must be a string or number.');
      elem.style.height = typeof value === 'number' ? "".concat(value, "px") : value;
      return el;
    }
  }, {
    key: "setWidth",
    value: function setWidth(el, value) {
      var elem = TinyHtml._preHtmlElem(el, 'setWidth');
      if (typeof value !== 'number' && typeof value !== 'string') throw new TypeError('The value must be a string or number.');
      elem.style.width = typeof value === 'number' ? "".concat(value, "px") : value;
      return el;
    }
  }, {
    key: "height",
    value: function height(el) {
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'height');
      return TinyHtml.getDimension(elem, 'height', 'content');
    }
  }, {
    key: "width",
    value: function width(el) {
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'width');
      return TinyHtml.getDimension(elem, 'width', 'content');
    }
  }, {
    key: "innerHeight",
    value: function innerHeight(el) {
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'innerHeight');
      return TinyHtml.getDimension(elem, 'height', 'padding');
    }
  }, {
    key: "innerWidth",
    value: function innerWidth(el) {
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'innerWidth');
      return TinyHtml.getDimension(elem, 'width', 'padding');
    }
  }, {
    key: "outerHeight",
    value: function outerHeight(el) {
      var includeMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (typeof includeMargin !== 'boolean') throw new TypeError('The "includeMargin" must be a boolean.');
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'outerHeight');
      return TinyHtml.getDimension(elem, 'height', includeMargin ? 'margin' : 'border');
    }
  }, {
    key: "outerWidth",
    value: function outerWidth(el) {
      var includeMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (typeof includeMargin !== 'boolean') throw new TypeError('The "includeMargin" must be a boolean.');
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'outerWidth');
      return TinyHtml.getDimension(elem, 'width', includeMargin ? 'margin' : 'border');
    }
  }, {
    key: "animate",
    value: function animate(el, keyframes, ops) {
      TinyHtml._preElems(el, 'animate').forEach(function (elem) {
        return elem.animate(keyframes, ops);
      });
      return el;
    }
  }, {
    key: "offset",
    value: function offset(el) {
      var elem = TinyHtml._preElem(el, 'offset');
      var rect = elem.getBoundingClientRect();
      var scrollTop = window.scrollY || document.documentElement.scrollTop;
      var scrollLeft = window.scrollX || document.documentElement.scrollLeft;
      return {
        top: rect.top + scrollTop,
        left: rect.left + scrollLeft
      };
    }
  }, {
    key: "position",
    value: function position(el) {
      var elem = TinyHtml._preHtmlElem(el, 'position');
      var offsetParent;
      var offset;
      var parentOffset = {
        top: 0,
        left: 0
      };
      var computedStyle = window.getComputedStyle(elem);
      if (computedStyle.position === 'fixed') {
        offset = elem.getBoundingClientRect();
      } else {
        offset = TinyHtml.offset(elem);
        offsetParent = elem.offsetParent || document.documentElement;
        var _window$getComputedSt = window.getComputedStyle(offsetParent),
          _position = _window$getComputedSt.position;
        while (offsetParent instanceof HTMLElement && (offsetParent === document.body || offsetParent === document.documentElement) && _position === 'static') {
          offsetParent = offsetParent.parentNode;
        }
        if (offsetParent instanceof HTMLElement && offsetParent !== elem && offsetParent.nodeType === 1) {
          var _TinyHtml$cssFloats = TinyHtml.cssFloats(offsetParent, ['borderTopWidth', 'borderLeftWidth']),
            borderTopWidth = _TinyHtml$cssFloats.borderTopWidth,
            borderLeftWidth = _TinyHtml$cssFloats.borderLeftWidth;
          parentOffset = TinyHtml.offset(offsetParent);
          parentOffset.top += borderTopWidth;
          parentOffset.left += borderLeftWidth;
        }
      }
      return {
        top: offset.top - parentOffset.top - TinyHtml.cssFloat(elem, 'marginTop'),
        left: offset.left - parentOffset.left - TinyHtml.cssFloat(elem, 'marginLeft')
      };
    }
  }, {
    key: "offsetParent",
    value: function offsetParent(el) {
      var elem = TinyHtml._preHtmlElem(el, 'offsetParent');
      var offsetParent = elem.offsetParent;
      while (offsetParent instanceof HTMLElement && window.getComputedStyle(offsetParent).position === 'static') {
        offsetParent = offsetParent.offsetParent;
      }
      // Fallback to document.documentElement
      return offsetParent instanceof HTMLElement ? offsetParent : document.documentElement;
    }
  }, {
    key: "scrollTop",
    value: function scrollTop(el) {
      var elem = TinyHtml._preElemAndWindow(el, 'scrollTop');
      if (TinyHtml.isWindow(elem)) return elem.pageYOffset;
      // @ts-ignore
      if (elem.nodeType === 9) return elem.defaultView.pageYOffset;
      return elem.scrollTop;
    }
  }, {
    key: "scrollLeft",
    value: function scrollLeft(el) {
      var elem = TinyHtml._preElemAndWindow(el, 'scrollLeft');
      if (TinyHtml.isWindow(elem)) return elem.pageXOffset;
      // @ts-ignore
      if (elem.nodeType === 9) return elem.defaultView.pageXOffset;
      return elem.scrollLeft;
    }
  }, {
    key: "scrollToXY",
    value:
    /**
     * Smoothly scrolls one or more elements (or the window) to the specified X and Y coordinates
     * using a custom duration and easing function.
     *
     * If `duration` or a valid `easing` is not provided, the scroll will be performed immediately.
     *
     * @param {TinyElementAndWindow | TinyElementAndWindow[]} el - A single element, array of elements, or the window to scroll.
     * @param {Object} [settings={}] - Configuration object for the scroll animation.
     * @param {number} [settings.targetX] - The horizontal scroll target in pixels.
     * @param {number} [settings.targetY] - The vertical scroll target in pixels.
     * @param {number} [settings.duration] - The duration of the animation in milliseconds.
     * @param {Easings} [settings.easing] - The easing function name to use for the scroll animation.
     * @param {OnScrollAnimation} [settings.onAnimation] - Optional callback invoked on each animation
     *   frame with the current scroll position, normalized animation time (`0` to `1`), and a completion flag.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     * @throws {TypeError} If `el` is not a valid element, array, or window.
     * @throws {TypeError} If `targetX` or `targetY` is defined but not a number.
     * @throws {TypeError} If `duration` is defined but not a number.
     * @throws {TypeError} If `easing` is defined but not a valid easing function name.
     * @throws {TypeError} If `onAnimation` is defined but not a function.
     */
    function scrollToXY(el) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        targetX = _ref4.targetX,
        targetY = _ref4.targetY,
        duration = _ref4.duration,
        easing = _ref4.easing,
        onAnimation = _ref4.onAnimation;
      if (targetX !== undefined && typeof targetX !== 'number') throw new TypeError('`targetX` must be a number if provided.');
      if (targetY !== undefined && typeof targetY !== 'number') throw new TypeError('`targetY` must be a number if provided.');
      if (duration !== undefined && typeof duration !== 'number') throw new TypeError('`duration` must be a number if provided.');
      if (easing !== undefined && typeof easing !== 'string') throw new TypeError('`easing` must be a string if provided.');
      if (easing !== undefined && typeof TinyHtml.easings[easing] !== 'function') throw new TypeError("Unknown easing function: \"".concat(easing, "\"."));
      if (onAnimation !== undefined && typeof onAnimation !== 'function') throw new TypeError('`onAnimation` must be a function if provided.');
      /**
       * Performs an instant scroll to the given coordinates.
       *
       * @param {ElementAndWindow} elem - The element or window to scroll.
       * @param {number} newX - The final horizontal scroll position.
       * @param {number} newY - The final vertical scroll position.
       * @param {number} time - Normalized progress value.
       */
      var executeScroll = function executeScroll(elem, newX, newY, time) {
        if (elem instanceof Window) {
          window.scrollTo(newX, newY);
        } else if (elem.nodeType === 9) {
          // @ts-ignore
          elem.defaultView.scrollTo(newX, newY);
        } else {
          var startX = elem instanceof Window ? window.scrollX : elem.scrollLeft;
          var startY = elem instanceof Window ? window.scrollY : elem.scrollTop;
          if (startX !== newX) elem.scrollLeft = newX;
          if (startY !== newY) elem.scrollTop = newY;
        }
        if (typeof onAnimation === 'function') onAnimation({
          x: newX,
          y: newY,
          isComplete: time >= 1,
          time: time
        });
      };
      TinyHtml._preElemsAndWindow(el, 'scrollToXY').forEach(function (elem) {
        var startX = elem instanceof Window ? window.scrollX : elem.scrollLeft;
        var startY = elem instanceof Window ? window.scrollY : elem.scrollTop;
        var targX = targetX !== null && targetX !== void 0 ? targetX : startX;
        var targY = targetY !== null && targetY !== void 0 ? targetY : startY;
        var changeX = targX - startX;
        var changeY = targY - startY;
        var ease = typeof easing === 'string' && TinyHtml.easings[easing] || null;
        if (typeof duration !== 'number' || typeof ease !== 'function') return executeScroll(elem, targX, targY, 1);
        var startTime = performance.now();
        var dur = duration !== null && duration !== void 0 ? duration : 0;
        /**
         * Animates the scroll position based on easing and time.
         *
         * @param {number} currentTime - Timestamp provided by requestAnimationFrame.
         */
        function animateScroll(currentTime) {
          if (typeof ease !== 'function') return;
          var time = Math.min(1, (currentTime - startTime) / dur);
          var easedTime = ease(time);
          var newX = startX + changeX * easedTime;
          var newY = startY + changeY * easedTime;
          executeScroll(elem, newX, newY, time);
          if (time < 1) requestAnimationFrame(animateScroll);
        }
        requestAnimationFrame(animateScroll);
      });
      return el;
    }
  }, {
    key: "setScrollTop",
    value: function setScrollTop(el, value) {
      if (typeof value !== 'number') throw new TypeError('ScrollTop value must be a number.');
      return TinyHtml.scrollToXY(el, {
        targetY: value
      });
    }
  }, {
    key: "setScrollLeft",
    value: function setScrollLeft(el, value) {
      if (typeof value !== 'number') throw new TypeError('ScrollLeft value must be a number.');
      return TinyHtml.scrollToXY(el, {
        targetX: value
      });
    }
  }, {
    key: "borderWidth",
    value: function borderWidth(el) {
      var elem = TinyHtml._preElem(el, 'borderWidth');
      var _TinyHtml$cssFloats2 = TinyHtml.cssFloats(elem, ['borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth']),
        left = _TinyHtml$cssFloats2.borderLeftWidth,
        right = _TinyHtml$cssFloats2.borderRightWidth,
        top = _TinyHtml$cssFloats2.borderTopWidth,
        bottom = _TinyHtml$cssFloats2.borderBottomWidth;
      var x = left + right;
      var y = top + bottom;
      return {
        x: x,
        y: y,
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }
  }, {
    key: "border",
    value: function border(el) {
      var elem = TinyHtml._preElem(el, 'border');
      var _TinyHtml$cssFloats3 = TinyHtml.cssFloats(elem, ['borderLeft', 'borderRight', 'borderTop', 'borderBottom']),
        left = _TinyHtml$cssFloats3.borderLeft,
        right = _TinyHtml$cssFloats3.borderRight,
        top = _TinyHtml$cssFloats3.borderTop,
        bottom = _TinyHtml$cssFloats3.borderBottom;
      var x = left + right;
      var y = top + bottom;
      return {
        x: x,
        y: y,
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }
  }, {
    key: "margin",
    value: function margin(el) {
      var elem = TinyHtml._preElem(el, 'margin');
      var _TinyHtml$cssFloats4 = TinyHtml.cssFloats(elem, ['marginLeft', 'marginRight', 'marginTop', 'marginBottom']),
        left = _TinyHtml$cssFloats4.marginLeft,
        right = _TinyHtml$cssFloats4.marginRight,
        top = _TinyHtml$cssFloats4.marginTop,
        bottom = _TinyHtml$cssFloats4.marginBottom;
      var x = left + right;
      var y = top + bottom;
      return {
        x: x,
        y: y,
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }
  }, {
    key: "padding",
    value: function padding(el) {
      var elem = TinyHtml._preElem(el, 'padding');
      var _TinyHtml$cssFloats5 = TinyHtml.cssFloats(elem, ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom']),
        left = _TinyHtml$cssFloats5.paddingLeft,
        right = _TinyHtml$cssFloats5.paddingRight,
        top = _TinyHtml$cssFloats5.paddingTop,
        bottom = _TinyHtml$cssFloats5.paddingBottom;
      var x = left + right;
      var y = top + bottom;
      return {
        x: x,
        y: y,
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }
  }, {
    key: "addClass",
    value: function addClass(el) {
      for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
        args[_key12 - 1] = arguments[_key12];
      }
      TinyHtml._preElems(el, 'addClass').forEach(function (elem) {
        var _elem$classList;
        return (_elem$classList = elem.classList).add.apply(_elem$classList, args);
      });
      return el;
    }
  }, {
    key: "removeClass",
    value: function removeClass(el) {
      for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
        args[_key13 - 1] = arguments[_key13];
      }
      TinyHtml._preElems(el, 'removeClass').forEach(function (elem) {
        var _elem$classList2;
        return (_elem$classList2 = elem.classList).remove.apply(_elem$classList2, args);
      });
      return el;
    }
  }, {
    key: "replaceClass",
    value: function replaceClass(el, token, newToken) {
      if (typeof token !== 'string') throw new TypeError('The "token" parameter must be a string.');
      if (typeof newToken !== 'string') throw new TypeError('The "newToken" parameter must be a string.');
      /** @type {boolean[]} */
      var result = [];
      TinyHtml._preElems(el, 'replaceClass').forEach(function (elem) {
        return result.push(elem.classList.replace(token, newToken));
      });
      return result;
    }
  }, {
    key: "classItem",
    value: function classItem(el, index) {
      var elem = TinyHtml._preElem(el, 'classItem');
      if (typeof index !== 'number') throw new TypeError('The "index" parameter must be a number.');
      return elem.classList.item(index);
    }
  }, {
    key: "toggleClass",
    value: function toggleClass(el, token, force) {
      if (typeof token !== 'string') throw new TypeError('The "token" parameter must be a string.');
      if (typeof force !== 'undefined' && typeof force !== 'boolean') throw new TypeError('The "force" parameter must be a boolean.');
      /** @type {boolean[]} */
      var result = [];
      TinyHtml._preElems(el, 'toggleClass').forEach(function (elem) {
        return result.push(elem.classList.toggle(token, force));
      });
      return result;
    }
  }, {
    key: "hasClass",
    value: function hasClass(el, token) {
      var elem = TinyHtml._preElem(el, 'hasClass');
      if (typeof token !== 'string') throw new TypeError('The "token" parameter must be a string.');
      return elem.classList.contains(token);
    }
  }, {
    key: "classLength",
    value: function classLength(el) {
      var elem = TinyHtml._preElem(el, 'classLength');
      return elem.classList.length;
    }
  }, {
    key: "classList",
    value: function classList(el) {
      var elem = TinyHtml._preElem(el, 'classList');
      return elem.classList.values().toArray();
    }
  }, {
    key: "tagName",
    value: function tagName(el) {
      var elem = TinyHtml._preElem(el, 'tagName');
      return elem.tagName;
    }
  }, {
    key: "id",
    value: function id(el) {
      var elem = TinyHtml._preElem(el, 'id');
      return elem.id;
    }
  }, {
    key: "text",
    value: function text(el) {
      var elem = TinyHtml._preElem(el, 'text');
      return elem.textContent;
    }
  }, {
    key: "setText",
    value: function setText(el, value) {
      if (typeof value !== 'string') throw new Error('Value is not a valid string.');
      TinyHtml._preElems(el, 'setText').forEach(function (el) {
        return el.textContent = value;
      });
      return el;
    }
  }, {
    key: "empty",
    value: function empty(el) {
      TinyHtml._preElems(el, 'empty').forEach(function (el) {
        return el.textContent = '';
      });
      return el;
    }
  }, {
    key: "html",
    value: function html(el, ops) {
      var elem = TinyHtml._preElem(el, 'html');
      return elem.getHTML(ops);
    }
  }, {
    key: "setHtml",
    value: function setHtml(el, value) {
      if (typeof value !== 'string') throw new Error('Value is not a valid string.');
      TinyHtml._preElems(el, 'setHtml').forEach(function (el) {
        return el.innerHTML = value;
      });
      return el;
    }
  }, {
    key: "setVal",
    value:
    /**
     * Sets the value of the current HTML value element (input, select, textarea, etc.).
     * Accepts strings, numbers, booleans or arrays of these values, or a callback function that computes them.
     *
     * @param {TinyInputElement|TinyInputElement[]} el - Target element.
     * @param {SetValueList|((el: InputElement, val: SetValueList) => SetValueList)} value - The value to assign or a function that returns it.
     * @throws {Error} If the computed value is not a valid string or boolean.
     * @returns {TinyInputElement|TinyInputElement[]}
     */
    function setVal(el, value) {
      TinyHtml._preInputElems(el, 'setVal').forEach(function (elem) {
        /**
         * @param {SetValueBase[]} array
         * @param {(v: SetValueBase, i: number) => SetValueBase} callback
         */
        var mapArray = function mapArray(array, callback) {
          var result = [];
          for (var i = 0; i < array.length; i++) {
            result.push(callback(array[i], i));
          }
          return result;
        };
        if (elem.nodeType !== 1) return;
        /** @type {SetValueList} */
        var valToSet = typeof value === 'function' ? value(elem, TinyHtml.val(elem)) : value;
        if (valToSet == null) {
          valToSet = '';
        } else if (typeof valToSet === 'number') {
          valToSet = String(valToSet);
        } else if (Array.isArray(valToSet)) {
          valToSet = mapArray(valToSet, function (v) {
            return v == null ? '' : String(v);
          });
        }
        // @ts-ignore
        var hook = TinyHtml._valHooks[elem.type] || TinyHtml._valHooks[elem.nodeName.toLowerCase()];
        if (!hook || typeof hook.set !== 'function' || hook.set(elem, valToSet, 'value') === undefined) {
          if (typeof valToSet !== 'string' && typeof valToSet !== 'boolean') throw new Error("Invalid setValue \"".concat(_typeof(valToSet), "\" value."));
          if (typeof valToSet === 'string') elem.value = valToSet;
        }
      });
      return el;
    }
  }, {
    key: "_getValByType",
    value:
    /**
     * Gets the value of an input element according to the specified type.
     *
     * @param {InputElement} elem - The input element to extract the value from.
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @param {string} where - The context/method name using this validation.
     * @returns {any} The extracted value, depending on the type.
     * @throws {Error} If the element is not an HTMLInputElement or if the type handler is invalid.
     * @readonly
     */
    function _getValByType(elem, type, where) {
      if (typeof type !== 'string') throw new TypeError('The "type" must be a string.');
      if (typeof where !== 'string') throw new TypeError('The "where" must be a string.');
      if (!(elem instanceof HTMLInputElement) && !(elem instanceof HTMLTextAreaElement)) throw new Error("Provided element is not an HTMLInputElement in ".concat(where, "()."));
      if (typeof TinyHtml._valTypes[type] !== 'function') throw new Error("No handler found for type \"".concat(type, "\" in ").concat(where, "()."));
      // @ts-ignore
      return TinyHtml._valTypes[type](elem);
    }
    /**
     * Retrieves the raw value from the HTML input element.
     * If a custom value hook exists, it will be used first.
     *
     * @param {TinyInputElement} el - Target element.
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @param {string} where - The context/method name using this validation.
     * @returns {any} The raw value retrieved from the element or hook.
     * @readonly
     */
  }, {
    key: "_val",
    value: function _val(el, where, type) {
      var elem = TinyHtml._preInputElem(el, where);
      // @ts-ignore
      var hook = TinyHtml._valHooks[elem.type] || TinyHtml._valHooks[elem.nodeName.toLowerCase()];
      if (hook && typeof hook.get === 'function') {
        var ret = hook.get(elem, 'value', type);
        if (ret !== undefined) return typeof ret === 'string' ? ret.replace(/\r/g, '') : ret;
      }
      return TinyHtml._getValByType(elem, type, where);
    }
  }, {
    key: "val",
    value: function val(el) {
      return /** @type {SetValueList} */TinyHtml._val(el, 'val', 'string');
    }
  }, {
    key: "valTxt",
    value: function valTxt(el) {
      /** @type {string} */
      var ret = TinyHtml._val(el, 'valTxt', 'string');
      if (typeof ret !== 'string' && ret !== null) throw new Error('Value is not a valid string.');
      return ret == null ? '' : typeof ret === 'string' ? ret.replace(/\r/g, '') : ret;
    }
  }, {
    key: "_valArr",
    value: function _valArr(el, where, type) {
      /** @type {SetValueBase[]} */
      var ret = TinyHtml._val(el, where, type);
      if (!Array.isArray(ret)) throw new Error("Value expected an array but got ".concat(_typeof(ret), "."));
      return ret;
    }
  }, {
    key: "valArr",
    value: function valArr(el) {
      return TinyHtml._valArr(el, 'valArr', 'string');
    }
  }, {
    key: "valNb",
    value: function valNb(el) {
      var elem = TinyHtml._preInputElem(el, 'valNb');
      if (!(elem instanceof HTMLInputElement)) throw new Error('Element must be an input element.');
      /** @type {number} */
      var result = TinyHtml._val(el, 'valNb', 'number');
      if (Number.isNaN(result)) throw new Error('Value is not a valid number.');
      return result;
    }
  }, {
    key: "valDate",
    value: function valDate(el) {
      var elem = TinyHtml._preInputElem(el, 'valDate');
      if (!(elem instanceof HTMLInputElement)) throw new Error('Element must be an input element.');
      /** @type {Date} */
      var result = TinyHtml._val(el, 'valDate', 'date');
      if (!(result instanceof Date)) throw new Error('Value is not a valid date.');
      return result;
    }
  }, {
    key: "valBool",
    value: function valBool(el) {
      var elem = TinyHtml._preInputElem(el, 'valBool');
      if (!(elem instanceof HTMLInputElement)) throw new Error('Element must be an input element.');
      return TinyHtml.val(elem) === 'on' ? true : false;
    }
  }, {
    key: "listenForPaste",
    value: function listenForPaste(el) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        onFilePaste = _ref5.onFilePaste,
        onTextPaste = _ref5.onTextPaste;
      if (typeof onFilePaste !== 'undefined' && typeof onFilePaste !== 'function') throw new TypeError('onFilePaste must be a function.');
      if (typeof onTextPaste !== 'undefined' && typeof onTextPaste !== 'function') throw new TypeError('onTextPaste must be a function.');
      /** @type {EventListenerOrEventListenerObject} */
      var pasteEvent = function pasteEvent(event) {
        var _event$clipboardData;
        if (!(event instanceof ClipboardEvent)) return;
        var items = ((_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.items) || [];
        var _iterator10 = _createForOfIteratorHelper(items),
          _step10;
        try {
          var _loop = function _loop() {
            var item = _step10.value;
            if (item.kind === 'file') {
              if (typeof onFilePaste === 'function') {
                var file = item.getAsFile();
                if (file) onFilePaste(item, file);
              }
            } else if (item.kind === 'string') {
              if (typeof onTextPaste === 'function') item.getAsString(function (text) {
                return onTextPaste(item, text);
              });
            }
          };
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
      };
      TinyHtml._preElemsWithDoc(el, 'listenForPaste').forEach(function (elem) {
        return TinyHtml.on(elem, 'paste', pasteEvent);
      });
      return pasteEvent;
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(el, event) {
      var elem = TinyHtml._preEventTargetElem(el, 'hasEventListener');
      if (!__eventRegistry.has(elem)) return false;
      var events = __eventRegistry.get(elem);
      return !!(events && Array.isArray(events[event]) && events[event].length > 0);
    }
  }, {
    key: "hasExactEventListener",
    value: function hasExactEventListener(el, event, handler) {
      var elem = TinyHtml._preEventTargetElem(el, 'hasExactEventListener');
      if (typeof handler !== 'function') throw new TypeError('The "handler" must be a function.');
      if (!__eventRegistry.has(elem)) return false;
      var events = __eventRegistry.get(elem);
      if (!events || !Array.isArray(events[event])) return false;
      return events[event].some(function (item) {
        return item.handler === handler;
      });
    }
  }, {
    key: "on",
    value: function on(el, event, handler, options) {
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'on').forEach(function (elem) {
        elem.addEventListener(event, handler, options);
        if (!__eventRegistry.has(elem)) __eventRegistry.set(elem, {});
        var events = __eventRegistry.get(elem);
        if (!events) return;
        if (!Array.isArray(events[event])) events[event] = [];
        events[event].push({
          handler: handler,
          options: options
        });
      });
      return el;
    }
  }, {
    key: "once",
    value: function once(el, event, handler) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'once').forEach(function (elem) {
        /** @type {EventListenerOrEventListenerObject} */
        var _wrapped = function wrapped(e) {
          TinyHtml.off(elem, event, _wrapped);
          if (typeof handler === 'function') handler(e);
        };
        TinyHtml.on(elem, event, _wrapped, typeof options === 'boolean' ? options : _objectSpread(_objectSpread({}, options), {}, {
          once: true
        }));
      });
      return el;
    }
  }, {
    key: "off",
    value: function off(el, event, handler, options) {
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'off').forEach(function (elem) {
        elem.removeEventListener(event, handler, options);
        var events = __eventRegistry.get(elem);
        if (events && events[event]) {
          events[event] = events[event].filter(function (entry) {
            return entry.handler !== handler;
          });
          if (events[event].length === 0) delete events[event];
        }
      });
      return el;
    }
  }, {
    key: "offAll",
    value: function offAll(el, event) {
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'offAll').forEach(function (elem) {
        var events = __eventRegistry.get(elem);
        if (events && events[event]) {
          var _iterator11 = _createForOfIteratorHelper(events[event]),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var entry = _step11.value;
              elem.removeEventListener(event, entry.handler, entry.options);
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
          delete events[event];
        }
      });
      return el;
    }
  }, {
    key: "offAllTypes",
    value: function offAllTypes(el) {
      var filterFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (filterFn !== null && typeof filterFn !== 'function') throw new TypeError('The "filterFn" must be a function.');
      TinyHtml._preEventTargetElems(el, 'offAllTypes').forEach(function (elem) {
        var events = __eventRegistry.get(elem);
        if (!events) return;
        for (var event in events) {
          var _iterator12 = _createForOfIteratorHelper(events[event]),
            _step12;
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var entry = _step12.value;
              if (typeof filterFn !== 'function' || filterFn(entry.handler, event)) {
                elem.removeEventListener(event, entry.handler, entry.options);
              }
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
        }
        __eventRegistry["delete"](elem);
      });
      return el;
    }
  }, {
    key: "trigger",
    value: function trigger(el, event) {
      var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'trigger').forEach(function (elem) {
        var evt = payload instanceof Event || payload instanceof CustomEvent ? payload : new CustomEvent(event, {
          bubbles: true,
          cancelable: true,
          detail: payload
        });
        elem.dispatchEvent(evt);
      });
      return el;
    }
  }, {
    key: "getPropName",
    value:
    /**
     * Normalizes an attribute name to its corresponding DOM property name.
     *
     * Example: `'class'` â `'className'`, `'for'` â `'htmlFor'`.
     * If the name is not mapped, it returns the original name.
     *
     * @param {string} name - The attribute name to normalize.
     * @returns {string} - The corresponding property name.
     */
    function getPropName(name) {
      // @ts-ignore
      var propName = typeof TinyHtml.propFix[name] === 'string' ? TinyHtml.propFix[name] : name;
      return propName;
    }
    /**
     * Converts a DOM property name back to its corresponding attribute name.
     *
     * Example: `'className'` â `'class'`, `'htmlFor'` â `'for'`.
     * If the name is not mapped, it returns the original name.
     *
     * @param {string} name - The property name to convert.
     * @returns {string} - The corresponding attribute name.
     */
  }, {
    key: "getAttrName",
    value: function getAttrName(name) {
      // @ts-ignore
      var propName = typeof TinyHtml.attrFix[name] === 'string' ? TinyHtml.attrFix[name] : name;
      return propName;
    }
    /**
     * Get an attribute on an element.
     * @param {TinyElement} el
     * @param {string} name
     * @returns {string|null}
     */
  }, {
    key: "attr",
    value: function attr(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      var elem = TinyHtml._preElem(el, 'attr');
      return elem.getAttribute(TinyHtml.getAttrName(name));
    }
  }, {
    key: "setAttr",
    value: function setAttr(el, name) {
      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      if (value !== null && typeof value !== 'string') throw new TypeError('The "value" must be a string.');
      TinyHtml._preElems(el, 'setAttr').forEach(function (elem) {
        if (value === null) elem.removeAttribute(TinyHtml.getAttrName(name));else elem.setAttribute(TinyHtml.getAttrName(name), value);
      });
      return el;
    }
  }, {
    key: "removeAttr",
    value: function removeAttr(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      TinyHtml._preElems(el, 'removeAttr').forEach(function (elem) {
        return elem.removeAttribute(TinyHtml.getAttrName(name));
      });
      return el;
    }
  }, {
    key: "hasAttr",
    value: function hasAttr(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      var elem = TinyHtml._preElem(el, 'hasAttr');
      return elem.hasAttribute(TinyHtml.getAttrName(name));
    }
  }, {
    key: "hasProp",
    value: function hasProp(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      var elem = TinyHtml._preElem(el, 'hasProp');
      // @ts-ignore
      return !!elem[TinyHtml.getPropName(name)];
    }
  }, {
    key: "addProp",
    value: function addProp(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      TinyHtml._preElems(el, 'addProp').forEach(function (elem) {
        // @ts-ignore
        elem[TinyHtml.getPropName(name)] = true;
      });
      return el;
    }
  }, {
    key: "removeProp",
    value: function removeProp(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      TinyHtml._preElems(el, 'removeProp').forEach(function (elem) {
        // @ts-ignore
        elem[TinyHtml.getPropName(name)] = false;
      });
      return el;
    }
  }, {
    key: "toggleProp",
    value: function toggleProp(el, name, force) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      if (typeof force !== 'undefined' && typeof force !== 'boolean') throw new TypeError('The "force" must be a boolean.');
      TinyHtml._preElems(el, 'toggleProp').forEach(function (elem) {
        // @ts-ignore
        var shouldEnable = force === undefined ? !elem[TinyHtml.getPropName(name)] : force;
        // @ts-ignore
        if (shouldEnable) TinyHtml.addProp(elem, name);else TinyHtml.removeProp(elem, name);
      });
    }
  }, {
    key: "remove",
    value: function remove(el) {
      TinyHtml._preElems(el, 'remove').forEach(function (elem) {
        return elem.remove();
      });
      return el;
    }
  }, {
    key: "index",
    value: function index(el) {
      var el2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var elem = TinyHtml._preElem(el, 'index');
      if (!elem) return -1;
      if (!el2) {
        var _elem$parentNode;
        return Array.prototype.indexOf.call(((_elem$parentNode = elem.parentNode) === null || _elem$parentNode === void 0 ? void 0 : _elem$parentNode.children) || [], elem);
      }
      if (el2) {
        var matchEls = typeof el2 === 'string' ? document.querySelectorAll(el2) : TinyHtml._preElems(el2, 'index');
        return Array.prototype.indexOf.call(matchEls, elem);
      }
      return -1;
    }
  }, {
    key: "_getCustomRect",
    value: function _getCustomRect(rect, extraRect) {
      /** @type {DOMRect} */
      var result = {
        height: 0,
        width: 0,
        x: 0,
        y: 0,
        bottom: 0,
        left: 0,
        right: 0,
        top: 0,
        toJSON: function toJSON() {
          throw new Error('Function not implemented.');
        }
      };
      for (var name in rect) {
        // @ts-ignore
        if (typeof rect[name] === 'number')
          // @ts-ignore
          result[name] = rect[name];
      }
      if (_typeof(extraRect) !== 'object' || extraRect === null || Array.isArray(extraRect)) throw new Error('extraRect must be a non-null object.');
      var _extraRect$height = extraRect.height,
        height = _extraRect$height === void 0 ? 0 : _extraRect$height,
        _extraRect$width = extraRect.width,
        width = _extraRect$width === void 0 ? 0 : _extraRect$width,
        _extraRect$top = extraRect.top,
        top = _extraRect$top === void 0 ? 0 : _extraRect$top,
        _extraRect$bottom = extraRect.bottom,
        bottom = _extraRect$bottom === void 0 ? 0 : _extraRect$bottom,
        _extraRect$left = extraRect.left,
        left = _extraRect$left === void 0 ? 0 : _extraRect$left,
        _extraRect$right = extraRect.right,
        right = _extraRect$right === void 0 ? 0 : _extraRect$right;
      if (typeof height !== 'number') throw new Error('extraRect.height must be a number.');
      if (typeof width !== 'number') throw new Error('extraRect.width must be a number.');
      if (typeof top !== 'number') throw new Error('extraRect.top must be a number.');
      if (typeof bottom !== 'number') throw new Error('extraRect.bottom must be a number.');
      if (typeof left !== 'number') throw new Error('extraRect.left must be a number.');
      if (typeof right !== 'number') throw new Error('extraRect.right must be a number.');
      // @ts-ignore
      result.height += height;
      // @ts-ignore
      result.width += width;
      // @ts-ignore
      result.top += top;
      // @ts-ignore
      result.bottom += bottom;
      // @ts-ignore
      result.left += left;
      // @ts-ignore
      result.right += right;
      return result;
    }
    /**
     * Determines if two HTML elements are colliding, using a simple bounding box comparison.
     *
     * @param {TinyElement} el1 - The first element to compare.
     * @param {TinyElement} el2 - The second element to compare.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} - `true` if the elements are colliding, `false` otherwise.
     */
  }, {
    key: "isCollWith",
    value: function isCollWith(el1, el2) {
      var extraRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var rect1 = TinyHtml._getCustomRect(TinyHtml._preElem(el1, 'isCollWith').getBoundingClientRect(), extraRect);
      var rect2 = TinyHtml._preElem(el2, 'isCollWith').getBoundingClientRect();
      return areElsColliding(rect1, rect2);
    }
  }, {
    key: "isCollPerfWith",
    value: function isCollPerfWith(el1, el2) {
      var extraRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var rect1 = TinyHtml._getCustomRect(TinyHtml._preElem(el1, 'isCollPerfWith').getBoundingClientRect(), extraRect);
      var rect2 = TinyHtml._preElem(el2, 'isCollPerfWith').getBoundingClientRect();
      return areElsPerfColliding(rect1, rect2);
    }
  }, {
    key: "_isCollWithLock",
    value: function _isCollWithLock(isColliding, rect1, rect2, elem1, lockDirection) {
      var lockMap = __elemCollision[lockDirection];
      if (isColliding) {
        // Save entry direction
        if (!lockMap.has(elem1)) {
          lockMap.set(elem1, true);
        }
        return true;
      }
      // Handle unlock logic
      if (lockMap.has(elem1)) {
        var shouldUnlock = false;
        switch (lockDirection) {
          case 'top':
            shouldUnlock = areElsCollTop(rect1, rect2);
            break;
          case 'bottom':
            shouldUnlock = areElsCollBottom(rect1, rect2);
            break;
          case 'left':
            shouldUnlock = areElsCollLeft(rect1, rect2);
            break;
          case 'right':
            shouldUnlock = areElsCollRight(rect1, rect2);
            break;
        }
        if (shouldUnlock) lockMap["delete"](elem1);
        return lockMap.has(elem1); // still colliding (locked)
      }
      return false;
    }
    /**
     * Checks if two DOM elements are colliding on the screen, and locks the collision
     * until the element exits through the same side it entered.
     *
     * @param {TinyElement} el1 - First DOM element (e.g. draggable or moving element).
     * @param {TinyElement} el2 - Second DOM element (e.g. a container or boundary element).
     * @param {CollisionDirLock} lockDirection - Direction that must be respected to unlock the collision.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} True if collision is still active.
     */
  }, {
    key: "isCollWithLock",
    value: function isCollWithLock(el1, el2, lockDirection) {
      var extraRect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var elem1 = TinyHtml._preElem(el1, 'isCollWithLock');
      var elem2 = TinyHtml._preElem(el2, 'isCollWithLock');
      var rect1 = TinyHtml._getCustomRect(elem1.getBoundingClientRect(), extraRect);
      var rect2 = elem2.getBoundingClientRect();
      var isColliding = areElsColliding(rect1, rect2);
      return TinyHtml._isCollWithLock(isColliding, rect1, rect2, elem1, lockDirection);
    }
  }, {
    key: "isCollPerfWithLock",
    value: function isCollPerfWithLock(el1, el2, lockDirection) {
      var extraRect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var elem1 = TinyHtml._preElem(el1, 'isCollPerfWithLock');
      var elem2 = TinyHtml._preElem(el2, 'isCollPerfWithLock');
      var rect1 = TinyHtml._getCustomRect(elem1.getBoundingClientRect(), extraRect);
      var rect2 = elem2.getBoundingClientRect();
      var isColliding = areElsPerfColliding(rect1, rect2);
      return TinyHtml._isCollWithLock(isColliding, rect1, rect2, elem1, lockDirection);
    }
  }, {
    key: "resetCollLock",
    value: function resetCollLock(el) {
      var elem = TinyHtml._preElem(el, 'resetCollLock');
      var removed = false;
      for (var _i3 = 0, _arr = /** @type {CollisionDirLock[]} */['top', 'bottom', 'left', 'right']; _i3 < _arr.length; _i3++) {
        var dir = _arr[_i3];
        if (__elemCollision[dir].has(elem)) {
          __elemCollision[dir]["delete"](elem);
          removed = true;
        }
      }
      return removed;
    }
  }, {
    key: "resetCollLockDir",
    value: function resetCollLockDir(el, direction) {
      var elem = TinyHtml._preElem(el, 'resetCollLockDir');
      var lockMap = __elemCollision[direction];
      if (lockMap.has(elem)) {
        lockMap["delete"](elem);
        return true;
      }
      return false;
    }
  }, {
    key: "isInViewport",
    value: function isInViewport(el) {
      var elem = TinyHtml._preElem(el, 'isInViewport');
      if (!elem.checkVisibility({
        contentVisibilityAuto: false,
        opacityProperty: false,
        visibilityProperty: false
      })) return false;
      var elementTop = TinyHtml.offset(elem).top;
      var elementBottom = elementTop + TinyHtml.outerHeight(elem);
      var viewportTop = TinyHtml.scrollTop(window);
      var viewportBottom = viewportTop + TinyHtml.height(window);
      return elementBottom > viewportTop && elementTop < viewportBottom;
    }
  }, {
    key: "isScrolledIntoView",
    value: function isScrolledIntoView(el) {
      var elem = TinyHtml._preElem(el, 'isScrolledIntoView');
      if (!elem.checkVisibility({
        contentVisibilityAuto: false,
        opacityProperty: false,
        visibilityProperty: false
      })) return false;
      var docViewTop = TinyHtml.scrollTop(window);
      var docViewBottom = docViewTop + TinyHtml.height(window);
      var elemTop = TinyHtml.offset(elem).top;
      var elemBottom = elemTop + TinyHtml.height(elem);
      return elemBottom <= docViewBottom && elemTop >= docViewTop;
    }
  }, {
    key: "isInContainer",
    value: function isInContainer(el, cont) {
      var elem = TinyHtml._preElem(el, 'isInContainer');
      var container = TinyHtml._preElem(cont, 'isInContainer');
      if (!elem.checkVisibility({
        contentVisibilityAuto: false,
        opacityProperty: false,
        visibilityProperty: false
      })) return false;
      var elemRect = elem.getBoundingClientRect();
      var containerRect = container.getBoundingClientRect();
      var verticallyVisible = elemRect.bottom > containerRect.top && elemRect.top < containerRect.bottom;
      var horizontallyVisible = elemRect.right > containerRect.left && elemRect.left < containerRect.right;
      return verticallyVisible && horizontallyVisible;
    }
  }, {
    key: "isFullyInContainer",
    value: function isFullyInContainer(el, cont) {
      var elem = TinyHtml._preElem(el, 'isScrolledIntoView');
      var container = TinyHtml._preElem(cont, 'isInContainer');
      if (!elem.checkVisibility({
        contentVisibilityAuto: false,
        opacityProperty: false,
        visibilityProperty: false
      })) return false;
      var elemRect = elem.getBoundingClientRect();
      var containerRect = container.getBoundingClientRect();
      var isFullyVisible = elemRect.top >= containerRect.top && elemRect.bottom <= containerRect.bottom && elemRect.left >= containerRect.left && elemRect.right <= containerRect.right;
      return isFullyVisible;
    }
  }, {
    key: "hasScroll",
    value: function hasScroll(el) {
      var elem = TinyHtml._preElem(el, 'hasScroll');
      return {
        v: elem.scrollHeight > elem.clientHeight,
        h: elem.scrollWidth > elem.clientWidth
      };
    }
  }]);
}();
_TinyHtml = TinyHtml;
/** @typedef {import('../basics/collision.mjs').ObjRect} ObjRect */
_defineProperty(TinyHtml, "Utils", _objectSpread({}, TinyCollision));
/**
 * Internal data selectors for accessing public or private data stores.
 *
 * @type {Record<string, (where: string, elem: TinyElement) => ElementDataStore>}
 * @readonly
 */
_defineProperty(TinyHtml, "_dataSelector", {
  "public": function _public(where, el) {
    var elem = _TinyHtml._preElem(el, where);
    var data = __elementDataMap.get(elem);
    if (!data) {
      data = {};
      __elementDataMap.set(elem, data);
    }
    return data;
  },
  "private": function _private(where, el) {
    if (!(el instanceof _TinyHtml)) throw new Error("Element must be a TinyHtml instance to execute ".concat(where, "()."));
    return el._data;
  }
});
var _cssPropAliases = {
  _: {
    alignContent: 'align-content',
    alignItems: 'align-items',
    alignSelf: 'align-self',
    animationDelay: 'animation-delay',
    animationDirection: 'animation-direction',
    animationDuration: 'animation-duration',
    animationFillMode: 'animation-fill-mode',
    animationIterationCount: 'animation-iteration-count',
    animationName: 'animation-name',
    animationPlayState: 'animation-play-state',
    animationTimingFunction: 'animation-timing-function',
    backfaceVisibility: 'backface-visibility',
    backgroundAttachment: 'background-attachment',
    backgroundBlendMode: 'background-blend-mode',
    backgroundClip: 'background-clip',
    backgroundColor: 'background-color',
    backgroundImage: 'background-image',
    backgroundOrigin: 'background-origin',
    backgroundPosition: 'background-position',
    backgroundRepeat: 'background-repeat',
    backgroundSize: 'background-size',
    borderBottom: 'border-bottom',
    borderBottomColor: 'border-bottom-color',
    borderBottomLeftRadius: 'border-bottom-left-radius',
    borderBottomRightRadius: 'border-bottom-right-radius',
    borderBottomStyle: 'border-bottom-style',
    borderBottomWidth: 'border-bottom-width',
    borderCollapse: 'border-collapse',
    borderColor: 'border-color',
    borderImage: 'border-image',
    borderImageOutset: 'border-image-outset',
    borderImageRepeat: 'border-image-repeat',
    borderImageSlice: 'border-image-slice',
    borderImageSource: 'border-image-source',
    borderImageWidth: 'border-image-width',
    borderLeft: 'border-left',
    borderLeftColor: 'border-left-color',
    borderLeftStyle: 'border-left-style',
    borderLeftWidth: 'border-left-width',
    borderRadius: 'border-radius',
    borderRight: 'border-right',
    borderRightColor: 'border-right-color',
    borderRightStyle: 'border-right-style',
    borderRightWidth: 'border-right-width',
    borderSpacing: 'border-spacing',
    borderStyle: 'border-style',
    borderTop: 'border-top',
    borderTopColor: 'border-top-color',
    borderTopLeftRadius: 'border-top-left-radius',
    borderTopRightRadius: 'border-top-right-radius',
    borderTopStyle: 'border-top-style',
    borderTopWidth: 'border-top-width',
    borderWidth: 'border-width',
    boxDecorationBreak: 'box-decoration-break',
    boxShadow: 'box-shadow',
    boxSizing: 'box-sizing',
    breakAfter: 'break-after',
    breakBefore: 'break-before',
    breakInside: 'break-inside',
    captionSide: 'caption-side',
    caretColor: 'caret-color',
    clipPath: 'clip-path',
    columnCount: 'column-count',
    columnFill: 'column-fill',
    columnGap: 'column-gap',
    columnRule: 'column-rule',
    columnRuleColor: 'column-rule-color',
    columnRuleStyle: 'column-rule-style',
    columnRuleWidth: 'column-rule-width',
    columnSpan: 'column-span',
    columnWidth: 'column-width',
    counterIncrement: 'counter-increment',
    counterReset: 'counter-reset',
    emptyCells: 'empty-cells',
    flexBasis: 'flex-basis',
    flexDirection: 'flex-direction',
    flexFlow: 'flex-flow',
    flexGrow: 'flex-grow',
    flexShrink: 'flex-shrink',
    flexWrap: 'flex-wrap',
    fontFamily: 'font-family',
    fontFeatureSettings: 'font-feature-settings',
    fontKerning: 'font-kerning',
    fontLanguageOverride: 'font-language-override',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontSynthesis: 'font-synthesis',
    fontVariant: 'font-variant',
    fontVariantAlternates: 'font-variant-alternates',
    fontVariantCaps: 'font-variant-caps',
    fontVariantEastAsian: 'font-variant-east-asian',
    fontVariantLigatures: 'font-variant-ligatures',
    fontVariantNumeric: 'font-variant-numeric',
    fontVariantPosition: 'font-variant-position',
    fontWeight: 'font-weight',
    gridArea: 'grid-area',
    gridAutoColumns: 'grid-auto-columns',
    gridAutoFlow: 'grid-auto-flow',
    gridAutoRows: 'grid-auto-rows',
    gridColumn: 'grid-column',
    gridColumnEnd: 'grid-column-end',
    gridColumnGap: 'grid-column-gap',
    gridColumnStart: 'grid-column-start',
    gridGap: 'grid-gap',
    gridRow: 'grid-row',
    gridRowEnd: 'grid-row-end',
    gridRowGap: 'grid-row-gap',
    gridRowStart: 'grid-row-start',
    gridTemplate: 'grid-template',
    gridTemplateAreas: 'grid-template-areas',
    gridTemplateColumns: 'grid-template-columns',
    gridTemplateRows: 'grid-template-rows',
    imageRendering: 'image-rendering',
    justifyContent: 'justify-content',
    letterSpacing: 'letter-spacing',
    lineBreak: 'line-break',
    lineHeight: 'line-height',
    listStyle: 'list-style',
    listStyleImage: 'list-style-image',
    listStylePosition: 'list-style-position',
    listStyleType: 'list-style-type',
    marginBottom: 'margin-bottom',
    marginLeft: 'margin-left',
    marginRight: 'margin-right',
    marginTop: 'margin-top',
    maskClip: 'mask-clip',
    maskComposite: 'mask-composite',
    maskImage: 'mask-image',
    maskMode: 'mask-mode',
    maskOrigin: 'mask-origin',
    maskPosition: 'mask-position',
    maskRepeat: 'mask-repeat',
    maskSize: 'mask-size',
    maskType: 'mask-type',
    maxHeight: 'max-height',
    maxWidth: 'max-width',
    minHeight: 'min-height',
    minWidth: 'min-width',
    mixBlendMode: 'mix-blend-mode',
    objectFit: 'object-fit',
    objectPosition: 'object-position',
    offsetAnchor: 'offset-anchor',
    offsetDistance: 'offset-distance',
    offsetPath: 'offset-path',
    offsetRotate: 'offset-rotate',
    outlineColor: 'outline-color',
    outlineOffset: 'outline-offset',
    outlineStyle: 'outline-style',
    outlineWidth: 'outline-width',
    overflowAnchor: 'overflow-anchor',
    overflowWrap: 'overflow-wrap',
    overflowX: 'overflow-x',
    overflowY: 'overflow-y',
    paddingBottom: 'padding-bottom',
    paddingLeft: 'padding-left',
    paddingRight: 'padding-right',
    paddingTop: 'padding-top',
    pageBreakAfter: 'page-break-after',
    pageBreakBefore: 'page-break-before',
    pageBreakInside: 'page-break-inside',
    perspectiveOrigin: 'perspective-origin',
    placeContent: 'place-content',
    placeItems: 'place-items',
    placeSelf: 'place-self',
    pointerEvents: 'pointer-events',
    rowGap: 'row-gap',
    scrollBehavior: 'scroll-behavior',
    scrollMargin: 'scroll-margin',
    scrollMarginBlock: 'scroll-margin-block',
    scrollMarginBlockEnd: 'scroll-margin-block-end',
    scrollMarginBlockStart: 'scroll-margin-block-start',
    scrollMarginBottom: 'scroll-margin-bottom',
    scrollMarginInline: 'scroll-margin-inline',
    scrollMarginInlineEnd: 'scroll-margin-inline-end',
    scrollMarginInlineStart: 'scroll-margin-inline-start',
    scrollMarginLeft: 'scroll-margin-left',
    scrollMarginRight: 'scroll-margin-right',
    scrollMarginTop: 'scroll-margin-top',
    scrollPadding: 'scroll-padding',
    scrollPaddingBlock: 'scroll-padding-block',
    scrollPaddingBlockEnd: 'scroll-padding-block-end',
    scrollPaddingBlockStart: 'scroll-padding-block-start',
    scrollPaddingBottom: 'scroll-padding-bottom',
    scrollPaddingInline: 'scroll-padding-inline',
    scrollPaddingInlineEnd: 'scroll-padding-inline-end',
    scrollPaddingInlineStart: 'scroll-padding-inline-start',
    scrollPaddingLeft: 'scroll-padding-left',
    scrollPaddingRight: 'scroll-padding-right',
    scrollPaddingTop: 'scroll-padding-top',
    scrollSnapAlign: 'scroll-snap-align',
    scrollSnapStop: 'scroll-snap-stop',
    scrollSnapType: 'scroll-snap-type',
    shapeImageThreshold: 'shape-image-threshold',
    shapeMargin: 'shape-margin',
    shapeOutside: 'shape-outside',
    tabSize: 'tab-size',
    tableLayout: 'table-layout',
    textAlign: 'text-align',
    textAlignLast: 'text-align-last',
    textCombineUpright: 'text-combine-upright',
    textDecoration: 'text-decoration',
    textDecorationColor: 'text-decoration-color',
    textDecorationLine: 'text-decoration-line',
    textDecorationStyle: 'text-decoration-style',
    textIndent: 'text-indent',
    textJustify: 'text-justify',
    textOrientation: 'text-orientation',
    textOverflow: 'text-overflow',
    textShadow: 'text-shadow',
    textTransform: 'text-transform',
    transformBox: 'transform-box',
    transformOrigin: 'transform-origin',
    transformStyle: 'transform-style',
    transitionDelay: 'transition-delay',
    transitionDuration: 'transition-duration',
    transitionProperty: 'transition-property',
    transitionTimingFunction: 'transition-timing-function',
    unicodeBidi: 'unicode-bidi',
    userSelect: 'user-select',
    verticalAlign: 'vertical-align',
    whiteSpace: 'white-space',
    willChange: 'will-change',
    wordBreak: 'word-break',
    wordSpacing: 'word-spacing',
    wordWrap: 'word-wrap',
    writingMode: 'writing-mode',
    zIndex: 'z-index',
    WebkitTransform: '-webkit-transform',
    WebkitTransition: '-webkit-transition',
    WebkitBoxShadow: '-webkit-box-shadow',
    MozBoxShadow: '-moz-box-shadow',
    MozTransform: '-moz-transform',
    MozTransition: '-moz-transition',
    msTransform: '-ms-transform',
    msTransition: '-ms-transition'
  }
};
/**
 * Public proxy to manage camelCase â kebab-case CSS property aliasing.
 *
 * Modifying this object ensures that the reverse mapping in `cssPropRevAliases` is updated accordingly.
 *
 * @type {Record<string | symbol, string>}
 */
_defineProperty(TinyHtml, "cssPropAliases", new Proxy(_cssPropAliases._, {
  set: function set(target, camelCaseKey, kebabValue) {
    target[camelCaseKey] = kebabValue;
    // @ts-ignore
    _TinyHtml.cssPropRevAliases[kebabValue] = camelCaseKey;
    return true;
  }
}));
/**
 * Reverse map of `cssPropAliases`, mapping kebab-case back to camelCase CSS property names.
 *
 * This enables consistent bidirectional lookups of style properties.
 *
 * @type {Record<string | symbol, string>}
 */
_defineProperty(TinyHtml, "cssPropRevAliases", Object.fromEntries(Object.entries(_cssPropAliases._).map(function (_ref6) {
  var _ref7 = _slicedToArray(_ref6, 2),
    camel = _ref7[0],
    kebab = _ref7[1];
  return [kebab, camel];
})));
_defineProperty(TinyHtml, "easings", {
  linear: function linear(t) {
    return t;
  },
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
});
_defineProperty(TinyHtml, "_valHooks", {
  option: {
    /**
     * @param {HTMLOptionElement} elem
     * @returns {string|null}
     */
    get: function get(elem) {
      var val = elem.getAttribute('value');
      return val != null ? val : elem.textContent;
    }
  },
  select: {
    /**
     * @param {HTMLSelectElement} elem
     * @returns {(string | null)[] | string | null}
     */
    get: function get(elem) {
      var options = elem.options;
      var index = elem.selectedIndex;
      var isSingle = elem.type === 'select-one';
      var max = isSingle ? index + 1 : options.length;
      /** @type {(string | null)[] | null} */
      var values = [];
      var i = index < 0 ? max : isSingle ? index : 0;
      for (; i < max; i++) {
        var option = options[i];
        /** @type {HTMLSelectElement|null} */
        // @ts-ignore
        var parentNode = option.parentNode;
        if ((option.selected || i === index) && !option.disabled && (!parentNode || !parentNode.disabled || parentNode.tagName !== 'OPTGROUP')) {
          var val = _TinyHtml._valHooks.option.get(option);
          if (isSingle) return val;
          values.push(val);
        }
      }
      return values;
    },
    /**
     * @param {HTMLSelectElement} elem
     * @param {string[]|string} value
     */
    set: function set(elem, value) {
      var options = elem.options;
      var values = Array.isArray(value) ? value.map(String) : [String(value)];
      var optionSet = false;
      for (var i = 0; i < options.length; i++) {
        var option = options[i];
        var optionVal = _TinyHtml._valHooks.option.get(option);
        if (typeof optionVal === 'string' && (option.selected = values.includes(optionVal))) {
          optionSet = true;
        }
      }
      if (!optionSet) {
        elem.selectedIndex = -1;
      }
      return values;
    }
  },
  radio: {
    /**
     * @param {HTMLInputElement} elem
     * @returns {string}
     */
    get: function get(elem) {
      return elem.checked ? 'on' : 'off';
    },
    /**
     * @param {HTMLInputElement} elem
     * @param {string[]} value
     */
    set: function set(elem, value) {
      if (typeof value === 'boolean') {
        var label = elem.closest('label');
        if (value && label) {
          var otherRadios = label.querySelectorAll('input[type="radio"]');
          otherRadios.forEach(function (otherRadio) {
            if (otherRadio instanceof HTMLInputElement && otherRadio !== elem) otherRadio.checked = false;
          });
        }
        elem.checked = value;
        return value;
      }
    }
  },
  checkbox: {
    /**
     * @param {HTMLInputElement} elem
     * @returns {string}
     */
    get: function get(elem) {
      return elem.checked ? 'on' : 'off';
    },
    /**
     * @param {HTMLInputElement} elem
     * @param {boolean} value
     */
    set: function set(elem, value) {
      if (typeof value === 'boolean') {
        elem.checked = value;
        return value;
      }
    }
  }
});
_defineProperty(TinyHtml, "_valTypes", {
  /**
   * Gets the string value from any HTMLInputElement.
   * @type {(elem: HTMLInputElement) => string}
   */
  string: function string(elem) {
    return elem.value;
  },
  /**
   * Gets the value as a Date object from supported input types.
   * Valid only for types: "date", "datetime-local", "month", "time", "week".
   * Returns `null` if the field is empty or invalid.
   * @type {(elem: HTMLInputElement & { type: "date" | "datetime-local" | "month" | "time" | "week" }) => Date | null}
   */
  date: function date(elem) {
    return elem.valueAsDate;
  },
  /**
   * Gets the numeric value from supported input types.
   * Valid for types: "number", "range", "date", "time".
   * Returns `NaN` if the value is invalid or empty.
   * @type {(elem: HTMLInputElement & { type: "number" | "range" | "date" | "time" }) => number}
   */
  number: function number(elem) {
    return elem.valueAsNumber;
  }
});
var _propFix = {
  _: {
    "for": 'htmlFor',
    "class": 'className'
  }
};
/**
 * Public proxy for normalized DOM property names.
 *
 * Setting a new entry here will also automatically update the reverse map in `TinyHtml.attrFix`.
 *
 * @type {Record<string | symbol, string>}
 */
_defineProperty(TinyHtml, "propFix", new Proxy(_propFix._, {
  set: function set(target, val1, val2) {
    target[val1] = val2;
    // @ts-ignore
    _TinyHtml.attrFix[val2] = val1;
    return true;
  }
}));
/**
 * Reverse map of `propFix`, mapping property names back to their attribute equivalents.
 *
 * Used when converting DOM property names into HTML attribute names.
 *
 * @type {Record<string | symbol, string>}
 */
_defineProperty(TinyHtml, "attrFix", Object.fromEntries(Object.entries(_propFix._).map(function (_ref8) {
  var _ref9 = _slicedToArray(_ref8, 2),
    val1 = _ref9[0],
    val2 = _ref9[1];
  return [val2, val1];
})));
var _default = exports["default"] = TinyHtml;

},{"../basics/collision.mjs":171}],191:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _objChecker = require("../basics/objChecker.mjs");
var _TinyEvents = _interopRequireDefault(require("./TinyEvents.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/** @type {WeakMap<Window, TinyIframeEvents>} */
var instances = new WeakMap();
/**
 * @callback handler
 * A function to handle incoming event payloads.
 * @param {any} payload - The data sent by the emitter.
 * @param {MessageEvent<any>} event - Metadata about the message.
 */
/**
 * A flexible event routing system for structured communication
 * between a parent window and its iframe using `postMessage`.
 *
 * This class abstracts the complexity of cross-origin and window-type handling,
 * allowing both the iframe and parent to:
 * - Send events with arbitrary payloads
 * - Listen to specific event names
 * - Filter events by origin and source
 * - Work symmetrically from both sides with automatic direction handling
 *
 * Use this class when building applications that require modular, event-driven
 * communication across embedded frames.
 */
var _events = /*#__PURE__*/new WeakMap();
var _targetWindow = /*#__PURE__*/new WeakMap();
var _targetOrigin = /*#__PURE__*/new WeakMap();
var _selfType = /*#__PURE__*/new WeakMap();
var _isDestroyed = /*#__PURE__*/new WeakMap();
var _ready = /*#__PURE__*/new WeakMap();
var _pendingQueue = /*#__PURE__*/new WeakMap();
var _secretEventName = /*#__PURE__*/new WeakMap();
var _TinyIframeEvents_brand = /*#__PURE__*/new WeakSet();
var TinyIframeEvents = /*#__PURE__*/function () {
  /**
   * Creates a new TinyIframeEvents instance to manage communication between iframe and parent.
   * Automatically determines the current context (`iframe` or `parent`) based on the `targetWindow`.
   *
   * @param {Object} config - Configuration object.
   * @param {HTMLIFrameElement} [config.targetIframe] - The target window to post messages to. Defaults to `window.parent` (assumes this is inside an iframe).
   * @param {string} [config.targetOrigin] - The target origin to restrict messages to. Defaults to `window.location.origin`.
   */
  function TinyIframeEvents() {
    var _targetIframe$content;
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      targetIframe = _ref.targetIframe,
      targetOrigin = _ref.targetOrigin;
    _classCallCheck(this, TinyIframeEvents);
    /**
     * Marks the communication as ready and flushes any queued messages.
     */
    _classPrivateMethodInitSpec(this, _TinyIframeEvents_brand);
    _classPrivateFieldInitSpec(this, _events, new _TinyEvents["default"]());
    ///////////////////////////////////////////////////
    /** @type {Window} */
    _classPrivateFieldInitSpec(this, _targetWindow, void 0);
    /** @type {string} */
    _classPrivateFieldInitSpec(this, _targetOrigin, void 0);
    /** @type {string} */
    _classPrivateFieldInitSpec(this, _selfType, void 0);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _isDestroyed, false);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _ready, false);
    /**
     * @typedef {object} IframeEventBase
     * @property {string} eventName - The name of the custom event route.
     * @property {any} payload - The data being sent (can be any type).
     * @property {'iframe' | 'parent'} direction - Indicates the sender: 'iframe' or 'parent'.
     */
    /**
     * Queue of messages emitted before connection is ready
     * @type {IframeEventBase[]}
     */
    _classPrivateFieldInitSpec(this, _pendingQueue, []);
    /** @type {string} Internal message type for routed communication */
    _classPrivateFieldInitSpec(this, _secretEventName, '__tinyIframeEvent__');
    if (typeof targetIframe !== 'undefined' && (!(targetIframe instanceof HTMLIFrameElement) || !targetIframe.contentWindow)) throw new TypeError("[TinyIframeEvents] Invalid \"targetIframe\" provided: expected a HTML Iframe Element, received ".concat(_typeof(targetIframe)));
    if (typeof targetOrigin !== 'undefined' && typeof targetOrigin !== 'string') throw new TypeError("[TinyIframeEvents] Invalid \"targetOrigin\" provided: expected a string, received ".concat(_typeof(targetOrigin)));
    _classPrivateFieldSet(_targetWindow, this, (_targetIframe$content = targetIframe === null || targetIframe === void 0 ? void 0 : targetIframe.contentWindow) !== null && _targetIframe$content !== void 0 ? _targetIframe$content : window.parent);
    _classPrivateFieldSet(_targetOrigin, this, targetOrigin !== null && targetOrigin !== void 0 ? targetOrigin : window.location.origin);
    _classPrivateFieldSet(_selfType, this, !targetIframe ? 'iframe' : 'parent');
    if (instances.has(_classPrivateFieldGet(_targetWindow, this))) throw new Error('Duplicate window reference.');
    this._boundOnMessage = _assertClassBrand(_TinyIframeEvents_brand, this, _onMessage).bind(this);
    this._boundOnceMessage = _assertClassBrand(_TinyIframeEvents_brand, this, _onceMessage).bind(this);
    if (_classPrivateFieldGet(_targetWindow, this).document.readyState === 'complete' || _classPrivateFieldGet(_targetWindow, this).document.readyState === 'interactive') _assertClassBrand(_TinyIframeEvents_brand, this, _onceMessage).call(this);else {
      _classPrivateFieldGet(_targetWindow, this).addEventListener('load', this._boundOnceMessage, false);
      _classPrivateFieldGet(_targetWindow, this).addEventListener('DOMContentLoaded', this._boundOnceMessage, false);
    }
    window.addEventListener('message', this._boundOnMessage, false);
    instances.set(_classPrivateFieldGet(_targetWindow, this), this);
  }
  return _createClass(TinyIframeEvents, [{
    key: "setThrowOnMaxListeners",
    value:
    /**
     * Enables or disables throwing an error when the maximum number of listeners is exceeded.
     *
     * @param {boolean} shouldThrow - If true, an error will be thrown when the max is exceeded.
     */
    function setThrowOnMaxListeners(shouldThrow) {
      return _classPrivateFieldGet(_events, this).setThrowOnMaxListeners(shouldThrow);
    }
    /**
     * Checks whether an error will be thrown when the max listener limit is exceeded.
     *
     * @returns {boolean} True if an error will be thrown, false if only a warning is shown.
     */
  }, {
    key: "getThrowOnMaxListeners",
    value: function getThrowOnMaxListeners() {
      return _classPrivateFieldGet(_events, this).getThrowOnMaxListeners();
    }
    /////////////////////////////////////////////////////////////
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     */
  }, {
    key: "prependListener",
    value: function prependListener(event, handler) {
      return _classPrivateFieldGet(_events, this).prependListener(event, handler);
    }
    /**
     * Adds a one-time listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     * @returns {handler} - The wrapped handler used internally.
     */
  }, {
    key: "prependListenerOnce",
    value: function prependListenerOnce(event, handler) {
      return _classPrivateFieldGet(_events, this).prependListenerOnce(event, handler);
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     */
  }, {
    key: "appendListener",
    value: function appendListener(event, handler) {
      return _classPrivateFieldGet(_events, this).appendListener(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - The callback function to run on event.
     * @returns {handler} - The wrapped version of the handler.
     */
  }, {
    key: "appendListenerOnce",
    value: function appendListenerOnce(event, handler) {
      return _classPrivateFieldGet(_events, this).appendListenerOnce(event, handler);
    }
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     */
  }, {
    key: "on",
    value: function on(event, handler) {
      return _classPrivateFieldGet(_events, this).on(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - The callback function to run on event.
     * @returns {handler} - The wrapped version of the handler.
     */
  }, {
    key: "once",
    value: function once(event, handler) {
      return _classPrivateFieldGet(_events, this).once(event, handler);
    }
    ////////////////////////////////////////////////////////////////////
    /**
     * Removes a previously registered event listener.
     *
     * @param {string} event - The name of the event to remove the handler from.
     * @param {handler} handler - The specific callback function to remove.
     */
  }, {
    key: "off",
    value: function off(event, handler) {
      return _classPrivateFieldGet(_events, this).off(event, handler);
    }
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {string} event - The event type to remove (e.g. 'onScrollBoundary').
     */
  }, {
    key: "offAll",
    value: function offAll(event) {
      return _classPrivateFieldGet(_events, this).offAll(event);
    }
    /**
     * Removes all event listeners of all types from the element.
     */
  }, {
    key: "offAllTypes",
    value: function offAllTypes() {
      return _classPrivateFieldGet(_events, this).offAllTypes();
    }
    ////////////////////////////////////////////////////////////
    /**
     * Returns the number of listeners for a given event.
     *
     * @param {string} event - The name of the event.
     * @returns {number} Number of listeners for the event.
     */
  }, {
    key: "listenerCount",
    value: function listenerCount(event) {
      return _classPrivateFieldGet(_events, this).listenerCount(event);
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {handler[]} Array of listener functions.
     */
  }, {
    key: "listeners",
    value: function listeners(event) {
      return _classPrivateFieldGet(_events, this).listeners(event);
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {handler[]} Array of listener functions.
     */
  }, {
    key: "onceListeners",
    value: function onceListeners(event) {
      return _classPrivateFieldGet(_events, this).onceListeners(event);
    }
    /**
     * Returns a copy of the internal listeners array for the specified event,
     * including wrapper functions like those used by `.once()`.
     * @param {string | symbol} event - The event name.
     * @returns {handler[]} An array of raw listener functions.
     */
  }, {
    key: "allListeners",
    value: function allListeners(event) {
      return _classPrivateFieldGet(_events, this).allListeners(event);
    }
    /**
     * Returns an array of event names for which there are registered listeners.
     *
     * @returns {string[]} Array of registered event names.
     */
  }, {
    key: "eventNames",
    value: function eventNames() {
      return _classPrivateFieldGet(_events, this).eventNames();
    }
    //////////////////////////////////////////////////////
    /**
     * Sets the maximum number of listeners per event before a warning is shown.
     *
     * @param {number} n - The maximum number of listeners.
     */
  }, {
    key: "setMaxListeners",
    value: function setMaxListeners(n) {
      return _classPrivateFieldGet(_events, this).setMaxListeners(n);
    }
    /**
     * Gets the maximum number of listeners allowed per event.
     *
     * @returns {number} The maximum number of listeners.
     */
  }, {
    key: "getMaxListeners",
    value: function getMaxListeners() {
      return _classPrivateFieldGet(_events, this).getMaxListeners();
    }
  }, {
    key: "secretEventName",
    get:
    /**
     * Gets the internal secret iframe event name.
     * @returns {string}
     */
    function get() {
      return _classPrivateFieldGet(_secretEventName, this);
    }
    /**
     * Sets the internal secret iframe event name.
     * @param {string} name
     * @throws {TypeError} If the value is not a string.
     */,
    set: function set(name) {
      if (typeof name !== 'string') throw new TypeError('TinyIframeEvents: secretEventName must be a string.');
      _classPrivateFieldSet(_secretEventName, this, name);
    }
  }, {
    key: "emit",
    value:
    /**
     * Sends an event to the target window.
     *
     * @param {string} eventName - A unique name identifying the event.
     * @param {*} payload - The data to send with the event. Can be any serializable value.
     * @throws {Error} If `eventName` is not a string.
     */
    function emit(eventName, payload) {
      if (typeof eventName !== 'string') throw new TypeError('Event name must be a string.');
      if (_classPrivateFieldGet(_isDestroyed, this)) throw new Error('Cannot emit: instance has been destroyed.');
      /** @type {IframeEventBase} */
      var message = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, _classPrivateFieldGet(_secretEventName, this), true), "eventName", eventName), "payload", payload), "direction", _classPrivateFieldGet(_selfType, this) === 'parent' ? 'iframe' : 'parent');
      if (!_classPrivateFieldGet(_ready, this)) {
        _classPrivateFieldGet(_pendingQueue, this).push(message);
        return;
      }
      _classPrivateFieldGet(_targetWindow, this).postMessage(message, _classPrivateFieldGet(_targetOrigin, this));
    }
    /**
     * Sends all pending messages queued before handshake completion.
     *
     * @returns {void}
     */
  }, {
    key: "isDestroyed",
    value:
    /**
     * Checks if the communication instance has been destroyed.
     *
     * @returns {boolean}
     */
    function isDestroyed() {
      return _classPrivateFieldGet(_isDestroyed, this);
    }
    /**
     * Unsubscribes all registered event listeners and removes the message handler.
     * Call this when the instance is no longer needed to prevent memory leaks.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldSet(_isDestroyed, this, true);
      window.removeEventListener('message', this._boundOnMessage);
      _classPrivateFieldGet(_targetWindow, this).removeEventListener('load', this._boundOnceMessage, false);
      _classPrivateFieldGet(_targetWindow, this).removeEventListener('DOMContentLoaded', this._boundOnceMessage, false);
      _classPrivateFieldGet(_events, this).offAllTypes();
      _classPrivateFieldSet(_pendingQueue, this, []);
      instances["delete"](_classPrivateFieldGet(_targetWindow, this));
    }
  }]);
}();
function _onceMessage() {
  if (_classPrivateFieldGet(_ready, this)) return;
  _classPrivateFieldSet(_ready, this, true);
  _assertClassBrand(_TinyIframeEvents_brand, this, _flushQueue).call(this);
}
/**
 * Internal handler for the message event. Filters and dispatches incoming messages.
 *
 * @param {MessageEvent<any>} event - The message event received via `postMessage`.
 */
function _onMessage(event) {
  var data = event.data,
    source = event.source;
  // Reject non-object or unrelated messages
  if (!(0, _objChecker.isJsonObject)(data) || !data[_classPrivateFieldGet(_secretEventName, this)]) return;
  var eventName = data.eventName,
    payload = data.payload,
    direction = data.direction;
  // Reject if not from the expected window (for security)
  if (source !== _classPrivateFieldGet(_targetWindow, this)) return;
  // Reject if direction is not meant for this side
  if (_classPrivateFieldGet(_selfType, this) === 'iframe' && direction !== 'iframe' || _classPrivateFieldGet(_selfType, this) === 'parent' && direction !== 'parent') return;
  _classPrivateFieldGet(_events, this).emit(/** @type {string} */eventName, payload, event);
}
function _flushQueue() {
  while (_classPrivateFieldGet(_pendingQueue, this).length) {
    var data = _classPrivateFieldGet(_pendingQueue, this).shift();
    if (data) _classPrivateFieldGet(_targetWindow, this).postMessage(data, _classPrivateFieldGet(_targetOrigin, this));
  }
}
var _default = exports["default"] = TinyIframeEvents;

},{"../basics/objChecker.mjs":175,"./TinyEvents.mjs":189}],192:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _objChecker = require("../basics/objChecker.mjs");
var _TinyEvents = _interopRequireDefault(require("./TinyEvents.mjs"));
var _TinyLocalStorage;
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/** @type {Map<any, EncodeFn>} */
var customEncoders = new Map();
/** @type {Map<any, DecodeFn>} */
var customDecoders = new Map();
/** @type {Set<any>} */
var customTypesFreezed = new Set(['string', 'boolean', 'number', 'object', 'array', String, Boolean, Number, Object, Array, BigInt, Symbol]);
/**
 * A function that encodes a value into a serializable JSON-compatible format.
 *
 * @callback EncodeFn
 * @param {any} value - The value to encode.
 * @param {encodeSpecialJson} encodeSpecialJson - Recursive encoder helper.
 * @returns {any} The encoded value.
 */
/**
 * An object that defines how to check and decode a specific serialized type.
 *
 * @typedef {Object} DecodeFn
 * @property {(value: any) => any} check - Checks if the value matches the custom encoded structure.
 * @property {(value: any, decodeSpecialJson: decodeSpecialJson) => any} decode - Decodes the structure back into its original form.
 */
/**
 * Encodes extended JSON-compatible structures recursively.
 * @callback encodeSpecialJson
 * @param {any} value
 * @returns {any}
 */
/**
 * Decodes extended JSON-compatible structures recursively.
 * @callback decodeSpecialJson
 * @param {any} value
 * @returns {any}
 */
/**
 * Represents a value that can be safely stored and restored using JSON in `localStorage`,
 * including structures like arrays, plain objects, Map and Set.
 *
 * - `Record<string|number|symbol, any>` â plain object (e.g., `{ key: value }`)
 * - `any[]` â array of any JSON-serializable values
 * - `Map<string|number|symbol, any>` â converted to `{ __map__: true, data: [[k, v], ...] }`
 * - `Set<any>` â converted to `{ __set__: true, data: [v1, v2, ...] }`
 *
 * These conversions allow complex structures to be restored after JSON serialization.
 *
 * @typedef {(Record<string|number|symbol, any> | any[] | Map<string|number|symbol, any> | Set<any>)} LocalStorageJsonValue
 */
/**
 * A powerful wrapper for Web Storage (`localStorage` or `sessionStorage`) that supports
 * type-safe methods and full JSON-like structure encoding and decoding.
 *
 * `TinyLocalStorage` allows storing and retrieving complex types such as:
 * - `Map`, `Set`
 * - `Date`, `RegExp`
 * - `BigInt`, `Symbol`
 * - `undefined`, `null`
 * - Plain objects and arrays
 *
 * Includes:
 * - Type-specific `set` and `get` methods (`setDate`, `getBool`, etc.)
 * - `getValue()` to retrieve any structure regardless of type
 * - Auto-encoding/decoding with support for custom types via `registerJsonType`
 * - Built-in event system (`TinyEvents`) to listen for changes
 * - Optional fallback values on decoding errors
 *
 * Supports registering and unregistering custom types via:
 * - `registerJsonType(...)`
 * - `deleteJsonType(...)`
 *
 * This class is suitable for applications that require structured persistence in the browser.
 */
var _events = /*#__PURE__*/new WeakMap();
var _localStorage = /*#__PURE__*/new WeakMap();
var _dbKey = /*#__PURE__*/new WeakMap();
var _version = /*#__PURE__*/new WeakMap();
var _storageEvent = /*#__PURE__*/new WeakMap();
var _TinyLocalStorage_brand = /*#__PURE__*/new WeakSet();
var TinyLocalStorage = /*#__PURE__*/function () {
  /**
   * Initializes the TinyLocalStorage instance and sets up cross-tab sync.
   *
   * Adds listener for the native `storage` event to support tab synchronization.
   * @param {string} [dbName] - Unique database name.
   */
  function TinyLocalStorage(dbName) {
    var _this = this;
    _classCallCheck(this, TinyLocalStorage);
    /**
     * Validates that a given key does not conflict with internal database keys.
     *
     * This method is used to prevent accidental overwriting of reserved `LSDB::` keys
     * in `localStorage`, which are used internally by TinyLocalStorage for versioning
     * and data management.
     *
     * @param {string} name - The key to validate before writing to localStorage.
     * @throws {Error} If the key starts with `LSDB::`.
     */
    _classPrivateMethodInitSpec(this, _TinyLocalStorage_brand);
    /** @typedef {import('./TinyEvents.mjs').handler} handler */
    _classPrivateFieldInitSpec(this, _events, new _TinyEvents["default"]());
    //////////////////////////////////////////////////////
    /** @type {Storage} */
    _classPrivateFieldInitSpec(this, _localStorage, window.localStorage);
    /** @type {string|null} */
    _classPrivateFieldInitSpec(this, _dbKey, null);
    /** @type {number} */
    _classPrivateFieldInitSpec(this, _version, 0);
    /** @type {(ev: StorageEvent) => any} */
    _classPrivateFieldInitSpec(this, _storageEvent, function (ev) {
      return _this.emit('storage', ev);
    });
    if (typeof dbName !== 'undefined' && typeof dbName !== 'string') throw new TypeError('TinyLocalStorage: dbName must be a string if provided.');
    if (typeof dbName === 'string') _classPrivateFieldSet(_dbKey, this, "LSDB::".concat(dbName));
    window.addEventListener('storage', _classPrivateFieldGet(_storageEvent, this));
  }
  return _createClass(TinyLocalStorage, [{
    key: "setThrowOnMaxListeners",
    value:
    /**
     * Enables or disables throwing an error when the maximum number of listeners is exceeded.
     *
     * @param {boolean} shouldThrow - If true, an error will be thrown when the max is exceeded.
     */
    function setThrowOnMaxListeners(shouldThrow) {
      return _classPrivateFieldGet(_events, this).setThrowOnMaxListeners(shouldThrow);
    }
    /**
     * Checks whether an error will be thrown when the max listener limit is exceeded.
     *
     * @returns {boolean} True if an error will be thrown, false if only a warning is shown.
     */
  }, {
    key: "getThrowOnMaxListeners",
    value: function getThrowOnMaxListeners() {
      return _classPrivateFieldGet(_events, this).getThrowOnMaxListeners();
    }
    /////////////////////////////////////////////////////////////
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     */
  }, {
    key: "prependListener",
    value: function prependListener(event, handler) {
      return _classPrivateFieldGet(_events, this).prependListener(event, handler);
    }
    /**
     * Adds a one-time listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     * @returns {handler} - The wrapped handler used internally.
     */
  }, {
    key: "prependListenerOnce",
    value: function prependListenerOnce(event, handler) {
      return _classPrivateFieldGet(_events, this).prependListenerOnce(event, handler);
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     */
  }, {
    key: "appendListener",
    value: function appendListener(event, handler) {
      return _classPrivateFieldGet(_events, this).appendListener(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - The callback function to run on event.
     * @returns {handler} - The wrapped version of the handler.
     */
  }, {
    key: "appendListenerOnce",
    value: function appendListenerOnce(event, handler) {
      return _classPrivateFieldGet(_events, this).appendListenerOnce(event, handler);
    }
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     */
  }, {
    key: "on",
    value: function on(event, handler) {
      return _classPrivateFieldGet(_events, this).on(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - The callback function to run on event.
     * @returns {handler} - The wrapped version of the handler.
     */
  }, {
    key: "once",
    value: function once(event, handler) {
      return _classPrivateFieldGet(_events, this).once(event, handler);
    }
    ////////////////////////////////////////////////////////////////////
    /**
     * Removes a previously registered event listener.
     *
     * @param {string} event - The name of the event to remove the handler from.
     * @param {handler} handler - The specific callback function to remove.
     */
  }, {
    key: "off",
    value: function off(event, handler) {
      return _classPrivateFieldGet(_events, this).off(event, handler);
    }
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {string} event - The event type to remove (e.g. 'onScrollBoundary').
     */
  }, {
    key: "offAll",
    value: function offAll(event) {
      return _classPrivateFieldGet(_events, this).offAll(event);
    }
    /**
     * Removes all event listeners of all types from the element.
     */
  }, {
    key: "offAllTypes",
    value: function offAllTypes() {
      return _classPrivateFieldGet(_events, this).offAllTypes();
    }
    ////////////////////////////////////////////////////////////
    /**
     * Returns the number of listeners for a given event.
     *
     * @param {string} event - The name of the event.
     * @returns {number} Number of listeners for the event.
     */
  }, {
    key: "listenerCount",
    value: function listenerCount(event) {
      return _classPrivateFieldGet(_events, this).listenerCount(event);
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {handler[]} Array of listener functions.
     */
  }, {
    key: "listeners",
    value: function listeners(event) {
      return _classPrivateFieldGet(_events, this).listeners(event);
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {handler[]} Array of listener functions.
     */
  }, {
    key: "onceListeners",
    value: function onceListeners(event) {
      return _classPrivateFieldGet(_events, this).onceListeners(event);
    }
    /**
     * Returns a copy of the internal listeners array for the specified event,
     * including wrapper functions like those used by `.once()`.
     * @param {string | symbol} event - The event name.
     * @returns {handler[]} An array of raw listener functions.
     */
  }, {
    key: "allListeners",
    value: function allListeners(event) {
      return _classPrivateFieldGet(_events, this).allListeners(event);
    }
    /**
     * Returns an array of event names for which there are registered listeners.
     *
     * @returns {string[]} Array of registered event names.
     */
  }, {
    key: "eventNames",
    value: function eventNames() {
      return _classPrivateFieldGet(_events, this).eventNames();
    }
    //////////////////////////////////////////////////////
    /**
     * Emits an event, triggering all registered handlers for that event.
     *
     * @param {string} event - The event name to emit.
     * @param {...any} payload - Optional data to pass to each handler.
     * @returns {boolean} True if any listeners were called, false otherwise.
     */
  }, {
    key: "emit",
    value: function emit(event) {
      var _classPrivateFieldGet2;
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }
      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_events, this)).emit.apply(_classPrivateFieldGet2, [event].concat(payload));
    }
    /**
     * Sets the maximum number of listeners per event before a warning is shown.
     *
     * @param {number} n - The maximum number of listeners.
     */
  }, {
    key: "setMaxListeners",
    value: function setMaxListeners(n) {
      return _classPrivateFieldGet(_events, this).setMaxListeners(n);
    }
    /**
     * Gets the maximum number of listeners allowed per event.
     *
     * @returns {number} The maximum number of listeners.
     */
  }, {
    key: "getMaxListeners",
    value: function getMaxListeners() {
      return _classPrivateFieldGet(_events, this).getMaxListeners();
    }
    ///////////////////////////////////////////////////
    /**
     * Checks whether a JSON-serializable type is already registered.
     *
     * @param {any} type - The type identifier, which can be a string (e.g., `"bigint"`, `"symbol"`)
     *                     or a reference to a class/constructor function.
     * @returns {boolean} True if the type has both an encoder and decoder registered.
     */
  }, {
    key: "updateStorageVersion",
    value:
    /**
     * Updates the version of the storage and triggers migration if needed.
     *
     * @param {number} version - Desired version of the database.
     * @param {(oldVersion: number, newVersion: number) => void} onUpgrade - Callback to perform migration logic.
     * @throws {Error} If the database key has not been initialized.
     * @throws {TypeError} If `version` is not a valid positive number.
     * @throws {TypeError} If `onUpgrade` is not a function.
     */
    function updateStorageVersion(version, onUpgrade) {
      if (typeof _classPrivateFieldGet(_dbKey, this) !== 'string') throw new Error('TinyLocalStorage: Database key is not initialized. Set a valid dbName in the constructor.');
      if (typeof version !== 'number' || Number.isNaN(version) || version < 1) throw new TypeError('TinyLocalStorage: version must be a positive number.');
      if (typeof onUpgrade !== 'function') throw new TypeError('TinyLocalStorage: onUpgrade must be a function.');
      // @ts-ignore
      var savedVersion = parseInt(localStorage.getItem(_classPrivateFieldGet(_dbKey, this)), 10) || 0;
      if (typeof savedVersion !== 'number' || Number.isNaN(savedVersion) || savedVersion < 0) throw new TypeError('TinyLocalStorage: saved version in localStorage is not a valid number.');
      if (version < savedVersion) throw new Error("TinyLocalStorage: Cannot downgrade database version from ".concat(savedVersion, " to ").concat(version, "."));
      if (version > savedVersion) {
        onUpgrade(savedVersion, version);
        localStorage.setItem(_classPrivateFieldGet(_dbKey, this), String(version));
        _classPrivateFieldSet(_version, this, version);
      }
    }
    /**
     * Gets the current database key used in localStorage.
     *
     * @returns {string|null} The database key, or null if not set.
     */
  }, {
    key: "getDbKey",
    value: function getDbKey() {
      return _classPrivateFieldGet(_dbKey, this);
    }
    /**
     * Gets the current version of the database.
     *
     * @returns {number} The current version number.
     */
  }, {
    key: "getVersion",
    value: function getVersion() {
      return _classPrivateFieldGet(_version, this);
    }
    /**
     * Defines a custom storage interface (e.g. `sessionStorage`).
     *
     * @param {Storage} localstorage - A valid Storage object (localStorage or sessionStorage).
     */
  }, {
    key: "setLocalStorage",
    value: function setLocalStorage(localstorage) {
      if (!(localstorage instanceof Storage)) throw new TypeError('Argument must be a valid instance of Storage.');
      _classPrivateFieldSet(_localStorage, this, localstorage);
    }
    /**
     * Checks if `localStorage` is supported by the current environment.
     *
     * @returns {boolean} True if `localStorage` exists, false otherwise.
     */
  }, {
    key: "localStorageExists",
    value: function localStorageExists() {
      return _classPrivateFieldGet(_localStorage, this) instanceof Storage;
    }
    /**
     * Automatically serializes nested instances.
     *
     * @param {string} name - The key under which to store the data.
     * @param {*} data - The data to be serialized.
     * @returns {*}
     */
  }, {
    key: "setJson",
    value:
    /**
     * Stores a JSON-compatible value in `localStorage`.
     *
     * Automatically serializes nested `Map` and `Set` instances.
     *
     * @param {string} name - The key under which to store the data.
     * @param {LocalStorageJsonValue} data - The data to be serialized and stored.
     */
    function setJson(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (!(0, _objChecker.isJsonObject)(data) && !Array.isArray(data) && !(data instanceof Map) && !(data instanceof Set)) {
        throw new TypeError('The storage value is not a valid JSON-compatible structure.');
      }
      var encoded = _assertClassBrand(_TinyLocalStorage_brand, this, _setJson).call(this, name, data);
      this.emit('setJson', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, JSON.stringify(encoded));
    }
    /**
     * Retrieves a value from `localStorage`.
     *
     * Automatically restores nested instances.
     *
     * @param {string} name - The key to retrieve.
     * @param {'array'|'obj'|'map'|'set'|'null'} [defaultData] - Default fallback format if value is invalid.
     * @returns {{ decoded: any, fallback: any }} The parsed object or fallback.
     */
  }, {
    key: "getJson",
    value:
    /**
     * Retrieves and parses a JSON value from `localStorage`.
     *
     * Automatically restores nested `Map` and `Set` instances.
     *
     * @param {string} name - The key to retrieve.
     * @param {'array'|'obj'|'map'|'set'|'null'} [defaultData] - Default fallback format if value is invalid.
     * @returns {LocalStorageJsonValue|null} The parsed object or fallback.
     */
    function getJson(name, defaultData) {
      var _assertClassBrand$cal = _assertClassBrand(_TinyLocalStorage_brand, this, _getJson).call(this, name, defaultData),
        decoded = _assertClassBrand$cal.decoded,
        fallback = _assertClassBrand$cal.fallback;
      if (decoded instanceof Map || decoded instanceof Set || Array.isArray(decoded) || (0, _objChecker.isJsonObject)(decoded)) return decoded;
      return fallback;
    }
    /**
     * Stores a Date in localStorage.
     * @param {string} name
     * @param {Date} data
     */
  }, {
    key: "setDate",
    value: function setDate(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (!(data instanceof Date)) throw new TypeError('Value must be a Date.');
      var encoded = _assertClassBrand(_TinyLocalStorage_brand, this, _setJson).call(this, name, data);
      this.emit('setDate', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, JSON.stringify(encoded));
    }
    /**
     * Retrieves a Date from localStorage.
     * @param {string} name
     * @returns {Date|null}
     */
  }, {
    key: "getDate",
    value: function getDate(name) {
      var value = _assertClassBrand(_TinyLocalStorage_brand, this, _getJson).call(this, name).decoded;
      return value instanceof Date ? value : null;
    }
    /**
     * Stores a RegExp in localStorage.
     * @param {string} name
     * @param {RegExp} data
     */
  }, {
    key: "setRegExp",
    value: function setRegExp(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (!(data instanceof RegExp)) throw new TypeError('Value must be a RegExp.');
      var encoded = _assertClassBrand(_TinyLocalStorage_brand, this, _setJson).call(this, name, data);
      this.emit('setRegExp', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, JSON.stringify(encoded));
    }
    /**
     * Retrieves a RegExp from localStorage.
     * @param {string} name
     * @returns {RegExp|null}
     */
  }, {
    key: "getRegExp",
    value: function getRegExp(name) {
      var value = _assertClassBrand(_TinyLocalStorage_brand, this, _getJson).call(this, name).decoded;
      return value instanceof RegExp ? value : null;
    }
    /**
     * Stores a BigInt in localStorage.
     * @param {string} name
     * @param {bigint} data
     */
  }, {
    key: "setBigInt",
    value: function setBigInt(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (typeof data !== 'bigint') throw new TypeError('Value must be a BigInt.');
      var encoded = _assertClassBrand(_TinyLocalStorage_brand, this, _setJson).call(this, name, data);
      this.emit('setBigInt', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, JSON.stringify(encoded));
    }
    /**
     * Retrieves a BigInt from localStorage.
     * @param {string} name
     * @returns {bigint|null}
     */
  }, {
    key: "getBigInt",
    value: function getBigInt(name) {
      var value = _assertClassBrand(_TinyLocalStorage_brand, this, _getJson).call(this, name).decoded;
      return typeof value === 'bigint' ? value : null;
    }
    /**
     * Stores a Symbol in localStorage.
     * Only global symbols (`Symbol.for`) will preserve the key.
     * @param {string} name
     * @param {symbol} data
     */
  }, {
    key: "setSymbol",
    value: function setSymbol(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (_typeof(data) !== 'symbol') throw new TypeError('Value must be a Symbol.');
      var encoded = _assertClassBrand(_TinyLocalStorage_brand, this, _setJson).call(this, name, data);
      this.emit('setSymbol', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, JSON.stringify(encoded));
    }
    /**
     * Retrieves a Symbol from localStorage.
     * @param {string} name
     * @returns {symbol|null}
     */
  }, {
    key: "getSymbol",
    value: function getSymbol(name) {
      var value = _assertClassBrand(_TinyLocalStorage_brand, this, _getJson).call(this, name).decoded;
      return _typeof(value) === 'symbol' ? value : null;
    }
    /**
     * Retrieves a value from `localStorage`.
     *
     * @param {string} name - The key to retrieve.
     * @returns {any} The stored value or null if not found.
     */
  }, {
    key: "getValue",
    value: function getValue(name) {
      var _assertClassBrand$cal2;
      return (_assertClassBrand$cal2 = _assertClassBrand(_TinyLocalStorage_brand, this, _getJson).call(this, name).decoded) !== null && _assertClassBrand$cal2 !== void 0 ? _assertClassBrand$cal2 : null;
    }
    /**
     * Stores a raw string value in `localStorage`.
     *
     * @param {string} name - The key to use.
     * @param {any} data - The data to store.
     */
  }, {
    key: "setItem",
    value: function setItem(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      this.emit('setItem', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, data);
    }
    /**
     * Retrieves a raw string value from `localStorage`.
     *
     * @param {string} name - The key to retrieve.
     * @returns {string|null} The stored value or null if not found.
     */
  }, {
    key: "getItem",
    value: function getItem(name) {
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      return _classPrivateFieldGet(_localStorage, this).getItem(name);
    }
    /**
     * Stores a string in `localStorage`, ensuring the data is a valid string.
     *
     * @param {string} name - The key to store the string under.
     * @param {string} data - The string to store.
     */
  }, {
    key: "setString",
    value: function setString(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      if (typeof data !== 'string') throw new TypeError('Value must be a string.');
      this.emit('setString', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, JSON.stringify({
        __string__: true,
        value: data
      }));
    }
    /**
     * Retrieves a string value from `localStorage`.
     *
     * @param {string} name - The key to retrieve.
     * @returns {string|null} The string if valid, or null.
     */
  }, {
    key: "getString",
    value: function getString(name) {
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      var value = _classPrivateFieldGet(_localStorage, this).getItem(name);
      try {
        /** @type {{ value: string; __string__: boolean }} */
        // @ts-ignore
        value = JSON.parse(value);
        if (!(0, _objChecker.isJsonObject)(value) || !value.__string__ || typeof value.value !== 'string') return null;
        value = value.value;
      } catch (_unused) {
        value = null;
      }
      if (typeof value === 'string') return value;
      return null;
    }
    /**
     * Stores a number value in `localStorage`.
     *
     * @param {string} name - The key to use.
     * @param {number} data - The number to store.
     */
  }, {
    key: "setNumber",
    value: function setNumber(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      if (typeof data !== 'number') throw new TypeError('Value must be a number.');
      this.emit('setNumber', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, String(data));
    }
    /**
     * Retrieves a number from `localStorage`.
     *
     * @param {string} name - The key to retrieve.
     * @returns {number|null} The number or null if invalid.
     */
  }, {
    key: "getNumber",
    value: function getNumber(name) {
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      /** @type {number|string|null} */
      var number = _classPrivateFieldGet(_localStorage, this).getItem(name);
      if (typeof number === 'number') return number;
      if (typeof number === 'string' && number.length > 0) {
        number = parseFloat(number);
        if (!Number.isNaN(number)) return number;
      }
      return null;
    }
    /**
     * Stores a boolean value in `localStorage`.
     *
     * @param {string} name - The key to use.
     * @param {boolean} data - The boolean value to store.
     */
  }, {
    key: "setBool",
    value: function setBool(name, data) {
      _assertClassBrand(_TinyLocalStorage_brand, this, _isProtectedDbKey).call(this, name);
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      if (typeof data !== 'boolean') throw new TypeError('Value must be a boolean.');
      this.emit('setBool', name, data);
      return _classPrivateFieldGet(_localStorage, this).setItem(name, String(data));
    }
    /**
     * Retrieves a boolean value from `localStorage`.
     *
     * @param {string} name - The key to retrieve.
     * @returns {boolean|null} The boolean or null if invalid.
     */
  }, {
    key: "getBool",
    value: function getBool(name) {
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      var value = _classPrivateFieldGet(_localStorage, this).getItem(name);
      if (typeof value === 'boolean') return value;
      if (typeof value === 'string') {
        if (value === 'true') return true;
        if (value === 'false') return false;
      }
      return null;
    }
    /**
     * Removes a value from `localStorage`.
     *
     * @param {string} name - The key to remove.
     */
  }, {
    key: "removeItem",
    value: function removeItem(name) {
      if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
      this.emit('removeItem', name);
      return _classPrivateFieldGet(_localStorage, this).removeItem(name);
    }
    /**
     * Clears all data from `localStorage`.
     */
  }, {
    key: "clearLocalStorage",
    value: function clearLocalStorage() {
      return _classPrivateFieldGet(_localStorage, this).clear();
    }
    /**
     * Destroys the storage instance by removing the storage event listener.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      window.removeEventListener('storage', _classPrivateFieldGet(_storageEvent, this));
      _classPrivateFieldGet(_events, this).offAllTypes();
    }
  }], [{
    key: "hasJsonType",
    value: function hasJsonType(type) {
      return customEncoders.has(type) && customDecoders.has(type) || customTypesFreezed.has(type);
    }
    /**
     * Registers a new JSON-serializable type with its encoder and decoder.
     *
     * @param {any} type - The type identifier, which can be a string (e.g., `"bigint"`, `"symbol"`)
     *                     or a reference to a class/constructor function.
     * @param {EncodeFn} encodeFn - A function that receives a value of this type and returns a JSON-safe representation.
     * @param {DecodeFn} decodeFn - An object with `check(value)` to identify this type and `decode(value)` to restore it.
     * @param {boolean} [freezeType=false] - If true, prevents this type from being unregistered later.
     * @throws {Error} Throws an error if the type is frozen and cannot be registered.
     */
  }, {
    key: "registerJsonType",
    value: function registerJsonType(type, encodeFn, decodeFn) {
      var freezeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      if (customTypesFreezed.has(type)) throw new Error("Cannot register type \"".concat(type, "\" because it is frozen."));
      customEncoders.set(type, encodeFn);
      customDecoders.set(type, decodeFn);
      if (freezeType) customTypesFreezed.add(type);
    }
    /**
     * Unregisters a previously registered custom type from the encoding/decoding system.
     *
     * @param {any} type - The primitive name or constructor reference used in the registration.
     * @returns {boolean} Returns true if the type existed and was removed, or false if it wasn't found.
     * @throws {Error} Throws an error if the type is frozen and cannot be unregistered.
     */
  }, {
    key: "deleteJsonType",
    value: function deleteJsonType(type) {
      if (customTypesFreezed.has(type)) throw new Error("Cannot remove type \"".concat(type, "\" because it is frozen."));
      var isDeleted = false;
      if (customEncoders["delete"](type)) isDeleted = true;
      if (customDecoders["delete"](type)) isDeleted = true;
      return isDeleted;
    }
    //////////////////////////////////////////////////////
    /**
     * Recursively serializes a value to a JSON-compatible format.
     *
     * This includes custom types (via `registerJsonType`), plus support for:
     * - `undefined` â `{ __undefined__: true }`
     * - `null` â `{ __null__: true }`
     *
     * @type {encodeSpecialJson}
     */
  }, {
    key: "encodeSpecialJson",
    value: function encodeSpecialJson(value) {
      if (typeof value === 'undefined') return {
        __undefined__: true
      };
      if (value === null) return {
        __null__: true
      };
      var _iterator = _createForOfIteratorHelper(customEncoders.entries()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            type = _step$value[0],
            encoder = _step$value[1];
          if (typeof type !== 'string' && value instanceof type || _typeof(value) === type) {
            return encoder(value, TinyLocalStorage.encodeSpecialJson);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (Array.isArray(value)) {
        return value.map(TinyLocalStorage.encodeSpecialJson);
      }
      if ((0, _objChecker.isJsonObject)(value)) {
        var encoded = {};
        for (var key in value) {
          // @ts-ignore
          encoded[key] = TinyLocalStorage.encodeSpecialJson(value[key]);
        }
        return encoded;
      }
      return value;
    }
    /**
     * Recursively deserializes a JSON-compatible value into its original structure.
     *
     * Automatically handles:
     * - `__undefined__` â `undefined`
     * - `__null__` â `null`
     * - Any type registered via `registerJsonType`
     *
     * @type {decodeSpecialJson}
     */
  }, {
    key: "decodeSpecialJson",
    value: function decodeSpecialJson(value) {
      var isJson = (0, _objChecker.isJsonObject)(value);
      if (isJson) {
        if (value.__undefined__) return undefined;
        if (value.__null__) return null;
      }
      if (Array.isArray(value)) {
        return value.map(TinyLocalStorage.decodeSpecialJson);
      }
      if (isJson) {
        var _iterator2 = _createForOfIteratorHelper(customDecoders.entries()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
              type = _step2$value[0],
              decoder = _step2$value[1];
            if (decoder.check && decoder.check(value)) {
              return decoder.decode(value, TinyLocalStorage.decodeSpecialJson);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        var decoded = {};
        for (var key in value) {
          // @ts-ignore
          decoded[key] = TinyLocalStorage.decodeSpecialJson(value[key]);
        }
        return decoded;
      }
      return value;
    }
  }]);
}(); // First registers
// Map
_TinyLocalStorage = TinyLocalStorage;
function _isProtectedDbKey(name) {
  if (typeof name === 'string' && name.startsWith('LSDB::')) throw new Error("TinyLocalStorage: Key \"".concat(name, "\" may conflict with reserved dbKeys."));
}
function _setJson(name, data) {
  if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
  return _TinyLocalStorage.encodeSpecialJson(data);
}
function _getJson(name, defaultData) {
  if (typeof name !== 'string' || !name.length) throw new TypeError('Key must be a non-empty string.');
  var raw = _classPrivateFieldGet(_localStorage, this).getItem(name);
  var fallbackTypes = {
    obj: function obj() {
      return {};
    },
    array: function array() {
      return [];
    },
    map: function map() {
      return new Map();
    },
    set: function set() {
      return new Set();
    }
  };
  var fallback =
  // @ts-ignore
  typeof fallbackTypes[defaultData] === 'function' ? fallbackTypes[defaultData]() : null;
  var parsed;
  try {
    // @ts-ignore
    parsed = JSON.parse(raw);
  } catch (_unused2) {
    // @ts-ignore
    return fallback;
  }
  return {
    decoded: _TinyLocalStorage.decodeSpecialJson(parsed),
    fallback: fallback
  };
}
TinyLocalStorage.registerJsonType(Map, function (value, encodeSpecialJson) {
  return {
    __map__: true,
    data: Array.from(value.entries()).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        v = _ref2[1];
      return [k, encodeSpecialJson(v)];
    })
  };
}, {
  check: function check(value) {
    return value.__map__;
  },
  /** @param {{ data: any[] }} value */
  decode: function decode(value, decodeSpecialJson) {
    return new Map(value.data.map(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        k = _ref4[0],
        v = _ref4[1];
      return [k, decodeSpecialJson(v)];
    }));
  }
}, true);
// Set
TinyLocalStorage.registerJsonType(Set, function (value, encodeSpecialJson) {
  return {
    __set__: true,
    data: Array.from(value).map(encodeSpecialJson)
  };
}, {
  check: function check(value) {
    return value.__set__;
  },
  decode: function decode(value, decodeSpecialJson) {
    return new Set(value.data.map(decodeSpecialJson));
  }
}, true);
// Date
TinyLocalStorage.registerJsonType(Date, function (value) {
  return {
    __date__: true,
    value: value.toISOString()
  };
}, {
  check: function check(value) {
    return value.__date__;
  },
  decode: function decode(value) {
    return new Date(value.value);
  }
}, true);
// Regex
TinyLocalStorage.registerJsonType(RegExp, function (value) {
  return {
    __regexp__: true,
    source: value.source,
    flags: value.flags
  };
}, {
  check: function check(value) {
    return value.__regexp__;
  },
  decode: function decode(value) {
    return new RegExp(value.source, value.flags);
  }
}, true);
// Big Int
TinyLocalStorage.registerJsonType('bigint', function (value) {
  return {
    __bigint__: true,
    value: value.toString()
  };
}, {
  check: function check(value) {
    return value.__bigint__;
  },
  decode: function decode(value) {
    return BigInt(value.value);
  }
}, true);
// Symbol
TinyLocalStorage.registerJsonType('symbol', function (value) {
  var _ref5, _Symbol$keyFor;
  return {
    __symbol__: true,
    key: (_ref5 = (_Symbol$keyFor = Symbol.keyFor(value)) !== null && _Symbol$keyFor !== void 0 ? _Symbol$keyFor : value.description) !== null && _ref5 !== void 0 ? _ref5 : null
  };
}, {
  check: function check(value) {
    return value.__symbol__;
  },
  decode: function decode(value) {
    var key = value.key;
    return key != null ? Symbol["for"](key) : Symbol();
  }
}, true);
var _default = exports["default"] = TinyLocalStorage;

},{"../basics/objChecker.mjs":175,"./TinyEvents.mjs":189}],193:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _TinyEvents = _interopRequireDefault(require("./TinyEvents.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Stores polling intervals associated with window references.
 * Used to detect when the window is closed.
 *
 * @type {WeakMap<Window, NodeJS.Timeout>}
 */
var pollClosedInterval = new WeakMap();
/**
 * @callback handler
 * A function to handle incoming event payloads.
 * @param {any} payload - The data sent by the emitter.
 * @param {MessageEvent<any>} event - Metadata about the message.
 */
/**
 * TinyNewWinEvents provides structured communication between a main window
 * and a child window (created using window.open) using postMessage.
 *
 * It supports routing, queuing messages until handshake is ready,
 * connection status checks, and close detection.
 *
 * @class
 */
var _events = /*#__PURE__*/new WeakMap();
var _windowRef = /*#__PURE__*/new WeakMap();
var _targetOrigin = /*#__PURE__*/new WeakMap();
var _pendingQueue = /*#__PURE__*/new WeakMap();
var _ready = /*#__PURE__*/new WeakMap();
var _isHost = /*#__PURE__*/new WeakMap();
var _pollClosedInterval = /*#__PURE__*/new WeakMap();
var _readyEventName = /*#__PURE__*/new WeakMap();
var _routeEventName = /*#__PURE__*/new WeakMap();
var _TinyNewWinEvents_brand = /*#__PURE__*/new WeakSet();
var TinyNewWinEvents = /*#__PURE__*/function () {
  /**
   * Initializes a TinyNewWinEvents instance for communication.
   *
   * @param {Object} [settings={}] Configuration object.
   * @param {string} [settings.targetOrigin] Origin to enforce in postMessage.
   * @param {string} [settings.url] URL string to open.
   * @param {string} [settings.name] Window name (required if opening a new window).
   * @param {string} [settings.features] Features string for `window.open`.
   *
   * @throws {Error} If `name` is "_blank", which is not allowed.
   * @throws {TypeError} If `targetOrigin`, `url`, or `features` are not strings (when provided).
   * @throws {Error} If the window reference is invalid or already being tracked.
   */
  function TinyNewWinEvents() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      targetOrigin = _ref.targetOrigin,
      url = _ref.url,
      name = _ref.name,
      features = _ref.features;
    _classCallCheck(this, TinyNewWinEvents);
    /**
     * Internal message handler.
     *
     * @param {MessageEvent} event
     * @returns {void}
     */
    _classPrivateMethodInitSpec(this, _TinyNewWinEvents_brand);
    _classPrivateFieldInitSpec(this, _events, new _TinyEvents["default"]());
    ///////////////////////////////////////////////////
    /** @type {Window|null} Reference to the opened or parent window */
    _classPrivateFieldInitSpec(this, _windowRef, void 0);
    /** @type {string} Expected origin for postMessage communication */
    _classPrivateFieldInitSpec(this, _targetOrigin, void 0);
    /** @type {{ route: string, payload: any }[]} Queue of messages emitted before connection is ready */
    _classPrivateFieldInitSpec(this, _pendingQueue, []);
    /** @type {boolean} True if handshake between windows is complete */
    _classPrivateFieldInitSpec(this, _ready, false);
    /** @type {boolean} True if this instance is the main window (host) */
    _classPrivateFieldInitSpec(this, _isHost, false);
    /** @type {NodeJS.Timeout|null} Interval for polling child window closure */
    _classPrivateFieldInitSpec(this, _pollClosedInterval, null);
    /** @type {string} Internal message type for handshake */
    _classPrivateFieldInitSpec(this, _readyEventName, '__TNE_READY__');
    /** @type {string} Internal message type for routed communication */
    _classPrivateFieldInitSpec(this, _routeEventName, '__TNE_ROUTE__');
    if (typeof name === 'string' && name === '_blank') throw new Error('TinyNewWinEvents: The window name "_blank" is not supported. Please use a custom name to allow tracking.');
    if (typeof targetOrigin !== 'undefined' && typeof targetOrigin !== 'string') throw new TypeError('TinyNewWinEvents: The "targetOrigin" option must be a string.');
    if (typeof url !== 'undefined' && typeof url !== 'string') throw new TypeError('TinyNewWinEvents: The "url" option must be a string.');
    if (typeof features !== 'undefined' && typeof features !== 'string') throw new TypeError('TinyNewWinEvents: The "features" option must be a string if provided.');
    // Open Page
    if (typeof url === 'undefined') _classPrivateFieldSet(_windowRef, this, window.opener);
    // Main Page
    else {
      _classPrivateFieldSet(_windowRef, this, typeof url === 'string' ? window.open(url, name, features) : url);
      _classPrivateFieldSet(_isHost, this, true);
    }
    if (!_classPrivateFieldGet(_windowRef, this) || pollClosedInterval.has(_classPrivateFieldGet(_windowRef, this))) throw new Error('Invalid or duplicate window reference.');
    _classPrivateFieldSet(_targetOrigin, this, targetOrigin !== null && targetOrigin !== void 0 ? targetOrigin : window.location.origin);
    this._handleMessage = _assertClassBrand(_TinyNewWinEvents_brand, this, _handleMessage).bind(this);
    window.addEventListener('message', this._handleMessage, false);
    // Sends handshake if it is host (main window)
    if (!_classPrivateFieldGet(_isHost, this)) {
      _assertClassBrand(_TinyNewWinEvents_brand, this, _postRaw).call(this, _classPrivateFieldGet(_readyEventName, this), null);
      _assertClassBrand(_TinyNewWinEvents_brand, this, _startCloseWatcher).call(this);
    }
  }
  /**
   * Returns the internal window reference.
   *
   * @returns {Window|null}
   */
  return _createClass(TinyNewWinEvents, [{
    key: "setThrowOnMaxListeners",
    value:
    /**
     * Enables or disables throwing an error when the maximum number of listeners is exceeded.
     *
     * @param {boolean} shouldThrow - If true, an error will be thrown when the max is exceeded.
     */
    function setThrowOnMaxListeners(shouldThrow) {
      return _classPrivateFieldGet(_events, this).setThrowOnMaxListeners(shouldThrow);
    }
    /**
     * Checks whether an error will be thrown when the max listener limit is exceeded.
     *
     * @returns {boolean} True if an error will be thrown, false if only a warning is shown.
     */
  }, {
    key: "getThrowOnMaxListeners",
    value: function getThrowOnMaxListeners() {
      return _classPrivateFieldGet(_events, this).getThrowOnMaxListeners();
    }
    /////////////////////////////////////////////////////////////
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     */
  }, {
    key: "prependListener",
    value: function prependListener(event, handler) {
      return _classPrivateFieldGet(_events, this).prependListener(event, handler);
    }
    /**
     * Adds a one-time listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {handler} handler - The callback function.
     * @returns {handler} - The wrapped handler used internally.
     */
  }, {
    key: "prependListenerOnce",
    value: function prependListenerOnce(event, handler) {
      return _classPrivateFieldGet(_events, this).prependListenerOnce(event, handler);
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     */
  }, {
    key: "appendListener",
    value: function appendListener(event, handler) {
      return _classPrivateFieldGet(_events, this).appendListener(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - The callback function to run on event.
     * @returns {handler} - The wrapped version of the handler.
     */
  }, {
    key: "appendListenerOnce",
    value: function appendListenerOnce(event, handler) {
      return _classPrivateFieldGet(_events, this).appendListenerOnce(event, handler);
    }
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - Callback function to be called when event fires.
     */
  }, {
    key: "on",
    value: function on(event, handler) {
      return _classPrivateFieldGet(_events, this).on(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {handler} handler - The callback function to run on event.
     * @returns {handler} - The wrapped version of the handler.
     */
  }, {
    key: "once",
    value: function once(event, handler) {
      return _classPrivateFieldGet(_events, this).once(event, handler);
    }
    ////////////////////////////////////////////////////////////////////
    /**
     * Removes a previously registered event listener.
     *
     * @param {string} event - The name of the event to remove the handler from.
     * @param {handler} handler - The specific callback function to remove.
     */
  }, {
    key: "off",
    value: function off(event, handler) {
      return _classPrivateFieldGet(_events, this).off(event, handler);
    }
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {string} event - The event type to remove (e.g. 'onScrollBoundary').
     */
  }, {
    key: "offAll",
    value: function offAll(event) {
      return _classPrivateFieldGet(_events, this).offAll(event);
    }
    /**
     * Removes all event listeners of all types from the element.
     */
  }, {
    key: "offAllTypes",
    value: function offAllTypes() {
      return _classPrivateFieldGet(_events, this).offAllTypes();
    }
    ////////////////////////////////////////////////////////////
    /**
     * Returns the number of listeners for a given event.
     *
     * @param {string} event - The name of the event.
     * @returns {number} Number of listeners for the event.
     */
  }, {
    key: "listenerCount",
    value: function listenerCount(event) {
      return _classPrivateFieldGet(_events, this).listenerCount(event);
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {handler[]} Array of listener functions.
     */
  }, {
    key: "listeners",
    value: function listeners(event) {
      return _classPrivateFieldGet(_events, this).listeners(event);
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {handler[]} Array of listener functions.
     */
  }, {
    key: "onceListeners",
    value: function onceListeners(event) {
      return _classPrivateFieldGet(_events, this).onceListeners(event);
    }
    /**
     * Returns a copy of the internal listeners array for the specified event,
     * including wrapper functions like those used by `.once()`.
     * @param {string | symbol} event - The event name.
     * @returns {handler[]} An array of raw listener functions.
     */
  }, {
    key: "allListeners",
    value: function allListeners(event) {
      return _classPrivateFieldGet(_events, this).allListeners(event);
    }
    /**
     * Returns an array of event names for which there are registered listeners.
     *
     * @returns {string[]} Array of registered event names.
     */
  }, {
    key: "eventNames",
    value: function eventNames() {
      return _classPrivateFieldGet(_events, this).eventNames();
    }
    //////////////////////////////////////////////////////
    /**
     * Sets the maximum number of listeners per event before a warning is shown.
     *
     * @param {number} n - The maximum number of listeners.
     */
  }, {
    key: "setMaxListeners",
    value: function setMaxListeners(n) {
      return _classPrivateFieldGet(_events, this).setMaxListeners(n);
    }
    /**
     * Gets the maximum number of listeners allowed per event.
     *
     * @returns {number} The maximum number of listeners.
     */
  }, {
    key: "getMaxListeners",
    value: function getMaxListeners() {
      return _classPrivateFieldGet(_events, this).getMaxListeners();
    }
  }, {
    key: "readyEventName",
    get:
    /**
     * Gets the internal handshake event name.
     * @returns {string}
     */
    function get() {
      return _classPrivateFieldGet(_readyEventName, this);
    }
    /**
     * Sets the internal handshake event name.
     * @param {string} name
     * @throws {TypeError} If the value is not a string.
     */,
    set: function set(name) {
      if (typeof name !== 'string') throw new TypeError('TinyNewWinEvents: readyEventName must be a string.');
      _classPrivateFieldSet(_readyEventName, this, name);
    }
    /**
     * Gets the internal route event name.
     * @returns {string}
     */
  }, {
    key: "routeEventName",
    get: function get() {
      return _classPrivateFieldGet(_routeEventName, this);
    }
    /**
     * Sets the internal route event name.
     * @param {string} name
     * @throws {TypeError} If the value is not a string.
     */,
    set: function set(name) {
      if (typeof name !== 'string') throw new TypeError('TinyNewWinEvents: routeEventName must be a string.');
      _classPrivateFieldSet(_routeEventName, this, name);
    }
  }, {
    key: "getWin",
    value: function getWin() {
      return _classPrivateFieldGet(_windowRef, this);
    }
  }, {
    key: "close",
    value:
    /**
     * Closes the child window (only allowed from the host).
     *
     * @returns {void}
     */
    function close() {
      if (!_classPrivateFieldGet(_isHost, this)) throw new Error('Only host can close the window.');
      if (_classPrivateFieldGet(_windowRef, this) && !_classPrivateFieldGet(_windowRef, this).closed) _classPrivateFieldGet(_windowRef, this).close();
    }
    /**
     * Emits a message to the other window on a specific route.
     * If the handshake is not yet complete, the message is queued.
     * Throws an error if the instance has already been destroyed.
     *
     * @param {string} route - Route name used to identify the message handler.
     * @param {any} payload - Data to send along with the message.
     * @throws {Error} If the instance is already destroyed.
     * @returns {void}
     */
  }, {
    key: "emit",
    value: function emit(route, payload) {
      if (typeof route !== 'string') throw new TypeError('Event name must be a string.');
      if (this.isDestroyed()) throw new Error('Cannot emit: instance has been destroyed.');
      if (!_classPrivateFieldGet(_ready, this)) {
        _classPrivateFieldGet(_pendingQueue, this).push({
          route: route,
          payload: payload
        });
        return;
      }
      _assertClassBrand(_TinyNewWinEvents_brand, this, _postRaw).call(this, _classPrivateFieldGet(_routeEventName, this), payload, route);
    }
    /**
     * Checks if the connection is active and the window is still open.
     *
     * @returns {boolean}
     */
  }, {
    key: "isConnected",
    value: function isConnected() {
      return _classPrivateFieldGet(_ready, this) && _classPrivateFieldGet(_windowRef, this) && !_classPrivateFieldGet(_windowRef, this).closed ? true : false;
    }
    /**
     * Starts polling to detect when the window is closed.
     *
     * @returns {void}
     */
  }, {
    key: "onClose",
    value:
    /**
     * Registers a callback for when the window is closed.
     *
     * @param {handler} callback Callback to run on close
     * @returns {void}
     */
    function onClose(callback) {
      return _classPrivateFieldGet(_events, this).on('WINDOW_REF_CLOSED', callback);
    }
    /**
     * Unregisters a previously registered close callback.
     *
     * @param {handler} callback Callback to remove
     * @returns {void}
     */
  }, {
    key: "offClose",
    value: function offClose(callback) {
      return _classPrivateFieldGet(_events, this).off('WINDOW_REF_CLOSED', callback);
    }
    /**
     * Checks if the communication instance has been destroyed.
     *
     * @returns {boolean}
     */
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return !_classPrivateFieldGet(_windowRef, this);
    }
    /**
     * Destroys the communication instance, cleaning up all resources and listeners.
     *
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (!_classPrivateFieldGet(_windowRef, this)) return;
      if (_classPrivateFieldGet(_pollClosedInterval, this)) {
        clearInterval(_classPrivateFieldGet(_pollClosedInterval, this));
        _classPrivateFieldSet(_pollClosedInterval, this, null);
        pollClosedInterval["delete"](_classPrivateFieldGet(_windowRef, this));
      }
      window.removeEventListener('message', this._handleMessage);
      _classPrivateFieldSet(_pendingQueue, this, []);
      _classPrivateFieldSet(_ready, this, false);
      _classPrivateFieldSet(_windowRef, this, null);
      _classPrivateFieldGet(_events, this).offAllTypes();
    }
  }]);
}();
function _handleMessage(event) {
  if (!event.source || _classPrivateFieldGet(_windowRef, this) && event.source !== _classPrivateFieldGet(_windowRef, this)) return;
  var _ref2 = event.data || {},
    type = _ref2.type,
    route = _ref2.route,
    payload = _ref2.payload;
  if (type === _classPrivateFieldGet(_readyEventName, this)) {
    _classPrivateFieldSet(_ready, this, true);
    _assertClassBrand(_TinyNewWinEvents_brand, this, _flushQueue).call(this);
    _assertClassBrand(_TinyNewWinEvents_brand, this, _startCloseWatcher).call(this); // start watcher after handshake (for child window)
    if (_classPrivateFieldGet(_isHost, this)) _assertClassBrand(_TinyNewWinEvents_brand, this, _postRaw).call(this, _classPrivateFieldGet(_readyEventName, this), null);
    return;
  }
  if (type === _classPrivateFieldGet(_routeEventName, this)) _classPrivateFieldGet(_events, this).emit(route, payload, event);
}
/**
 * Sends all pending messages queued before handshake completion.
 *
 * @returns {void}
 */
function _flushQueue() {
  while (_classPrivateFieldGet(_pendingQueue, this).length) {
    var data = _classPrivateFieldGet(_pendingQueue, this).shift();
    if (data) {
      var route = data.route,
        payload = data.payload;
      this.emit(route, payload);
    }
  }
}
/**
 * Sends a raw postMessage with given type and payload.
 *
 * @param {string} type Internal message type
 * @param {any} payload Data to send
 * @param {string} [route=''] Optional route name
 * @returns {void}
 */
function _postRaw(type, payload) {
  var _classPrivateFieldGet2;
  var route = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  if (_classPrivateFieldGet(_windowRef, this) && _classPrivateFieldGet(_windowRef, this).closed) return;
  (_classPrivateFieldGet2 = _classPrivateFieldGet(_windowRef, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.postMessage({
    type: type,
    route: route,
    payload: payload
  }, _classPrivateFieldGet(_targetOrigin, this));
}
function _startCloseWatcher() {
  var _this = this;
  if (!_classPrivateFieldGet(_windowRef, this) || _classPrivateFieldGet(_pollClosedInterval, this)) return;
  _classPrivateFieldSet(_pollClosedInterval, this, setInterval(function () {
    var _classPrivateFieldGet3;
    if ((_classPrivateFieldGet3 = _classPrivateFieldGet(_windowRef, _this)) !== null && _classPrivateFieldGet3 !== void 0 && _classPrivateFieldGet3.closed) {
      _classPrivateFieldGet(_events, _this).emit('WINDOW_REF_CLOSED');
      _this.destroy();
    }
  }, 500));
  pollClosedInterval.set(_classPrivateFieldGet(_windowRef, this), _classPrivateFieldGet(_pollClosedInterval, this));
}
var _default = exports["default"] = TinyNewWinEvents;

},{"./TinyEvents.mjs":189}],194:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _text = require("../basics/text.mjs");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * A utility class to manage browser notifications with sound and custom behavior.
 * Useful for triggering system notifications with optional sound, avatar icon, body truncation, and click actions.
 *
 * @class
 */
var _allowed = /*#__PURE__*/new WeakMap();
var _permissionRequested = /*#__PURE__*/new WeakMap();
var _audio = /*#__PURE__*/new WeakMap();
var _bodyLimit = /*#__PURE__*/new WeakMap();
var _defaultIcon = /*#__PURE__*/new WeakMap();
var _defaultOnClick = /*#__PURE__*/new WeakMap();
var TinyNotifications = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of TinyNotifications.
   *
   * @param {Object} [settings={}] - Optional settings to initialize the notification manager.
   * @param {string|HTMLAudioElement|null} [settings.audio] - Path or URL to the audio file for notification sounds.
   * @param {string|null} [settings.defaultIcon] - Default icon URL to be used in notifications.
   * @param {number} [settings.bodyLimit=100] - Maximum number of characters allowed in the notification body.
   * @param {(this: Notification, evt: Event) => any} [settings.defaultOnClick] - Default function to execute when a notification is clicked.
   * @throws {TypeError} If any of the parameters are of an invalid type.
   */
  function TinyNotifications() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$audio = _ref.audio,
      audio = _ref$audio === void 0 ? null : _ref$audio,
      _ref$defaultIcon = _ref.defaultIcon,
      defaultIcon = _ref$defaultIcon === void 0 ? null : _ref$defaultIcon,
      _ref$bodyLimit = _ref.bodyLimit,
      bodyLimit = _ref$bodyLimit === void 0 ? 100 : _ref$bodyLimit,
      _ref$defaultOnClick = _ref.defaultOnClick,
      defaultOnClick = _ref$defaultOnClick === void 0 ? function (event) {
        event.preventDefault();
        if (window.focus) window.focus();
        this.close();
      } : _ref$defaultOnClick;
    _classCallCheck(this, TinyNotifications);
    /** @type {boolean} Whether notifications are currently allowed by the user. */
    _classPrivateFieldInitSpec(this, _allowed, false);
    /** @type {boolean} Indicates whether the user has already requested permission at least once. */
    _classPrivateFieldInitSpec(this, _permissionRequested, false);
    /** @type {HTMLAudioElement|null} Audio element to play when a notification is triggered. */
    _classPrivateFieldInitSpec(this, _audio, null);
    /** @type {number} Maximum number of characters in the notification body. */
    _classPrivateFieldInitSpec(this, _bodyLimit, 100);
    /** @type {string|null} Default avatar icon URL for notifications. */
    _classPrivateFieldInitSpec(this, _defaultIcon, null);
    /** @type {(this: Notification, evt: Event) => any} Default handler when a notification is clicked. */
    _classPrivateFieldInitSpec(this, _defaultOnClick, void 0);
    if (!(audio instanceof HTMLAudioElement) && typeof audio !== 'string' && audio !== null) throw new TypeError('audio must be an instance of HTMLAudioElement or null.');
    if (defaultIcon !== null && typeof defaultIcon !== 'string') throw new TypeError('defaultIcon must be a string or null.');
    if (!Number.isFinite(bodyLimit) || bodyLimit < 0) throw new TypeError('bodyLimit must be a non-negative number.');
    if (typeof defaultOnClick !== 'function') throw new TypeError('defaultOnClick must be a function.');
    _classPrivateFieldSet(_audio, this, typeof audio !== 'string' ? audio : new Audio(audio));
    _classPrivateFieldSet(_defaultIcon, this, defaultIcon);
    _classPrivateFieldSet(_bodyLimit, this, bodyLimit);
    _classPrivateFieldSet(_defaultOnClick, this, defaultOnClick);
  }
  /**
   * Requests permission from the user to show notifications.
   * Updates the internal `#allowed` flag.
   *
   * @returns {Promise<boolean>} Resolves to `true` if permission is granted, otherwise `false`.
   */
  return _createClass(TinyNotifications, [{
    key: "requestPerm",
    value: function requestPerm() {
      var _this = this;
      var tinyThis = this;
      return new Promise(function (resolve, reject) {
        if (tinyThis.isCompatible()) {
          if (Notification.permission === 'default') {
            Notification.requestPermission().then(function (permission) {
              _classPrivateFieldSet(_permissionRequested, _this, true);
              _classPrivateFieldSet(_allowed, tinyThis, permission === 'granted');
              resolve(_classPrivateFieldGet(_allowed, tinyThis));
            })["catch"](reject);
          } else {
            _classPrivateFieldSet(_permissionRequested, _this, true);
            _classPrivateFieldSet(_allowed, tinyThis, Notification.permission === 'granted');
            resolve(_classPrivateFieldGet(_allowed, tinyThis));
          }
        } else {
          _classPrivateFieldSet(_permissionRequested, _this, true);
          _classPrivateFieldSet(_allowed, tinyThis, false);
          resolve(false);
        }
      });
    }
    /**
     * Checks if the Notification API is supported by the current browser.
     *
     * @returns {boolean} Returns `true` if notifications are supported, otherwise `false`.
     */
  }, {
    key: "isCompatible",
    value: function isCompatible() {
      return 'Notification' in window;
    }
    /**
     * Sends a browser notification with the provided title and configuration.
     * Truncates the body if necessary and plays a sound if configured.
     *
     * @param {string} title - The title of the notification.
     * @param {NotificationOptions & { vibrate?: number[] }} [config={}] - Optional configuration for the notification.
     * @returns {Notification|null} The created `Notification` instance, or `null` if permission is not granted.
     * @throws {TypeError} If the title is not a string or config is not a valid object.
     */
  }, {
    key: "send",
    value: function send(title) {
      var _this2 = this;
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!_classPrivateFieldGet(_permissionRequested, this)) throw new Error('You must call requestPerm() before sending a notification.');
      if (typeof title !== 'string') throw new TypeError('title must be a string.');
      if (_typeof(config) !== 'object' || config === null) throw new TypeError('config must be a non-null object.');
      if (!_classPrivateFieldGet(_allowed, this)) return null;
      var _config$icon = config.icon,
        icon = _config$icon === void 0 ? _classPrivateFieldGet(_defaultIcon, this) || undefined : _config$icon,
        _config$vibrate = config.vibrate,
        vibrate = _config$vibrate === void 0 ? [200, 100, 200] : _config$vibrate;
      var options = _objectSpread({}, config);
      if (typeof icon === 'string') options.icon = icon;
      if (Array.isArray(vibrate)) options.vibrate = vibrate;
      if (typeof options.body === 'string') options.body = (0, _text.safeTextTrim)(options.body, _classPrivateFieldGet(_bodyLimit, this));
      var notification = new Notification(title, options);
      notification.addEventListener('show', function () {
        if (!(_classPrivateFieldGet(_audio, _this2) instanceof HTMLAudioElement)) return;
        _classPrivateFieldGet(_audio, _this2).currentTime = 0;
        _classPrivateFieldGet(_audio, _this2).play()["catch"](function (err) {
          return console.error(err);
        });
      });
      if (typeof _classPrivateFieldGet(_defaultOnClick, this) === 'function') notification.addEventListener('click', _classPrivateFieldGet(_defaultOnClick, this));
      return notification;
    }
    // === Getters and Setters ===
    /**
     * Whether the requestPerm() method was already called.
     * @returns {boolean}
     */
  }, {
    key: "wasPermissionRequested",
    value: function wasPermissionRequested() {
      return _classPrivateFieldGet(_permissionRequested, this);
    }
    /**
     * Returns the current permission status.
     * @returns {boolean} `true` if permission was granted, otherwise `false`.
     */
  }, {
    key: "isAllowed",
    value: function isAllowed() {
      return _classPrivateFieldGet(_allowed, this);
    }
    /**
     * Gets the current notification audio.
     * @returns {HTMLAudioElement|null} The sound element, or `null` if not set.
     */
  }, {
    key: "getAudio",
    value: function getAudio() {
      return _classPrivateFieldGet(_audio, this);
    }
    /**
     * Sets the audio element used for notification sounds.
     * @param {HTMLAudioElement|string|null} value - A valid `HTMLAudioElement` or `null` to disable sound.
     * @throws {TypeError} If the value is not an `HTMLAudioElement` or `null`.
     */
  }, {
    key: "setAudio",
    value: function setAudio(value) {
      if (!(value instanceof HTMLAudioElement) && typeof value !== 'string' && value !== null) throw new TypeError('sound must be an instance of HTMLAudioElement or null.');
      _classPrivateFieldSet(_audio, this, typeof value !== 'string' ? value : new Audio(value));
    }
    /**
     * Gets the maximum length of the notification body text.
     * @returns {number} Number of characters allowed.
     */
  }, {
    key: "getBodyLimit",
    value: function getBodyLimit() {
      return _classPrivateFieldGet(_bodyLimit, this);
    }
    /**
     * Sets the maximum number of characters allowed in the notification body.
     * @param {number} value - A non-negative integer.
     * @throws {TypeError} If the value is not a valid non-negative number.
     */
  }, {
    key: "setBodyLimit",
    value: function setBodyLimit(value) {
      if (!Number.isFinite(value) || value < 0) throw new TypeError('bodyLimit must be a non-negative number.');
      _classPrivateFieldSet(_bodyLimit, this, value);
    }
    /**
     * Gets the default avatar icon URL.
     * @returns {string|null} The URL string or `null`.
     */
  }, {
    key: "getDefaultAvatar",
    value: function getDefaultAvatar() {
      return _classPrivateFieldGet(_defaultIcon, this);
    }
    /**
     * Sets the default avatar icon URL.
     * @param {string|null} value - A string URL or `null` to disable default icon.
     * @throws {TypeError} If the value is not a string or `null`.
     */
  }, {
    key: "setDefaultAvatar",
    value: function setDefaultAvatar(value) {
      if (!(typeof value === 'string' || value === null)) throw new TypeError('defaultIcon must be a string or null.');
      _classPrivateFieldSet(_defaultIcon, this, value);
    }
    /**
     * Gets the default click event handler for notifications.
     * @returns {(this: Notification, evt: Event) => any} The current click handler function.
     */
  }, {
    key: "getDefaultOnClick",
    value: function getDefaultOnClick() {
      return _classPrivateFieldGet(_defaultOnClick, this);
    }
    /**
     * Sets the default click event handler for notifications.
     * @param {(this: Notification, evt: Event) => any} value - A function to handle the notification click event.
     * @throws {TypeError} If the value is not a function.
     */
  }, {
    key: "setDefaultOnClick",
    value: function setDefaultOnClick(value) {
      if (typeof value !== 'function') throw new TypeError('defaultOnClick must be a function.');
      _classPrivateFieldSet(_defaultOnClick, this, value);
    }
  }]);
}();
var _default = exports["default"] = TinyNotifications;

},{"../basics/text.mjs":178}],195:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _center = /*#__PURE__*/new WeakMap();
var _list = /*#__PURE__*/new WeakMap();
var _badge = /*#__PURE__*/new WeakMap();
var _button = /*#__PURE__*/new WeakMap();
var _overlay = /*#__PURE__*/new WeakMap();
var _count = /*#__PURE__*/new WeakMap();
var _maxCount = /*#__PURE__*/new WeakMap();
var _removeDelay = /*#__PURE__*/new WeakMap();
var _markAllAsReadOnClose = /*#__PURE__*/new WeakMap();
var _modes = /*#__PURE__*/new WeakMap();
var _TinyNotifyCenter_brand = /*#__PURE__*/new WeakSet();
/**
 * Represents a single notification entry.
 *
 * A notification can be provided as a simple string (treated as a plain message),
 * or as an object with additional data such as a title, an avatar image, and a click handler.
 *
 * @typedef {string | {
 *   title?: string,              // Optional title displayed above the message
 *   message: string,             // Required message content
 *   avatar?: string,             // Optional avatar image URL (displayed on the left)
 *   onClick?: (e: MouseEvent) => void // Optional click handler for the entire notification
 * }} NotifyData
 */
/**
 * A notification center component for displaying interactive alerts in the UI.
 *
 * This class renders a notification overlay on the page and allows dynamically
 * adding, clearing, or interacting with notification items. Notifications can
 * contain plain text or HTML, and optionally support click events, titles, and avatars.
 *
 * Features:
 * - Dynamic rendering of notification UI with `insertTemplate()`
 * - Supports text and HTML content modes
 * - Optional avatars for each notification
 * - Callback support on notification click
 * - Per-notification close buttons
 * - Notification count badge
 *
 * @class
 */
var TinyNotifyCenter = /*#__PURE__*/function () {
  /**
   * Options for configuring the NotificationCenter instance.
   *
   * Allows manual specification of the main elements used by the notification center.
   * If not provided, default elements will be selected from the DOM automatically.
   *
   * @param {Object} options - Configuration object.
   * @param {HTMLElement} [options.center=document.getElementById('notifCenter')] - The container element that holds the list of notifications.
   * @param {HTMLElement} [options.badge=document.getElementById('notifBadge')] - The badge element used to display the current notification count.
   * @param {HTMLElement} [options.button=document.querySelector('.notify-bell')] - The button element that toggles the notification center.
   * @param {HTMLElement} [options.overlay=document.querySelector('.notify-overlay')] - The overlay element that covers the screen when the center is visible.
   */
  function TinyNotifyCenter() {
    var _center$querySelector,
      _this = this,
      _classPrivateFieldGet2;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, TinyNotifyCenter);
    /** @param {HTMLElement|ChildNode} item */
    _classPrivateMethodInitSpec(this, _TinyNotifyCenter_brand);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _center, void 0);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _list, void 0);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _badge, void 0);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _button, void 0);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _overlay, void 0);
    _classPrivateFieldInitSpec(this, _count, 0);
    _classPrivateFieldInitSpec(this, _maxCount, 99);
    _classPrivateFieldInitSpec(this, _removeDelay, 300);
    _classPrivateFieldInitSpec(this, _markAllAsReadOnClose, false);
    _classPrivateFieldInitSpec(this, _modes, new WeakMap());
    var _options$center = options.center,
      center = _options$center === void 0 ? document.getElementById('notifCenter') : _options$center,
      _options$badge = options.badge,
      badge = _options$badge === void 0 ? document.getElementById('notifBadge') : _options$badge,
      _options$button = options.button,
      button = _options$button === void 0 ? document.querySelector('.notify-bell') : _options$button,
      _options$overlay = options.overlay,
      overlay = _options$overlay === void 0 ? document.querySelector('.notify-overlay') : _options$overlay;
    // Element existence and type validation
    if (!(center instanceof HTMLElement)) throw new Error("NotificationCenter: \"center\" must be an HTMLElement. Got: ".concat(center));
    if (!(overlay instanceof HTMLElement)) throw new Error("NotificationCenter: \"overlay\" must be an HTMLElement. Got: ".concat(overlay));
    if (!(badge instanceof HTMLElement)) throw new Error("NotificationCenter: \"badge\" must be an HTMLElement. Got: ".concat(badge));
    if (!(button instanceof HTMLElement)) throw new Error("NotificationCenter: \"button\" must be an HTMLElement. Got: ".concat(button));
    var clearAllBtn = center === null || center === void 0 ? void 0 : center.querySelector('.clear-all');
    var list = (_center$querySelector = center === null || center === void 0 ? void 0 : center.querySelector('.list')) !== null && _center$querySelector !== void 0 ? _center$querySelector : null;
    if (!(list instanceof HTMLElement)) throw new Error("NotificationCenter: \".list\" inside center must be an HTMLElement. Got: ".concat(list));
    _classPrivateFieldSet(_center, this, center);
    _classPrivateFieldSet(_list, this, list);
    _classPrivateFieldSet(_badge, this, badge);
    _classPrivateFieldSet(_button, this, button);
    _classPrivateFieldSet(_overlay, this, overlay);
    _classPrivateFieldGet(_button, this).addEventListener('click', function () {
      return _this.toggle();
    });
    (_classPrivateFieldGet2 = _classPrivateFieldGet(_center, this).querySelector('.close')) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.addEventListener('click', function () {
      return _this.close();
    });
    if (clearAllBtn) clearAllBtn.addEventListener('click', function () {
      return _this.clear();
    });
    _classPrivateFieldGet(_overlay, this).addEventListener('click', function (e) {
      if (e.target === _classPrivateFieldGet(_overlay, _this)) _this.close();
    });
  }
  /**
   * Enable or disable automatic mark-as-read on close.
   * @param {boolean} value
   */
  return _createClass(TinyNotifyCenter, [{
    key: "setMarkAllAsReadOnClose",
    value: function setMarkAllAsReadOnClose(value) {
      if (typeof value !== 'boolean') throw new TypeError("Expected boolean for markAllAsReadOnClose, got ".concat(_typeof(value)));
      _classPrivateFieldSet(_markAllAsReadOnClose, this, value);
    }
    /**
     * Define how long the remove animation takes (in ms).
     * @param {number} ms
     */
  }, {
    key: "setRemoveDelay",
    value: function setRemoveDelay(ms) {
      if (typeof ms !== 'number') throw new Error("NotificationCenter: \"ms\" must be an number.");
      _classPrivateFieldSet(_removeDelay, this, ms);
    }
    /**
     * Get rendering mode ('text' or 'html') by index.
     * @param {number} index
     * @returns {'text' | 'html' | null}
     */
  }, {
    key: "getItemMode",
    value: function getItemMode(index) {
      var item = this.getItem(index);
      return item ? _classPrivateFieldGet(_modes, this).get(item) : null;
    }
    /**
     * Get a notify element by index.
     * @param {number} index
     * @returns {HTMLElement}
     */
  }, {
    key: "getItem",
    value: function getItem(index) {
      var element = _classPrivateFieldGet(_list, this).children.item(index);
      if (!(element instanceof HTMLElement)) throw new Error("NotificationCenter: \"item\" must be an HTMLElement. Got: ".concat(element));
      return element;
    }
    /**
     * Check if a notify exists at the given index.
     * @param {number} index
     * @returns {boolean}
     */
  }, {
    key: "hasItem",
    value: function hasItem(index) {
      return index >= 0 && index < _classPrivateFieldGet(_list, this).children.length;
    }
    /**
     * Mark a notification index as read.
     * @param {number|HTMLElement} index
     */
  }, {
    key: "markAsRead",
    value: function markAsRead(index) {
      var item = index instanceof HTMLElement ? index : this.getItem(index);
      if (item.classList.contains('unread')) {
        item.classList.remove('unread');
        _assertClassBrand(_TinyNotifyCenter_brand, this, _updateCount).call(this, _classPrivateFieldGet(_count, this) - 1);
      }
    }
    /**
     * Add a new notify to the center.
     *
     * @param {NotifyData} message - Notification content or a full object with title, avatar, and callback.
     * @param {'text'|'html'} [mode='text'] - How to treat the message content.
     */
  }, {
    key: "add",
    value: function add(message) {
      var _this2 = this;
      var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
      var item = document.createElement('div');
      item.className = 'item unread';
      var titleText = null;
      var messageText = null;
      var avatarUrl = null;
      var onClick = null;
      if (_typeof(message) === 'object' && message !== null) {
        titleText = message.title;
        messageText = message.message;
        avatarUrl = message.avatar;
        onClick = message.onClick;
      } else {
        messageText = message;
      }
      // Optional avatar
      if (avatarUrl) {
        var avatarElem = document.createElement('div');
        avatarElem.className = 'avatar';
        avatarElem.style.backgroundImage = "url(\"".concat(avatarUrl, "\")");
        item.appendChild(avatarElem);
      }
      // Content wrapper
      var contentWrapper = document.createElement('div');
      contentWrapper.className = 'content';
      // Optional title
      if (titleText) {
        var titleElem = document.createElement('div');
        titleElem.className = 'title';
        titleElem.textContent = titleText;
        contentWrapper.appendChild(titleElem);
      }
      // Message
      var messageElem = document.createElement('div');
      messageElem.className = 'message';
      if (mode === 'html') {
        messageElem.innerHTML = messageText;
      } else {
        messageElem.textContent = messageText;
      }
      contentWrapper.appendChild(messageElem);
      // Action by clicking (if provided)
      if (typeof onClick === 'function') {
        item.classList.add('clickable');
        item.addEventListener('click', function (e) {
          // Prevents the close button from clicking
          if (e.target instanceof HTMLElement && !e.target.closest('.notify-close')) {
            onClick(e);
          }
        });
      }
      // Close button
      var closeBtn = document.createElement('button');
      closeBtn.className = 'notify-close';
      closeBtn.setAttribute('type', 'button');
      closeBtn.innerHTML = '&times;';
      closeBtn.addEventListener('click', function (e) {
        e.stopPropagation(); // prevents propagation for the main onClick
        _assertClassBrand(_TinyNotifyCenter_brand, _this2, _removeItem).call(_this2, item);
      });
      item.append(contentWrapper, closeBtn);
      _classPrivateFieldGet(_list, this).prepend(item);
      _classPrivateFieldGet(_modes, this).set(item, mode);
      _assertClassBrand(_TinyNotifyCenter_brand, this, _updateCount).call(this, _classPrivateFieldGet(_count, this) + 1);
    }
    /**
     * Remove a notify by index.
     * @param {number} index
     */
  }, {
    key: "remove",
    value: function remove(index) {
      var item = this.getItem(index);
      _assertClassBrand(_TinyNotifyCenter_brand, this, _removeItem).call(this, item);
    }
    /**
     * Clear all notifications safely.
     */
  }, {
    key: "clear",
    value: function clear() {
      var needAgain = true;
      while (needAgain) {
        needAgain = false;
        var items = Array.from(_classPrivateFieldGet(_list, this).children);
        for (var _i = 0, _items = items; _i < _items.length; _i++) {
          var item = _items[_i];
          if (item instanceof HTMLElement && !item.classList.contains('removing')) {
            _assertClassBrand(_TinyNotifyCenter_brand, this, _removeItem).call(this, item);
            needAgain = true;
          }
        }
      }
    }
    /**
     * Open the notify center.
     */
  }, {
    key: "open",
    value: function open() {
      _classPrivateFieldGet(_overlay, this).classList.remove('hidden');
      _classPrivateFieldGet(_center, this).classList.add('open');
    }
    /**
     * Close the notify center.
     */
  }, {
    key: "close",
    value: function close() {
      _classPrivateFieldGet(_overlay, this).classList.add('hidden');
      _classPrivateFieldGet(_center, this).classList.remove('open');
      if (_classPrivateFieldGet(_markAllAsReadOnClose, this)) {
        var items = _classPrivateFieldGet(_list, this).querySelectorAll('.item.unread');
        var _iterator = _createForOfIteratorHelper(items),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var item = _step.value;
            if (item instanceof HTMLElement) this.markAsRead(item);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    /**
     * Toggle open/close state.
     */
  }, {
    key: "toggle",
    value: function toggle() {
      if (_classPrivateFieldGet(_center, this).classList.contains('open')) this.close();else this.open();
    }
    /**
     * Recalculate the number of notifications based on the actual DOM list.
     */
  }, {
    key: "recount",
    value: function recount() {
      var count = _classPrivateFieldGet(_list, this).querySelectorAll('.item.unread').length;
      _assertClassBrand(_TinyNotifyCenter_brand, this, _updateCount).call(this, count);
    }
    /**
     * Get current count.
     * @returns {number}
     */
  }, {
    key: "count",
    get: function get() {
      return _classPrivateFieldGet(_count, this);
    }
    /**
     * Destroys the notification center instance, removing all event listeners,
     * clearing notifications, and optionally removing DOM elements.
     *
     * Call this when the notification center is no longer needed to prevent memory leaks.
     *
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _classPrivateFieldGet3, _classPrivateFieldGet4, _classPrivateFieldGet5, _classPrivateFieldGet6, _classPrivateFieldGet7, _classPrivateFieldGet8, _classPrivateFieldGet9;
      // Remove event listeners
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_button, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.removeEventListener('click', this.toggle);
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_center, this)) === null || _classPrivateFieldGet4 === void 0 || (_classPrivateFieldGet4 = _classPrivateFieldGet4.querySelector('.close')) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.removeEventListener('click', this.close);
      (_classPrivateFieldGet5 = _classPrivateFieldGet(_center, this)) === null || _classPrivateFieldGet5 === void 0 || (_classPrivateFieldGet5 = _classPrivateFieldGet5.querySelector('.clear-all')) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.removeEventListener('click', this.clear);
      (_classPrivateFieldGet6 = _classPrivateFieldGet(_overlay, this)) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.removeEventListener('click', this.close);
      // Clear all notifications
      this.clear();
      (_classPrivateFieldGet7 = _classPrivateFieldGet(_center, this)) === null || _classPrivateFieldGet7 === void 0 || _classPrivateFieldGet7.remove();
      (_classPrivateFieldGet8 = _classPrivateFieldGet(_overlay, this)) === null || _classPrivateFieldGet8 === void 0 || _classPrivateFieldGet8.remove();
      (_classPrivateFieldGet9 = _classPrivateFieldGet(_button, this)) === null || _classPrivateFieldGet9 === void 0 || _classPrivateFieldGet9.remove();
      // Clean internal references
      // this.#center = null;
      // this.#list = null;
      // this.#badge = null;
      // this.#button = null;
      // this.#overlay = null;
      _classPrivateFieldSet(_count, this, 0);
      _classPrivateFieldSet(_modes, this, new WeakMap());
    }
  }], [{
    key: "getTemplate",
    value:
    /**
     * Returns the full HTML structure for the notification system as a string.
     *
     * This includes:
     * - A hidden `.notify-overlay` containing the central notification panel (`#notifCenter`),
     *   which has a header with a "Notifications" label, a "clear all" button, and a close button.
     * - A `.list` container for dynamically added notifications.
     * - A bell button (`.notify-bell`) to toggle the notification center, with an embedded badge.
     *
     * This template can be inserted into the DOM using `insertAdjacentHTML()` or parsed dynamically
     * into elements using JavaScript or jQuery, depending on the needs of the system.
     *
     * @returns {string} The complete HTML structure for the notification center.
     */
    function getTemplate() {
      return "\n<div class=\"notify-overlay hidden\">\n  <div class=\"notify-center\" id=\"notifCenter\">\n    <div class=\"header\">\n      <div>Notifications</div>\n      <div class=\"options\">\n        <button class=\"clear-all\" type=\"button\">\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            viewBox=\"0 0 24 24\"\n            width=\"24\"\n            height=\"24\"\n            fill=\"currentColor\"\n          >\n            <path\n              d=\"M21.6 2.4a1 1 0 0 0-1.4 0L13 9.6l-1.3-1.3a1 1 0 0 0-1.4 0L3 15.6a1 1 0 0 0 0 1.4l4 4a1 1 0 0 0 1.4 0l7.3-7.3a1 1 0 0 0 0-1.4l-1.3-1.3 7.2-7.2a1 1 0 0 0 0-1.4zM6 17l3.5-3.5 1.5 1.5L7.5 18.5 6 17z\"\n            />\n          </svg>\n        </button>\n        <button class=\"close\">\xD7</button>\n      </div>\n    </div>\n    <div class=\"list\"></div>\n  </div>\n</div>\n\n<button class=\"notify-bell\" aria-label=\"Open notifications\">\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"20\"\n    height=\"20\"\n    fill=\"currentColor\"\n    viewBox=\"0 0 24 24\"\n  >\n    <path\n      d=\"M12 2C10.3 2 9 3.3 9 5v1.1C6.7 7.2 5 9.4 5 12v5l-1 1v1h16v-1l-1-1v-5c0-2.6-1.7-4.8-4-5.9V5c0-1.7-1.3-3-3-3zm0 20c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2z\"\n    />\n  </svg>\n  <span class=\"badge\" id=\"notifBadge\">0</span>\n</button>\n    ";
    }
    /**
     * Inserts the full notification center template into the document body.
     *
     * The structure is injected directly into the DOM using
     * `insertAdjacentHTML`.
     *
     * The `where` parameter allows control over where inside the `document.body`
     * the HTML is inserted:
     * - `'afterbegin'` (default): Inserts right after the opening <body> tag.
     * - `'beforeend'`: Inserts right before the closing </body> tag.
     * - Any valid position accepted by `insertAdjacentHTML`.
     *
     * @param {'beforebegin'|'afterbegin'|'beforeend'|'afterend'} [where='afterbegin']
     * The position relative to `document.body` where the HTML should be inserted.
     */
  }, {
    key: "insertTemplate",
    value: function insertTemplate() {
      var where = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'afterbegin';
      document.body.insertAdjacentHTML(where, TinyNotifyCenter.getTemplate());
    }
  }]);
}();
function _removeItem(item) {
  var _this3 = this;
  _classPrivateFieldGet(_modes, this)["delete"](item);
  if (item instanceof HTMLElement) {
    item.classList.add('removing');
    setTimeout(function () {
      _this3.markAsRead(item);
      item.remove();
    }, _classPrivateFieldGet(_removeDelay, this));
  } else throw new Error('Invalid HTMLElement to clear.');
}
/**
 * Update notify count and badge.
 * @param {number} value
 */
function _updateCount(value) {
  _classPrivateFieldSet(_count, this, Math.max(0, value));
  _classPrivateFieldGet(_badge, this).setAttribute('data-value', String(_classPrivateFieldGet(_count, this)));
  _classPrivateFieldGet(_badge, this).textContent = _classPrivateFieldGet(_count, this) > _classPrivateFieldGet(_maxCount, this) ? "".concat(_classPrivateFieldGet(_maxCount, this), "+") : String(_classPrivateFieldGet(_count, this));
}
var _default = exports["default"] = TinyNotifyCenter;

},{}],196:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"dup":164}],197:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"_process":111,"dup":165}],198:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _TinyHtml = _interopRequireDefault(require("./TinyHtml.mjs"));
var TinyCollision = _interopRequireWildcard(require("../basics/collision.mjs"));
var _TinyEvents = _interopRequireDefault(require("./TinyEvents.mjs"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Represents the dimensions of a DOM element.
 *
 * @typedef {Object} NodeSizes
 * @property {number} height - The height of the element in pixels.
 * @property {number} width - The width of the element in pixels.
 */
/**
 * A callback function that receives node size change data and optionally returns a modified NodeSizes object.
 *
 * @callback NodeSizesEvent
 * @param {Element} elem - The DOM element whose size is being tracked.
 * @param {{ old: NodeSizes, now: NodeSizes }} sizes - The old and new size measurements of the element.
 * @param {{ old: number, now: number }} elemAmount - The number of matching elements before and after the update.
 * @returns {NodeSizes|undefined} A modified NodeSizes object to override the default measurement, or undefined to use the original.
 */
/**
 * A generic scroll-related event listener callback function.
 *
 * @callback ScrollListenersFunc
 * @param {any} payload - The data payload passed when the scroll event is triggered. The type may vary depending on the event.
 * @returns {void}
 */
/**
 * TinySmartScroller is a utility class designed to enhance and manage scroll behaviors within containers or the window.
 *
 * It enables advanced scroll monitoring, auto-scrolling to bottom, preserving scroll position during DOM changes,
 * and detecting visibility changes of elements. This is particularly useful for dynamic UIs like chat applications,
 * feed viewers, or live content containers.
 *
 * Features:
 * - Detects when the scroll reaches the top, bottom, or custom boundaries
 * - Supports automatic scrolling to the bottom unless the user scrolls away
 * - Observes DOM mutations and resizes, and adapts scroll position accordingly
 * - Emits scroll-related events such as 'onScrollBoundary', 'onAutoScroll', and 'onScrollPause'
 * - Includes customizable scroll correction filters for layout shift mitigation
 * - Handles media element load events (e.g. `<img>`, `<iframe>`, `<video>`) to prevent sudden scroll jumps
 *
 * This class is **not framework-dependent** and works with vanilla DOM elements and the window object.
 */
var _events = /*#__PURE__*/new WeakMap();
var _oldSizes = /*#__PURE__*/new WeakMap();
var _newSizes = /*#__PURE__*/new WeakMap();
var _newVisibles = /*#__PURE__*/new WeakMap();
var _oldVisibles = /*#__PURE__*/new WeakMap();
var _newVisiblesByTime = /*#__PURE__*/new WeakMap();
var _oldVisiblesByTime = /*#__PURE__*/new WeakMap();
var _resizeObserver = /*#__PURE__*/new WeakMap();
var _mutationObserver = /*#__PURE__*/new WeakMap();
var _loadTags = /*#__PURE__*/new WeakMap();
var _handler = /*#__PURE__*/new WeakMap();
var _isPastAtBottom = /*#__PURE__*/new WeakMap();
var _isPastAtTop = /*#__PURE__*/new WeakMap();
var _isPastAtCustomTop = /*#__PURE__*/new WeakMap();
var _isPastAtCustomBottom = /*#__PURE__*/new WeakMap();
var _isAtBottom = /*#__PURE__*/new WeakMap();
var _isAtTop = /*#__PURE__*/new WeakMap();
var _isAtCustomTop = /*#__PURE__*/new WeakMap();
var _isAtCustomBottom = /*#__PURE__*/new WeakMap();
var _querySelector = /*#__PURE__*/new WeakMap();
var _useWindow = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _scrollPaused = /*#__PURE__*/new WeakMap();
var _autoScrollBottom = /*#__PURE__*/new WeakMap();
var _observeMutations = /*#__PURE__*/new WeakMap();
var _preserveScrollOnLayoutShift = /*#__PURE__*/new WeakMap();
var _debounceTime = /*#__PURE__*/new WeakMap();
var _elemAmount = /*#__PURE__*/new WeakMap();
var _elemOldAmount = /*#__PURE__*/new WeakMap();
var _lastKnownScrollBottomOffset = /*#__PURE__*/new WeakMap();
var _extraScrollBoundary = /*#__PURE__*/new WeakMap();
var _attributeFilter = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _sizeFilter = /*#__PURE__*/new WeakMap();
var TinySmartScroller = /*#__PURE__*/function () {
  /**
   * Creates a new instance of TinySmartScroller, attaching scroll and resize observers to manage
   * automatic scroll behaviors, layout shift correction, and visibility tracking.
   *
   * @param {Element|Window} target - The scroll container to monitor. Can be an element or `window`.
   * @param {Object} [options={}] - Optional settings to configure scroll behavior.
   * @param {number} [options.extraScrollBoundary=0] - Extra margin in pixels to extend scroll boundary detection.
   * @param {boolean} [options.autoScrollBottom=true] - Whether to auto-scroll to bottom on layout updates.
   * @param {boolean} [options.observeMutations=true] - Enables MutationObserver to detect DOM changes.
   * @param {boolean} [options.preserveScrollOnLayoutShift=true] - Prevents scroll jumps when layout changes.
   * @param {number} [options.debounceTime=100] - Debounce time in milliseconds for scroll events.
   * @param {string|null} [options.querySelector=null] - Optional CSS selector to filter observed child nodes.
   * @param {string[]|Set<string>|null} [options.attributeFilter=['class', 'style', 'src', 'data-*', 'height', 'width']]
   *     - Which attributes to observe for changes.
   */
  function TinySmartScroller(target) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$extraScrollBound = _ref.extraScrollBoundary,
      extraScrollBoundary = _ref$extraScrollBound === void 0 ? 0 : _ref$extraScrollBound,
      _ref$autoScrollBottom = _ref.autoScrollBottom,
      autoScrollBottom = _ref$autoScrollBottom === void 0 ? true : _ref$autoScrollBottom,
      _ref$observeMutations = _ref.observeMutations,
      observeMutations = _ref$observeMutations === void 0 ? true : _ref$observeMutations,
      _ref$preserveScrollOn = _ref.preserveScrollOnLayoutShift,
      preserveScrollOnLayoutShift = _ref$preserveScrollOn === void 0 ? true : _ref$preserveScrollOn,
      _ref$debounceTime = _ref.debounceTime,
      debounceTime = _ref$debounceTime === void 0 ? 100 : _ref$debounceTime,
      _ref$querySelector = _ref.querySelector,
      querySelector = _ref$querySelector === void 0 ? null : _ref$querySelector,
      _ref$attributeFilter = _ref.attributeFilter,
      attributeFilter = _ref$attributeFilter === void 0 ? ['class', 'style', 'src', 'data-*', 'height', 'width'] : _ref$attributeFilter;
    _classCallCheck(this, TinySmartScroller);
    _classPrivateFieldInitSpec(this, _events, new _TinyEvents["default"]());
    ///////////////////////////////////////////////////
    /** @type {WeakMap<Element, NodeSizes>} */
    _classPrivateFieldInitSpec(this, _oldSizes, new WeakMap());
    /** @type {WeakMap<Element, NodeSizes>} */
    _classPrivateFieldInitSpec(this, _newSizes, new WeakMap());
    /** @type {WeakMap<Element, boolean>} */
    _classPrivateFieldInitSpec(this, _newVisibles, new WeakMap());
    /** @type {WeakMap<Element, boolean>} */
    _classPrivateFieldInitSpec(this, _oldVisibles, new WeakMap());
    /** @type {WeakMap<Element, boolean>} */
    _classPrivateFieldInitSpec(this, _newVisiblesByTime, new WeakMap());
    /** @type {WeakMap<Element, boolean>} */
    _classPrivateFieldInitSpec(this, _oldVisiblesByTime, new WeakMap());
    /** @type {ResizeObserver|null} */
    _classPrivateFieldInitSpec(this, _resizeObserver, null);
    /** @type {MutationObserver|null} */
    _classPrivateFieldInitSpec(this, _mutationObserver, null);
    /** @type {Set<string>} */
    _classPrivateFieldInitSpec(this, _loadTags, new Set(['IMG', 'IFRAME', 'VIDEO']));
    /** @type {null|EventListenerOrEventListenerObject} */
    _classPrivateFieldInitSpec(this, _handler, null);
    _classPrivateFieldInitSpec(this, _isPastAtBottom, false);
    _classPrivateFieldInitSpec(this, _isPastAtTop, false);
    _classPrivateFieldInitSpec(this, _isPastAtCustomTop, false);
    _classPrivateFieldInitSpec(this, _isPastAtCustomBottom, false);
    _classPrivateFieldInitSpec(this, _isAtBottom, false);
    _classPrivateFieldInitSpec(this, _isAtTop, false);
    _classPrivateFieldInitSpec(this, _isAtCustomTop, false);
    _classPrivateFieldInitSpec(this, _isAtCustomBottom, false);
    _classPrivateFieldInitSpec(this, _querySelector, '');
    _classPrivateFieldInitSpec(this, _useWindow, false);
    _classPrivateFieldInitSpec(this, _destroyed, false);
    _classPrivateFieldInitSpec(this, _scrollPaused, false);
    _classPrivateFieldInitSpec(this, _autoScrollBottom, false);
    _classPrivateFieldInitSpec(this, _observeMutations, false);
    _classPrivateFieldInitSpec(this, _preserveScrollOnLayoutShift, false);
    _classPrivateFieldInitSpec(this, _debounceTime, 0);
    _classPrivateFieldInitSpec(this, _elemAmount, 0);
    _classPrivateFieldInitSpec(this, _elemOldAmount, 0);
    _classPrivateFieldInitSpec(this, _lastKnownScrollBottomOffset, 0);
    _classPrivateFieldInitSpec(this, _extraScrollBoundary, 0);
    /** @type {Set<string>} */
    _classPrivateFieldInitSpec(this, _attributeFilter, void 0);
    /** @type {Element} */
    _classPrivateFieldInitSpec(this, _target, void 0);
    /** @type {Set<NodeSizesEvent>} */
    _classPrivateFieldInitSpec(this, _sizeFilter, new Set());
    // === target ===
    if (!(target instanceof Element || target === window)) throw new TypeError("TinySmartScroller: 'target' must be a DOM Element or 'window', but got ".concat(_typeof(target)));
    // === extraScrollBoundary ===
    if (typeof extraScrollBoundary !== 'number' || Number.isNaN(extraScrollBoundary)) throw new TypeError("TinySmartScroller: 'extraScrollBoundary' must be a valid number, received ".concat(extraScrollBoundary));
    // === autoScrollBottom ===
    if (typeof autoScrollBottom !== 'boolean') throw new TypeError("TinySmartScroller: 'autoScrollBottom' must be a boolean, received ".concat(_typeof(autoScrollBottom)));
    // === observeMutations ===
    if (typeof observeMutations !== 'boolean') throw new TypeError("TinySmartScroller: 'observeMutations' must be a boolean, received ".concat(_typeof(observeMutations)));
    // === preserveScrollOnLayoutShift ===
    if (typeof preserveScrollOnLayoutShift !== 'boolean') throw new TypeError("TinySmartScroller: 'preserveScrollOnLayoutShift' must be a boolean, received ".concat(_typeof(preserveScrollOnLayoutShift)));
    // === debounceTime ===
    if (typeof debounceTime !== 'number' || debounceTime < 0 || Number.isNaN(debounceTime)) throw new TypeError("TinySmartScroller: 'debounceTime' must be a non-negative number, received ".concat(debounceTime));
    // === querySelector ===
    if (querySelector !== null && typeof querySelector !== 'string') throw new TypeError("TinySmartScroller: 'querySelector' must be a string or null, received ".concat(_typeof(querySelector)));
    // === attributeFilter ===
    var isValidAttrList = attributeFilter === null || Array.isArray(attributeFilter) || attributeFilter instanceof Set;
    if (!isValidAttrList) throw new TypeError("TinySmartScroller: 'attributeFilter' must be an array, Set, or null. Got ".concat(_typeof(attributeFilter)));
    // Start values
    _classPrivateFieldSet(_target, this, target instanceof Window ? document.documentElement : target);
    _classPrivateFieldSet(_useWindow, this, target instanceof Window);
    _classPrivateFieldSet(_autoScrollBottom, this, autoScrollBottom);
    _classPrivateFieldSet(_observeMutations, this, observeMutations);
    _classPrivateFieldSet(_preserveScrollOnLayoutShift, this, preserveScrollOnLayoutShift);
    _classPrivateFieldSet(_debounceTime, this, debounceTime);
    _classPrivateFieldSet(_extraScrollBoundary, this, extraScrollBoundary);
    _classPrivateFieldSet(_querySelector, this, querySelector || '');
    _classPrivateFieldSet(_attributeFilter, this, new Set(attributeFilter || undefined));
    // Bind scroll
    /** @type {NodeJS.Timeout} */
    var timeout;
    _classPrivateFieldSet(_handler, this, function () {
      _this._scrollDataUpdater();
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        return _this._onScroll();
      }, _classPrivateFieldGet(_debounceTime, _this));
    });
    (_classPrivateFieldGet(_useWindow, this) ? window : _classPrivateFieldGet(_target, this)).addEventListener('scroll', _classPrivateFieldGet(_handler, this), {
      passive: true
    });
    // Mutations
    if (_classPrivateFieldGet(_observeMutations, this)) {
      this._observeMutations();
      this._observeResizes(_classPrivateFieldGet(_target, this).children);
    }
    this._scrollDataUpdater();
  }
  /**
   * Returns a size difference callback that only reacts when height changes, filtered by tag name.
   *
   * @param {string[]} filter - List of tag names to allow. If empty, all tags are accepted.
   * @returns {NodeSizesEvent} A function that compares previous and current height, returning height delta.
   */
  return _createClass(TinySmartScroller, [{
    key: "setThrowOnMaxListeners",
    value:
    /**
     * Enables or disables throwing an error when the maximum number of listeners is exceeded.
     *
     * @param {boolean} shouldThrow - If true, an error will be thrown when the max is exceeded.
     */
    function setThrowOnMaxListeners(shouldThrow) {
      return _classPrivateFieldGet(_events, this).setThrowOnMaxListeners(shouldThrow);
    }
    /**
     * Checks whether an error will be thrown when the max listener limit is exceeded.
     *
     * @returns {boolean} True if an error will be thrown, false if only a warning is shown.
     */
  }, {
    key: "getThrowOnMaxListeners",
    value: function getThrowOnMaxListeners() {
      return _classPrivateFieldGet(_events, this).getThrowOnMaxListeners();
    }
    /////////////////////////////////////////////////////////////
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {ScrollListenersFunc} handler - The callback function.
     */
  }, {
    key: "prependListener",
    value: function prependListener(event, handler) {
      return _classPrivateFieldGet(_events, this).prependListener(event, handler);
    }
    /**
     * Adds a one-time listener to the beginning of the listeners array for the specified event.
     *
     * @param {string} event - Event name.
     * @param {ScrollListenersFunc} handler - The callback function.
     * @returns {ScrollListenersFunc} - The wrapped handler used internally.
     */
  }, {
    key: "prependListenerOnce",
    value: function prependListenerOnce(event, handler) {
      return _classPrivateFieldGet(_events, this).prependListenerOnce(event, handler);
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {ScrollListenersFunc} handler - Callback function to be called when event fires.
     */
  }, {
    key: "appendListener",
    value: function appendListener(event, handler) {
      return _classPrivateFieldGet(_events, this).appendListener(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {ScrollListenersFunc} handler - The callback function to run on event.
     * @returns {ScrollListenersFunc} - The wrapped version of the handler.
     */
  }, {
    key: "appendListenerOnce",
    value: function appendListenerOnce(event, handler) {
      return _classPrivateFieldGet(_events, this).appendListenerOnce(event, handler);
    }
    /**
     * Adds a event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {ScrollListenersFunc} handler - Callback function to be called when event fires.
     */
  }, {
    key: "on",
    value: function on(event, handler) {
      return _classPrivateFieldGet(_events, this).on(event, handler);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {ScrollListenersFunc} handler - The callback function to run on event.
     * @returns {ScrollListenersFunc} - The wrapped version of the handler.
     */
  }, {
    key: "once",
    value: function once(event, handler) {
      return _classPrivateFieldGet(_events, this).once(event, handler);
    }
    ////////////////////////////////////////////////////////////////////
    /**
     * Removes a previously registered event listener.
     *
     * @param {string} event - The name of the event to remove the handler from.
     * @param {ScrollListenersFunc} handler - The specific callback function to remove.
     */
  }, {
    key: "off",
    value: function off(event, handler) {
      return _classPrivateFieldGet(_events, this).off(event, handler);
    }
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {string} event - The event type to remove (e.g. 'onScrollBoundary').
     */
  }, {
    key: "offAll",
    value: function offAll(event) {
      return _classPrivateFieldGet(_events, this).offAll(event);
    }
    /**
     * Removes all event listeners of all types from the element.
     */
  }, {
    key: "offAllTypes",
    value: function offAllTypes() {
      return _classPrivateFieldGet(_events, this).offAllTypes();
    }
    ////////////////////////////////////////////////////////////
    /**
     * Returns the number of listeners for a given event.
     *
     * @param {string} event - The name of the event.
     * @returns {number} Number of listeners for the event.
     */
  }, {
    key: "listenerCount",
    value: function listenerCount(event) {
      return _classPrivateFieldGet(_events, this).listenerCount(event);
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {ScrollListenersFunc[]} Array of listener functions.
     */
  }, {
    key: "listeners",
    value: function listeners(event) {
      return _classPrivateFieldGet(_events, this).listeners(event);
    }
    /**
     * Returns a copy of the array of listeners for the specified event.
     *
     * @param {string} event - The name of the event.
     * @returns {ScrollListenersFunc[]} Array of listener functions.
     */
  }, {
    key: "onceListeners",
    value: function onceListeners(event) {
      return _classPrivateFieldGet(_events, this).onceListeners(event);
    }
    /**
     * Returns a copy of the internal listeners array for the specified event,
     * including wrapper functions like those used by `.once()`.
     * @param {string | symbol} event - The event name.
     * @returns {ScrollListenersFunc[]} An array of raw listener functions.
     */
  }, {
    key: "allListeners",
    value: function allListeners(event) {
      return _classPrivateFieldGet(_events, this).allListeners(event);
    }
    /**
     * Returns an array of event names for which there are registered listeners.
     *
     * @returns {string[]} Array of registered event names.
     */
  }, {
    key: "eventNames",
    value: function eventNames() {
      return _classPrivateFieldGet(_events, this).eventNames();
    }
    //////////////////////////////////////////////////////
    /**
     * Emits an event, triggering all registered handlers for that event.
     *
     * @param {string} event - The event name to emit.
     * @param {...any} payload - Optional data to pass to each handler.
     * @returns {boolean} True if any listeners were called, false otherwise.
     */
  }, {
    key: "emit",
    value: function emit(event) {
      var _classPrivateFieldGet2;
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }
      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_events, this)).emit.apply(_classPrivateFieldGet2, [event].concat(payload));
    }
    /**
     * Sets the maximum number of listeners per event before a warning is shown.
     *
     * @param {number} n - The maximum number of listeners.
     */
  }, {
    key: "setMaxListeners",
    value: function setMaxListeners(n) {
      return _classPrivateFieldGet(_events, this).setMaxListeners(n);
    }
    /**
     * Gets the maximum number of listeners allowed per event.
     *
     * @returns {number} The maximum number of listeners.
     */
  }, {
    key: "getMaxListeners",
    value: function getMaxListeners() {
      return _classPrivateFieldGet(_events, this).getMaxListeners();
    }
  }, {
    key: "getSimpleOnHeight",
    value: function getSimpleOnHeight() {
      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (!Array.isArray(filter)) throw new TypeError('getSimpleOnHeight(filter): filter must be an array of tag names');
      return function (elem, sizes, amounts) {
        if (filter.length > 0 && !filter.includes(elem.tagName) || amounts.now !== amounts.old) return;
        var oldSize = sizes.old;
        var newSize = sizes.now;
        var height = newSize.height - oldSize.height;
        return {
          height: height,
          width: 0
        };
      };
    }
    /**
     * Adds a height difference callback to the size filter system.
     *
     * @param {string[]} filter - List of tag names to allow.
     * @returns {NodeSizesEvent} The added size difference callback.
     */
  }, {
    key: "addSimpleOnHeight",
    value: function addSimpleOnHeight(filter) {
      if (!Array.isArray(filter)) throw new TypeError('addSimpleOnHeight(filter): filter must be an array of tag names');
      var result = this.getSimpleOnHeight(filter);
      this.onSize(result);
      return result;
    }
    /**
     * Returns a list of all currently tracked load tags.
     *
     * @returns {string[]} Array of tag names.
     */
  }, {
    key: "getLoadTags",
    value: function getLoadTags() {
      return Array.from(_classPrivateFieldGet(_loadTags, this));
    }
    /**
     * Adds a new tag to the set of load tags.
     *
     * @param {string} tag - The tag name to add (e.g., 'IMG').
     */
  }, {
    key: "addLoadTag",
    value: function addLoadTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('addLoadTag(tag): tag must be a string');
      _classPrivateFieldGet(_loadTags, this).add(tag.toUpperCase());
    }
    /**
     * Removes a tag from the set of load tags.
     *
     * @param {string} tag - The tag name to remove.
     */
  }, {
    key: "removeLoadTag",
    value: function removeLoadTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('removeLoadTag(tag): tag must be a string');
      _classPrivateFieldGet(_loadTags, this)["delete"](tag.toUpperCase());
    }
    /**
     * Checks whether a tag is tracked as a load tag.
     *
     * @param {string} tag - The tag name to check.
     * @returns {boolean} True if the tag is being tracked.
     */
  }, {
    key: "hasLoadTag",
    value: function hasLoadTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('hasLoadTag(tag): tag must be a string');
      return _classPrivateFieldGet(_loadTags, this).has(tag.toUpperCase());
    }
    /**
     * Clears the set of load tags. If `addDefault` is true, it will reset to the default tags: 'IMG', 'IFRAME', and 'VIDEO'.
     *
     * @param {boolean} [addDefault=false] - Whether to restore the default tags after clearing.
     * @throws {TypeError} If `addDefault` is not a boolean.
     */
  }, {
    key: "resetLoadTags",
    value: function resetLoadTags() {
      var addDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (typeof addDefault !== 'boolean') throw new TypeError('resetLoadTags(addDefault): addDefault must be a boolean');
      _classPrivateFieldGet(_loadTags, this).clear();
      if (!addDefault) return;
      _classPrivateFieldGet(_loadTags, this).add('IMG');
      _classPrivateFieldGet(_loadTags, this).add('IFRAME');
      _classPrivateFieldGet(_loadTags, this).add('VIDEO');
    }
    /**
     * Returns a list of all currently tracked attribute filters.
     *
     * @returns {string[]} Array of attribute names.
     */
  }, {
    key: "getAttributeFilters",
    value: function getAttributeFilters() {
      return Array.from(_classPrivateFieldGet(_attributeFilter, this));
    }
    /**
     * Adds an attribute to the filter list.
     *
     * @param {string} attr - The attribute name to add.
     */
  }, {
    key: "addAttributeFilter",
    value: function addAttributeFilter(attr) {
      if (typeof attr !== 'string') throw new TypeError('addAttributeFilter(attr): attr must be a string');
      _classPrivateFieldGet(_attributeFilter, this).add(attr);
    }
    /**
     * Removes an attribute from the filter list.
     *
     * @param {string} attr - The attribute name to remove.
     */
  }, {
    key: "removeAttributeFilter",
    value: function removeAttributeFilter(attr) {
      if (typeof attr !== 'string') throw new TypeError('removeAttributeFilter(attr): attr must be a string');
      _classPrivateFieldGet(_attributeFilter, this)["delete"](attr);
    }
    /**
     * Checks whether a specific attribute is being filtered.
     *
     * @param {string} attr - The attribute name to check.
     * @returns {boolean} True if the attribute is being filtered.
     */
  }, {
    key: "hasAttributeFilter",
    value: function hasAttributeFilter(attr) {
      if (typeof attr !== 'string') throw new TypeError('hasAttributeFilter(attr): attr must be a string');
      return _classPrivateFieldGet(_attributeFilter, this).has(attr);
    }
    /**
     * Clears the set of observed attribute filters. If `addDefault` is true, it will reset to the default attributes:
     * 'class', 'style', 'src', 'data-*', 'height', and 'width'.
     *
     * @param {boolean} [addDefault=false] - Whether to restore the default attribute filters after clearing.
     * @throws {TypeError} If `addDefault` is not a boolean.
     */
  }, {
    key: "resetAttributeFilters",
    value: function resetAttributeFilters() {
      var _this2 = this;
      var addDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (typeof addDefault !== 'boolean') throw new TypeError('resetAttributeFilters(addDefault): addDefault must be a boolean');
      _classPrivateFieldGet(_attributeFilter, this).clear();
      if (!addDefault) return;
      ['class', 'style', 'src', 'data-*', 'height', 'width'].forEach(function (attr) {
        return _classPrivateFieldGet(_attributeFilter, _this2).add(attr);
      });
    }
    /**
     * Registers a custom node size change handler to the internal size filter set.
     *
     * @param {NodeSizesEvent} handler - Function that compares old and new sizes.
     */
  }, {
    key: "onSize",
    value: function onSize(handler) {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      if (typeof handler !== 'function') throw new TypeError('onSize(handler): handler must be a function');
      _classPrivateFieldGet(_sizeFilter, this).add(handler);
    }
    /**
     * Unregisters a previously registered size handler from the internal filter set.
     *
     * @param {NodeSizesEvent} handler - The handler function to remove.
     */
  }, {
    key: "offSize",
    value: function offSize(handler) {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      if (typeof handler !== 'function') throw new TypeError('offSize(handler): handler must be a function');
      _classPrivateFieldGet(_sizeFilter, this)["delete"](handler);
    }
    /**
     * Checks which elements inside the target are currently visible and updates internal maps.
     *
     * @returns {Map<Element, { oldIsVisible: boolean; isVisible: boolean }>} Visibility comparison results.
     */
  }, {
    key: "_scrollDataUpdater",
    value: function _scrollDataUpdater() {
      var _this3 = this;
      var results = new Map();
      _classPrivateFieldGet(_target, this).querySelectorAll(_classPrivateFieldGet(_querySelector, this) || '*').forEach(function (target) {
        var _classPrivateFieldGet3;
        var oldIsVisible = (_classPrivateFieldGet3 = _classPrivateFieldGet(_newVisibles, _this3).get(target)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : false;
        _classPrivateFieldGet(_oldVisibles, _this3).set(target, oldIsVisible);
        var isVisible = _TinyHtml["default"].isInContainer(_classPrivateFieldGet(_target, _this3), target);
        _classPrivateFieldGet(_newVisibles, _this3).set(target, isVisible);
        results.set(target, {
          oldIsVisible: oldIsVisible,
          isVisible: isVisible
        });
      });
      return results;
    }
    /**
     * Emits a scroll-related event to all registered listeners.
     *
     * @param {string} event - Event name.
     * @param {*} [payload] - Optional event data payload.
     * @deprecated - Use emit() instead.
     */
  }, {
    key: "_emit",
    value: function _emit(event, payload) {
      this.emit(event, payload);
    }
    /**
     * Handles scroll events, calculates position-related statuses, and emits appropriate events.
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      var _classPrivateFieldGet4, _classPrivateFieldGet5, _classPrivateFieldGet6, _classPrivateFieldGet7;
      if (_classPrivateFieldGet(_destroyed, this)) return;
      // Get values
      var scrollCache = this._scrollDataUpdater();
      var el = _classPrivateFieldGet(_target, this);
      var scrollTop = el.scrollTop;
      var scrollHeight = el.scrollHeight;
      var clientHeight = el.clientHeight;
      // Prepare sroll values
      var scrollResult = {
        scrollTop: scrollTop,
        scrollHeight: scrollHeight,
        clientHeight: clientHeight
      };
      var atResult = null;
      var atCustomResult = null;
      var atTop = scrollTop === 0;
      var atBottom = scrollTop + clientHeight >= scrollHeight - 1;
      var atCustomTop = scrollTop <= 0 + _classPrivateFieldGet(_extraScrollBoundary, this);
      var atCustomBottom = scrollTop + clientHeight >= scrollHeight - 1 - _classPrivateFieldGet(_extraScrollBoundary, this);
      // Scroll results
      if (atTop && atBottom) atResult = 'all';else if (atTop) atResult = 'top';else if (atBottom) atResult = 'bottom';
      if (atCustomTop && atCustomBottom) atCustomResult = 'all';else if (atCustomTop) atCustomResult = 'top';else if (atCustomBottom) atCustomResult = 'bottom';
      _classPrivateFieldSet(_isPastAtTop, this, (_classPrivateFieldGet4 = _classPrivateFieldGet(_isAtTop, this)) !== null && _classPrivateFieldGet4 !== void 0 ? _classPrivateFieldGet4 : false);
      _classPrivateFieldSet(_isPastAtBottom, this, (_classPrivateFieldGet5 = _classPrivateFieldGet(_isAtBottom, this)) !== null && _classPrivateFieldGet5 !== void 0 ? _classPrivateFieldGet5 : false);
      _classPrivateFieldSet(_isPastAtCustomTop, this, (_classPrivateFieldGet6 = _classPrivateFieldGet(_isAtCustomTop, this)) !== null && _classPrivateFieldGet6 !== void 0 ? _classPrivateFieldGet6 : false);
      _classPrivateFieldSet(_isPastAtCustomBottom, this, (_classPrivateFieldGet7 = _classPrivateFieldGet(_isAtCustomBottom, this)) !== null && _classPrivateFieldGet7 !== void 0 ? _classPrivateFieldGet7 : false);
      _classPrivateFieldSet(_isAtTop, this, atTop);
      _classPrivateFieldSet(_isAtBottom, this, atBottom);
      _classPrivateFieldSet(_isAtCustomTop, this, atCustomTop);
      _classPrivateFieldSet(_isAtCustomBottom, this, atCustomBottom);
      _classPrivateFieldSet(_scrollPaused, this, !(_classPrivateFieldGet(_autoScrollBottom, this) && _classPrivateFieldGet(_isAtBottom, this)));
      _classPrivateFieldSet(_lastKnownScrollBottomOffset, this, scrollHeight - scrollTop - clientHeight);
      // Send results
      this.emit('onScrollBoundary', _objectSpread(_objectSpread({
        status: atResult
      }, scrollResult), {}, {
        scrollCache: scrollCache
      }));
      this.emit('onExtraScrollBoundary', _objectSpread(_objectSpread({
        status: atCustomResult
      }, scrollResult), {}, {
        scrollCache: scrollCache
      }));
      if (!_classPrivateFieldGet(_scrollPaused, this)) {
        this.emit('onAutoScroll', _objectSpread(_objectSpread({}, scrollResult), {}, {
          scrollCache: scrollCache
        }));
      } else {
        this.emit('onScrollPause', _objectSpread(_objectSpread({}, scrollResult), {}, {
          scrollCache: scrollCache
        }));
      }
    }
    /**
     * Attempts to correct the scroll position when layout shifts happen, preserving the user position if needed.
     *
     * @param {Element[]} [targets=[]] - List of elements involved in the size change.
     */
  }, {
    key: "_fixScroll",
    value: function _fixScroll() {
      var _this4 = this;
      var targets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (_classPrivateFieldGet(_destroyed, this)) return;
      // === Validation ===
      if (!Array.isArray(targets)) throw new TypeError('_fixScroll: targets must be an array of Elements');
      // Get Scroll data
      var prevScrollHeight = _classPrivateFieldGet(_target, this).scrollHeight;
      var prevScrollTop = _classPrivateFieldGet(_target, this).scrollTop;
      var prevBottomOffset = _classPrivateFieldGet(_target, this).scrollHeight - _classPrivateFieldGet(_target, this).scrollTop - _classPrivateFieldGet(_target, this).clientHeight;
      // Get new size
      var newScrollHeight = _classPrivateFieldGet(_target, this).scrollHeight;
      var heightDelta = newScrollHeight - prevScrollHeight;
      /** @type {() => NodeSizes} */
      var calculateScrollSize = function calculateScrollSize() {
        // Run size getter
        var scrollSize = {
          height: 0,
          width: 0
        };
        var _iterator = _createForOfIteratorHelper(targets),
          _step;
        try {
          var _loop = function _loop() {
            var target = _step.value;
            var tgOs = _classPrivateFieldGet(_oldSizes, _this4).get(target) || {
              height: 0,
              width: 0
            };
            var tgNs = _classPrivateFieldGet(_newSizes, _this4).get(target) || {
              height: 0,
              width: 0
            };
            _classPrivateFieldGet(_sizeFilter, _this4).forEach(function (fn) {
              /** @type {NodeSizes| undefined} */
              var sizes = fn(target, {
                old: tgOs,
                now: tgNs
              }, {
                old: _classPrivateFieldGet(_elemOldAmount, _this4),
                now: _classPrivateFieldGet(_elemAmount, _this4)
              });
              // Fix size
              if (_classPrivateFieldGet(_newVisibles, _this4).get(target) || _classPrivateFieldGet(_newVisiblesByTime, _this4).get(target)) {
                if (typeof sizes !== 'undefined' && _typeof(sizes) !== 'object') throw new Error('_fixScroll: size filter must return an object or undefined');
                if (typeof sizes === 'undefined') return;
                scrollSize.height = sizes.height;
                scrollSize.width = sizes.width;
              }
            });
          };
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
          }
          // Checker
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (typeof scrollSize.height !== 'number' && scrollSize.height < 0) throw new Error('_fixScroll: invalid scrollSize.height value');
        if (typeof scrollSize.width !== 'number' && scrollSize.width < 0) throw new Error('_fixScroll: invalid scrollSize.width value');
        if (scrollSize.height !== 0 || scrollSize.width !== 0) {
          var _iterator2 = _createForOfIteratorHelper(targets),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _classPrivateFieldGet8, _classPrivateFieldGet9;
              var target = _step2.value;
              _classPrivateFieldGet(_newVisiblesByTime, _this4).set(target, (_classPrivateFieldGet8 = _classPrivateFieldGet(_newVisibles, _this4).get(target)) !== null && _classPrivateFieldGet8 !== void 0 ? _classPrivateFieldGet8 : false);
              _classPrivateFieldGet(_oldVisiblesByTime, _this4).set(target, (_classPrivateFieldGet9 = _classPrivateFieldGet(_oldVisibles, _this4).get(target)) !== null && _classPrivateFieldGet9 !== void 0 ? _classPrivateFieldGet9 : false);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        return scrollSize;
      };
      // Fix scroll size
      if (_classPrivateFieldGet(_elemOldAmount, this) > 0 && _TinyHtml["default"].hasScroll(_classPrivateFieldGet(_target, this)).v && _classPrivateFieldGet(_autoScrollBottom, this) && _classPrivateFieldGet(_preserveScrollOnLayoutShift, this) && !_classPrivateFieldGet(_isAtBottom, this) && !_classPrivateFieldGet(_isAtTop, this)) {
        var scrollSize = calculateScrollSize();
        // Complete
        _classPrivateFieldGet(_target, this).scrollTop = prevScrollTop + heightDelta + scrollSize.height;
        if (scrollSize.width > 0) _classPrivateFieldGet(_target, this).scrollLeft = _classPrivateFieldGet(_target, this).scrollLeft + scrollSize.width;
      }
      // Normal stuff
      else if (!_classPrivateFieldGet(_scrollPaused, this) && _classPrivateFieldGet(_autoScrollBottom, this)) {
        calculateScrollSize();
        this.scrollToBottom();
      } else if (!_classPrivateFieldGet(_autoScrollBottom, this) && !_classPrivateFieldGet(_isAtBottom, this)) {
        calculateScrollSize();
        _classPrivateFieldGet(_target, this).scrollTop = _classPrivateFieldGet(_target, this).scrollHeight - _classPrivateFieldGet(_target, this).clientHeight - prevBottomOffset;
      }
    }
    /**
     * Sets up a MutationObserver to watch for DOM changes and react accordingly to maintain scroll consistency.
     */
  }, {
    key: "_observeMutations",
    value: function _observeMutations() {
      var _this5 = this;
      _classPrivateFieldSet(_mutationObserver, this, new MutationObserver(function (mutations) {
        if (_classPrivateFieldGet(_destroyed, _this5)) return;
        _this5._scrollDataUpdater();
        _classPrivateFieldSet(_elemOldAmount, _this5, _classPrivateFieldGet(_elemAmount, _this5));
        _classPrivateFieldSet(_elemAmount, _this5, _classPrivateFieldGet(_target, _this5).childElementCount);
        mutations.forEach(function (mutation) {
          mutation.addedNodes.forEach(function (node) {
            if (!(node instanceof Element) || node.nodeType !== 1) return;
            _this5._observeResizes([node]);
            _this5._listenLoadEvents(node);
            if (_classPrivateFieldGet(_querySelector, _this5)) {
              var children = node.querySelectorAll(_classPrivateFieldGet(_querySelector, _this5));
              _this5._observeResizes(children);
              _this5._listenLoadEvents(children);
            }
          });
        });
        _this5._fixScroll();
      }));
      // Install observer
      _classPrivateFieldGet(_mutationObserver, this).observe(_classPrivateFieldGet(_target, this), {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: _classPrivateFieldGet(_attributeFilter, this).size > 0 ? Array.from(_classPrivateFieldGet(_attributeFilter, this)) : undefined
      });
    }
    /**
     * Adds a ResizeObserver to monitor elements' size changes and trigger layout adjustments.
     *
     * @param {NodeListOf<Element>|Element[]|HTMLCollection} elements - Elements to observe.
     */
  }, {
    key: "_observeResizes",
    value: function _observeResizes(elements) {
      var _this6 = this;
      // Add resize observer
      if (!_classPrivateFieldGet(_resizeObserver, this)) {
        _classPrivateFieldSet(_resizeObserver, this, new ResizeObserver(function (entries) {
          if (_classPrivateFieldGet(_destroyed, _this6)) return;
          _this6._scrollDataUpdater();
          /** @type {Element[]} */
          var targets = [];
          var _iterator3 = _createForOfIteratorHelper(entries),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var entry = _step3.value;
              // Target
              var target = entry.target;
              // Update old size
              var oldSize = _classPrivateFieldGet(_newSizes, _this6).get(target);
              if (oldSize) _classPrivateFieldGet(_oldSizes, _this6).set(target, oldSize);
              // Set new size
              var _entry$contentRect = entry.contentRect,
                width = _entry$contentRect.width,
                height = _entry$contentRect.height;
              _classPrivateFieldGet(_newSizes, _this6).set(target, {
                width: width,
                height: height
              });
              targets.push(target);
            }
            // Animation frame
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          _this6._fixScroll(targets);
        }));
      }
      // Execute observer
      Array.from(elements).forEach(function (el) {
        if (!_classPrivateFieldGet(_resizeObserver, _this6)) throw new Error('_observeResizes: ResizeObserver instance is not initialized');
        _classPrivateFieldGet(_resizeObserver, _this6).observe(el);
      });
    }
    /**
     * Listens for media/content load events (e.g., images, iframes, videos) to trigger scroll updates.
     *
     * @param {NodeListOf<Element>|Element} elements - Target element(s) to listen on.
     */
  }, {
    key: "_listenLoadEvents",
    value: function _listenLoadEvents(elements) {
      var _this7 = this;
      if (_classPrivateFieldGet(_destroyed, this)) return;
      var list = elements instanceof NodeList ? Array.from(elements) : [elements];
      list.forEach(function (el) {
        if (_classPrivateFieldGet(_loadTags, _this7).has(el.tagName)) {
          // @ts-ignore
          if (!el.complete) {
            el.addEventListener('load', function () {
              _this7._scrollDataUpdater();
              if (!_classPrivateFieldGet(_scrollPaused, _this7) && _classPrivateFieldGet(_autoScrollBottom, _this7)) {
                _this7.scrollToBottom();
              }
            });
          }
        }
      });
    }
    /**
     * Returns the internal scroll container element being monitored.
     *
     * @returns {Element} The DOM element used as the scroll container target.
     */
  }, {
    key: "target",
    get: function get() {
      return _classPrivateFieldGet(_target, this);
    }
    /**
     * Returns the previous size of a given element, or undefined if not tracked.
     *
     * @param {Element} el - The DOM element to query.
     * @returns {NodeSizes|null} The old size, or undefined.
     */
  }, {
    key: "getOldSize",
    value: function getOldSize(el) {
      var _classPrivateFieldGet0;
      return (_classPrivateFieldGet0 = _classPrivateFieldGet(_oldSizes, this).get(el)) !== null && _classPrivateFieldGet0 !== void 0 ? _classPrivateFieldGet0 : null;
    }
    /**
     * Returns the current size of a given element, or undefined if not tracked.
     *
     * @param {Element} el - The DOM element to query.
     * @returns {NodeSizes|null} The new size, or undefined.
     */
  }, {
    key: "getNewSize",
    value: function getNewSize(el) {
      var _classPrivateFieldGet1;
      return (_classPrivateFieldGet1 = _classPrivateFieldGet(_newSizes, this).get(el)) !== null && _classPrivateFieldGet1 !== void 0 ? _classPrivateFieldGet1 : null;
    }
    /**
     * Returns whether the given element was visible in the last scroll update.
     *
     * @param {Element} el - The DOM element to check.
     * @returns {boolean} True if visible, false if not, or undefined if not tracked.
     */
  }, {
    key: "wasVisible",
    value: function wasVisible(el) {
      var _classPrivateFieldGet10;
      return (_classPrivateFieldGet10 = _classPrivateFieldGet(_oldVisibles, this).get(el)) !== null && _classPrivateFieldGet10 !== void 0 ? _classPrivateFieldGet10 : false;
    }
    /**
     * Returns whether the given element is currently visible.
     *
     * @param {Element} el - The DOM element to check.
     * @returns {boolean} True if visible, false if not, or undefined if not tracked.
     */
  }, {
    key: "isVisible",
    value: function isVisible(el) {
      var _classPrivateFieldGet11;
      return (_classPrivateFieldGet11 = _classPrivateFieldGet(_newVisibles, this).get(el)) !== null && _classPrivateFieldGet11 !== void 0 ? _classPrivateFieldGet11 : false;
    }
    /**
     * Returns whether the element was visible in the last time-based visibility check.
     *
     * @param {Element} el - The DOM element to check.
     * @returns {boolean} Visibility state from the previous timed check.
     */
  }, {
    key: "wasTimedVisible",
    value: function wasTimedVisible(el) {
      var _classPrivateFieldGet12;
      return (_classPrivateFieldGet12 = _classPrivateFieldGet(_oldVisiblesByTime, this).get(el)) !== null && _classPrivateFieldGet12 !== void 0 ? _classPrivateFieldGet12 : false;
    }
    /**
     * Returns whether the element is currently visible in the time-based check.
     *
     * @param {Element} el - The DOM element to check.
     * @returns {boolean} Visibility state from the current timed check.
     */
  }, {
    key: "isTimedVisible",
    value: function isTimedVisible(el) {
      var _classPrivateFieldGet13;
      return (_classPrivateFieldGet13 = _classPrivateFieldGet(_newVisiblesByTime, this).get(el)) !== null && _classPrivateFieldGet13 !== void 0 ? _classPrivateFieldGet13 : false;
    }
    /**
     * Sets the extra scroll boundary margin used when determining if the user is at a "custom" bottom or top.
     *
     * @param {number} value - Pixels of additional margin to use.
     */
  }, {
    key: "setExtraScrollBoundary",
    value: function setExtraScrollBoundary(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) throw new TypeError('setExtraScrollBoundary(value): value must be a valid number');
      _classPrivateFieldSet(_extraScrollBoundary, this, value);
    }
    /**
     * Returns the current extra scroll boundary setting.
     *
     * @returns {number}
     */
  }, {
    key: "getExtraScrollBoundary",
    value: function getExtraScrollBoundary() {
      return _classPrivateFieldGet(_extraScrollBoundary, this);
    }
    /**
     * Returns the last known distance (in pixels) from the bottom of the scroll container.
     *
     * @returns {number}
     */
  }, {
    key: "getLastKnownScrollBottomOffset",
    value: function getLastKnownScrollBottomOffset() {
      return _classPrivateFieldGet(_lastKnownScrollBottomOffset, this);
    }
    /**
     * Forces the scroll position to move to the very bottom of the target.
     */
  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      _classPrivateFieldGet(_target, this).scrollTop = _classPrivateFieldGet(_target, this).scrollHeight;
    }
    /**
     * Forces the scroll position to move to the very top of the target.
     */
  }, {
    key: "scrollToTop",
    value: function scrollToTop() {
      _classPrivateFieldGet(_target, this).scrollTop = 0;
    }
    /**
     * Checks if the user is within the defined extra scroll boundary from the bottom.
     *
     * @returns {boolean}
     */
  }, {
    key: "isAtCustomBottom",
    value: function isAtCustomBottom() {
      return _classPrivateFieldGet(_isAtCustomBottom, this);
    }
    /**
     * Checks if the user is within the defined extra scroll boundary from the top.
     *
     * @returns {boolean}
     */
  }, {
    key: "isAtCustomTop",
    value: function isAtCustomTop() {
      return _classPrivateFieldGet(_isAtCustomTop, this);
    }
    /**
     * Returns true if the user is currently scrolled to the bottom of the element.
     *
     * @returns {boolean}
     */
  }, {
    key: "isAtBottom",
    value: function isAtBottom() {
      return _classPrivateFieldGet(_isAtBottom, this);
    }
    /**
     * Returns true if the user is currently scrolled to the top of the element.
     *
     * @returns {boolean}
     */
  }, {
    key: "isAtTop",
    value: function isAtTop() {
      return _classPrivateFieldGet(_isAtTop, this);
    }
    /**
     * Returns true if the user has already passed beyond the bottom boundary at some point.
     *
     * @returns {boolean}
     */
  }, {
    key: "isPastAtBottom",
    value: function isPastAtBottom() {
      return _classPrivateFieldGet(_isPastAtBottom, this);
    }
    /**
     * Returns true if the user has already passed beyond the top boundary at some point.
     *
     * @returns {boolean}
     */
  }, {
    key: "isPastAtTop",
    value: function isPastAtTop() {
      return _classPrivateFieldGet(_isPastAtTop, this);
    }
    /**
     * Returns true if the user has passed beyond the defined extra scroll boundary from the top at some point.
     *
     * @returns {boolean}
     */
  }, {
    key: "isPastAtCustomTop",
    value: function isPastAtCustomTop() {
      return _classPrivateFieldGet(_isPastAtCustomTop, this);
    }
    /**
     * Returns true if the user has passed beyond the defined extra scroll boundary from the bottom at some point.
     *
     * @returns {boolean}
     */
  }, {
    key: "isPastAtCustomBottom",
    value: function isPastAtCustomBottom() {
      return _classPrivateFieldGet(_isPastAtCustomBottom, this);
    }
    /**
     * Checks if the user is within the defined extra scroll boundary from the bottom.
     *
     * @returns {boolean}
     * @deprecated - Use isAtCustomBottom instead.
     */
  }, {
    key: "isUserAtCustomBottom",
    value: function isUserAtCustomBottom() {
      return _classPrivateFieldGet(_isAtCustomBottom, this);
    }
    /**
     * Checks if the user is within the defined extra scroll boundary from the top.
     *
     * @returns {boolean}
     * @deprecated - Use isAtCustomTop instead.
     */
  }, {
    key: "isUserAtCustomTop",
    value: function isUserAtCustomTop() {
      return _classPrivateFieldGet(_isAtCustomTop, this);
    }
    /**
     * Returns true if the user is currently scrolled to the bottom of the element.
     *
     * @returns {boolean}
     * @deprecated - Use isAtBottom instead.
     */
  }, {
    key: "isUserAtBottom",
    value: function isUserAtBottom() {
      return _classPrivateFieldGet(_isAtBottom, this);
    }
    /**
     * Returns true if the user is currently scrolled to the top of the element.
     *
     * @returns {boolean}
     * @deprecated - Use isAtTop instead.
     */
  }, {
    key: "isUserAtTop",
    value: function isUserAtTop() {
      return _classPrivateFieldGet(_isAtTop, this);
    }
    /**
     * Returns true if automatic scrolling is currently paused.
     *
     * @returns {boolean}
     */
  }, {
    key: "isScrollPaused",
    value: function isScrollPaused() {
      return _classPrivateFieldGet(_scrollPaused, this);
    }
    /**
     * Returns whether the target is the window object.
     *
     * @returns {boolean} True if the scroll target is window, false otherwise.
     */
  }, {
    key: "isWindow",
    value: function isWindow() {
      return _classPrivateFieldGet(_useWindow, this);
    }
    /**
     * Returns whether the instance has been destroyed.
     *
     * @returns {boolean} True if the instance is destroyed, false otherwise.
     */
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return _classPrivateFieldGet(_destroyed, this);
    }
    /**
     * Returns whether auto-scroll-to-bottom is enabled.
     *
     * @returns {boolean} True if auto-scroll is active, false otherwise.
     */
  }, {
    key: "getAutoScrollBottom",
    value: function getAutoScrollBottom() {
      return _classPrivateFieldGet(_autoScrollBottom, this);
    }
    /**
     * Returns whether MutationObserver is enabled.
     *
     * @returns {boolean} True if mutation observation is active, false otherwise.
     */
  }, {
    key: "getObserveMutations",
    value: function getObserveMutations() {
      return _classPrivateFieldGet(_observeMutations, this);
    }
    /**
     * Returns whether layout shift protection is enabled.
     *
     * @returns {boolean} True if scroll preservation is active, false otherwise.
     */
  }, {
    key: "getPreserveScrollOnLayoutShift",
    value: function getPreserveScrollOnLayoutShift() {
      return _classPrivateFieldGet(_preserveScrollOnLayoutShift, this);
    }
    /**
     * Returns the debounce delay in milliseconds used for scroll events.
     *
     * @returns {number} Debounce delay time.
     */
  }, {
    key: "getDebounceTime",
    value: function getDebounceTime() {
      return _classPrivateFieldGet(_debounceTime, this);
    }
    /**
     * Returns the current number of matching elements observed inside the scroll target.
     *
     * @returns {number} Current count of matching elements.
     */
  }, {
    key: "getElemAmount",
    value: function getElemAmount() {
      return _classPrivateFieldGet(_elemAmount, this);
    }
    /**
     * Returns the previous known count of matching elements from the last update.
     *
     * @returns {number} Previous count of matching elements.
     */
  }, {
    key: "getPrevElemAmount",
    value: function getPrevElemAmount() {
      return _classPrivateFieldGet(_elemOldAmount, this);
    }
    /**
     * Returns the query selector string used to filter observed elements.
     *
     * @returns {string} The CSS selector string, or an empty string if none was provided.
     */
  }, {
    key: "getQuerySelector",
    value: function getQuerySelector() {
      return _classPrivateFieldGet(_querySelector, this);
    }
    /**
     * Disconnects all listeners, observers, and clears memory structures.
     * Once destroyed, this instance should no longer be used.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      _classPrivateFieldSet(_destroyed, this, true);
      // Disconnects MutationObserver
      if (_classPrivateFieldGet(_mutationObserver, this)) {
        _classPrivateFieldGet(_mutationObserver, this).disconnect();
        _classPrivateFieldSet(_mutationObserver, this, null);
      }
      // Disconnect ResizeObserver
      if (_classPrivateFieldGet(_resizeObserver, this)) {
        _classPrivateFieldGet(_resizeObserver, this).disconnect();
        _classPrivateFieldSet(_resizeObserver, this, null);
      }
      // Removes scroll listener
      var target = _classPrivateFieldGet(_useWindow, this) ? window : _classPrivateFieldGet(_target, this);
      if (_classPrivateFieldGet(_handler, this)) target.removeEventListener('scroll', _classPrivateFieldGet(_handler, this));
      // Clean the WeakMaps
      _classPrivateFieldSet(_oldSizes, this, new WeakMap());
      _classPrivateFieldSet(_newSizes, this, new WeakMap());
      _classPrivateFieldSet(_newVisibles, this, new WeakMap());
      _classPrivateFieldSet(_oldVisibles, this, new WeakMap());
      _classPrivateFieldSet(_newVisiblesByTime, this, new WeakMap());
      _classPrivateFieldSet(_oldVisiblesByTime, this, new WeakMap());
      // Cleans listeners and filters
      _classPrivateFieldGet(_events, this).offAllTypes();
      _classPrivateFieldGet(_sizeFilter, this).clear();
      _classPrivateFieldGet(_loadTags, this).clear();
    }
  }]);
}();
_defineProperty(TinySmartScroller, "Utils", _objectSpread(_objectSpread({}, TinyCollision), {}, {
  TinyHtml: _TinyHtml["default"]
}));
var _default = exports["default"] = TinySmartScroller;

},{"../basics/collision.mjs":171,"./TinyEvents.mjs":189,"./TinyHtml.mjs":190}],199:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _el = /*#__PURE__*/new WeakMap();
var _openTag = /*#__PURE__*/new WeakMap();
var _closeTag = /*#__PURE__*/new WeakMap();
/**
 * A full-featured text range editor for `<input>` and `<textarea>` elements,
 * including advanced utilities for BBCode or similar tag-based markup editing.
 */
var TinyTextRangeEditor = /*#__PURE__*/function () {
  /**
   * @param {HTMLInputElement | HTMLTextAreaElement} elem - The target editable input or textarea element.
   * @param {Object} [settings={}] - Optional tag symbol customization.
   * @param {string} [settings.openTag='['] - The character or symbol used to start a tag (e.g., `'['`).
   * @param {string} [settings.closeTag=']'] - The character or symbol used to end a tag (e.g., `']'`).
   */
  function TinyTextRangeEditor(elem) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$openTag = _ref.openTag,
      openTag = _ref$openTag === void 0 ? '[' : _ref$openTag,
      _ref$closeTag = _ref.closeTag,
      closeTag = _ref$closeTag === void 0 ? ']' : _ref$closeTag;
    _classCallCheck(this, TinyTextRangeEditor);
    /** @type {HTMLInputElement | HTMLTextAreaElement} */
    _classPrivateFieldInitSpec(this, _el, void 0);
    /** @type {string} */
    _classPrivateFieldInitSpec(this, _openTag, void 0);
    /** @type {string} */
    _classPrivateFieldInitSpec(this, _closeTag, void 0);
    if (!(elem instanceof HTMLInputElement || elem instanceof HTMLTextAreaElement)) throw new TypeError('Element must be an input or textarea.');
    if (typeof openTag !== 'string') throw new TypeError('openTag must be a string.');
    if (typeof closeTag !== 'string') throw new TypeError('closeTag must be a string.');
    _classPrivateFieldSet(_el, this, elem);
    _classPrivateFieldSet(_openTag, this, openTag);
    _classPrivateFieldSet(_closeTag, this, closeTag);
  }
  /** @returns {string} The current open tag symbol. */
  return _createClass(TinyTextRangeEditor, [{
    key: "getOpenTag",
    value: function getOpenTag() {
      return _classPrivateFieldGet(_openTag, this);
    }
    /** @returns {string} The current close tag symbol. */
  }, {
    key: "getCloseTag",
    value: function getCloseTag() {
      return _classPrivateFieldGet(_closeTag, this);
    }
    /** @param {string} tag - New open tag symbol to use (e.g., `'['`). */
  }, {
    key: "setOpenTag",
    value: function setOpenTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('Open tag must be a string.');
      _classPrivateFieldSet(_openTag, this, tag);
    }
    /** @param {string} tag - New close tag symbol to use (e.g., `']'`). */
  }, {
    key: "setCloseTag",
    value: function setCloseTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('Close tag must be a string.');
      _classPrivateFieldSet(_closeTag, this, tag);
    }
    /**
     * Ensures the element has focus.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "ensureFocus",
    value: function ensureFocus() {
      if (document.activeElement !== _classPrivateFieldGet(_el, this)) _classPrivateFieldGet(_el, this).focus();
      return this;
    }
    /**
     * Focus the element.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "focus",
    value: function focus() {
      _classPrivateFieldGet(_el, this).focus();
      return this;
    }
    /** @returns {{ start: number, end: number }} The current selection range. */
  }, {
    key: "getSelectionRange",
    value: function getSelectionRange() {
      var _classPrivateFieldGet2, _classPrivateFieldGet3;
      return {
        start: (_classPrivateFieldGet2 = _classPrivateFieldGet(_el, this).selectionStart) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : NaN,
        end: (_classPrivateFieldGet3 = _classPrivateFieldGet(_el, this).selectionEnd) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : NaN
      };
    }
    /**
     * Sets the current selection range.
     * @param {number} start - Start index.
     * @param {number} end - End index.
     * @param {boolean} [preserveScroll=true] - Whether to preserve scroll position.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "setSelectionRange",
    value: function setSelectionRange(start, end) {
      var preserveScroll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (typeof start !== 'number' || typeof end !== 'number') throw new TypeError('start and end must be numbers.');
      if (typeof preserveScroll !== 'boolean') throw new TypeError('preserveScroll must be a boolean.');
      var scrollTop = _classPrivateFieldGet(_el, this).scrollTop;
      var scrollLeft = _classPrivateFieldGet(_el, this).scrollLeft;
      _classPrivateFieldGet(_el, this).setSelectionRange(start, end);
      if (preserveScroll) {
        _classPrivateFieldGet(_el, this).scrollTop = scrollTop;
        _classPrivateFieldGet(_el, this).scrollLeft = scrollLeft;
      }
      return this;
    }
    /** @returns {string} The full current text value. */
  }, {
    key: "getValue",
    value: function getValue() {
      return _classPrivateFieldGet(_el, this).value;
    }
    /**
     * Sets the full value of the element.
     * @param {string} value - The new value to assign.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      if (typeof value !== 'string') throw new TypeError('Value must be a string.');
      _classPrivateFieldGet(_el, this).value = value;
      return this;
    }
    /** @returns {string} The currently selected text. */
  }, {
    key: "getSelectedText",
    value: function getSelectedText() {
      var _this$getSelectionRan = this.getSelectionRange(),
        start = _this$getSelectionRan.start,
        end = _this$getSelectionRan.end;
      return _classPrivateFieldGet(_el, this).value.slice(start, end);
    }
    /**
     * Inserts text at the current selection, replacing any selected content.
     * @param {string} text - The text to insert.
     * @param {Object} [settings={}] - Optional auto-spacing behavior.
     * @param {'start' | 'end' | 'preserve'} [settings.newCursor='end'] - Controls caret position after insertion.
     * @param {boolean} [settings.autoSpacing=false]
     * @param {boolean} [settings.autoSpaceLeft=false]
     * @param {boolean} [settings.autoSpaceRight=false]
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "insertText",
    value: function insertText(text) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$newCursor = _ref2.newCursor,
        newCursor = _ref2$newCursor === void 0 ? 'end' : _ref2$newCursor,
        _ref2$autoSpacing = _ref2.autoSpacing,
        autoSpacing = _ref2$autoSpacing === void 0 ? false : _ref2$autoSpacing,
        _ref2$autoSpaceLeft = _ref2.autoSpaceLeft,
        autoSpaceLeft = _ref2$autoSpaceLeft === void 0 ? autoSpacing : _ref2$autoSpaceLeft,
        _ref2$autoSpaceRight = _ref2.autoSpaceRight,
        autoSpaceRight = _ref2$autoSpaceRight === void 0 ? autoSpacing : _ref2$autoSpaceRight;
      if (typeof text !== 'string') throw new TypeError('Text must be a string.');
      if (!['start', 'end', 'preserve'].includes(newCursor)) throw new TypeError("newCursor must be one of 'start', 'end', or 'preserve'.");
      if (typeof autoSpacing !== 'boolean') throw new TypeError('autoSpacing must be a boolean.');
      if (typeof autoSpaceLeft !== 'boolean') throw new TypeError('autoSpaceLeft must be a boolean.');
      if (typeof autoSpaceRight !== 'boolean') throw new TypeError('autoSpaceRight must be a boolean.');
      var _this$getSelectionRan2 = this.getSelectionRange(),
        start = _this$getSelectionRan2.start,
        end = _this$getSelectionRan2.end;
      var value = _classPrivateFieldGet(_el, this).value;
      var leftChar = value[start - 1] || '';
      var rightChar = value[end] || '';
      var addLeft = autoSpaceLeft && leftChar && !/\s/.test(leftChar);
      var addRight = autoSpaceRight && rightChar && !/\s/.test(rightChar);
      var finalText = "".concat(addLeft ? ' ' : '').concat(text).concat(addRight ? ' ' : '');
      var newValue = value.slice(0, start) + finalText + value.slice(end);
      this.setValue(newValue);
      var cursorPos = start;
      if (newCursor === 'end') cursorPos = start + finalText.length;else if (newCursor === 'preserve') cursorPos = start;
      this.setSelectionRange(cursorPos, cursorPos);
      return this;
    }
    /**
     * Deletes the currently selected text.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "deleteSelection",
    value: function deleteSelection() {
      this.insertText('');
      return this;
    }
    /**
     * Replaces the selection using a transformation function.
     * @param {(selected: string) => string} transformer - Function that modifies the selected text.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "transformSelection",
    value: function transformSelection(transformer) {
      if (typeof transformer !== 'function') throw new TypeError('transformer must be a function.');
      var _this$getSelectionRan3 = this.getSelectionRange(),
        start = _this$getSelectionRan3.start;
      var selected = this.getSelectedText();
      var transformed = transformer(selected);
      this.insertText(transformed);
      this.setSelectionRange(start, start + transformed.length);
      return this;
    }
    /**
     * Surrounds current selection with prefix and suffix.
     * @param {string} prefix - Text to insert before.
     * @param {string} suffix - Text to insert after.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "surroundSelection",
    value: function surroundSelection(prefix, suffix) {
      if (typeof prefix !== 'string' || typeof suffix !== 'string') throw new TypeError('prefix and suffix must be strings.');
      var selected = this.getSelectedText();
      this.insertText("".concat(prefix).concat(selected).concat(suffix));
      return this;
    }
    /**
     * Moves the caret by a given offset.
     * @param {number} offset - Characters to move.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "moveCaret",
    value: function moveCaret(offset) {
      if (typeof offset !== 'number') throw new TypeError('offset must be a number.');
      var _this$getSelectionRan4 = this.getSelectionRange(),
        start = _this$getSelectionRan4.start;
      var pos = Math.max(0, start + offset);
      this.setSelectionRange(pos, pos);
      return this;
    }
    /**
     * Selects all content in the field.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "selectAll",
    value: function selectAll() {
      this.setSelectionRange(0, _classPrivateFieldGet(_el, this).value.length);
      return this;
    }
    /**
     * Expands the current selection by character amounts.
     * @param {number} before - Characters to expand to the left.
     * @param {number} after - Characters to expand to the right.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "expandSelection",
    value: function expandSelection(before, after) {
      if (typeof before !== 'number' || typeof after !== 'number') throw new TypeError('before and after must be numbers.');
      var _this$getSelectionRan5 = this.getSelectionRange(),
        start = _this$getSelectionRan5.start,
        end = _this$getSelectionRan5.end;
      var newStart = Math.max(0, start - before);
      var newEnd = Math.min(_classPrivateFieldGet(_el, this).value.length, end + after);
      this.setSelectionRange(newStart, newEnd);
      return this;
    }
    /**
     * Replaces all regex matches in the content.
     * @param {RegExp} regex - Regex to match.
     * @param {(match: string) => string} replacer - Replacement function.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "replaceAll",
    value: function replaceAll(regex, replacer) {
      if (!(regex instanceof RegExp)) throw new TypeError('regex must be a RegExp.');
      if (typeof replacer !== 'function') throw new TypeError('replacer must be a function.');
      var newValue = _classPrivateFieldGet(_el, this).value.replace(regex, replacer);
      this.setValue(newValue);
      return this;
    }
    /**
     * Replaces all regex matches within the currently selected text.
     *
     * @param {RegExp} regex - Regular expression to match inside selection.
     * @param {(match: string) => string} replacer - Function to replace each match.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "replaceInSelection",
    value: function replaceInSelection(regex, replacer) {
      if (!(regex instanceof RegExp)) throw new TypeError('regex must be a RegExp.');
      if (typeof replacer !== 'function') throw new TypeError('replacer must be a function.');
      var _this$getSelectionRan6 = this.getSelectionRange(),
        start = _this$getSelectionRan6.start,
        end = _this$getSelectionRan6.end;
      var original = _classPrivateFieldGet(_el, this).value;
      var selected = original.slice(start, end);
      var replaced = selected.replace(regex, replacer);
      var updated = original.slice(0, start) + replaced + original.slice(end);
      this.setValue(updated);
      this.setSelectionRange(start, start + replaced.length);
      return this;
    }
    /**
     * Toggles a code around the current selection.
     * If it's already wrapped, unwraps it.
     * @param {string} codeName - The code to toggle.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "toggleCode",
    value: function toggleCode(codeName) {
      if (typeof codeName !== 'string') throw new TypeError('codeName must be a string.');
      var selected = this.getSelectedText();
      if (selected.startsWith(codeName) && selected.endsWith(codeName)) {
        var unwrapped = selected.slice(codeName.length, selected.length - codeName.length);
        this.insertText(unwrapped);
      } else {
        this.insertText("".concat(codeName).concat(selected).concat(codeName));
      }
      return this;
    }
    /**
     * Converts a list of attributes into a string suitable for tag insertion.
     *
     * This method supports both standard key-value attribute objects (e.g., `{ key: "value" }`)
     * and boolean-style attribute arrays (e.g., `[ "disabled", "autofocus" ]`).
     *
     * - Attributes passed as an array will render as boolean attributes (e.g., `disabled autofocus`)
     * - Attributes passed as an object will render as `key="value"` pairs (or just `key` if the value is an empty string)
     *
     * @param {Record<string, string> | string[]} attributes - The attributes to serialize into a tag string.
     *   - If an array: treated as a list of boolean-style attributes.
     *   - If an object: treated as key-value pairs.
     *
     * @throws {TypeError} If the array contains non-strings, or the object contains non-string values.
     * @returns {string} A string of serialized attributes for use inside a tag.
     *
     * @example
     * // Using object attributes
     * _insertAttr({ size: "12", color: "red" });
     * // Returns: 'size="12" color="red"'
     *
     * @example
     * // Using boolean attributes
     * _insertAttr(["disabled", "autofocus"]);
     * // Returns: 'disabled autofocus'
     *
     * @example
     * // Using mixed/empty object values
     * _insertAttr({ checked: "", class: "btn" });
     * // Returns: 'checked class="btn"'
     */
  }, {
    key: "_insertAttr",
    value: function _insertAttr(attributes) {
      // Reuse attribute logic
      var attrStr = '';
      if (Array.isArray(attributes)) {
        // string[]
        if (!attributes.every(function (attr) {
          return typeof attr === 'string';
        })) throw new TypeError('All entries in attributes array must be strings.');
        attrStr = attributes.map(function (attr) {
          return "".concat(attr);
        }).join(' ');
      } else if (_typeof(attributes) === 'object' && attributes !== null) {
        // Record<string, string>
        attrStr = Object.entries(attributes).map(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            val = _ref4[1];
          if (typeof val !== 'string') throw new TypeError('All entries in attributes object must be strings.');
          return "".concat(key).concat(val.length > 0 ? "=\"".concat(val, "\"") : '');
        }).join(' ');
      } else {
        throw new TypeError('attributes must be an object or an array of strings.');
      }
      return attrStr;
    }
    /**
     * Wraps the current selection with a tag, optionally including attributes.
     *
     * @param {string} tagName - The tag name (e.g., `b`, `color`, etc.).
     * @param {Record<string,string> | string[]} [attributes={}] - Optional attributes for the opening tag.
     *   - If an object: key-value pairs (e.g., `{ color: "red" }` â `color="red"`).
     *   - If an array: boolean attributes (e.g., `["disabled", "readonly"]`).
     *
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "wrapWithTag",
    value: function wrapWithTag(tagName) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (typeof tagName !== 'string') throw new TypeError('tagName must be a string.');
      var attrStr = this._insertAttr(attributes);
      var openTag = attrStr ? "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName, " ").concat(attrStr).concat(_classPrivateFieldGet(_closeTag, this)) : "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      var closeTag = "".concat(_classPrivateFieldGet(_openTag, this), "/").concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      this.surroundSelection(openTag, closeTag);
      return this;
    }
    /**
     * Inserts a tag with optional inner content.
     * @param {string} tagName - The tag to insert.
     * @param {string} [content=''] - Optional content between tags.
     * @param {Record<string,string> | string[]} [attributes={}] - Optional attributes or list of empty attributes.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "insertTag",
    value: function insertTag(tagName) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (typeof tagName !== 'string') throw new TypeError('tagName must be a string.');
      if (typeof content !== 'string') throw new TypeError('content must be a string.');
      var attrStr = this._insertAttr(attributes);
      var open = attrStr ? "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName, " ").concat(attrStr).concat(_classPrivateFieldGet(_closeTag, this)) : "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      var close = "".concat(_classPrivateFieldGet(_openTag, this), "/").concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      this.insertText("".concat(open).concat(content).concat(close));
      return this;
    }
    /**
     * Inserts a self-closing tag.
     * @param {string} tagName - The tag name.
     * @param {Record<string,string> | string[]} [attributes={}] - Optional attributes or list of empty attributes.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "insertSelfClosingTag",
    value: function insertSelfClosingTag(tagName) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (typeof tagName !== 'string') throw new TypeError('tagName must be a string.');
      var attrStr = this._insertAttr(attributes);
      var tag = attrStr ? "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName, " ").concat(attrStr).concat(_classPrivateFieldGet(_closeTag, this)) : "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      this.insertText(tag);
      return this;
    }
    /**
     * Toggles a tag around the current selection.
     * Supports tags with attributes. If already wrapped, it unwraps.
     * @param {string} tagName - The tag to toggle.
     * @param {Record<string,string> | string[]} [attributes={}] - Optional attributes to apply when wrapping.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "toggleTag",
    value: function toggleTag(tagName) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (typeof tagName !== 'string') throw new TypeError('tagName must be a string.');
      var selected = this.getSelectedText();
      // Regex: opening tag with optional attributes, and closing tag
      var openRegex = new RegExp("^\\[".concat(tagName, "(\\s+[^\\]]*)?\\]"));
      var closeRegex = new RegExp("\\[/".concat(tagName, "\\]$"));
      var hasOpen = openRegex.test(selected);
      var hasClose = closeRegex.test(selected);
      if (hasOpen && hasClose) {
        var unwrapped = selected.replace(openRegex, '') // remove opening tag
        .replace(closeRegex, ''); // remove closing tag
        this.insertText(unwrapped);
      } else {
        var attrStr = this._insertAttr(attributes);
        var open = attrStr ? "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName, " ").concat(attrStr).concat(_classPrivateFieldGet(_closeTag, this)) : "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
        var close = "".concat(_classPrivateFieldGet(_openTag, this), "/").concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
        this.insertText("".concat(open).concat(selected).concat(close));
      }
      return this;
    }
  }]);
}();
var _default = exports["default"] = TinyTextRangeEditor;

},{}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _lineHeight = /*#__PURE__*/new WeakMap();
var _maxRows = /*#__PURE__*/new WeakMap();
var _extraHeight = /*#__PURE__*/new WeakMap();
var _lastKnownHeight = /*#__PURE__*/new WeakMap();
var _lastKnownRows = /*#__PURE__*/new WeakMap();
var _textarea = /*#__PURE__*/new WeakMap();
var _onResize = /*#__PURE__*/new WeakMap();
var _onInput = /*#__PURE__*/new WeakMap();
var _TinyTextarea_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {Object} OnInputInfo
 * @property {number} breakLines - Total number of `\n` line breaks in the textarea value.
 * @property {number} height - Final calculated height (in pixels) applied to the textarea.
 * @property {number} scrollHeight - Internal scrollHeight before limiting.
 * @property {number} maxHeight - Maximum allowed height before scrolling is forced.
 * @property {number} lineHeight - Height of one line of text, computed from CSS.
 * @property {number} maxRows - Maximum number of visible rows allowed.
 * @property {number} rows - Effective number of visual rows being used.
 */
/**
 * A lightweight utility class that automatically adjusts the height of a `<textarea>`
 * element based on its content. It prevents scrollbars by expanding vertically as needed,
 * up to a configurable maximum number of visible rows.
 *
 * Features:
 * - Automatically resizes the textarea as the user types
 * - Prevents vertical scrollbars until a maximum row limit is reached
 * - Supports additional height padding
 * - Provides real-time callbacks for input and resize events
 * - Allows manual refresh and cleanup of behavior
 *
 * Ideal for chat inputs, note editors, or any form where dynamic space usage
 * is preferred without relying on scrollbars too early.
 *
 * @class
 * @beta
 */
var TinyTextarea = /*#__PURE__*/function () {
  /**
   * Creates a new TinyTextarea instance.
   *
   * @param {HTMLTextAreaElement} textarea - The `<textarea>` element to enhance.
   * @param {Object} [options={}] - Optional configuration parameters.
   * @param {number} [options.maxRows] - Maximum number of visible rows before scrolling.
   * @param {number} [options.extraHeight] - Additional pixels to add to final height.
   * @param {(info: OnInputInfo) => void} [options.onResize] - Callback when the number of rows changes.
   * @param {(info: OnInputInfo) => void} [options.onInput] - Callback on every input event.
   * @throws {Error} If `textarea` is not a valid `<textarea>` element.
   * @throws {TypeError} If provided options are of invalid types.
   */
  function TinyTextarea(textarea) {
    var _options$maxRows,
      _options$extraHeight,
      _options$onResize,
      _options$onInput,
      _this = this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, TinyTextarea);
    /**
     * Automatically resize the textarea based on its content and notify listeners.
     * Triggers `onResize` if the number of rows has changed.
     * Always triggers `onInput`.
     */
    _classPrivateMethodInitSpec(this, _TinyTextarea_brand);
    _classPrivateFieldInitSpec(this, _lineHeight, void 0);
    _classPrivateFieldInitSpec(this, _maxRows, void 0);
    _classPrivateFieldInitSpec(this, _extraHeight, void 0);
    _classPrivateFieldInitSpec(this, _lastKnownHeight, 0);
    _classPrivateFieldInitSpec(this, _lastKnownRows, 0);
    /** @type {HTMLTextAreaElement} */
    _classPrivateFieldInitSpec(this, _textarea, void 0);
    /**
     * @type {((info: OnInputInfo) => void) | null}
     */
    _classPrivateFieldInitSpec(this, _onResize, null);
    /**
     * @type {((info: OnInputInfo) => void) | null}
     */
    _classPrivateFieldInitSpec(this, _onInput, null);
    if (!(textarea instanceof HTMLTextAreaElement)) throw new Error('TinyTextarea: Provided element is not a <textarea>.');
    if (_typeof(options) !== 'object' || options === null) throw new TypeError('TinyTextarea: Options must be an object if provided.');
    if ('maxRows' in options && typeof options.maxRows !== 'number') throw new TypeError('TinyTextarea: `maxRows` must be a number.');
    if ('extraHeight' in options && typeof options.extraHeight !== 'number') throw new TypeError('TinyTextarea: `extraHeight` must be a number.');
    if ('onResize' in options && typeof options.onResize !== 'function') throw new TypeError('TinyTextarea: `onResize` must be a function.');
    if ('onInput' in options && typeof options.onInput !== 'function') throw new TypeError('TinyTextarea: `onInput` must be a function.');
    _classPrivateFieldSet(_textarea, this, textarea);
    _classPrivateFieldSet(_maxRows, this, ((_options$maxRows = options.maxRows) !== null && _options$maxRows !== void 0 ? _options$maxRows : 5) + 1);
    _classPrivateFieldSet(_extraHeight, this, (_options$extraHeight = options.extraHeight) !== null && _options$extraHeight !== void 0 ? _options$extraHeight : 0);
    _classPrivateFieldSet(_onResize, this, (_options$onResize = options.onResize) !== null && _options$onResize !== void 0 ? _options$onResize : null);
    _classPrivateFieldSet(_onInput, this, (_options$onInput = options.onInput) !== null && _options$onInput !== void 0 ? _options$onInput : null);
    _classPrivateFieldSet(_lineHeight, this, _assertClassBrand(_TinyTextarea_brand, this, _getLineHeight).call(this));
    textarea.style.overflowY = 'hidden';
    textarea.style.resize = 'none';
    this._handleInput = function () {
      return _assertClassBrand(_TinyTextarea_brand, _this, _resize).call(_this);
    };
    textarea.addEventListener('input', this._handleInput);
    _assertClassBrand(_TinyTextarea_brand, this, _resize).call(this);
  }
  return _createClass(TinyTextarea, [{
    key: "lineHeight",
    get:
    /**
     * Returns the computed line height in pixels.
     * @returns {number}
     */
    function get() {
      return _classPrivateFieldGet(_lineHeight, this);
    }
    /**
     * Returns the maximum number of rows allowed.
     * @returns {number}
     */
  }, {
    key: "maxRows",
    get: function get() {
      return _classPrivateFieldGet(_maxRows, this) - 1;
    }
    /**
     * Returns the additional height added to the textarea.
     * @returns {number}
     */
  }, {
    key: "extraHeight",
    get: function get() {
      return _classPrivateFieldGet(_extraHeight, this);
    }
    /**
     * Returns the most recently applied height.
     * @returns {number}
     */
  }, {
    key: "currentHeight",
    get: function get() {
      return _classPrivateFieldGet(_lastKnownHeight, this);
    }
    /**
     * Returns the most recently calculated row count.
     * @returns {number}
     */
  }, {
    key: "currentRows",
    get: function get() {
      return _classPrivateFieldGet(_lastKnownRows, this);
    }
    /**
     * Returns the original textarea element managed by this instance.
     * @returns {HTMLTextAreaElement}
     */
  }, {
    key: "textarea",
    get: function get() {
      return _classPrivateFieldGet(_textarea, this);
    }
  }, {
    key: "getData",
    value:
    /**
     * Returns the latest height and row count of the textarea.
     * @returns {{ height: number, rows: number }} - Last known resize state.
     */
    function getData() {
      return {
        rows: _classPrivateFieldGet(_lastKnownRows, this),
        height: _classPrivateFieldGet(_lastKnownHeight, this)
      };
    }
    /**
     * Manually trigger a resize check.
     */
  }, {
    key: "refresh",
    value: function refresh() {
      _assertClassBrand(_TinyTextarea_brand, this, _resize).call(this);
    }
    /**
     * Cleans up internal listeners and disables dynamic behavior.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _classPrivateFieldGet(_textarea, this).removeEventListener('input', this._handleInput);
    }
  }]);
}();
function _resize() {
  _classPrivateFieldGet(_textarea, this).style.height = 'auto';
  var style = window.getComputedStyle(_classPrivateFieldGet(_textarea, this));
  var paddingTop = parseFloat(style.paddingTop) || 0;
  var paddingBottom = parseFloat(style.paddingBottom) || 0;
  var breakLines = (_classPrivateFieldGet(_textarea, this).value.match(/\n/g) || []).length;
  var scrollHeight = _classPrivateFieldGet(_textarea, this).scrollHeight;
  var maxHeight = _classPrivateFieldGet(_lineHeight, this) * _classPrivateFieldGet(_maxRows, this);
  var newHeight = Math.ceil(Math.min(scrollHeight, maxHeight) - paddingTop - paddingBottom + _classPrivateFieldGet(_extraHeight, this));
  // const rows = Math.round(newHeight / this.#lineHeight);
  var maxRows = _classPrivateFieldGet(_maxRows, this) - 1;
  var rows = breakLines < maxRows ? breakLines + 1 : maxRows;
  _classPrivateFieldGet(_textarea, this).style.height = "".concat(newHeight, "px");
  _classPrivateFieldGet(_textarea, this).style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
  _classPrivateFieldSet(_lastKnownHeight, this, newHeight);
  var info = {
    breakLines: breakLines,
    rows: rows,
    height: newHeight,
    scrollHeight: scrollHeight,
    maxHeight: maxHeight,
    lineHeight: _classPrivateFieldGet(_lineHeight, this),
    maxRows: maxRows
  };
  if (rows !== _classPrivateFieldGet(_lastKnownRows, this)) {
    _classPrivateFieldSet(_lastKnownRows, this, rows);
    if (typeof _classPrivateFieldGet(_onResize, this) === 'function') {
      _classPrivateFieldGet(_onResize, this).call(this, _objectSpread({}, info));
    }
  }
  if (typeof _classPrivateFieldGet(_onInput, this) === 'function') {
    _classPrivateFieldGet(_onInput, this).call(this, info);
  }
}
/**
 * Computes the current line height from the textarea's computed styles.
 * Falls back to `fontSize * 1.2` if lineHeight is not a number.
 * @returns {number} - The computed line height in pixels.
 */
function _getLineHeight() {
  var style = window.getComputedStyle(_classPrivateFieldGet(_textarea, this));
  var line = parseFloat(style.lineHeight);
  if (!Number.isNaN(line)) return line;
  return parseFloat(style.fontSize) * 1.2;
}
var _default = exports["default"] = TinyTextarea;

},{}],201:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _isDestroyed = /*#__PURE__*/new WeakMap();
var _allowAutoConfigChange = /*#__PURE__*/new WeakMap();
var _cooldownWatcherTime = /*#__PURE__*/new WeakMap();
var _cooldownWatcher = /*#__PURE__*/new WeakMap();
var _timeoutFixer = /*#__PURE__*/new WeakMap();
/**
 * A utility class to manage dynamically adjusted timeouts based on how often
 * each unique ID is triggered. Also provides polling support for asynchronous conditions.
 */
var TinyTimeout = /*#__PURE__*/function () {
  /**
   * Creates a new instance of TinyTimeout.
   *
   * @param {Object} [options={}] Optional configuration object.
   * @param {number} [options.cooldownWatcherTime=5000] Interval in milliseconds for reducing `now` counters.
   * @param {boolean} [options.allowAutoConfigChange=false] Whether to allow auto value changes for existing IDs.
   */
  function TinyTimeout() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$cooldownWatcherT = _ref.cooldownWatcherTime,
      cooldownWatcherTime = _ref$cooldownWatcherT === void 0 ? 5000 : _ref$cooldownWatcherT,
      _ref$allowAutoConfigC = _ref.allowAutoConfigChange,
      allowAutoConfigChange = _ref$allowAutoConfigC === void 0 ? false : _ref$allowAutoConfigC;
    _classCallCheck(this, TinyTimeout);
    /** @type {boolean} Whether this instance has been destroyed. */
    _classPrivateFieldInitSpec(this, _isDestroyed, false);
    /** @type {boolean} Whether to allow auto-updating an ID's timeout config if `value` changes. */
    _classPrivateFieldInitSpec(this, _allowAutoConfigChange, void 0);
    /** @type {number} The interval time (ms) used to decrement cooldown counters. */
    _classPrivateFieldInitSpec(this, _cooldownWatcherTime, void 0);
    /** @type {NodeJS.Timeout|null} Reference to the internal cooldown interval. */
    _classPrivateFieldInitSpec(this, _cooldownWatcher, null);
    /**
     * Internal map that keeps track of how many times each ID has been triggered,
     * along with the base multiplier used to calculate delays.
     *
     * @type {Map<string, { value: number, now: number }>}
     */
    _classPrivateFieldInitSpec(this, _timeoutFixer, new Map());
    if (!Number.isFinite(cooldownWatcherTime) || cooldownWatcherTime <= 0) throw new TypeError("Expected 'cooldownWatcherTime' to be a positive number.");
    if (typeof allowAutoConfigChange !== 'boolean') throw new TypeError("Expected 'allowAutoConfigChange' to be a boolean.");
    _classPrivateFieldSet(_cooldownWatcherTime, this, cooldownWatcherTime);
    _classPrivateFieldSet(_allowAutoConfigChange, this, allowAutoConfigChange);
    this.setCooldownWatcherTime(cooldownWatcherTime);
  }
  /**
   * Whether this instance has been destroyed and is no longer usable.
   *
   * @returns {boolean}
   */
  return _createClass(TinyTimeout, [{
    key: "isDestroyed",
    value: function isDestroyed() {
      return _classPrivateFieldGet(_isDestroyed, this);
    }
    /**
     * Whether auto config change is enabled.
     *
     * @returns {boolean}
     */
  }, {
    key: "getAllowAutoConfigChange",
    value: function getAllowAutoConfigChange() {
      return _classPrivateFieldGet(_allowAutoConfigChange, this);
    }
    /**
     * Gets the interval time used for cooldown decrementing.
     *
     * @returns {number}
     */
  }, {
    key: "getCooldownWatcherTime",
    value: function getCooldownWatcherTime() {
      return _classPrivateFieldGet(_cooldownWatcherTime, this);
    }
    /**
     * Sets whether to allow auto-updating an ID's timeout config if `value` changes.
     *
     * @param {boolean} value
     */
  }, {
    key: "setAllowAutoConfigChange",
    value: function setAllowAutoConfigChange(value) {
      if (typeof value !== 'boolean') throw new TypeError("Expected 'value' to be a boolean.");
      _classPrivateFieldSet(_allowAutoConfigChange, this, value);
    }
    /**
     * Sets the cooldown watcher interval time.
     * Automatically resets the interval if it was already running.
     *
     * @param {number} value
     */
  }, {
    key: "setCooldownWatcherTime",
    value: function setCooldownWatcherTime(value) {
      var _this = this;
      if (_classPrivateFieldGet(_isDestroyed, this)) throw new Error('TinyTimeout has been destroyed.');
      if (!Number.isFinite(value) || value <= 0) throw new TypeError("Expected 'value' to be a positive number.");
      _classPrivateFieldSet(_cooldownWatcherTime, this, value);
      if (_classPrivateFieldGet(_cooldownWatcher, this)) clearInterval(_classPrivateFieldGet(_cooldownWatcher, this));
      _classPrivateFieldSet(_cooldownWatcher, this, setInterval(function () {
        _classPrivateFieldGet(_timeoutFixer, _this).forEach(function (data) {
          if (data.now > 0) data.now--;
        });
      }, _classPrivateFieldGet(_cooldownWatcherTime, this)));
    }
    /**
     * Schedules a callback using a dynamically adjusted timeout based on usage frequency.
     * The more often an ID is triggered, the longer the timeout becomes,
     * scaled by the provided `value`. Optionally, the delay can be limited by `limit`.
     *
     * @param {string} id - A unique identifier to track timeout usage.
     * @param {Function} callback - The function to execute after the delay.
     * @param {number} value - Base delay multiplier in milliseconds.
     * @param {number|null} [limit=null] - Optional maximum delay cap.
     * @returns {number} Handle to the scheduled timeout.
     * @throws {Error} Throws if the instance has been destroyed or arguments are invalid.
     */
  }, {
    key: "set",
    value: function set(id, callback, value) {
      var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      if (_classPrivateFieldGet(_isDestroyed, this)) throw new Error('TinyTimeout has been destroyed.');
      if (typeof id !== 'string' || id.trim() === '') throw new TypeError("Expected 'id' to be a non-empty string.");
      if (typeof callback !== 'function') throw new TypeError("Expected 'callback' to be a function.");
      if (!Number.isFinite(value) || value < 0) throw new TypeError("Expected 'value' to be a non-negative number.");
      if (limit !== null && (!Number.isFinite(limit) || limit < 0)) throw new TypeError("Expected 'limit' to be null or a non-negative number.");
      var entry = _classPrivateFieldGet(_timeoutFixer, this).get(id);
      if (!entry || _classPrivateFieldGet(_allowAutoConfigChange, this) && value !== entry.value) {
        entry = {
          value: value,
          now: 0
        };
        _classPrivateFieldGet(_timeoutFixer, this).set(id, entry);
      }
      var delay = entry.value * entry.now;
      entry.now++;
      return setTimeout(callback, typeof limit === 'number' ? Math.min(delay, limit) : delay);
    }
    /**
     * Waits until a provided function returns `true`, checking repeatedly at the defined interval.
     * Useful for polling asynchronous conditions.
     *
     * @param {() => boolean} getValue - A function that returns `true` when the condition is met.
     * @param {number} [checkInterval=100] - How often (in ms) to check the condition.
     * @returns {Promise<void>} Resolves when the condition is met.
     * @throws {TypeError} If arguments are invalid.
     */
  }, {
    key: "waitForTrue",
    value:
    /**
     * Instance version of `waitForTrue`, which defaults to using the instance's
     * cooldownWatcherTime if not explicitly provided.
     *
     * @param {() => boolean} getValue - A function that returns `true` when the condition is met.
     * @param {number|null} [checkInterval=100] - How often (in ms) to check the condition.
     * @returns {Promise<void>} Resolves when the condition is met.
     * @throws {Error} If the instance is destroyed or arguments are invalid.
     */
    function waitForTrue(getValue) {
      var checkInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      if (_classPrivateFieldGet(_isDestroyed, this)) throw new Error('TinyTimeout has been destroyed.');
      if (typeof getValue !== 'function') throw new TypeError("Expected 'getValue' to be a function.");
      if (checkInterval !== null && (!Number.isFinite(checkInterval) || checkInterval <= 0)) throw new TypeError("Expected 'checkInterval' to be null or a positive number.");
      return TinyTimeout.waitForTrue(getValue, checkInterval !== null && checkInterval !== void 0 ? checkInterval : _classPrivateFieldGet(_cooldownWatcherTime, this));
    }
    /**
     * Cleans up all internal references and stops the cooldown watcher.
     * After calling this, the instance becomes unusable.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (_classPrivateFieldGet(_isDestroyed, this)) return;
      _classPrivateFieldSet(_isDestroyed, this, true);
      if (_classPrivateFieldGet(_cooldownWatcher, this)) clearInterval(_classPrivateFieldGet(_cooldownWatcher, this));
      _classPrivateFieldSet(_cooldownWatcher, this, null);
      _classPrivateFieldGet(_timeoutFixer, this).clear();
    }
  }], [{
    key: "waitForTrue",
    value: function waitForTrue(getValue) {
      var checkInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      if (typeof getValue !== 'function') throw new TypeError("Expected 'getValue' to be a function.");
      if (!Number.isFinite(checkInterval) || checkInterval <= 0) throw new TypeError("Expected 'checkInterval' to be a positive number.");
      return new Promise(function (resolve) {
        var interval = setInterval(function () {
          if (getValue()) {
            clearInterval(interval);
            resolve();
          }
        }, checkInterval);
      });
    }
  }]);
}();
var _default = exports["default"] = TinyTimeout;

},{}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _y = /*#__PURE__*/new WeakMap();
var _x = /*#__PURE__*/new WeakMap();
var _baseDuration = /*#__PURE__*/new WeakMap();
var _extraPerChar = /*#__PURE__*/new WeakMap();
var _fadeOutDuration = /*#__PURE__*/new WeakMap();
var _container = /*#__PURE__*/new WeakMap();
var _TinyToastNotify_brand = /*#__PURE__*/new WeakSet();
/**
 * A callback function used to manually close a notification.
 * Passed as a second argument to `onClick` handlers, allowing programmatic dismissal of the toast.
 *
 * @typedef {() => void} CloseToastFunc
 */
/**
 * Represents the data used to display a notification.
 * Can be a plain string (used as the message), or an object with more customization options.
 *
 * @typedef {string | {
 *   message: string, // The main message to display
 *   title?: string,  // Optional title to appear above the message
 *   onClick?: function(MouseEvent, CloseToastFunc): void, // Optional click handler for the notification
 *   html?: boolean,  // Whether the message should be interpreted as raw HTML
 *   avatar?: string  // Optional URL to an avatar image shown on the left
 * }} NotifyData
 */
/**
 * A lightweight notification system designed to display timed messages inside a container.
 * Supports positioning, timing customization, click actions, HTML content, and optional avatars.
 *
 * ## Features:
 * - Positioning via `x` (`left`, `center`, `right`) and `y` (`top`, `bottom`).
 * - Dynamic display time based on message length.
 * - Optional `title`, `avatar`, `onClick`, and `html` message rendering.
 * - Fade-out animation with customizable duration.
 * - Rigid validation of inputs and internal state.
 *
 * ## Customization via setters:
 * - `setX(position)` â horizontal alignment.
 * - `setY(position)` â vertical alignment.
 * - `setBaseDuration(ms)` â base visible time in milliseconds.
 * - `setExtraPerChar(ms)` â extra time added per character.
 * - `setFadeOutDuration(ms)` â fade-out animation duration in milliseconds.
 *
 * @class
 */
var TinyToastNotify = /*#__PURE__*/function () {
  /**
   * @param {'top'|'bottom'} y - 'top' or 'bottom'
   * @param {'right'|'left'|'center'} x - 'right', 'left', or 'center'
   * @param {number} baseDuration - Base display time in ms
   * @param {number} extraPerChar - Extra ms per character
   * @param {number} fadeOutDuration - Time in ms for fade-out effect
   * @param {string} [selector='.notify-container'] - Base selector for container
   */
  function TinyToastNotify() {
    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'top';
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'right';
    var baseDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;
    var extraPerChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 50;
    var fadeOutDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 300;
    var selector = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '.notify-container';
    _classCallCheck(this, TinyToastNotify);
    /**
     * Validates the vertical position value.
     * Must be either 'top' or 'bottom'.
     *
     * @param {string} value - The vertical position to validate.
     * @throws {Error} If the value is not 'top' or 'bottom'.
     */
    _classPrivateMethodInitSpec(this, _TinyToastNotify_brand);
    _classPrivateFieldInitSpec(this, _y, void 0);
    _classPrivateFieldInitSpec(this, _x, void 0);
    _classPrivateFieldInitSpec(this, _baseDuration, void 0);
    _classPrivateFieldInitSpec(this, _extraPerChar, void 0);
    _classPrivateFieldInitSpec(this, _fadeOutDuration, void 0);
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _container, void 0);
    _assertClassBrand(_TinyToastNotify_brand, this, _validateY).call(this, y);
    _assertClassBrand(_TinyToastNotify_brand, this, _validateX).call(this, x);
    _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, baseDuration, 'baseDuration');
    _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, extraPerChar, 'extraPerChar');
    _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, fadeOutDuration, 'fadeOutDuration');
    _classPrivateFieldSet(_y, this, y);
    _classPrivateFieldSet(_x, this, x);
    _classPrivateFieldSet(_baseDuration, this, baseDuration);
    _classPrivateFieldSet(_extraPerChar, this, extraPerChar);
    _classPrivateFieldSet(_fadeOutDuration, this, fadeOutDuration);
    var container = document.querySelector("".concat(selector, ".").concat(y, ".").concat(x));
    if (!(container instanceof HTMLElement)) {
      _classPrivateFieldSet(_container, this, document.createElement('div'));
      _classPrivateFieldGet(_container, this).className = "notify-container ".concat(y, " ").concat(x);
      document.body.appendChild(_classPrivateFieldGet(_container, this));
    } else _classPrivateFieldSet(_container, this, container);
  }
  /**
   * Returns the notification container element.
   * Ensures that the container is a valid HTMLElement.
   *
   * @returns {HTMLElement} The notification container.
   * @throws {Error} If the container is not a valid HTMLElement.
   */
  return _createClass(TinyToastNotify, [{
    key: "getContainer",
    value: function getContainer() {
      if (!(_classPrivateFieldGet(_container, this) instanceof HTMLElement)) throw new Error('Container is not a valid HTMLElement.');
      return _classPrivateFieldGet(_container, this);
    }
  }, {
    key: "getY",
    value:
    /**
     * Returns the current vertical position.
     *
     * @returns {'top'|'bottom'} The vertical direction of the notification container.
     */
    function getY() {
      return _classPrivateFieldGet(_y, this);
    }
    /**
     * Sets the vertical position of the notification container.
     * Updates the container's class to reflect the new position.
     *
     * @param {'top'|'bottom'} value - The vertical direction to set.
     * @throws {Error} If the value is invalid.
     */
  }, {
    key: "setY",
    value: function setY(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateY).call(this, value);
      var container = this.getContainer();
      container.classList.remove(_classPrivateFieldGet(_y, this));
      container.classList.add(value);
      _classPrivateFieldSet(_y, this, value);
    }
    /**
     * Returns the current horizontal position.
     *
     * @returns {'left'|'right'|'center'} The horizontal direction of the notification container.
     */
  }, {
    key: "getX",
    value: function getX() {
      return _classPrivateFieldGet(_x, this);
    }
    /**
     * Sets the horizontal position of the notification container.
     * Updates the container's class to reflect the new position.
     *
     * @param {'left'|'right'|'center'} value - The horizontal direction to set.
     * @throws {Error} If the value is invalid.
     */
  }, {
    key: "setX",
    value: function setX(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateX).call(this, value);
      var container = this.getContainer();
      container.classList.remove(_classPrivateFieldGet(_x, this));
      container.classList.add(value);
      _classPrivateFieldSet(_x, this, value);
    }
    /**
     * Returns the base duration for displaying the notification.
     *
     * @returns {number} Base time (in milliseconds) that a notification stays on screen.
     */
  }, {
    key: "getBaseDuration",
    value: function getBaseDuration() {
      return _classPrivateFieldGet(_baseDuration, this);
    }
    /**
     * Sets the base duration for the notification display time.
     *
     * @param {number} value - Base display time in milliseconds.
     * @throws {Error} If the value is not a valid non-negative finite number.
     */
  }, {
    key: "setBaseDuration",
    value: function setBaseDuration(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, value, 'baseDuration');
      _classPrivateFieldSet(_baseDuration, this, value);
    }
    /**
     * Returns the extra display time added per character.
     *
     * @returns {number} Extra time (in milliseconds) per character in the notification.
     */
  }, {
    key: "getExtraPerChar",
    value: function getExtraPerChar() {
      return _classPrivateFieldGet(_extraPerChar, this);
    }
    /**
     * Sets the additional display time per character.
     *
     * @param {number} value - Extra time in milliseconds per character.
     * @throws {Error} If the value is not a valid non-negative finite number.
     */
  }, {
    key: "setExtraPerChar",
    value: function setExtraPerChar(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, value, 'extraPerChar');
      _classPrivateFieldSet(_extraPerChar, this, value);
    }
    /**
     * Returns the fade-out duration.
     *
     * @returns {number} Time (in milliseconds) used for fade-out transition.
     */
  }, {
    key: "getFadeOutDuration",
    value: function getFadeOutDuration() {
      return _classPrivateFieldGet(_fadeOutDuration, this);
    }
    /**
     * Sets the fade-out transition time for notifications.
     *
     * @param {number} value - Fade-out duration in milliseconds.
     * @throws {Error} If the value is not a valid non-negative finite number.
     */
  }, {
    key: "setFadeOutDuration",
    value: function setFadeOutDuration(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, value, 'fadeOutDuration');
      _classPrivateFieldSet(_fadeOutDuration, this, value);
    }
    /**
     * Displays a notification for a time based on message length.
     * Accepts a string or an object with:
     * {
     *   message: string,
     *   title?: string,
     *   onClick?: function(MouseEvent, CloseToastFunc): void,
     *   html?: boolean,
     *   avatar?: string // Optional avatar image URL
     * }
     *
     * @param {NotifyData} data
     */
  }, {
    key: "show",
    value: function show(data) {
      var _this = this;
      var message = '';
      var title = '';
      var onClick = null;
      var useHTML = false;
      var avatarUrl = null;
      var notify = document.createElement('div');
      notify.className = 'notify enter';
      if (typeof data === 'string') {
        message = data;
      } else if (_typeof(data) === 'object' && data !== null && typeof data.message === 'string') {
        message = data.message;
        title = typeof data.title === 'string' ? data.title : '';
        useHTML = data.html === true;
        avatarUrl = typeof data.avatar === 'string' ? data.avatar : null;
        if (data.onClick !== undefined) {
          if (typeof data.onClick !== 'function') {
            throw new Error('onClick must be a function if defined');
          }
          onClick = data.onClick;
          notify.classList.add('clickable');
        }
      } else {
        throw new Error("Invalid argument for show(): expected string or { message: string, title?: string, onClick?: function, html?: boolean, avatar?: string }");
      }
      // Add close button
      var closeBtn = document.createElement('button');
      closeBtn.innerHTML = '&times;';
      closeBtn.className = 'close';
      closeBtn.setAttribute('aria-label', 'Close');
      // Optional hover effect
      closeBtn.addEventListener('mouseenter', function () {
        closeBtn.style.color = 'var(--notif-close-color-hover)';
      });
      closeBtn.addEventListener('mouseleave', function () {
        closeBtn.style.color = 'var(--notif-close-color)';
      });
      // Avatar
      if (avatarUrl) {
        var avatar = document.createElement('img');
        avatar.src = avatarUrl;
        avatar.alt = 'avatar';
        avatar.className = 'avatar';
        notify.appendChild(avatar);
      }
      // Title
      if (title) {
        var titleElem = document.createElement('strong');
        titleElem.textContent = title;
        titleElem.style.display = 'block';
        notify.appendChild(titleElem);
      }
      // Message
      if (useHTML) {
        var msgWrapper = document.createElement('div');
        msgWrapper.innerHTML = message;
        notify.appendChild(msgWrapper);
      } else {
        notify.appendChild(document.createTextNode(message));
      }
      notify.appendChild(closeBtn);
      this.getContainer().appendChild(notify);
      var visibleTime = _classPrivateFieldGet(_baseDuration, this) + message.length * _classPrivateFieldGet(_extraPerChar, this);
      var totalTime = visibleTime + _classPrivateFieldGet(_fadeOutDuration, this);
      // Close logic
      var removed = false;
      var close = function close() {
        if (removed) return;
        removed = true;
        notify.classList.remove('enter', 'show');
        notify.classList.add('exit');
        setTimeout(function () {
          return notify.remove();
        }, _classPrivateFieldGet(_fadeOutDuration, _this));
      };
      // Click handler
      if (typeof onClick === 'function') {
        notify.addEventListener('click', function (e) {
          if (e.target === closeBtn) return;
          onClick(e, close);
        });
      }
      // Close button click
      closeBtn.addEventListener('click', function (e) {
        e.stopPropagation();
        close();
      });
      // Transition activation force soon after the element is added
      setTimeout(function () {
        notify.classList.remove('enter');
        notify.classList.add('show');
      }, 1);
      setTimeout(function () {
        return close();
      }, totalTime);
    }
    /**
     * Destroys the notification container and removes all active notifications.
     * This should be called when the notification system is no longer needed,
     * such as when unloading a page or switching views in a single-page app.
     *
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (!(_classPrivateFieldGet(_container, this) instanceof HTMLElement)) return;
      // Remove all child notifications
      _classPrivateFieldGet(_container, this).querySelectorAll('.notify').forEach(function (el) {
        return el.remove();
      });
      // Remove the container itself from the DOM
      if (_classPrivateFieldGet(_container, this).parentNode) {
        _classPrivateFieldGet(_container, this).parentNode.removeChild(_classPrivateFieldGet(_container, this));
      }
      // Optional: Clean internal references (safe practice)
      _classPrivateFieldSet(_container, this, null);
    }
  }]);
}();
function _validateY(value) {
  if (!['top', 'bottom'].includes(value)) {
    throw new Error("Invalid vertical direction \"".concat(value, "\". Expected \"top\" or \"bottom\"."));
  }
}
/**
 * Validates the horizontal position value.
 * Must be 'left', 'right', or 'center'.
 *
 * @param {string} value - The horizontal position to validate.
 * @throws {Error} If the value is not one of the accepted directions.
 */
function _validateX(value) {
  if (!['left', 'right', 'center'].includes(value)) {
    throw new Error("Invalid horizontal position \"".concat(value, "\". Expected \"left\", \"right\" or \"center\"."));
  }
}
/**
 * Validates a numeric timing value.
 * Must be a non-negative finite number.
 *
 * @param {number} value - The number to validate.
 * @param {string} name - The name of the parameter (used for error messaging).
 * @throws {Error} If the number is invalid.
 */
function _validateTiming(value, name) {
  if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {
    throw new Error("Invalid value for \"".concat(name, "\": ").concat(value, ". Must be a non-negative finite number."));
  }
}
var _default = exports["default"] = TinyToastNotify;

},{}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var defaultWords = ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit', 'sed', 'do', 'eiusmod', 'tempor', 'incididunt', 'ut', 'labore', 'et', 'dolore', 'magna', 'aliqua'];
var defaultEmojis = ['ð', 'ð', 'ð¤', 'ð¥', 'ð¸', 'ð', 'ð¦', 'ð§ ', 'ð§¬', 'ð', 'ð« ', 'ð«', 'ð©', 'ð¾', 'ð', 'ð¥´', 'ð', 'ð§', 'ðª', 'ð', 'ð§¸', 'ð»', 'ð¥³', 'ð­', 'ð', 'ðº', 'ð®', 'ðª', 'ð®', 'ð¥', 'ð®'];
var defaultNouns = ['pudding', 'bean', 'snuggle', 'bloop', 'jelly', 'unicorn', 'floof', 'giggle', 'bubble', 'muffin', 'puff', 'pickle', 'goblin', 'waffle', 'sprinkle', 'cupcake', 'fizzle', 'marshmallow', 'duckling', 'sock', 'cloud', 'teacup', 'nugget', 'gnome', 'hug', 'moonbean', 'crayon', 'jiggle', 'glitter', 'carrot', 'goober'];
var defaultVerbs = ['wiggles', 'bounces', 'flies', 'splats', 'scoots', 'giggles', 'wigglesnacks', 'twirls', 'boops', 'pops', 'sings', 'hugs', 'floats', 'glows', 'flaps', 'mlems', 'dances', 'puddles', 'nomnoms', 'wigglejumps', 'sniffs', 'tumbles', 'slides', 'chirps', 'burps', 'sparkles', 'waddles', 'rambles', 'blinks', 'mews'];
var defaultAdjectives = ['fluffy', 'silly', 'yummy', 'squishy', 'wobbly', 'magical', 'tiny', 'sleepy', 'wiggly', 'bubbly', 'glittery', 'fuzzy', 'jiggly', 'sparkly', 'giggly', 'crunchy', 'goofy', 'soft', 'mushy', 'sweet', 'loopy', 'floaty', 'bonkers', 'chewy', 'ticklish', 'dreamy', 'pastel', 'cozy', 'teensy', 'grumbly'];
var defaultTemplates = [
// ð§ Tiny
'Boop!', 'Wiggle achieved.', 'Oops, {noun} everywhere!', 'Tiny {adj} {noun}, big {adj} {noun}.', 'Snuggle initiated with a {adj} {noun}.', '{adj} vibes only, powered by {noun}.', 'No {noun}, no {noun}.', 'Bounce first, {verb} later.', 'Mlem. {verb}. {noun}.', '{noun} go brrr and {verb}.', 'Why not? {noun} did. Then {noun} followed.',
// ð¬ Simple
'A {adj} {noun} just {verb} near the {adj} window.', 'That {adj} {noun} stole my {noun}!', 'Look, a {adj} {noun} trying to {verb} again!', 'Every {noun} deserves a {adj} nap.', 'The {adj} {noun} is my {adj} spirit animal.', 'Someone call the {noun}, itâs {verb}ing and {verb}ing again!', 'Donât touch the {adj} {noun}. It {verb}s loudly.', '{noun} forgot how {noun}s work and just {verb}ed.',
// ð© Averages
'There once was a {adj} {noun} who loved to {verb} with a {adj} {noun} all day.', 'Apparently, {noun}s are banned from {verb}ing and {verb}ing in the {noun} library.', 'That {adj} noise? Just a {noun} learning to {verb} on a {adj} {noun}.', 'I saw a {adj} {noun} {verb} so hard, it became a {adj} muffin.', 'The {adj} {noun} met a {adj} pickle and everything {verb}ed.', '{noun}s are like {noun}: {adj}, unpredictable, and wiggly.', 'Donât judge a {adj} {noun} by its ability to {verb}, or by its {adj} hat.', 'All I wanted was peace, but a {adj} {noun} with a {adj} {noun} had other plans.',
// ð Giants
'One {adj} morning, a {adj} {noun} decided it was finally time to {verb}, but halfway through, it tripped on a {noun} and turned into a {adj} marshmallow.', 'I tried to be {adj} today, but then a {noun} {verb}ed across my {noun} and typed âasdfgh{noun}â repeatedly.', 'If you think youâve seen everything, wait until a {adj} {noun} {verb}s on a {noun} wearing {adj} socks with tiny {noun}s.', 'No one ever believed the stories about the ancient {adj} {noun} who could {verb} with such {adj} grace that entire {noun}s turned pink out of embarrassment.', 'A curious {adj} {noun} wandered into a {noun} shop, not knowing that its destiny involved twelve {adj} {noun}s, one rubber {noun}, and a suspiciously quiet {adj} llama.',
// ð Giants and narratives
'In a land where every {adj} {noun} was made of pudding and the sky was {adj} whipped cream, one brave {adj} {noun} set out to discover the legendary Spoon of {noun}s, facing obstacles like bouncing {noun}s, sassy {noun}s, and the Great Wobble of the {noun}.', 'Once upon a {adj} time, long before the {noun}s learned to {verb}, there existed a tiny {adj} {noun} who dreamed of swimming in a pool made entirely of {adj} glitter pudding while {verb}ing off-key lullabies to passing {noun}s with monocles.', 'The Council of {noun}s gathered in {adj} secret when the sacred {adj} {noun} started to {verb} uncontrollably, threatening the entire {adj} dessert-based civilization with spontaneous {noun} jiggles and uncontainable {noun} fits across the {noun}.',
// âï¸ Chats and chats
'Hey... do you ever wonder if {noun}s dream of {noun}s?', 'Okay but hear me out: what if the {adj} {noun} could actually {verb} backwards?', 'Can we talk about the {noun} that just {verb}ed and vanished?', 'So I was talking to a {noun}, and it told me to stop being {adj}. Rude.', 'Not to alarm you, but thereâs a {adj} {noun} behind you doing the {verb}.', 'Why does this {noun} keep staring at me like I owe it pudding?', 'Is this a safe space to admit I accidentally {verb}ed a {noun}?', 'I just walked into the room and someone shouted â{adj} {noun}!â â what did I miss?', 'Wait... we were supposed to bring a {noun}? No one told me!', 'Okay but what if the {adj} {noun} has feelings too?', 'Be honest, do I look like a {noun} that forgot how to {verb}?', 'If I say "oops", do I still have to explain why the {noun} is glowing?', 'I donât know whatâs going on but I brought snacks and a confused {noun}.', 'Do you think pudding knows itâs pudding? Just a thought.', 'Is this about the time I {verb}ed the {adj} {noun} by accident? Because I can explain.',
// ð Confusions, unexpected entrances, lost people
'Wait, are we talking about {noun}s or am I on the wrong chat again?', 'What is this group even about? I just saw "pudding" and joined.', 'Hi! I have no idea whatâs happening but Iâm here and I brought a {noun}.', 'I blinked and now thereâs a {adj} {noun} in charge of everything.', 'Can someone please explain why the {noun} is floating and chanting?', 'Okay who gave the {noun} access to glitter and emotional support pickles?', 'I came for a calm discussion and now thereâs a {adj} battle between {noun}s.', 'Not sure if Iâm early, late, or inside a {noun} dream.', 'I was gone for 3 minutes and now someoneâs riding a {noun} into the pudding realm.', 'This isnât the pudding appreciation group, is it? ...oh no.', 'So... who summoned the {adj} {noun} this time? Be honest.', 'I came here for vibes and stayed for the {noun}s.', 'Does anyone else hear faint giggling or is that just the {adj} {noun} again?', 'I feel like I missed step one, two, and also three of this conversation.', 'All I asked was âwhatâs up?â and now Iâm emotionally attached to a {noun}.',
// ð¬ More interactive chat style
'Me: "Iâll be normal today." Also me: *{verb}s into a meeting riding a {adj} {noun}*', '"Itâs just pudding," they said. "It canât hurt you," they said. They were wrong.', 'I said one nice thing to a {noun} and now it follows me everywhere.', 'Can we take a moment to appreciate how the {adj} {noun} is just vibing?', 'Who put a tiny hat on the {noun}? Because thatâs adorable.', 'My life has been different ever since the {noun} started {verb}ing.', 'Raise your hand if youâve ever been personally attacked by a {adj} {noun}.', '"Donât be weird," they said. So I became a {noun} instead.', 'Do {noun}s have feelings? Asking for a {adj} friend.', 'I trusted the {noun} and all I got was a glitter-covered sock.', 'Plot twist: the {adj} {noun} was inside us all along.',
// Mini cute explosions and chaos
'The {adj} {noun} {verb} and {verb} all over the {adj} {noun}!', 'Oops! {noun}s {verb}ed into the {adj} {noun} while {verb}ing crazily.', '{adj}, {adj}, and more {adj} {noun}s just {verb}ed by!', 'Why does the {adj} {noun} keep {verb}ing and {verb}ing without stopping?', 'Look! A {adj} {noun}, a {adj} {noun}, and a {noun} all {verb}ing together!', 'Sometimes, the {noun} just {verb}s, then {verb}s again, and never stops being {adj}.',
// Phrases with repetition and multiple spaces for chaos
'{noun}, {noun}, and {noun} â all {verb}ing and {verb}ing in a {adj} {noun}.', 'I saw a {adj} {noun} {verb}, then another {noun} {verb}ing with a {adj} {noun}.', 'The {noun} {verb}s {verb} while the {adj} {noun} {verb}s and the {noun} just {verb}s.', 'Can a {adj} {noun} {verb} {verb} without a {adj} {noun} watching?',
// Phrases with interactions and breaks for fun
'Whoa! The {adj} {noun} just {verb}ed... and then {verb}ed again!', 'Hey... did you see that {adj} {noun} {verb} over there?', 'Umm, the {noun} is {verb}ing but also {verb}ing and {verb}ing!', 'Lol! {noun}s {verb} so {adj}ly, itâs impossible not to giggle.',
// Mini exaggerated and cute dialogues
'"Hey! Whatâs up?" asked the {adj} {noun}, who {verb}ed loudly.', '"Iâm just a {adj} {noun} trying to {verb}, you know?"', '"Did you see the {adj} {noun} that just {verb}ed in the pudding?"', '"No way! The {noun} {verb}s better than me!"', '"Wait, the {adj} {noun} said it would {verb}, but it {verb}ed instead!"',
// Extensive, crazy and fun narrative phrases
'Once upon a {adj} {noun}, a group of {adj} {noun}s {verb}ed through the {adj} forest, singing {adj} songs and eating {noun}s made of pudding.', 'The legend tells of a {adj} {noun} who could {verb} faster than any {noun} ever seen, leaving trails of {adj} sparkles behind.', 'Every day, the {adj} {noun} would {verb} around the {adj} meadow, trying to convince the {noun}s to join the grand pudding party.', 'No one knows why the {adj} {noun} suddenly {verb}ed and then {verb}ed again, but everyone agrees it was the cutest thing they ever saw.', 'In the kingdom of {adj} {noun}s, only the bravest {noun} dared to {verb} the giant pudding monster, armed with nothing but {adj} smiles and jellybeans.',
// Total cases with many placeholders
'{adj} {noun} {verb} {verb} {verb} {noun} {verb} {adj} {noun} {verb} {noun}!', '{noun} {noun} {verb} {adj} {noun} and then {verb} {verb} the {adj} {noun}.', '{verb} the {adj} {noun}, then {verb} the {noun} while {verb}ing {adj}ly.', 'Can the {adj} {noun} {verb} and {verb} the {adj} {noun} at the same time?', '{noun} {verb} {noun} {verb}, but the {adj} {noun} {verb}s better.',
// Frases with cute interjections and silly sounds
'Boop! The {adj} {noun} just {verb}ed in the pudding.', 'Bloop bloop, the {noun} is {verb}ing all over again!', 'Mlem mlem, a {adj} {noun} {verb}s quietly in the corner.', 'Splat! {noun} {verb}ed right on the {adj} {noun}.', 'Yum! A {adj} {noun} just {verb}ed in my mouth.',
// Phrases with silly questions
'Do {noun}s really {verb} when nobodyâs watching?', 'Why does the {adj} {noun} always {verb} at midnight?', 'Can a {noun} be too {adj} to {verb} properly?', 'Is it normal for a {adj} {noun} to {verb} three times in a row?', 'Who taught the {noun} to {verb} like that?',
// Frases of confusion and fun surprises
'Wait, did the {adj} {noun} just {verb} itself?', 'I canât believe the {noun} {verb}ed into a {adj} {noun}!', 'Suddenly, a {adj} {noun} appeared and started to {verb} wildly.', 'That {noun} was {verb}ing so {adj}ly it broke the pudding meter.', 'Everyoneâs talking about the {adj} {noun} that {verb}ed out of nowhere.'];
/**
 * @typedef {'mixed'|'readable'|'chaotic'|'natural'} RandomMsgModes
 * Defines how the message content is generated:
 * - `mixed`: Combines readable words, gibberish, symbols, emojis, etc.
 * - `readable`: Focuses on human-readable words only.
 * - `chaotic`: Pure chaos, mostly gibberish and symbols.
 * - `natural`: Uses structured grammar templates to form silly but proper sentences.
 */
/**
 * @typedef {'inline'|'end'|'none'} EmojiPlacement
 * Controls where emojis are placed:
 * - `inline`: Emojis may appear throughout the text.
 * - `end`: Emojis appear at the end of lines.
 * - `none`: No emojis will be used.
 */
/**
 * @typedef {Object} MsgGenConfig
 * Configuration object for customizing message generation.
 *
 * @property {number} minLength - Minimum total length (in characters) of the final generated text.
 * @property {number} maxLength - Maximum total length (in characters) of the final generated text.
 * @property {boolean} readable - Whether to favor readable word-like strings.
 * @property {boolean} useEmojis - Whether emojis are allowed in the generated content.
 * @property {boolean} includeNumbers - Whether random numbers can appear in the text.
 * @property {boolean} includeSymbols - Whether random symbols (e.g., !@#) are included.
 * @property {boolean} allowWeirdSpacing - Enables fun spacing effects (e.g., extra spaces, newlines, uppercase words).
 *
 * @property {string[]} emojiSet - List of emojis to choose from. Overrides default set if provided.
 * @property {string[]} wordSet - List of base words used in readable and mixed modes.
 *
 * @property {RandomMsgModes} mode - Determines the overall generation strategy (`mixed`, `readable`, `chaotic`, or `natural`).
 *
 * @property {Object} grammar - Grammar configuration used when `mode` is set to `'natural'`.
 * @property {string[]} grammar.templates - Sentence templates using placeholders (`{noun}`, `{verb}`, `{adj}`).
 * @property {string[]} grammar.nouns - List of nouns to insert into `{noun}` placeholders.
 * @property {string[]} grammar.verbs - List of verbs to insert into `{verb}` placeholders.
 * @property {string[]} grammar.adjectives - List of adjectives to insert into `{adj}` placeholders.
 *
 * @property {boolean} repeatWords - If false, avoids repeating the same word within a single generation.
 * @property {EmojiPlacement} emojiPlacement - Controls how emojis are placed in the text.
 *
 * @property {Object} [paragraphs] - Optional paragraph configuration.
 * @property {number} paragraphs.min - Minimum number of paragraphs to generate.
 * @property {number} paragraphs.max - Maximum number of paragraphs to generate.
 *
 * @property {Object} line - Configuration for line-based generation.
 * @property {number} line.minLength - Minimum number of characters per line.
 * @property {number} line.maxLength - Maximum number of characters per line.
 * @property {number} line.emojiChance - Probability (0 to 1) that a line will end with an emoji when allowed.
 */
/**
 * UltraRandomMsgGen - Phrase templates and word lists
 *
 * Portions of the templates, word sets, and phrase structures
 * were generated and expanded by ChatGPT (OpenAI).
 *
 * This content was crafted to produce innocent, playful, and diverse
 * random messages focused on a pudding-themed, whimsical style.
 *
 * @class
 */
var UltraRandomMsgGen = /*#__PURE__*/function () {
  /**
   * Creates an instance of UltraRandomMsgGen.
   *
   * @param {Object} [config={}] - Configuration object to customize the generator.
   * @param {number} [config.minLength=10] - Minimum total length (in characters) of generated text.
   * @param {number} [config.maxLength=300] - Maximum total length (in characters) of generated text.
   * @param {boolean} [config.readable=true] - Whether to generate readable words or random strings.
   * @param {boolean} [config.useEmojis=true] - Whether to include emojis in the generated text.
   * @param {boolean} [config.includeNumbers=true] - Whether to include numbers randomly.
   * @param {boolean} [config.includeSymbols=true] - Whether to include symbols randomly.
   * @param {boolean} [config.allowWeirdSpacing=false] - Whether to allow weird spacing (newlines, extra spaces, uppercase).
   * @param {string[]} [config.emojiSet] - Array of emojis to use (defaults to internal emoji set).
   * @param {string[]} [config.wordSet] - Array of words to use (defaults to internal word set).
   * @param {RandomMsgModes} [config.mode='mixed'] - Mode of text generation.
   * @param {Object} [config.grammar] - Grammar configuration with templates and word categories.
   * @param {string[]} [config.grammar.templates] - Array of string templates with placeholders for generating sentences.
   * @param {string[]} [config.grammar.nouns] - Array of noun strings for template substitution.
   * @param {string[]} [config.grammar.verbs] - Array of verb strings for template substitution.
   * @param {string[]} [config.grammar.adjectives] - Array of adjective strings for template substitution.
   * @param {boolean} [config.repeatWords=true] - Whether to allow repeating words in the output.
   * @param {EmojiPlacement} [config.emojiPlacement='inline'] - Placement mode for emojis in generated text.
   * @param {Object} [config.paragraphs] - Paragraph configuration object or null for single block text.
   * @param {number} [config.paragraphs.min] - Minimum number of paragraphs to generate.
   * @param {number} [config.paragraphs.max] - Maximum number of paragraphs to generate.
   * @param {Object} [config.line] - Line configuration for generated text.
   * @param {number} [config.line.minLength=20] - Minimum length (characters) per line.
   * @param {number} [config.line.maxLength=120] - Maximum length (characters) per line.
   * @param {number} [config.line.emojiChance=0.3] - Probability (0â1) of placing emoji per line.
   */
  function UltraRandomMsgGen() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, UltraRandomMsgGen);
    /** @type {MsgGenConfig} */
    _defineProperty(this, "config", {
      minLength: 10,
      maxLength: 300,
      readable: true,
      useEmojis: true,
      includeNumbers: true,
      includeSymbols: true,
      allowWeirdSpacing: false,
      emojiSet: [],
      wordSet: [],
      mode: 'mixed',
      // 'mixed', 'readable', 'chaotic'
      grammar: {
        templates: [],
        nouns: [],
        verbs: [],
        adjectives: []
      },
      repeatWords: true,
      emojiPlacement: 'inline',
      // 'inline' | 'end' | 'none'
      line: {
        minLength: 20,
        maxLength: 120,
        emojiChance: 0.3 // 30% chance per line
      }
    });
    this.symbols = '!@#$%^&*()-_=+[]{}|;:,.<>?/\\~'.split('');
    var minLength = config.minLength,
      maxLength = config.maxLength,
      readable = config.readable,
      useEmojis = config.useEmojis,
      includeNumbers = config.includeNumbers,
      includeSymbols = config.includeSymbols,
      allowWeirdSpacing = config.allowWeirdSpacing,
      emojiSet = config.emojiSet,
      wordSet = config.wordSet,
      mode = config.mode,
      grammar = config.grammar,
      repeatWords = config.repeatWords,
      emojiPlacement = config.emojiPlacement,
      paragraphs = config.paragraphs,
      line = config.line;
    // Validations
    if (minLength !== undefined && (!Number.isInteger(minLength) || minLength < 1)) {
      throw new TypeError('config.minLength must be an integer >= 1');
    }
    if (maxLength !== undefined && (!Number.isInteger(maxLength) || maxLength < 1)) {
      throw new TypeError('config.maxLength must be an integer >= 1');
    }
    if (minLength !== undefined && maxLength !== undefined && minLength > maxLength) {
      throw new RangeError('config.minLength cannot be greater than config.maxLength');
    }
    if (readable !== undefined && typeof readable !== 'boolean') {
      throw new TypeError('config.readable must be a boolean');
    }
    if (useEmojis !== undefined && typeof useEmojis !== 'boolean') {
      throw new TypeError('config.useEmojis must be a boolean');
    }
    if (includeNumbers !== undefined && typeof includeNumbers !== 'boolean') {
      throw new TypeError('config.includeNumbers must be a boolean');
    }
    if (includeSymbols !== undefined && typeof includeSymbols !== 'boolean') {
      throw new TypeError('config.includeSymbols must be a boolean');
    }
    if (allowWeirdSpacing !== undefined && typeof allowWeirdSpacing !== 'boolean') {
      throw new TypeError('config.allowWeirdSpacing must be a boolean');
    }
    if (emojiSet !== undefined && !Array.isArray(emojiSet)) {
      throw new TypeError('config.emojiSet must be an array of strings');
    }
    if (wordSet !== undefined && !Array.isArray(wordSet)) {
      throw new TypeError('config.wordSet must be an array of strings');
    }
    if (mode !== undefined && !['mixed', 'readable', 'chaotic', 'natural'].includes(mode)) {
      throw new RangeError('config.mode must be one of: "mixed", "readable", "chaotic", "natural');
    }
    if (grammar !== undefined) {
      if (_typeof(grammar) !== 'object' || grammar === null) {
        throw new TypeError('config.grammar must be an object');
      }
      var templates = grammar.templates,
        nouns = grammar.nouns,
        verbs = grammar.verbs,
        adjectives = grammar.adjectives;
      if (templates !== undefined && !Array.isArray(templates)) {
        throw new TypeError('config.grammar.templates must be an array of strings');
      }
      if (nouns !== undefined && !Array.isArray(nouns)) {
        throw new TypeError('config.grammar.nouns must be an array of strings');
      }
      if (verbs !== undefined && !Array.isArray(verbs)) {
        throw new TypeError('config.grammar.verbs must be an array of strings');
      }
      if (adjectives !== undefined && !Array.isArray(adjectives)) {
        throw new TypeError('config.grammar.adjectives must be an array of strings');
      }
    }
    if (repeatWords !== undefined && typeof repeatWords !== 'boolean') {
      throw new TypeError('config.repeatWords must be a boolean');
    }
    if (emojiPlacement !== undefined && !['inline', 'end', 'none'].includes(emojiPlacement)) {
      throw new RangeError('config.emojiPlacement must be one of: "inline", "end", "none"');
    }
    if (paragraphs !== undefined) {
      if (_typeof(paragraphs) !== 'object') {
        throw new TypeError('config.paragraphs must be an object or null');
      }
      var min = paragraphs.min,
        max = paragraphs.max;
      if (min !== undefined && (!Number.isInteger(min) || min < 1)) {
        throw new TypeError('config.paragraphs.min must be an integer >= 1');
      }
      if (max !== undefined && (!Number.isInteger(max) || max < 1)) {
        throw new TypeError('config.paragraphs.max must be an integer >= 1');
      }
      if (min !== undefined && max !== undefined && min > max) {
        throw new RangeError('config.paragraphs.min cannot be greater than config.paragraphs.max');
      }
    }
    if (line !== undefined) {
      if (_typeof(line) !== 'object' || line === null) {
        throw new TypeError('config.line must be an object');
      }
      var lineMin = line.minLength,
        lineMax = line.maxLength,
        emojiChance = line.emojiChance;
      if (lineMin !== undefined && (!Number.isInteger(lineMin) || lineMin < 1)) {
        throw new TypeError('config.line.minLength must be an integer >= 1');
      }
      if (lineMax !== undefined && (!Number.isInteger(lineMax) || lineMax < 1)) {
        throw new TypeError('config.line.maxLength must be an integer >= 1');
      }
      if (lineMin !== undefined && lineMax !== undefined && lineMin > lineMax) {
        throw new RangeError('config.line.minLength cannot be greater than config.line.maxLength');
      }
      if (emojiChance !== undefined && (typeof emojiChance !== 'number' || emojiChance < 0 || emojiChance > 1)) {
        throw new RangeError('config.line.emojiChance must be a number between 0 and 1');
      }
    }
    this.config.emojiSet = [].concat(defaultEmojis);
    this.config.wordSet = [].concat(defaultWords);
    this.config.grammar.templates = [].concat(defaultTemplates);
    this.config.grammar.nouns = [].concat(defaultNouns);
    this.config.grammar.verbs = [].concat(defaultVerbs);
    this.config.grammar.adjectives = [].concat(defaultAdjectives);
    Object.assign(this.config, config);
  }
  /**
   * Merges new configuration values into the current instance.
   * @param {Object} newConfig - Object with one or more configuration overrides.
   * @returns {UltraRandomMsgGen} - The instance for chaining.
   */
  return _createClass(UltraRandomMsgGen, [{
    key: "configure",
    value: function configure() {
      var newConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.assign(this.config, newConfig);
      return this;
    }
    /**
     * Replaces the entire list of grammar templates.
     * @param {...string[]} templates - One or more arrays or strings containing sentence templates.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setGrammarTemplates",
    value: function setGrammarTemplates() {
      for (var _len = arguments.length, templates = new Array(_len), _key = 0; _key < _len; _key++) {
        templates[_key] = arguments[_key];
      }
      this.config.grammar.templates = templates.flat();
      return this;
    }
    /**
     * Adds new grammar templates to the existing list.
     * @param {...string[]} templates - One or more arrays or strings containing sentence templates.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addGrammarTemplates",
    value: function addGrammarTemplates() {
      var _this$config$grammar$;
      for (var _len2 = arguments.length, templates = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        templates[_key2] = arguments[_key2];
      }
      (_this$config$grammar$ = this.config.grammar.templates).push.apply(_this$config$grammar$, _toConsumableArray(templates.flat()));
      return this;
    }
    /**
     * Replaces the list of noun words used in grammar templates.
     * @param {...string[]} nouns - One or more arrays or strings of nouns.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setGrammarNouns",
    value: function setGrammarNouns() {
      for (var _len3 = arguments.length, nouns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        nouns[_key3] = arguments[_key3];
      }
      this.config.grammar.nouns = nouns.flat();
      return this;
    }
    /**
     * Adds noun words to the existing list used in grammar templates.
     * @param {...string[]} nouns - One or more arrays or strings of nouns.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addGrammarNouns",
    value: function addGrammarNouns() {
      var _this$config$grammar$2;
      for (var _len4 = arguments.length, nouns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        nouns[_key4] = arguments[_key4];
      }
      (_this$config$grammar$2 = this.config.grammar.nouns).push.apply(_this$config$grammar$2, _toConsumableArray(nouns.flat()));
      return this;
    }
    /**
     * Replaces the list of verb words used in grammar templates.
     * @param {...string[]} verbs - One or more arrays or strings of verbs.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setGrammarVerbs",
    value: function setGrammarVerbs() {
      for (var _len5 = arguments.length, verbs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        verbs[_key5] = arguments[_key5];
      }
      this.config.grammar.verbs = verbs.flat();
      return this;
    }
    /**
     * Adds verb words to the existing list used in grammar templates.
     * @param {...string[]} verbs - One or more arrays or strings of verbs.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addGrammarVerbs",
    value: function addGrammarVerbs() {
      var _this$config$grammar$3;
      for (var _len6 = arguments.length, verbs = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        verbs[_key6] = arguments[_key6];
      }
      (_this$config$grammar$3 = this.config.grammar.verbs).push.apply(_this$config$grammar$3, _toConsumableArray(verbs.flat()));
      return this;
    }
    /**
     * Replaces the list of adjective words used in grammar templates.
     * @param {...string[]} adjectives - One or more arrays or strings of adjectives.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setGrammarAdjectives",
    value: function setGrammarAdjectives() {
      for (var _len7 = arguments.length, adjectives = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        adjectives[_key7] = arguments[_key7];
      }
      this.config.grammar.adjectives = adjectives.flat();
      return this;
    }
    /**
     * Adds adjective words to the existing list used in grammar templates.
     * @param {...string[]} adjectives - One or more arrays or strings of adjectives.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addGrammarAdjectives",
    value: function addGrammarAdjectives() {
      var _this$config$grammar$4;
      for (var _len8 = arguments.length, adjectives = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        adjectives[_key8] = arguments[_key8];
      }
      (_this$config$grammar$4 = this.config.grammar.adjectives).push.apply(_this$config$grammar$4, _toConsumableArray(adjectives.flat()));
      return this;
    }
    /**
     * Removes specific grammar templates from the current list.
     * @param {...string[]} templates - One or more arrays or strings of templates to remove.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeGrammarTemplates",
    value: function removeGrammarTemplates() {
      for (var _len9 = arguments.length, templates = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        templates[_key9] = arguments[_key9];
      }
      var removeSet = new Set(templates.flat());
      this.config.grammar.templates = this.config.grammar.templates.filter(function (t) {
        return !removeSet.has(t);
      });
      return this;
    }
    /**
     * Removes specific noun words from the grammar noun list.
     * @param {...string[]} nouns - One or more arrays or strings of nouns to remove.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeGrammarNouns",
    value: function removeGrammarNouns() {
      for (var _len0 = arguments.length, nouns = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {
        nouns[_key0] = arguments[_key0];
      }
      var removeSet = new Set(nouns.flat());
      this.config.grammar.nouns = this.config.grammar.nouns.filter(function (n) {
        return !removeSet.has(n);
      });
      return this;
    }
    /**
     * Removes specific verb words from the grammar verb list.
     * @param {...string[]} verbs - One or more arrays or strings of verbs to remove.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeGrammarVerbs",
    value: function removeGrammarVerbs() {
      for (var _len1 = arguments.length, verbs = new Array(_len1), _key1 = 0; _key1 < _len1; _key1++) {
        verbs[_key1] = arguments[_key1];
      }
      var removeSet = new Set(verbs.flat());
      this.config.grammar.verbs = this.config.grammar.verbs.filter(function (v) {
        return !removeSet.has(v);
      });
      return this;
    }
    /**
     * Removes specific adjective words from the grammar adjective list.
     * @param {...string[]} adjectives - One or more arrays or strings of adjectives to remove.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeGrammarAdjectives",
    value: function removeGrammarAdjectives() {
      for (var _len10 = arguments.length, adjectives = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        adjectives[_key10] = arguments[_key10];
      }
      var removeSet = new Set(adjectives.flat());
      this.config.grammar.adjectives = this.config.grammar.adjectives.filter(function (a) {
        return !removeSet.has(a);
      });
      return this;
    }
    /**
     * Replaces the entire word set used in readable/mixed modes.
     * @param {...string[]} words - One or more arrays or strings of words.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setWords",
    value: function setWords() {
      for (var _len11 = arguments.length, words = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        words[_key11] = arguments[_key11];
      }
      this.config.wordSet = words.flat();
      return this;
    }
    /**
     * Adds new words to the word set used in readable/mixed modes.
     * @param {...string[]} words - One or more arrays or strings of words.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addWords",
    value: function addWords() {
      var _this$config$wordSet;
      for (var _len12 = arguments.length, words = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        words[_key12] = arguments[_key12];
      }
      (_this$config$wordSet = this.config.wordSet).push.apply(_this$config$wordSet, _toConsumableArray(words.flat()));
      return this;
    }
    /**
     * Removes specific words from the word set.
     * @param {...string[]} words - Words to be removed.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeWords",
    value: function removeWords() {
      for (var _len13 = arguments.length, words = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        words[_key13] = arguments[_key13];
      }
      var removeSet = new Set(words.flat());
      this.config.wordSet = this.config.wordSet.filter(function (word) {
        return !removeSet.has(word);
      });
      return this;
    }
    /**
     * Replaces the emoji set used in generated output.
     * @param {...string[]} emojis - One or more arrays or strings of emojis.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setEmojis",
    value: function setEmojis() {
      for (var _len14 = arguments.length, emojis = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        emojis[_key14] = arguments[_key14];
      }
      this.config.emojiSet = emojis.flat();
      return this;
    }
    /**
     * Adds new emojis to the emoji set.
     * @param {...string[]} emojis - One or more arrays or strings of emojis.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addEmojis",
    value: function addEmojis() {
      var _this$config$emojiSet;
      for (var _len15 = arguments.length, emojis = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        emojis[_key15] = arguments[_key15];
      }
      (_this$config$emojiSet = this.config.emojiSet).push.apply(_this$config$emojiSet, _toConsumableArray(emojis.flat()));
      return this;
    }
    /**
     * Removes specific emojis from the emoji set.
     * @param {...string[]} emojis - Emojis to be removed.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeEmojis",
    value: function removeEmojis() {
      for (var _len16 = arguments.length, emojis = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        emojis[_key16] = arguments[_key16];
      }
      var removeSet = new Set(emojis.flat());
      this.config.emojiSet = this.config.emojiSet.filter(function (emoji) {
        return !removeSet.has(emoji);
      });
      return this;
    }
    /**
     * Returns a random item from an array.
     * @private
     * @param {string[]} array - Array to pick from.
     * @returns {string} - Random item from array.
     */
  }, {
    key: "_getRandomItem",
    value: function _getRandomItem(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    /**
     * Generates a single random content chunk based on the mode and settings.
     * @private
     * @returns {string} - A chunk (word, emoji, symbol, number, etc.).
     */
  }, {
    key: "_generateChunk",
    value: function _generateChunk() {
      var _this$config = this.config,
        wordSet = _this$config.wordSet,
        emojiSet = _this$config.emojiSet,
        includeNumbers = _this$config.includeNumbers,
        includeSymbols = _this$config.includeSymbols,
        useEmojis = _this$config.useEmojis,
        readable = _this$config.readable,
        mode = _this$config.mode,
        emojiPlacement = _this$config.emojiPlacement;
      if (mode === 'natural') {
        return this._generateNaturalSentence();
      }
      var pools = [];
      if (readable || mode === 'readable' || mode === 'mixed') {
        pools.push(this._getRandomItem(wordSet));
      }
      if (mode === 'chaotic' || mode === 'mixed') {
        pools.push(Math.random().toString(36).slice(2));
      }
      if (includeNumbers) {
        pools.push(Math.floor(Math.random() * 99999).toString());
      }
      if (includeSymbols) {
        pools.push(this._getRandomItem(this.symbols));
      }
      if (emojiPlacement === 'inline' && useEmojis && emojiSet.length) {
        pools.push(this._getRandomItem(emojiSet));
      }
      return this._getRandomItem(pools);
    }
    /**
     * Generates a natural sentence by replacing placeholders in a template.
     * @private
     * @returns {string} - A generated sentence.
     */
  }, {
    key: "_generateNaturalSentence",
    value: function _generateNaturalSentence() {
      var _this = this;
      var _this$config$grammar = this.config.grammar,
        templates = _this$config$grammar.templates,
        nouns = _this$config$grammar.nouns,
        verbs = _this$config$grammar.verbs,
        adjectives = _this$config$grammar.adjectives;
      var template = this._getRandomItem(templates);
      return template.replace(/{noun}/g, function () {
        return _this._getRandomItem(nouns);
      }).replace(/{verb}/g, function () {
        return _this._getRandomItem(verbs);
      }).replace(/{adj}/g, function () {
        return _this._getRandomItem(adjectives);
      });
    }
    /**
     * Generates a single line of text with target length and rules.
     * @private
     * @param {number} targetLength - Target character length for the line.
     * @param {Set<string>} [seenWords] - Set of already used words (for avoiding repeats).
     * @returns {string} - A generated line.
     */
  }, {
    key: "_generateLine",
    value: function _generateLine(targetLength, seenWords) {
      var _this$config2 = this.config,
        allowWeirdSpacing = _this$config2.allowWeirdSpacing,
        repeatWords = _this$config2.repeatWords,
        readable = _this$config2.readable,
        emojiSet = _this$config2.emojiSet,
        useEmojis = _this$config2.useEmojis,
        emojiPlacement = _this$config2.emojiPlacement,
        line = _this$config2.line;
      var parts = [];
      seenWords !== null && seenWords !== void 0 ? seenWords : seenWords = new Set();
      while (parts.join(' ').length < targetLength) {
        var chunk = this._generateChunk();
        if (!repeatWords && seenWords.has(chunk)) continue;
        seenWords.add(chunk);
        if (allowWeirdSpacing) {
          if (Math.random() < 0.1) chunk = '\n' + chunk;
          if (Math.random() < 0.1) chunk = '   ' + chunk;
          if (Math.random() < 0.05) chunk = chunk.toUpperCase();
        }
        parts.push(chunk);
      }
      var lineText = parts.join(readable ? ' ' : '');
      if (emojiPlacement === 'end' && useEmojis && emojiSet.length && Math.random() < ((line === null || line === void 0 ? void 0 : line.emojiChance) || 0)) {
        lineText += ' ' + this._getRandomItem(emojiSet);
      }
      return lineText;
    }
    /**
     * Generates lines to form a paragraph based on total length.
     * @private
     * @param {number} totalLength - Total target character count for the paragraph.
     * @returns {string[]} - Array of lines that form the paragraph.
     */
  }, {
    key: "_generateParagraphLines",
    value: function _generateParagraphLines(totalLength) {
      var line = this.config.line;
      var lines = [];
      var seenWords = new Set();
      var currentTotal = 0;
      while (currentTotal < totalLength) {
        var lineLength = Math.floor(Math.random() * (line.maxLength - line.minLength + 1) + line.minLength);
        var adjustedLength = Math.min(lineLength, totalLength - currentTotal);
        lines.push(this._generateLine(adjustedLength, seenWords));
        currentTotal += adjustedLength;
      }
      return lines;
    }
    /**
     * Generates the final random message, which can be a paragraph or block of lines.
     * Uses full configuration rules (grammar, symbols, emojis, etc).
     * @returns {string} - A full generated message.
     */
  }, {
    key: "generate",
    value: function generate() {
      var _this$config3 = this.config,
        minLength = _this$config3.minLength,
        maxLength = _this$config3.maxLength,
        paragraphs = _this$config3.paragraphs;
      var totalLength = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
      if (paragraphs && _typeof(paragraphs) === 'object') {
        var paraCount = Math.floor(Math.random() * (paragraphs.max - paragraphs.min + 1)) + paragraphs.min;
        var approxLength = Math.floor(totalLength / paraCount);
        var paragraphsArray = [];
        for (var i = 0; i < paraCount; i++) {
          var lines = this._generateParagraphLines(approxLength);
          paragraphsArray.push(lines.join('\n'));
        }
        return paragraphsArray.join('\n\n');
      }
      return this._generateParagraphLines(totalLength).join('\n');
    }
  }]);
}();
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultWords", defaultWords);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultEmojis", defaultEmojis);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultNouns", defaultNouns);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultVerbs", defaultVerbs);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultAdjectives", defaultAdjectives);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultTemplates", defaultTemplates);
var _default = exports["default"] = UltraRandomMsgGen;

},{}],204:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.createSingleton = exports.animateFill = void 0;
exports.delegate = delegate;
exports.sticky = exports.roundArrow = exports.inlinePositioning = exports.hideAll = exports.followCursor = void 0;
var _core = require("@popperjs/core");
/**!
* tippy.js v6.3.7
* (c) 2017-2021 atomiks
* MIT License
*/

var ROUND_ARROW = exports.roundArrow = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }
  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (obj[key] !== undefined) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement('div');
}
function isElement(value) {
  return ['Element', 'Fragment'].some(function (type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, 'NodeList');
}
function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements),
    element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body

  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
    clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
      popperState = _ref.popperState,
      props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
  // `webkitTransitionEnd`...

  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    box[method](event, listener);
  });
}
/**
 * Compared to xxx.contains, this function works for dom structures with shadow
 * dom
 */

function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener('blur', onWindowBlur);
}
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var isIE11 = isBrowser ?
// @ts-ignore
!!window.msCrypto : false;
function createMemoryLeakWarning(method) {
  var txt = method === 'destroy' ? 'n already-' : ' ';
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [getDevMessage(message),
  // title
  'color: #00C584; font-size: 1.3em; font-weight: bold;',
  // message
  'line-height: 1.5',
  // footer
  'color: #a6a095;'];
} // Assume warnings and errors never have the same message

var visitedMessages;
if (process.env.NODE_ENV !== "production") {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: 'fade',
  arrow: true,
  content: '',
  inertia: false,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: 'auto',
    expanded: 'auto'
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: '',
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  onClickOutside: function onClickOutside() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps(partialProps) {
  /* istanbul ignore else */
  if (process.env.NODE_ENV !== "production") {
    validateProps(partialProps, []);
  }
  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
      defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps);
}
function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys = Object.keys(partialProps);
  keys.forEach(function (prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function (plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
  });
}
var innerHTML = function innerHTML() {
  return 'innerHTML';
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow = div();
  if (value === true) {
    arrow.className = ARROW_CLASS;
  } else {
    arrow.className = SVG_ARROW_CLASS;
    if (isElement(value)) {
      arrow.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow, value);
    }
  }
  return arrow;
}
function setContent(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, '');
    content.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box: box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute('data-state', 'hidden');
  box.setAttribute('tabindex', '-1');
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');
  setContent(content, instance.props);
  popper.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper),
      box = _getChildren.box,
      content = _getChildren.content,
      arrow = _getChildren.arrow;
    if (nextProps.theme) {
      box.setAttribute('data-theme', nextProps.theme);
    } else {
      box.removeAttribute('data-theme');
    }
    if (typeof nextProps.animation === 'string') {
      box.setAttribute('data-animation', nextProps.animation);
    } else {
      box.removeAttribute('data-animation');
    }
    if (nextProps.inertia) {
      box.setAttribute('data-inertia', '');
    } else {
      box.removeAttribute('data-inertia');
    }
    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box.setAttribute('role', nextProps.role);
    } else {
      box.removeAttribute('role');
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow) {
        box.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box.removeChild(arrow);
        box.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow) {
      box.removeChild(arrow);
    }
  }
  return {
    popper: popper,
    onUpdate: onUpdate
  };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away

render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`

var mountedInstances = [];
function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
  // ð Private members
  // ===========================================================================

  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget; // ===========================================================================
  // ð Public members
  // ===========================================================================

  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: div(),
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    hideWithInteractivity: hideWithInteractivity,
    enable: enable,
    disable: disable,
    unmount: unmount,
    destroy: destroy
  }; // TODO: Investigate why this early return causes a TDZ error in the tests â
  // it doesn't seem to happen in the browser

  /* istanbul ignore if */

  if (!props.render) {
    if (process.env.NODE_ENV !== "production") {
      errorWhen(true, 'render() function has not been supplied.');
    }
    return instance;
  } // ===========================================================================
  // Initial mutations
  // ===========================================================================

  var _props$render = props.render(instance),
    popper = _props$render.popper,
    onUpdate = _props$render.onUpdate;
  popper.setAttribute('data-tippy-root', '');
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook('onCreate', [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding

  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function () {
    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
    }
  });
  return instance; // ===========================================================================
  // ð Private methods
  // ===========================================================================

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;

    // @ts-ignore
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }
  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
    popper.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    // Moved finger to scroll instead of an intentional tap outside
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === 'mousedown') {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

    if (instance.props.interactive && actualContains(popper, actualTarget)) {
      return;
    } // Clicked on the event listeners target

    if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
        return;
      }
    } else {
      invokeHook('onClickOutside', [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener('mousedown', onDocumentPress, true);
    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener('mousedown', onDocumentPress, true);
    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise

    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(box, 'add', listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, {
        passive: true
      });
      on('touchend', onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }
      on(eventType, onTrigger);
      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;
        case 'focus':
          on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;
        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
        eventType = _ref.eventType,
        handler = _ref.handler,
        options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips

    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
      var _instance$popperInsta;
      var instance = popper._tippy;
      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state) {
        return {
          popperRect: popper.getBoundingClientRect(),
          popperState: state,
          props: props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper

    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
      popperOptions = _instance$props2.popperOptions,
      placement = _instance$props2.placement,
      offset = _instance$props2.offset,
      getReferenceClientRect = _instance$props2.getReferenceClientRect,
      moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: '$$tippy',
      enabled: true,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref2) {
        var state = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
            box = _getDefaultTemplateCh.box;
          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
            if (attr === 'placement') {
              box.setAttribute('data-placement', state.placement);
            } else {
              if (state.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, '');
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: 'offset',
      options: {
        offset: offset
      }
    }, {
      name: 'preventOverflow',
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: 'flip',
      options: {
        padding: 5
      }
    }, {
      name: 'computeStyles',
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: 'arrow',
        options: {
          element: arrow,
          padding: 3
        }
      });
    }
    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = (0, _core.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {
      placement: placement,
      onFirstUpdate: onFirstUpdate,
      modifiers: modifiers
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper needs to read its dimensions

    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    /* istanbul ignore else */

    if (process.env.NODE_ENV !== "production") {
      // Accessibility check
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
      touchValue = _getNormalizedTouchSe[0],
      touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.

    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  } // ===========================================================================
  // ð Public methods
  // ===========================================================================

  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    } // Ensure stale aria-expanded attributes are removed

    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
      // and the nested ones get re-rendered first.
      // https://github.com/atomiks/tippyjs-react/issues/177
      // TODO: find a cleaner / more efficient solution(!)

      getNestedPopperTree().forEach(function (nestedPopper) {
        // React (and other UI libs likely) requires a rAF wrapper as it flushes
        // its work in one
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook('onAfterUpdate', [instance, partialProps]);
  }
  function setContent(content) {
    instance.setProps({
      content: content
    });
  }
  function show() {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
    } // Early bail-out

    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.

    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }
    invokeHook('onShow', [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'visible';
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper.style.transition = 'none';
    } // If flipping to the opposite side after hiding at least once, the
    // animation will use the wrong placement without resetting the duration

    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
        box = _getDefaultTemplateCh2.box,
        content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true; // reflow

      void popper.offsetHeight;
      popper.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
          _box = _getDefaultTemplateCh3.box,
          _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], 'visible');
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
      // popper has been positioned for the first time

      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook('onMount', [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook('onShown', [instance]);
        });
      }
    };
    mount();
  }
  function hide() {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
    } // Early bail-out

    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook('onHide', [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'hidden';
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
        box = _getDefaultTemplateCh4.box,
        content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], 'hidden');
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
    }
    getDocument().addEventListener('mousemove', debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
    // tree by default. This seems mainly for interactive tippies, but we should
    // find a workaround if possible

    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }
    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook('onHidden', [instance]);
  }
  function destroy() {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  /* istanbul ignore else */

  if (process.env.NODE_ENV !== "production") {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins
  });
  var elements = getArrayOfElements(targets);
  /* istanbul ignore else */

  if (process.env.NODE_ENV !== "production") {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
  }
  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var hideAll = exports.hideAll = function hideAll(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    excludedReferenceOrInstance = _ref.exclude,
    duration = _ref.duration;
  mountedInstances.forEach(function (instance) {
    var isExcluded = false;
    if (excludedReferenceOrInstance) {
      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
    }
    if (!isExcluded) {
      var originalDuration = instance.props.duration;
      instance.setProps({
        duration: duration
      });
      instance.hide();
      if (!instance.state.isDestroyed) {
        instance.setProps({
          duration: originalDuration
        });
      }
    }
  });
};

// every time the popper is destroyed (i.e. a new target), removing the styles
// and causing transitions to break for singletons when the console is open, but
// most notably for non-transform styles being used, `gpuAcceleration: false`.

var applyStylesModifier = Object.assign({}, _core.applyStyles, {
  effect: function effect(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    } // intentionally return no cleanup function
    // return () => { ... }
  }
});
var createSingleton = exports.createSingleton = function createSingleton(tippyInstances, optionalProps) {
  var _optionalProps$popper;
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== "production") {
    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));
  }
  var individualInstances = tippyInstances;
  var references = [];
  var triggerTargets = [];
  var currentTarget;
  var overrides = optionalProps.overrides;
  var interceptSetPropsCleanups = [];
  var shownOnCreate = false;
  function setTriggerTargets() {
    triggerTargets = individualInstances.map(function (instance) {
      return normalizeToArray(instance.props.triggerTarget || instance.reference);
    }).reduce(function (acc, item) {
      return acc.concat(item);
    }, []);
  }
  function setReferences() {
    references = individualInstances.map(function (instance) {
      return instance.reference;
    });
  }
  function enableInstances(isEnabled) {
    individualInstances.forEach(function (instance) {
      if (isEnabled) {
        instance.enable();
      } else {
        instance.disable();
      }
    });
  }
  function interceptSetProps(singleton) {
    return individualInstances.map(function (instance) {
      var originalSetProps = instance.setProps;
      instance.setProps = function (props) {
        originalSetProps(props);
        if (instance.reference === currentTarget) {
          singleton.setProps(props);
        }
      };
      return function () {
        instance.setProps = originalSetProps;
      };
    });
  } // have to pass singleton, as it maybe undefined on first call

  function prepareInstance(singleton, target) {
    var index = triggerTargets.indexOf(target); // bail-out

    if (target === currentTarget) {
      return;
    }
    currentTarget = target;
    var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
      acc[prop] = individualInstances[index].props[prop];
      return acc;
    }, {});
    singleton.setProps(Object.assign({}, overrideProps, {
      getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {
        var _references$index;
        return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();
      }
    }));
  }
  enableInstances(false);
  setReferences();
  setTriggerTargets();
  var plugin = {
    fn: function fn() {
      return {
        onDestroy: function onDestroy() {
          enableInstances(true);
        },
        onHidden: function onHidden() {
          currentTarget = null;
        },
        onClickOutside: function onClickOutside(instance) {
          if (instance.props.showOnCreate && !shownOnCreate) {
            shownOnCreate = true;
            currentTarget = null;
          }
        },
        onShow: function onShow(instance) {
          if (instance.props.showOnCreate && !shownOnCreate) {
            shownOnCreate = true;
            prepareInstance(instance, references[0]);
          }
        },
        onTrigger: function onTrigger(instance, event) {
          prepareInstance(instance, event.currentTarget);
        }
      };
    }
  };
  var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
    plugins: [plugin].concat(optionalProps.plugins || []),
    triggerTarget: triggerTargets,
    popperOptions: Object.assign({}, optionalProps.popperOptions, {
      modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])
    })
  }));
  var originalShow = singleton.show;
  singleton.show = function (target) {
    originalShow(); // first time, showOnCreate or programmatic call with no params
    // default to showing first instance

    if (!currentTarget && target == null) {
      return prepareInstance(singleton, references[0]);
    } // triggered from event (do nothing as prepareInstance already called by onTrigger)
    // programmatic call with no params when already visible (do nothing again)

    if (currentTarget && target == null) {
      return;
    } // target is index of instance

    if (typeof target === 'number') {
      return references[target] && prepareInstance(singleton, references[target]);
    } // target is a child tippy instance

    if (individualInstances.indexOf(target) >= 0) {
      var ref = target.reference;
      return prepareInstance(singleton, ref);
    } // target is a ReferenceElement

    if (references.indexOf(target) >= 0) {
      return prepareInstance(singleton, target);
    }
  };
  singleton.showNext = function () {
    var first = references[0];
    if (!currentTarget) {
      return singleton.show(0);
    }
    var index = references.indexOf(currentTarget);
    singleton.show(references[index + 1] || first);
  };
  singleton.showPrevious = function () {
    var last = references[references.length - 1];
    if (!currentTarget) {
      return singleton.show(last);
    }
    var index = references.indexOf(currentTarget);
    var target = references[index - 1] || last;
    singleton.show(target);
  };
  var originalSetProps = singleton.setProps;
  singleton.setProps = function (props) {
    overrides = props.overrides || overrides;
    originalSetProps(props);
  };
  singleton.setInstances = function (nextInstances) {
    enableInstances(true);
    interceptSetPropsCleanups.forEach(function (fn) {
      return fn();
    });
    individualInstances = nextInstances;
    enableInstances(false);
    setReferences();
    setTriggerTargets();
    interceptSetPropsCleanups = interceptSetProps(singleton);
    singleton.setProps({
      triggerTarget: triggerTargets
    });
  };
  interceptSetPropsCleanups = interceptSetProps(singleton);
  return singleton;
};
var BUBBLING_EVENTS_MAP = {
  mouseover: 'mouseenter',
  focusin: 'focus',
  click: 'click'
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */

function delegate(targets, props) {
  /* istanbul ignore else */
  if (process.env.NODE_ENV !== "production") {
    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
  }
  var listeners = [];
  var childTippyInstances = [];
  var disabled = false;
  var target = props.target;
  var nativeProps = removeProperties(props, ['target']);
  var parentProps = Object.assign({}, nativeProps, {
    trigger: 'manual',
    touch: false
  });
  var childProps = Object.assign({
    touch: defaultProps.touch
  }, nativeProps, {
    showOnCreate: true
  });
  var returnValue = tippy(targets, parentProps);
  var normalizedReturnValue = normalizeToArray(returnValue);
  function onTrigger(event) {
    if (!event.target || disabled) {
      return;
    }
    var targetNode = event.target.closest(target);
    if (!targetNode) {
      return;
    } // Get relevant trigger with fallbacks:
    // 1. Check `data-tippy-trigger` attribute on target node
    // 2. Fallback to `trigger` passed to `delegate()`
    // 3. Fallback to `defaultProps.trigger`

    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

    if (targetNode._tippy) {
      return;
    }
    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
      return;
    }
    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {
      return;
    }
    var instance = tippy(targetNode, childProps);
    if (instance) {
      childTippyInstances = childTippyInstances.concat(instance);
    }
  }
  function on(node, eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    node.addEventListener(eventType, handler, options);
    listeners.push({
      node: node,
      eventType: eventType,
      handler: handler,
      options: options
    });
  }
  function addEventListeners(instance) {
    var reference = instance.reference;
    on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);
    on(reference, 'mouseover', onTrigger);
    on(reference, 'focusin', onTrigger);
    on(reference, 'click', onTrigger);
  }
  function removeEventListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
        eventType = _ref.eventType,
        handler = _ref.handler,
        options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function applyMutations(instance) {
    var originalDestroy = instance.destroy;
    var originalEnable = instance.enable;
    var originalDisable = instance.disable;
    instance.destroy = function (shouldDestroyChildInstances) {
      if (shouldDestroyChildInstances === void 0) {
        shouldDestroyChildInstances = true;
      }
      if (shouldDestroyChildInstances) {
        childTippyInstances.forEach(function (instance) {
          instance.destroy();
        });
      }
      childTippyInstances = [];
      removeEventListeners();
      originalDestroy();
    };
    instance.enable = function () {
      originalEnable();
      childTippyInstances.forEach(function (instance) {
        return instance.enable();
      });
      disabled = false;
    };
    instance.disable = function () {
      originalDisable();
      childTippyInstances.forEach(function (instance) {
        return instance.disable();
      });
      disabled = true;
    };
    addEventListeners(instance);
  }
  normalizedReturnValue.forEach(applyMutations);
  return returnValue;
}
var animateFill = exports.animateFill = {
  name: 'animateFill',
  defaultValue: false,
  fn: function fn(instance) {
    var _instance$props$rende;

    // @ts-ignore
    if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {
      if (process.env.NODE_ENV !== "production") {
        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');
      }
      return {};
    }
    var _getChildren = getChildren(instance.popper),
      box = _getChildren.box,
      content = _getChildren.content;
    var backdrop = instance.props.animateFill ? createBackdropElement() : null;
    return {
      onCreate: function onCreate() {
        if (backdrop) {
          box.insertBefore(backdrop, box.firstElementChild);
          box.setAttribute('data-animatefill', '');
          box.style.overflow = 'hidden';
          instance.setProps({
            arrow: false,
            animation: 'shift-away'
          });
        }
      },
      onMount: function onMount() {
        if (backdrop) {
          var transitionDuration = box.style.transitionDuration;
          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
          // tooltip element. `clip-path` is the other alternative but is not
          // well-supported and is buggy on some devices.

          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          setVisibilityState([backdrop], 'visible');
        }
      },
      onShow: function onShow() {
        if (backdrop) {
          backdrop.style.transitionDuration = '0ms';
        }
      },
      onHide: function onHide() {
        if (backdrop) {
          setVisibilityState([backdrop], 'hidden');
        }
      }
    };
  }
};
function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  setVisibilityState([backdrop], 'hidden');
  return backdrop;
}
var mouseCoords = {
  clientX: 0,
  clientY: 0
};
var activeInstances = [];
function storeMouseCoords(_ref) {
  var clientX = _ref.clientX,
    clientY = _ref.clientY;
  mouseCoords = {
    clientX: clientX,
    clientY: clientY
  };
}
function addMouseCoordsListener(doc) {
  doc.addEventListener('mousemove', storeMouseCoords);
}
function removeMouseCoordsListener(doc) {
  doc.removeEventListener('mousemove', storeMouseCoords);
}
var followCursor = exports.followCursor = {
  name: 'followCursor',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;
    var doc = getOwnerDocument(instance.props.triggerTarget || reference);
    var isInternalUpdate = false;
    var wasFocusEvent = false;
    var isUnmounted = true;
    var prevProps = instance.props;
    function getIsInitialBehavior() {
      return instance.props.followCursor === 'initial' && instance.state.isVisible;
    }
    function addListener() {
      doc.addEventListener('mousemove', onMouseMove);
    }
    function removeListener() {
      doc.removeEventListener('mousemove', onMouseMove);
    }
    function unsetGetReferenceClientRect() {
      isInternalUpdate = true;
      instance.setProps({
        getReferenceClientRect: null
      });
      isInternalUpdate = false;
    }
    function onMouseMove(event) {
      // If the instance is interactive, avoid updating the position unless it's
      // over the reference element
      var isCursorOverReference = event.target ? reference.contains(event.target) : true;
      var followCursor = instance.props.followCursor;
      var clientX = event.clientX,
        clientY = event.clientY;
      var rect = reference.getBoundingClientRect();
      var relativeX = clientX - rect.left;
      var relativeY = clientY - rect.top;
      if (isCursorOverReference || !instance.props.interactive) {
        instance.setProps({
          // @ts-ignore - unneeded DOMRect properties
          getReferenceClientRect: function getReferenceClientRect() {
            var rect = reference.getBoundingClientRect();
            var x = clientX;
            var y = clientY;
            if (followCursor === 'initial') {
              x = rect.left + relativeX;
              y = rect.top + relativeY;
            }
            var top = followCursor === 'horizontal' ? rect.top : y;
            var right = followCursor === 'vertical' ? rect.right : x;
            var bottom = followCursor === 'horizontal' ? rect.bottom : y;
            var left = followCursor === 'vertical' ? rect.left : x;
            return {
              width: right - left,
              height: bottom - top,
              top: top,
              right: right,
              bottom: bottom,
              left: left
            };
          }
        });
      }
    }
    function create() {
      if (instance.props.followCursor) {
        activeInstances.push({
          instance: instance,
          doc: doc
        });
        addMouseCoordsListener(doc);
      }
    }
    function destroy() {
      activeInstances = activeInstances.filter(function (data) {
        return data.instance !== instance;
      });
      if (activeInstances.filter(function (data) {
        return data.doc === doc;
      }).length === 0) {
        removeMouseCoordsListener(doc);
      }
    }
    return {
      onCreate: create,
      onDestroy: destroy,
      onBeforeUpdate: function onBeforeUpdate() {
        prevProps = instance.props;
      },
      onAfterUpdate: function onAfterUpdate(_, _ref2) {
        var followCursor = _ref2.followCursor;
        if (isInternalUpdate) {
          return;
        }
        if (followCursor !== undefined && prevProps.followCursor !== followCursor) {
          destroy();
          if (followCursor) {
            create();
            if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {
              addListener();
            }
          } else {
            removeListener();
            unsetGetReferenceClientRect();
          }
        }
      },
      onMount: function onMount() {
        if (instance.props.followCursor && !wasFocusEvent) {
          if (isUnmounted) {
            onMouseMove(mouseCoords);
            isUnmounted = false;
          }
          if (!getIsInitialBehavior()) {
            addListener();
          }
        }
      },
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          mouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY
          };
        }
        wasFocusEvent = event.type === 'focus';
      },
      onHidden: function onHidden() {
        if (instance.props.followCursor) {
          unsetGetReferenceClientRect();
          removeListener();
          isUnmounted = true;
        }
      }
    };
  }
};
function getProps(props, modifier) {
  var _props$popperOptions;
  return {
    popperOptions: Object.assign({}, props.popperOptions, {
      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {
        var name = _ref.name;
        return name !== modifier.name;
      }), [modifier])
    })
  };
}
var inlinePositioning = exports.inlinePositioning = {
  name: 'inlinePositioning',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;
    function isEnabled() {
      return !!instance.props.inlinePositioning;
    }
    var placement;
    var cursorRectIndex = -1;
    var isInternalUpdate = false;
    var triedPlacements = [];
    var modifier = {
      name: 'tippyInlinePositioning',
      enabled: true,
      phase: 'afterWrite',
      fn: function fn(_ref2) {
        var state = _ref2.state;
        if (isEnabled()) {
          if (triedPlacements.indexOf(state.placement) !== -1) {
            triedPlacements = [];
          }
          if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {
            triedPlacements.push(state.placement);
            instance.setProps({
              // @ts-ignore - unneeded DOMRect properties
              getReferenceClientRect: function getReferenceClientRect() {
                return _getReferenceClientRect(state.placement);
              }
            });
          }
          placement = state.placement;
        }
      }
    };
    function _getReferenceClientRect(placement) {
      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
    }
    function setInternalProps(partialProps) {
      isInternalUpdate = true;
      instance.setProps(partialProps);
      isInternalUpdate = false;
    }
    function addModifier() {
      if (!isInternalUpdate) {
        setInternalProps(getProps(instance.props, modifier));
      }
    }
    return {
      onCreate: addModifier,
      onAfterUpdate: addModifier,
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          var rects = arrayFrom(instance.reference.getClientRects());
          var cursorRect = rects.find(function (rect) {
            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
          });
          var index = rects.indexOf(cursorRect);
          cursorRectIndex = index > -1 ? index : cursorRectIndex;
        }
      },
      onHidden: function onHidden() {
        cursorRectIndex = -1;
      }
    };
  }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
  // Not an inline element, or placement is not yet known
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  } // There are two rects and they are disjoined

  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
    return clientRects[cursorRectIndex] || boundingRect;
  }
  switch (currentBasePlacement) {
    case 'top':
    case 'bottom':
      {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === 'top';
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top: top,
          bottom: bottom,
          left: left,
          right: right,
          width: width,
          height: height
        };
      }
    case 'left':
    case 'right':
      {
        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function (rect) {
          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;
        var _width = _right - _left;
        var _height = _bottom - _top;
        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }
    default:
      {
        return boundingRect;
      }
  }
}
var sticky = exports.sticky = {
  name: 'sticky',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
      popper = instance.popper;
    function getReference() {
      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
    }
    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }
    var prevRefRect = null;
    var prevPopRect = null;
    function updatePosition() {
      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;
      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
        if (instance.popperInstance) {
          instance.popperInstance.update();
        }
      }
      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;
      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }
    return {
      onMount: function onMount() {
        if (instance.props.sticky) {
          updatePosition();
        }
      }
    };
  }
};
function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
  }
  return true;
}
tippy.setDefaultProps({
  render: render
});
var _default = exports["default"] = tippy;

}).call(this)}).call(this,require('_process'))
},{"@popperjs/core":31,"_process":111}],205:[function(require,module,exports){
module.exports=function(e){var r={};function t(n){if(r[n])return r[n].exports;var a=r[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var a in e)t.d(n,a,function(r){return e[r]}.bind(null,a));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=0)}([function(e,r,t){"use strict";t.r(r),t.d(r,"validateHTMLColorName",(function(){return l})),t.d(r,"validateHTMLColorSpecialName",(function(){return i})),t.d(r,"validateHTMLColorHex",(function(){return u})),t.d(r,"validateHTMLColorRgb",(function(){return g})),t.d(r,"validateHTMLColorHsl",(function(){return y})),t.d(r,"validateHTMLColorHwb",(function(){return L})),t.d(r,"validateHTMLColorLab",(function(){return S})),t.d(r,"validateHTMLColorLch",(function(){return m})),t.d(r,"validateHTMLColor",(function(){return G}));const n=e=>e&&"string"==typeof e,a=["AliceBlue","AntiqueWhite","Aqua","Aquamarine","Azure","Beige","Bisque","Black","BlanchedAlmond","Blue","BlueViolet","Brown","BurlyWood","CadetBlue","Chartreuse","Chocolate","Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","DarkBlue","DarkCyan","DarkGoldenrod","DarkGray","DarkGrey","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","DarkOrange","DarkOrchid","DarkRed","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray","DarkSlateGrey","DarkTurquoise","DarkViolet","DeepPink","DeepSkyBlue","DimGray","DimGrey","DodgerBlue","FireBrick","FloralWhite","ForestGreen","Fuchsia","Gainsboro","GhostWhite","Gold","Goldenrod","Gray","Grey","Green","GreenYellow","HoneyDew","HotPink","IndianRed","Indigo","Ivory","Khaki","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral","LightCyan","LightGoldenrodYellow","LightGray","LightGrey","LightGreen","LightPink","LightSalmon","LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSlateGrey","LightSteelBlue","LightYellow","Lime","LimeGreen","Linen","Magenta","Maroon","MediumAquamarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen","MediumSlateBlue","MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue","MintCream","MistyRose","Moccasin","NavajoWhite","Navy","OldLace","Olive","OliveDrab","Orange","OrangeRed","Orchid","PaleGoldenrod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip","PeachPuff","Peru","Pink","Plum","PowderBlue","Purple","RebeccaPurple","Red","RosyBrown","RoyalBlue","SaddleBrown","Salmon","SandyBrown","SeaGreen","SeaShell","Sienna","Silver","SkyBlue","SlateBlue","SlateGray","SlateGrey","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle","Tomato","Turquoise","Violet","Wheat","White","WhiteSmoke","Yellow","YellowGreen"],o=["currentColor","inherit","transparent"],l=e=>{let r=!1;return n(e)&&a.map(t=>(e.toLowerCase()===t.toLowerCase()&&(r=!0),null)),r},i=e=>{let r=!1;return n(e)&&o.map(t=>(e.toLowerCase()===t.toLowerCase()&&(r=!0),null)),r},u=e=>{if(n(e)){const r=/^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$/i;return e&&r.test(e)}return!1},d="(([\\d]{0,5})((\\.([\\d]{1,5}))?))",s=`(${d}%)`,c="(([0-9]|[1-9][0-9]|100)%)",f=`(${c}|(0?((\\.([\\d]{1,5}))?))|1)`,h=`([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?)([\\s]{1,5})${`(((${c}))|(0?((\\.([\\d]{1,5}))?))|1))?`}([\\s]{0,5})\\)`,$="(-?(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360)(deg)?)",g=e=>{if(n(e)){const r="([\\s]{0,5})([\\d]{1,5})%?([\\s]{0,5}),?",t="((([\\s]{0,5}),?([\\s]{0,5}))|(([\\s]{1,5})))",n=new RegExp(`^(rgb)a?\\(${`${r}${t}`}${`${r}${t}`}${`${r}${t}`}(${"(\\/?([\\s]{0,5})(0?\\.?([\\d]{1,5})%?([\\s]{0,5}))?|1|0)"})?\\)$`);return e&&n.test(e)}return!1},y=e=>{if(n(e)){const r=new RegExp(`^(hsl)a?\\((([\\s]{0,5})(${$}|${"(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-9][0-9]|400)grad)"}|${"((([0-5])?\\.([\\d]{1,5})|6\\.([0-9]|1[0-9]|2[0-8])|[0-6])rad)"}|${"((0?((\\.([\\d]{1,5}))?)|1)turn)"})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${c})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${c})([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?|,?)([\\s]{0,5})(((${c}))|(0?((\\.([\\d]{1,5}))?))|1))?\\)$`);return e&&r.test(e)}return!1},L=e=>{if(n(e)){const r=new RegExp(`^(hwb\\(([\\s]{0,5})${$}([\\s]{1,5}))((0|${c})([\\s]{1,5}))((0|${c})${h}$`);return e&&r.test(e)}return!1},S=e=>{if(n(e)){const r="(-?(([0-9]|[1-9][0-9]|1[0-5][0-9])((\\.([\\d]{1,5}))?)?|160))",t=new RegExp(`^(lab\\(([\\s]{0,5})${s}([\\s]{1,5})${r}([\\s]{1,5})${r}${h}$`);return e&&t.test(e)}return!1},m=e=>{if(n(e)){const r="((([0-9]|[1-9][0-9])?((\\.([\\d]{1,5}))?)|100)(%)?)",t=""+d,n=`((${$})|(0|${f})|(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360))`,a=`(\\/([\\s]{0,5})${f})`,o=new RegExp(`^lch\\(${`(([\\s]{0,5})${r}([\\s]{1,5})${t}([\\s]{1,5})${n}([\\s]{0,5})(${a})?)`}\\)$`);return e&&o.test(e)}return!1},G=e=>!!(e&&u(e)||g(e)||y(e)||L(e)||S(e)||m(e));r.default=e=>!!(e&&u(e)||l(e)||i(e)||g(e)||y(e)||L(e)||S(e)||m(e))}]);
},{}],206:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _moment = _interopRequireDefault(require("moment"));
var _objectHash = _interopRequireDefault(require("object-hash"));
var _jquery = _interopRequireDefault(require("jquery"));
var _tinyLib = _interopRequireDefault(require("../files/tinyLib.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * UserRoomManager
 *
 * UI Component to manage users in a real-time room environment.
 *
 * Created by: Yasmin Seidel (JasminDreasond)
 * Co-developed with: ChatGPT (OpenAI) as coding assistant
 *
 * @param {Object} config
 * @param {string} config.currentUserId - The userId of the current logged-in user.
 * @param {boolean} config.isOwner - Whether the current user is the owner of the room.
 * @param {jQuery} config.target - DOM element where the manager will be rendered.
 *
 * @example
 * const manager = new UserRoomManager({
 *   currentUserId: 'meow123',
 *   isOwner: true,
 *   root: $('#room-content'),
 * });
 *
 * manager.addUser('user1', { nickname: 'Twilight', ping: Date.now() });
 * manager.setModerators([{ userId: 'user1' }]);
 */
var _usersHtml = /*#__PURE__*/new WeakMap();
var _client = /*#__PURE__*/new WeakMap();
var _UserRoomManager_brand = /*#__PURE__*/new WeakSet();
var UserRoomManager = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the user room manager.
   *
   * @param {Object} options - The configuration object.
   * @param {Object} options.client - The client instance used for communication.
   * @param {jQuery} options.root - The root DOM element where the UI will be rendered.
   * @param {string} options.currentUserId - The ID of the current user.
   * @param {Object<string, Object>} [options.users={}] - An object containing user data, keyed by user ID.
   * @param {Array<Object>} [options.moderators=[]] - An array of moderator objects, each containing at least a `userId`.
   * @param {boolean} [options.isOwner=false] - Whether the current user is the room owner.
   */
  function UserRoomManager(_ref) {
    var client = _ref.client,
      root = _ref.root,
      currentUserId = _ref.currentUserId,
      users = _ref.users,
      moderators = _ref.moderators,
      isOwner = _ref.isOwner;
    _classCallCheck(this, UserRoomManager);
    /**
     * Retrieves the current search input value in lowercase.
     *
     * @returns {string} The trimmed, lowercase search query or an empty string if not valid.
     * @private
     */
    _classPrivateMethodInitSpec(this, _UserRoomManager_brand);
    _classPrivateFieldInitSpec(this, _usersHtml, []);
    _classPrivateFieldInitSpec(this, _client, void 0);
    this.$root = root;
    _classPrivateFieldSet(_client, this, client);
    this.currentUserId = currentUserId;
    this.users = users || {};
    this.moderators = moderators || [];
    this.isOwner = isOwner === true;
    this.isModerator = false;
    this.roomActive = true;
    this.isWaitingRoomStatus = false;
    this.$header = null;
    this.$footer = null;
    this.$searchInput = null;
    this.$userList = (0, _jquery["default"])('<div>');
    this.init();
  }
  return _createClass(UserRoomManager, [{
    key: "setClient",
    value:
    /**
     * Sets a new client instance for the manager.
     *
     * @param {Object} client - The new client instance to assign.
     */
    function setClient(client) {
      _classPrivateFieldSet(_client, this, client);
    }

    /**
     * Initializes the user interface by rendering the header, user list, footer,
     * and checking permissions.
     */
  }, {
    key: "init",
    value: function init() {
      this.renderHeader();
      this.renderUserList();
      this.renderFooter();
      this.checkPerms();
    }

    /**
     * Updates the active status of the room and resets the waiting room flag.
     *
     * @param {boolean} active - Indicates whether the room is active.
     */
  }, {
    key: "setRoomStatus",
    value: function setRoomStatus(active) {
      this.roomActive = active;
      this.isWaitingRoomStatus = false;
      this.updateRoomStatusButton();
    }

    /**
     * Checks and updates permissions for the current user and enables/disables
     * appropriate UI controls based on user roles.
     */
  }, {
    key: "checkPerms",
    value: function checkPerms() {
      var room = _classPrivateFieldGet(_client, this).getRoom() || {};
      var user = _classPrivateFieldGet(_client, this).getUser() || {};
      if (this.$unbanInput) this.$unbanInput.prop('disabled', !this.isModerator && !this.isOwner && !user.isOwner);
      if (this.$kickAll) this.$kickAll.prop('disabled', !this.isModerator && !this.isOwner && !user.isOwner);
      var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(_usersHtml, this)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          var needDisable = item.userId === room.ownerId || item.userId === this.currentUserId || !this.isModerator && !this.isOwner && !user.isOwner;
          item.actions.kick.prop('disabled', needDisable);
          item.actions.ban.prop('disabled', needDisable);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    /**
     * Renders the header section of the user manager UI.
     *
     * Includes:
     * - A "Kick all" button to remove all users except the current user and the room owner.
     * - A room status toggle button to enable or disable the room.
     * - A search input to filter users in real-time.
     *
     * Appends the constructed elements to the root and initializes their events.
     */
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      var _this = this;
      this.$header = (0, _jquery["default"])('<div>').addClass('d-flex flex-wrap align-items-center justify-content-between mb-3 gap-2');

      // Kick all
      this.$kickAll = _tinyLib["default"].bs.button('danger').text('Kick all');
      this.$kickAll.on('click', function () {
        var room = _classPrivateFieldGet(_client, _this).getRoom() || {};
        var userIds = [];
        Object.keys(_this.users).forEach(function (userId) {
          if (userId !== _this.currentUserId && userId !== room.ownerId) userIds.push(userId);
        });
        if (userIds.length > 0) _this.kickUser(userIds);
      });

      // Room status
      var $roomStatus = _tinyLib["default"].bs.button('secondary');
      this.$roomStatusButton = $roomStatus;
      $roomStatus.on('click', function () {
        if (_this.isWaitingRoomStatus) return;
        _this.isWaitingRoomStatus = true;
        _this.updateRoomStatusButton();
        if (_this.roomActive) _classPrivateFieldGet(_client, _this).disableRoom().then(function (result) {
          if (!result.error) _this.setRoomStatus(false);else _this.setRoomStatus(true);
        });else _classPrivateFieldGet(_client, _this).enableRoom().then(function (result) {
          if (!result.error) _this.setRoomStatus(true);else _this.setRoomStatus(false);
        });
      });

      // Search input
      this.$searchInput = (0, _jquery["default"])('<input>', {
        type: 'text',
        "class": 'form-control',
        placeholder: 'Search users...'
      });
      this.$searchInput.on('input', function () {
        _this.renderUserList(_this.$searchInput.val().trim().toLowerCase());
      });
      var $searchWrapper = (0, _jquery["default"])('<div>').addClass('flex-grow-1').append(this.$searchInput);
      this.$header.append(this.$kickAll, $roomStatus, $searchWrapper);
      this.$root.append(this.$header, this.$userList);
      this.updateRoomStatusButton();
    }

    /**
     * Renders the footer section of the user manager UI.
     *
     * Includes:
     * - An input field to manually enter a user ID to unban.
     * - An "Unban" button that triggers the unbanning action.
     *
     * The input listens for the "Enter" key to trigger the unban action as well.
     * Appends the constructed elements to the root container.
     */
  }, {
    key: "renderFooter",
    value: function renderFooter() {
      var _this2 = this;
      this.$footer = (0, _jquery["default"])('<div>');
      var $unbanWrapper = (0, _jquery["default"])('<div>').addClass('d-flex mt-4 gap-2 align-items-center');
      this.$unbanInput = (0, _jquery["default"])('<input>').addClass('form-control').attr('type', 'text').attr('placeholder', 'Enter user ID to unban').on('keydown', function (e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          $unbanButton.trigger('click');
        }
      });
      var $unbanButton = _tinyLib["default"].bs.button('success').text('Unban');
      $unbanButton.on('click', function () {
        if (!_this2.$unbanInput.prop('disabled')) {
          var userId = _this2.$unbanInput.val().trim();
          if (userId) {
            _this2.$unbanInput.val('');
            _this2.unbanUser(userId);
          }
        }
      });
      $unbanWrapper.append(this.$unbanInput, $unbanButton);
      this.$userList.append();
      this.$footer.append($unbanWrapper);
      this.$root.append(this.$footer);
    }

    /**
     * Updates the visual state and label of the room status toggle button.
     *
     * Changes the button style and text based on the current room state:
     * - Green ("Room is Active") when the room is active.
     * - Red ("Room is Inactive") when the room is inactive.
     * - Yellow ("Waiting...") while the state is updating.
     *
     * Disables the button if the current user is not the room owner.
     */
  }, {
    key: "updateRoomStatusButton",
    value: function updateRoomStatusButton() {
      var $btn = this.$roomStatusButton;
      if (!$btn) return;
      $btn.removeClass('btn-success btn-danger btn-warning').addClass(this.isWaitingRoomStatus ? 'btn-warning' : this.roomActive ? 'btn-success' : 'btn-danger').text(this.isWaitingRoomStatus ? 'Waiting...' : this.roomActive ? 'Room is Active' : 'Room is Inactive').prop('disabled', !this.isOwner);
    }

    /**
     * Renders the user list in the room, applying optional search filtering and sorting.
     *
     * This method:
     * - Clears and rebuilds the user list UI.
     * - Sorts users by:
     *    1. Logged-in user first,
     *    2. Then by most recent ping (activity),
     *    3. Then by nickname (alphabetically).
     * - Filters the list based on a search string, matching against nickname and userId.
     * - Displays for each user:
     *    - Nickname and user ID
     *    - Last ping time (human-readable)
     *    - Action buttons: Kick, Ban, Promote/Demote Moderator
     * - Updates `this.isModerator` if the logged-in user is found among moderators.
     * - Stores tooltip and action button references in `this.#usersHtml` for later updates.
     *
     * @param {string} [filter=''] - Optional filter string to match against nickname or userId.
     */
  }, {
    key: "renderUserList",
    value: function renderUserList() {
      var _this3 = this;
      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(_usersHtml, this)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var item = _step2.value;
          item.tooltips.map(function (item) {
            return item.hide();
          });
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this.$userList.empty();
      _classPrivateFieldSet(_usersHtml, this, []);
      var isMod = function isMod(userId) {
        return _this3.moderators.some(function (mod) {
          var modStatus = mod.userId === userId;
          if (_this3.currentUserId === userId) _this3.isModerator = modStatus;
          return modStatus;
        });
      };
      var sortedUsers = Object.entries(this.users).map(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          userId = _ref3[0],
          data = _ref3[1];
        return {
          userId: userId,
          nickname: data.nickname || userId,
          ping: (0, _moment["default"])(data.ping),
          isSelf: userId === _this3.currentUserId,
          isModerator: isMod(userId)
        };
      }).sort(function (a, b) {
        if (a.isSelf) return -1;
        if (b.isSelf) return 1;
        if (b.ping.valueOf() !== a.ping.valueOf()) {
          return b.ping.valueOf() - a.ping.valueOf();
        }
        return a.nickname.localeCompare(b.nickname);
      });
      sortedUsers.forEach(function (user, index) {
        if (filter && !user.nickname.toLowerCase().includes(filter.toLowerCase()) && !user.userId.toLowerCase().includes(filter.toLowerCase())) return;
        var $row = (0, _jquery["default"])('<div>').addClass("d-flex align-items-center py-2".concat(index < sortedUsers.length - 1 ? ' border-bottom' : ''));
        var $info = (0, _jquery["default"])('<div>').addClass('flex-grow-1 d-flex align-items-center gap-2');
        var $nickname = (0, _jquery["default"])('<strong>').text(user.nickname);
        var $userIdText = (0, _jquery["default"])('<small>').addClass('text-muted').text("(".concat(user.userId, ")"));
        $info.append($nickname, $userIdText);
        var $ping = (0, _jquery["default"])('<div>').addClass('text-muted small text-nowrap').text(user.ping.fromNow());
        var $actions = (0, _jquery["default"])('<div>').addClass('d-flex flex-wrap gap-2');
        var tooltips = [];
        var actions = {};
        var $kickBtn = _tinyLib["default"].bs.button('warning').append((0, _jquery["default"])('<i>').addClass('fas fa-user-slash')).attr('title', 'Kick');
        $kickBtn.on('click', function () {
          return _this3.kickUser(user.userId);
        });
        var $banBtn = _tinyLib["default"].bs.button('danger').append((0, _jquery["default"])('<i>').addClass('fas fa-ban')).attr('title', 'Ban');
        $banBtn.on('click', function () {
          return _this3.banUser(user.userId);
        });
        $actions.append($kickBtn, $banBtn);
        actions.kick = $kickBtn;
        actions.ban = $banBtn;
        tooltips.push($banBtn.tooltip(null, null, true));
        tooltips.push($kickBtn.tooltip(null, null, true));
        var $modBtn = _tinyLib["default"].bs.button(user.isModerator ? 'secondary' : 'info');
        $modBtn.append((0, _jquery["default"])('<i>').addClass(user.isModerator ? 'fas fa-user-minus' : 'fas fa-user-plus')).attr('title', user.isModerator ? 'Demote' : 'Promote').prop('disabled', user.isSelf || !_this3.isOwner);
        $modBtn.on('click', function () {
          if (user.isModerator) {
            _this3.reqDemoteModerator(user.userId);
          } else {
            _this3.reqPromoteModerator(user.userId);
          }
        });
        $actions.append($modBtn);
        actions.mod = $modBtn;
        tooltips.push($modBtn.tooltip(null, null, true));
        if (user.isSelf) $info.append((0, _jquery["default"])('<span>').addClass('badge bg-secondary ms-2').text('You'));
        $row.append($info.addClass('col-5'), $ping.addClass('col-2 text-end'), $actions.addClass('col-5 justify-content-end'));
        _classPrivateFieldGet(_usersHtml, _this3).push({
          tooltips: tooltips,
          actions: actions,
          userId: user.userId
        });
        _this3.$userList.append($row);
      });
    }

    /**
     * Adds or updates a user in the internal user list.
     *
     * If the user is new or their data (nickname/ping) has changed,
     * it triggers a re-render of the user list and re-checks permissions.
     *
     * @param {string} userId - Unique identifier of the user.
     * @param {{nickname?: string, ping: number|string|Date}} data - User data, including nickname and ping timestamp.
     */
  }, {
    key: "addUser",
    value: function addUser(userId, data) {
      var oldHash = this.users[userId] ? (0, _objectHash["default"])(this.users[userId]) : null;
      this.users[userId] = {
        nickname: data.nickname || userId,
        ping: (0, _moment["default"])(data.ping)
      };
      var newHash = (0, _objectHash["default"])(this.users[userId]);
      if (newHash !== oldHash) {
        this.renderUserList(_assertClassBrand(_UserRoomManager_brand, this, _getSearch).call(this));
        this.checkPerms();
      }
    }

    /**
     * Removes a user from the internal user list.
     *
     * If the user exists, they are removed and the user list is re-rendered.
     *
     * @param {string} userId - Unique identifier of the user to remove.
     */
  }, {
    key: "removeUser",
    value: function removeUser(userId) {
      if (this.users[userId]) {
        delete this.users[userId];
        this.renderUserList(_assertClassBrand(_UserRoomManager_brand, this, _getSearch).call(this));
      }
    }

    /**
     * Adds a user to the list of moderators, if not already present.
     * Triggers a re-render of the user list and permission checks.
     *
     * @param {string} userId - The user ID to promote to moderator.
     */
  }, {
    key: "promoteModerator",
    value: function promoteModerator(userId) {
      if (!this.moderators.find(function (m) {
        return m.userId === userId;
      })) {
        this.moderators.push({
          userId: userId
        });
        if (userId === this.currentUserId) this.isModerator = true;
        this.renderUserList(_assertClassBrand(_UserRoomManager_brand, this, _getSearch).call(this));
        this.checkPerms();
      }
    }

    /**
     * Removes a user from the list of moderators.
     * Triggers a re-render of the user list and permission checks.
     *
     * @param {string} userId - The user ID to demote from moderator.
     */
  }, {
    key: "demoteModerator",
    value: function demoteModerator(userId) {
      this.moderators = this.moderators.filter(function (m) {
        return m.userId !== userId;
      });
      if (userId === this.currentUserId) this.isModerator = false;
      this.renderUserList(_assertClassBrand(_UserRoomManager_brand, this, _getSearch).call(this));
      this.checkPerms();
    }

    /**
     * Replaces the entire list of moderators with a new list.
     * Triggers a re-render of the user list and permission checks.
     *
     * @param {Array<{userId: string}>} moderatorList - Array of moderator objects.
     */
  }, {
    key: "setModerators",
    value: function setModerators(moderatorList) {
      this.moderators = Array.isArray(moderatorList) ? moderatorList : [];
      this.renderUserList(_assertClassBrand(_UserRoomManager_brand, this, _getSearch).call(this));
      this.checkPerms();
    }

    /**
     * Sends a request to promote a user to moderator via the client.
     * Updates UI button state during request and, on success, adds the user as a moderator.
     *
     * @param {string} userId - The user ID to promote.
     */
  }, {
    key: "reqPromoteModerator",
    value: function reqPromoteModerator(userId) {
      var _this4 = this;
      if (!this.moderators.find(function (m) {
        return m.userId === userId;
      })) {
        var html = _classPrivateFieldGet(_usersHtml, this).find(function (item) {
          return item.userId === userId;
        });
        if (html) html.actions.mod.prop('disabled', true);
        _classPrivateFieldGet(_client, this).addMod([userId]).then(function (result) {
          if (html) html.actions.mod.prop('disabled', false).removeClass('disabled');
          if (!result.error) _this4.promoteModerator(userId);
        });
      }
    }

    /**
     * Sends a request to demote a user from moderator via the client.
     * Updates UI button state during request and, on success, removes the user from the moderator list.
     *
     * @param {string} userId - The user ID to demote.
     */
  }, {
    key: "reqDemoteModerator",
    value: function reqDemoteModerator(userId) {
      var _this5 = this;
      var html = _classPrivateFieldGet(_usersHtml, this).find(function (item) {
        return item.userId === userId;
      });
      if (html) html.actions.mod.prop('disabled', true);
      _classPrivateFieldGet(_client, this).removeMod([userId]).then(function (result) {
        if (html) html.actions.mod.prop('disabled', false).removeClass('disabled');
        if (!result.error) _this5.demoteModerator(userId);
      });
    }

    /**
     * Sends a request to ban a user via the client.
     * Disables the ban button during the request.
     * On success, removes the user from the user list.
     *
     * @param {string} userId - The user ID to ban.
     */
  }, {
    key: "banUser",
    value: function banUser(userId) {
      var _this6 = this;
      var html = _classPrivateFieldGet(_usersHtml, this).find(function (item) {
        return item.userId === userId;
      });
      if (html) html.actions.ban.prop('disabled', true);
      _classPrivateFieldGet(_client, this).banUser(userId).then(function (result) {
        if (html) html.actions.ban.prop('disabled', false).removeClass('disabled');
        if (!result.error) _this6.removeUser(userId);
      });
    }

    /**
     * Sends a request to unban a user via the client.
     * Disables the input field during the request.
     * On failure, displays the error message in the input.
     *
     * @param {string} userId - The user ID to unban.
     */
  }, {
    key: "unbanUser",
    value: function unbanUser(userId) {
      var _this7 = this;
      this.$unbanInput.prop('disabled', true);
      _classPrivateFieldGet(_client, this).unbanUser(userId).then(function (result) {
        _this7.$unbanInput.prop('disabled', false).removeClass('disabled');
        if (result.error) _this7.$unbanInput.val(typeof result.msg === 'string' ? result.msg : 'Unknown error');
        _this7.$unbanInput.trigger('focus').trigger('select');
      });
    }

    /**
     * Sends a request to kick a user via the client.
     * Disables the kick button during the request.
     * On success, removes the user from the user list.
     *
     * @param {string} userId - The user ID to kick.
     */
  }, {
    key: "kickUser",
    value: function kickUser(userId) {
      var _this8 = this;
      var html = _classPrivateFieldGet(_usersHtml, this).find(function (item) {
        return item.userId === userId;
      });
      if (html) html.actions.kick.prop('disabled', true);
      _classPrivateFieldGet(_client, this).kickUser(userId).then(function (result) {
        if (html) html.actions.kick.prop('disabled', false).removeClass('disabled');
        if (!result.error) _this8.removeUser(userId);
      });
    }

    /**
     * Destroys the root element, removing all child elements.
     * Used to clean up the component from the DOM.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.$root) this.$root.empty();
    }
  }]);
}();
function _getSearch() {
  var _this$$searchInput;
  var value = (_this$$searchInput = this.$searchInput) === null || _this$$searchInput === void 0 || (_this$$searchInput = _this$$searchInput.val()) === null || _this$$searchInput === void 0 ? void 0 : _this$$searchInput.trim().toLowerCase();
  return typeof value === 'string' ? value : '';
}
var _default = exports["default"] = UserRoomManager;

},{"../files/tinyLib.mjs":223,"jquery":97,"moment":104,"object-hash":106}],207:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _jquery = _interopRequireDefault(require("jquery"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/*
 * TinyMap - A lightweight map generator and handler
 *
 * Author: JasminDreasond
 * Description: This script is an adaptation of an older version used in an RPG page of the application called MyOC Page.
 *
 * This class provides functionalities to build and manage a grid-based map, allowing for the placement of locations and routes dynamically.
 * The map can be updated in real-time, and interactions such as tooltips and click events enhance the user experience.
 *
 * Features:
 * - Dynamic map creation using a grid system
 * - Supports customizable tile sizes and map dimensions
 * - Allows adding locations and routes with colors, names, and tooltips
 * - Interactive elements for displaying additional information
 * - Easy integration with RPG systems and other applications
 *
 * Documentation created by: ChatGPT (OpenAI)
 */
var _TinyMap_brand = /*#__PURE__*/new WeakSet();
var TinyMap = /*#__PURE__*/function () {
  /**
   * Creates a new TinyMap instance.
   * @param {Object} map - The map configuration containing size, tile dimensions, image, colors, locations, and routes.
   * @param {boolean} [firstBuild=false] - Determines if the map should be built immediately.
   */
  function TinyMap(map) {
    var firstBuild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, TinyMap);
    /**
     * Validates a background-image value restricted to safe data:image URLs only.
     *
     * @private
     * @param {string} value - The CSS background-image value.
     * @returns {boolean}
     */
    _classPrivateMethodInitSpec(this, _TinyMap_brand);
    // Data
    this.map = map;
    this.html = {};
    this.location = null;
    this._limitSize = 4000;
    this._isSubPage = false;

    // Design
    this.defaultColor = typeof this.map.defaultColor === 'string' ? this.map.defaultColor : '';

    // Size
    this.setSize(this.map.size.split('x'), false);
    this.setTile(this.map.tile.split('x'), false);
    this._setGrid();

    // Locations
    this.locations = Array.isArray(this.map.locations) ? this.map.locations : [];
    this.routes = Array.isArray(this.map.routes) ? this.map.routes : [];

    // First build
    if (firstBuild) this.buildMap(true);
    this.setMapImage(this.map.image);
  }
  return _createClass(TinyMap, [{
    key: "setLocation",
    value:
    /**
     * Sets the current location for the RPG map.
     *
     * Updates the internal `location` property.
     * Accepts only string values; if a non-string is provided,
     * the location is set to `null`.
     *
     * @param {string} location - The name or identifier of the map location.
     */
    function setLocation(location) {
      this.location = typeof location === 'string' ? location : null;
    }

    /**
     * Validates the size and tile dimensions of the map.
     * Ensures that all size and tile values are numbers and finite.
     *
     * @returns {boolean} - True if size and tile dimensions are valid, false otherwise.
     */
  }, {
    key: "sizeIsValidated",
    value: function sizeIsValidated() {
      return !Number.isNaN(this.size[0]) && !Number.isNaN(this.size[1]) && !Number.isNaN(this.tile[0]) && !Number.isNaN(this.tile[1]) && Number.isFinite(this.size[0]) && Number.isFinite(this.size[1]) && Number.isFinite(this.tile[0]) && Number.isFinite(this.tile[1]);
    }

    /**
     * Calculates and sets the grid dimensions based on the map size and tile size.
     * The grid represents how many tiles fit within the map's dimensions.
     *
     * - `grid.height`: Number of tiles that fit in the vertical axis.
     * - `grid.width`: Number of tiles that fit in the horizontal axis.
     *
     * This method ensures that the grid values are rounded to the nearest whole number.
     */
  }, {
    key: "_setGrid",
    value: function _setGrid() {
      this.grid = {
        height: Math.round(this.size[1] / this.tile[1]),
        width: Math.round(this.size[0] / this.tile[0])
      };
    }

    /**
     * Sets the name of the map and updates the corresponding UI element if available.
     *
     * @param {string} name - The new name of the map.
     *
     * This method updates the `name` property of the map and, if the `mapButton`
     * element exists in `this.html`, it updates its text content to reflect the new name.
     */
  }, {
    key: "setMapName",
    value: function setMapName(name) {
      this.name = name;
      if (this.html.mapButton) this.html.mapButton.text(name);
    }

    /**
     * Sets the size of the map and optionally updates the grid.
     *
     * @param {Array} size - An array containing the new width and height of the map.
     * @param {boolean} [setGrid=true] - A flag indicating whether to update the grid after setting the size.
     *
     * This method updates the `size` property of the map, ensuring the values are converted to numbers
     * and are within the allowed limits. It then calls the `_setGrid` method to adjust the grid based on
     * the new size unless the `setGrid` parameter is set to `false`.
     *
     * The width of the map is limited to the `_limitSize` value to prevent the map from exceeding a maximum size.
     */
  }, {
    key: "setSize",
    value: function setSize() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var setGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      // Size
      this.size = size;
      this.size[0] = Number(this.size[0]);
      this.size[1] = Number(this.size[1]);

      // Limit
      if (this.size[0] > this._limitSize) {
        this.size[0] = this._limitSize;
      }
      if (this.size[0] > this._limitSize) {
        this.size[0] = this._limitSize;
      }

      // Set grid
      if (setGrid) return this._setGrid();
    }

    /**
     * Sets the tile size of the map and optionally updates the grid.
     *
     * @param {Array} tile - An array containing the new width and height for each tile.
     * @param {boolean} [setGrid=true] - A flag indicating whether to update the grid after setting the tile size.
     *
     * This method updates the `tile` property of the map, ensuring the values are converted to numbers
     * and are within the allowed limits. It then calls the `_setGrid` method to adjust the grid based on
     * the new tile size unless the `setGrid` parameter is set to `false`.
     *
     * The height of each tile is limited to the `_limitSize` value to prevent the tile from exceeding a maximum size.
     */
  }, {
    key: "setTile",
    value: function setTile() {
      var tile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var setGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      // Tile
      this.tile = tile;
      this.tile[0] = Number(this.tile[0]);
      this.tile[1] = Number(this.tile[1]);

      // Limit
      if (this.tile[1] > this._limitSize) {
        this.tile[1] = this._limitSize;
      }
      if (this.tile[1] > this._limitSize) {
        this.tile[1] = this._limitSize;
      }

      // Set grid
      if (setGrid) return this._setGrid();
    }

    /**
     * Clears the content of the map's HTML table element.
     *
     * This method empties the HTML table associated with the map by calling the `empty()` method on the
     * `html.table` element. This is typically used to remove any existing content from the map before
     * redrawing or reinitializing it.
     */
  }, {
    key: "emptyMap",
    value: function emptyMap() {
      this.html.table.empty();
    }

    /**
     * Creates a table cell (`<td>`) element for the grid with optional coordinates, size, background color, and text.
     *
     * This function generates a table cell (`<td>`) element that can be used as part of the grid layout. The created
     * cell has optional coordinates, a specified height and width, an optional background color, and optional text content.
     *
     * @param {number} [cw=0] - The column width, used to set the cell's coordinates (optional).
     * @param {number} [ch=0] - The row height, used to set the cell's coordinates (optional).
     * @param {string|null} [text=null] - The text content to be displayed inside the cell (optional).
     * @param {string|null} [color=null] - The background color of the cell (optional).
     *
     * @returns {jQuery} - A jQuery object representing the table cell (`<td>`) element.
     */
  }, {
    key: "_buildGridTemplate",
    value: function _buildGridTemplate() {
      var cw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var ch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      return (0, _jquery["default"])('<td>', {
        "class": 'p-0 m-0',
        coordinates: typeof cw === 'number' && typeof ch === 'number' ? Number(cw) + 'x' + Number(ch) : null
      }).css({
        height: this.tile[1] - 2,
        width: this.tile[0] - 2,
        'background-color': color
      }).text(text);
    }

    /**
     * Builds the grid for the map by generating a table structure with cells.
     *
     * This function creates a grid layout by generating HTML table rows (`<tr>`) and cells (`<td>`) dynamically.
     * The grid dimensions are determined based on the `this.grid.height` and `this.grid.width` values.
     * It also utilizes `_buildGridTemplate()` to build individual table cells with optional coordinates and styling.
     *
     * The generated grid will be appended to the `this.html.table` element, and an array of grid elements is stored
     * in `this.html.grid`.
     *
     * @returns {void}
     */
  }, {
    key: "buildMapGrid",
    value: function buildMapGrid() {
      // Prepare Table
      this.html.grid = [];
      this.emptyMap();

      // Generator Height
      var firstValue = {
        height: true,
        width: true
      };
      var coordinates_w = 0;
      var coordinates_h = -1;

      // Render grid
      for (var i = 0; i < this.grid.height + 1; i++) {
        var tinytr = (0, _jquery["default"])('<tr>', {
          "class": 'p-0 m-0'
        });
        var tinytds = [];

        // Height
        if (!firstValue.height) {
          firstValue.width = true;

          // Generator Width
          coordinates_h = 0;
          for (var x = 0; x < this.grid.width + 1; x++) {
            if (!firstValue.width) {
              tinytds.push(this._buildGridTemplate(Number(coordinates_w), Number(coordinates_h), null, this.defaultColor));
            } else {
              tinytds.push(this._buildGridTemplate(null, null, coordinates_w + 1));
              coordinates_w++;
              firstValue.width = false;
            }
            coordinates_h++;
          }
        } else {
          firstValue.height = false;

          // Generator Width
          coordinates_h = -1;
          for (var _x = 0; _x < this.grid.width + 1; _x++) {
            tinytds.push(this._buildGridTemplate(null, null, coordinates_h + 1));
            coordinates_h++;
          }
        }

        // Insert
        if (this.html.table) this.html.table.append(tinytr.append(tinytds));
        this.html.grid.push({
          html: tinytr,
          data: tinytds
        });
      }
    }

    /**
     * Updates the grid content by generating and applying routes and locations to the map grid.
     *
     * This function performs two main tasks:
     * 1. It updates the grid cells with route information, including tooltips, route number, and styling (background color, font color).
     * 2. It updates the grid cells with location information, including tooltips, location names, mini names, and styling.
     * Additionally, it sets up click events on the location cells to trigger modal dialogs with location details and item shops.
     *
     * @returns {void}
     */
  }, {
    key: "updateGridContent",
    value: function updateGridContent() {
      var _this = this;
      // Routes Generator
      var tinyThis = this;
      var getCoordPlace = function getCoordPlace(coords) {
        var coordinates = coords.split('x');
        coordinates[0] = Number(coordinates[0]);
        coordinates[1] = Number(coordinates[1]);
        if (!Number.isNaN(coordinates[0]) && !Number.isNaN(coordinates[1])) {
          var cordsValue = coordinates[0] + 'x' + coordinates[1];
          for (var index in tinyThis.html.grid) {
            var coordBase = tinyThis.html.grid[index].data.find(function (item) {
              return item.attr('coordinates') === cordsValue;
            });
            if (coordBase) return coordBase;
          }
        }
        return null;
      };
      for (var item2 in this.routes) {
        var coordplace = getCoordPlace(this.routes[item2].coordinates);
        if (coordplace) {
          var routeNumber = item2;
          coordplace.attr('location_enabled', this.location === "Route {number}".replace(/\{number\}/g, routeNumber) ? 'on' : 'off');
          if (this.routes[item2].about) {
            coordplace.attr('title', 'Route {number}: {about}'.replace(/\{number\}/g, routeNumber).replace(/\{about\}/g, this.routes[item2].about));
          } else {
            coordplace.attr('title', 'Route {number}'.replace(/\{number\}/g, routeNumber));
          }
          coordplace.tooltip();
          coordplace.text('R' + routeNumber);
          if (this.routes[item2].color) {
            coordplace.css('background-color', this.routes[item2].color);
          }
          if (this.routes[item2].fontColor) {
            coordplace.css('color', this.routes[item2].fontColor);
          }
        }
      }

      // Locations Generator
      var _loop = function _loop(_item) {
        var coordplace = getCoordPlace(_this.locations[_item].coordinates);
        if (coordplace) {
          coordplace.attr('location_enabled', _this.location === _this.locations[_item].name ? 'on' : 'off');
          coordplace.attr('title', _this.locations[_item].name);
          var tooltip = coordplace.tooltip(null, null, true);
          coordplace.text(_this.locations[_item].mininame);
          if (_this.locations[_item].color) {
            coordplace.css('background-color', _this.locations[_item].color);
          }
          if (_this.locations[_item].fontColor) {
            coordplace.css('color', _this.locations[_item].fontColor);
          }

          // Click Location
          var _tinyThis = _this;
          coordplace.css('cursor', 'pointer').data('tinyLocation', _this.locations[_item]).on('click', function () {
            // Prepare Click
            var tinyLocation = (0, _jquery["default"])(this).data('tinyLocation');

            // Get Items
            var tinyItems;
            try {
              tinyItems = rpgData.data[place].getEditor('root.settings.items').getValue();
            } catch (err) {
              tinyItems = null;
            }

            // Items Shop
            var tinyShop = [];

            // Items
            if (Array.isArray(tinyItems) && tinyLocation.shop) {
              for (var item in tinyItems) {
                // Cities of the Item
                var cancity = false;
                var alllocations = false;
                if (typeof tinyItems[item].cities === 'string') {
                  // The cities
                  var tinyCities = [];
                  var tinyCities1 = tinyItems[item].cities.split(',');
                  var tinyCities2 = tinyItems[item].cities.split('\n');
                  if (tinyCities1.length > 0) for (var index in tinyCities1) tinyCities.push(tinyCities1[index]);else if (tinyCities2.length > 0) for (var _index in tinyCities2) tinyCities.push(tinyCities2[_index]);

                  // Load Cities
                  for (var city in tinyCities) {
                    tinyCities[city] = tinyCities[city].trim();
                    if (tinyCities[city] === 'all') {
                      cancity = true;
                      alllocations = true;
                    }

                    // Tiny fix
                    if (tinyCities[city] === _tinyThis.locations[_item].name && !alllocations) {
                      cancity = true;
                      break;
                    } else if (alllocations && tinyCities[city] === _tinyThis.locations[_item].name) {
                      cancity = false;
                      break;
                    }
                  }
                }

                // Add to the list
                if (cancity) {
                  var separeItem = '';
                  if (Number(item) !== Number(tinyItems.length - 1)) {
                    separeItem = (0, _jquery["default"])('<hr>');
                  }
                  tinyShop.push((0, _jquery["default"])('<div>').append([(0, _jquery["default"])('<span>').text("Name: "), (0, _jquery["default"])('<span>').text(tinyItems[item].name), (0, _jquery["default"])('<br>'), (0, _jquery["default"])('<span>').text("Price: "), (0, _jquery["default"])('<span>').text(tinyItems[item].price), (0, _jquery["default"])('<br>'), (0, _jquery["default"])('<span>').text("About: "), (0, _jquery["default"])('<span>').text(tinyItems[item].about), separeItem]));
                }
              }
            }

            // Modal Body
            var tinyBody = [
            // Info
            (0, _jquery["default"])('<h3>').text('Info'), (0, _jquery["default"])('<div>').text(tinyLocation.about)];
            if (tinyShop.length > 0) {
              tinyBody.push((0, _jquery["default"])('<hr>'), (0, _jquery["default"])('<h3>').text('Shop'));
              for (var _item2 in tinyShop) {
                tinyBody.push(tinyShop[_item2]);
              }
            }
            _tinyThis.html.subPage = {
              html: tinyBody,
              title: 'Location - {location}'.replace(/\{location\}/g, tinyLocation.name)
            };
            _tinyThis.activeSubPage(true);
            if (tooltip) tooltip.hide();
          });
        }
      };
      for (var _item in this.locations) {
        _loop(_item);
      }
    }

    /**
     * Updates the size of the map by adjusting the dimensions of the map's table element.
     *
     * This function modifies the `width` and `height` of the `html.table` element based on:
     * - The map's overall size (`this.size[0]` for width, `this.size[1]` for height).
     * - The size of the individual tiles (`this.tile[0]` for tile width, `this.tile[1]` for tile height).
     *
     * @returns {void}
     */
  }, {
    key: "updateMapSize",
    value: function updateMapSize() {
      this.html.table.css({
        width: this.size[0] + this.tile[0],
        height: this.size[1] + this.tile[1]
      });
    }

    /**
     * Sets the background image for the map and updates the table's background style.
     *
     * This function checks if the provided image URL (`imgUrl`) is a valid data URL (i.e., it starts with `data:`).
     * If it is, it sets the `this.image` property to that URL. The function then updates the background style
     * of `this.html.table` with the new image URL, and adjusts the background size to fit the map size.
     *
     * @param {string} imgUrl - The URL of the image to be set as the map background. It must be a valid string and
     *                          should start with 'data:' for data URLs.
     *
     * @returns {void}
     */
  }, {
    key: "setMapImage",
    value: function setMapImage(imgUrl) {
      this.image = typeof imgUrl === 'string' && _assertClassBrand(_TinyMap_brand, this, _isValidDataImage).call(this, imgUrl) ? imgUrl : '';
      if (this.html.table) this.html.table.css({
        background: this.image ? 'transparent url("' + this.image + '") no-repeat right bottom' : '',
        'background-size': this.image ? this.size[0] + 'px ' + Number(this.size[1] - 2) + 'px' : ''
      });
    }

    /**
     * Builds a new page structure by clearing the existing content and appending new elements.
     *
     * This function modifies `this.html.base` to build a new page layout. It:
     * - Clears any existing content using `.empty()`.
     * - Optionally adds a title, if a `title` string is provided, by creating an `<h3>` element.
     * - Appends a new `<div>` with an optional class name (`className`) and the provided `tinyHtml` content.
     *
     * @param {jQuery} tinyHtml - The HTML content to be appended to the page.
     * @param {string|null} [title=null] - The title for the page, which will be wrapped in an `<h3>` tag. If not provided, no title is added.
     * @param {string|null} [className=null] - The CSS class to be applied to the wrapping `<div>`. If not provided, no class is applied.
     *
     * @returns {void}
     */
  }, {
    key: "buildPage",
    value: function buildPage(tinyHtml) {
      var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this.html.base.empty().append(typeof title === 'string' ? (0, _jquery["default"])('<h3>').text(title) : null, (0, _jquery["default"])('<div>', {
        "class": className
      }).append(tinyHtml));
    }

    /**
     * Activates or deactivates the subpage view for the map.
     *
     * When activated, the function updates the page with the content of `this.html.subPage.html` and sets the title
     * to `this.html.subPage.title`. When deactivated, the map view is restored and resized based on the current table
     * dimensions, minus the tile size, with the class `table-responsive` applied.
     *
     * @param {boolean} [active=true] - Whether to activate or deactivate the subpage view.
     *                                  If `true`, the subpage content is shown. If `false`, the map view is restored.
     *
     * @returns {void}
     */
  }, {
    key: "activeSubPage",
    value: function activeSubPage() {
      var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this._isSubPage = active;
      if (!active) this.buildPage(this.html.table, Number(this.html.table.outerWidth(true) - this.tile[0]) + 'x' + Number(this.html.table.outerHeight(true) - this.tile[1]), 'table-responsive');else this.buildPage(this.html.subPage.html, this.html.subPage.title);
    }

    /**
     * Builds or resets the map view.
     *
     * If `resetHtml` is `true`, the HTML elements are recreated from scratch, including the base container,
     * table, and map button. The map grid is rebuilt and the map's size and image are updated accordingly.
     * The subpage view is also deactivated.
     *
     * When `resetHtml` is `false`, the function updates the existing map view without altering the HTML structure.
     * The map button toggles the visibility of the map and subpage content based on the current state of the subpage.
     *
     * @param {boolean} [resetHtml=false] - Whether to reset the HTML structure and start from scratch. If `true`,
     *                                      the HTML elements for the map are recreated.
     *
     * @returns {void}
     */
  }, {
    key: "buildMap",
    value: function buildMap() {
      var resetHtml = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      // The map
      var tinyThis = this;
      if (resetHtml) this.html.base = (0, _jquery["default"])('<center>', {
        "class": 'd-none'
      });

      // The table
      if (resetHtml) this.html.table = (0, _jquery["default"])('<table>', {
        "class": 'table table-bordered'
      });
      this.updateMapSize();

      // Insert map table into map element
      this.buildMapGrid();
      this.updateGridContent();

      // Map Button
      if (resetHtml) this.html.mapButton = (0, _jquery["default"])('<button>', {
        type: 'button',
        "class": 'btn btn-secondary m-2'
      }).on('click', function () {
        if (tinyThis._isSubPage) {
          tinyThis.buildMap();
          tinyThis.html.base.removeClass('d-none');
        } else tinyThis.html.base.toggleClass('d-none');
      });

      // Set name
      this.setMapName(typeof this.map.name === 'string' ? this.map.name : '');

      // Build page
      this.activeSubPage(false);
      this.setMapImage(this.image);
    }

    /**
     * Gets the map button element.
     *
     * @returns {jQuery} The map button element.
     */
  }, {
    key: "getMapButton",
    value: function getMapButton() {
      return this.html.mapButton;
    }

    /**
     * Gets the map table HTML element.
     *
     * @returns {jQuery} The table element representing the map.
     */
  }, {
    key: "getMapHtml",
    value: function getMapHtml() {
      return this.html.table;
    }

    /**
     * Gets the base HTML element for the map container.
     *
     * @returns {jQuery} The base container element for the map.
     */
  }, {
    key: "getMapBaseHtml",
    value: function getMapBaseHtml() {
      return this.html.base;
    }
  }]);
}();
function _isValidDataImage(value) {
  if (typeof value !== 'string') return false;
  var normalized = value.trim();

  // Only allow data:image/... base64 or URL-encoded images
  var dataUrlPattern = /^data:image\/(png|jpeg|jpg|gif|webp);base64,[a-z0-9+\/=]+$/i;
  return dataUrlPattern.test(normalized);
}
var _default = exports["default"] = TinyMap;

},{"jquery":97}],208:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AiScriptStart = void 0;
var _events = require("events");
var _circleLoader = require("circle-loader");
var _moment = _interopRequireDefault(require("moment"));
var _marked = require("marked");
var _clone = _interopRequireDefault(require("clone"));
var _objectHash = _interopRequireDefault(require("object-hash"));
var _fileSaver = require("file-saver");
var _jquery = _interopRequireDefault(require("jquery"));
var _tinyAiApi = require("tiny-ai-api");
var _tinyEssentials = require("tiny-essentials");
var _tinyDices = _interopRequireDefault(require("tiny-dices"));
var _tinyLib = _interopRequireDefault(require("../files/tinyLib.mjs"));
var _start = require("../start.mjs");
var _config = _interopRequireDefault(require("../chapters/config.mjs"));
var _TinyMap = _interopRequireDefault(require("./TinyMap.mjs"));
var _templates = _interopRequireDefault(require("./templates.mjs"));
var _socketClient = _interopRequireDefault(require("./socketClient.mjs"));
var _RoomUserManagerUI = _interopRequireDefault(require("./RoomUserManagerUI.mjs"));
var _rpgData = _interopRequireDefault(require("./aiSoftware/rpgData.mjs"));
var _enablerContent = _interopRequireDefault(require("./aiSoftware/enablerContent.mjs"));
require("./jsonTemplate.mjs");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _regeneratorKeys(e) { var n = Object(e), r = []; for (var t in n) r.unshift(t); return function e() { for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e; return e.done = !0, e; }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
// Localstorage Manager
var TinyAiStorage = /*#__PURE__*/function (_EventEmitter) {
  function TinyAiStorage() {
    var _this;
    _classCallCheck(this, TinyAiStorage);
    _this = _callSuper(this, TinyAiStorage);
    _this._selected = _start.tinyLs.getItem('tiny-ai-storage-selected');
    if (typeof _this._selected !== 'string') _this._selected = null;
    _this.storage = _start.tinyLs.getItem('tiny-ai-storage');
    try {
      _this.storage = JSON.parse(_this.storage);
      if (!_this.storage) _this.storage = {};
    } catch (_unused) {
      _this.storage = {};
    }
    return _this;
  }
  _inherits(TinyAiStorage, _EventEmitter);
  return _createClass(TinyAiStorage, [{
    key: "_saveApiStorage",
    value: function _saveApiStorage() {
      _start.tinyLs.setItem('tiny-ai-storage', JSON.stringify(this.storage));
      this.emit('saveApiStorage', this.storage);
    }
  }, {
    key: "_updateExistsAi",
    value: function _updateExistsAi() {
      if (this._selected && (typeof this.storage[this._selected] !== 'string' || this.storage[this._selected].length < 1) && typeof this.storage[this._selected] !== 'number' && !(0, _tinyEssentials.objType)(this.storage[this._selected], 'object')) {
        this._selected = null;
        _start.tinyLs.removeItem('tiny-ai-storage-selected');
      }
    }
  }, {
    key: "setSelectedAi",
    value: function setSelectedAi(value) {
      this._selected = typeof value === 'string' && (typeof this.storage[value] === 'string' && this.storage[value].length > 0 || typeof this.storage[value] === 'number' || (0, _tinyEssentials.objType)(this.storage[value], 'object')) ? value : null;
      if (this._selected) _start.tinyLs.setItem('tiny-ai-storage-selected', this._selected);else _start.tinyLs.removeItem('tiny-ai-storage-selected');
    }
  }, {
    key: "selectedAi",
    value: function selectedAi() {
      return this._selected;
    }
  }, {
    key: "setApiKey",
    value: function setApiKey(name, key) {
      if (typeof key === 'string' || typeof key === 'number' || (0, _tinyEssentials.objType)(key, 'object')) {
        this.storage[name] = key;
        this._saveApiStorage();
        this._updateExistsAi();
        this.emit('setApiKey', name, key);
        return;
      }
      throw new Error('Invalid AI api key data type!');
    }
  }, {
    key: "delApiKey",
    value: function delApiKey(name) {
      if (this.storage[name]) {
        delete this.storage[name];
        this._saveApiStorage();
        this._updateExistsAi();
        this.emit('delApiKey', name);
        return true;
      }
      return false;
    }
  }, {
    key: "getApiKey",
    value: function getApiKey(name) {
      return typeof this.storage[name] === 'string' ? {
        key: this.storage[name]
      } : this.storage[name] || {
        key: null
      };
    }
  }]);
}(_events.EventEmitter);
var AiScriptStart = exports.AiScriptStart = function AiScriptStart(connStore) {
  var tinyAiScript = {};

  // Read AI Apis
  var tinyIo = {
    client: null,
    firstTime: true
  };
  var tinyAi = new _tinyAiApi.TinyAiInstance();
  var tinyStorage = new TinyAiStorage();
  var aiLogin = null;
  tinyAiScript.setAiLogin = function (newAiLogin) {
    aiLogin = newAiLogin;
  };
  var canSandBox = function canSandBox(value) {
    return value === 'sandBoxFic' || value === 'noData';
  };
  tinyAiScript.killIo = function () {
    if (tinyIo.client) {
      tinyIo.client.destroy();
      tinyIo.client = null;
      console.log('[socket-io] Connection destroyed!');
      return true;
    } else return false;
  };

  // Detect Using AI
  _start.appData.emitter.on('isUsingAI', function (usingAI) {
    if (usingAI) {
      (0, _jquery["default"])('body').addClass('is-using-ai');
    } else {
      (0, _jquery["default"])('body').removeClass('is-using-ai');
    }
  });

  // Checker
  tinyAiScript.checkTitle = function () {
    // Get selected Ai
    var selectedAi = tinyStorage.selectedAi();

    // Exists Google only. Then select google generative
    if (typeof selectedAi === 'string' && selectedAi.length > 0 && selectedAi !== 'NONE') {
      var _tinyStorage$getApiKe;
      // Update html
      aiLogin.button.find('> i').removeClass('text-danger-emphasis');
      aiLogin.title = 'AI/RP Enabled';
      (0, _jquery["default"])('body').addClass('can-ai');

      // Update Ai API script
      tinyAiScript.mpClient = false;
      tinyAiScript.noai = false;

      // Google Generative
      if (selectedAi === 'google-generative') (0, _tinyAiApi.setTinyGoogleAi)(tinyAi, (_tinyStorage$getApiKe = tinyStorage.getApiKey('google-generative')) === null || _tinyStorage$getApiKe === void 0 ? void 0 : _tinyStorage$getApiKe.key);

      // Tiny Chat --> this is a multiplayer client session
      if (selectedAi === 'tiny-chat') tinyAiScript.mpClient = true;

      // No Ai
      if (selectedAi === 'no-ai') tinyAiScript.noai = true;

      // Enabled now
      tinyAiScript.enabled = true;
    } else {
      // Update html
      aiLogin.button.find('> i').addClass('text-danger-emphasis');
      aiLogin.title = 'AI/RP Disabled';
      (0, _jquery["default"])('body').removeClass('can-ai');
      tinyAiScript.enabled = false;
    }

    // Update login button
    aiLogin.updateTitle();
  };
  tinyAiScript.isEnabled = function () {
    return typeof tinyStorage.selectedAi() === 'string';
  };
  tinyAiScript.enabled = false;

  // Login button
  tinyAiScript.login = function () {
    // Selector
    var selector = (0, _jquery["default"])('<select>', {
      "class": 'form-select text-center'
    });
    selector.append((0, _jquery["default"])('<option>', {
      value: 'NONE'
    }).text('None'));
    var apiPlace = (0, _jquery["default"])('<span>');
    selector.on('change', function () {
      var value = selector.val();
      var html = tinyAiHtml[value] && tinyAiHtml[value].inputs ? tinyAiHtml[value].inputs() : null;
      apiPlace.empty();
      if (html) apiPlace.append(html.desc, html.input, html.submit);
      tinyStorage.setSelectedAi(value);
      tinyAiScript.checkTitle();
    });
    selector.prop('disabled', _start.appData.ai.using);
    var tinyAiHtml = {};

    // Server login inputs
    var insertServerLogin = function insertServerLogin(tinyInput, values) {
      var indexs = [];
      tinyInput.push((0, _jquery["default"])('<input>', {
        type: 'text',
        placeholder: 'Server ip',
        "class": 'form-control text-center'
      }));
      indexs.push(tinyInput.length - 1);
      tinyInput.push((0, _jquery["default"])('<input>', {
        type: 'text',
        placeholder: 'Username',
        "class": 'form-control text-center mt-3'
      }));
      indexs.push(tinyInput.length - 1);
      tinyInput.push((0, _jquery["default"])('<input>', {
        type: 'password',
        placeholder: 'Password',
        "class": 'form-control text-center mt-2'
      }));
      indexs.push(tinyInput.length - 1);
      tinyInput.push((0, _jquery["default"])('<input>', {
        type: 'text',
        placeholder: 'Room Id',
        "class": 'form-control text-center mt-3'
      }));
      indexs.push(tinyInput.length - 1);
      tinyInput.push((0, _jquery["default"])('<input>', {
        type: 'password',
        placeholder: 'Room password',
        "class": 'form-control text-center mt-2'
      }));
      indexs.push(tinyInput.length - 1);
      tinyInput[indexs[0]].val(values.ip).prop('disabled', _start.appData.ai.using);
      tinyInput[indexs[1]].val(values.username).prop('disabled', _start.appData.ai.using);
      tinyInput[indexs[2]].val(values.password).prop('disabled', _start.appData.ai.using);
      tinyInput[indexs[3]].val(values.roomId).prop('disabled', _start.appData.ai.using);
      tinyInput[indexs[4]].val(values.roomPassword).prop('disabled', _start.appData.ai.using);
      return indexs;
    };

    // Save server login
    var insertSaveServerLogin = function insertSaveServerLogin(inputs, ids) {
      return {
        ip: inputs[ids[0]].val(),
        username: inputs[ids[1]].val(),
        password: inputs[ids[2]].val(),
        roomId: inputs[ids[3]].val(),
        roomPassword: inputs[ids[4]].val()
      };
    };

    // Server host about
    var insertServerAbout = function insertServerAbout() {
      return (0, _jquery["default"])('<p>').append((0, _jquery["default"])('<span>').text('You can host your server '), (0, _jquery["default"])('<a>', {
        href: 'https://github.com/Pony-Driland/Website/tree/main/server/tiny-chat',
        target: '_blank'
      }).text('here'), (0, _jquery["default"])('<span>').text('. Enter the server settings you want to connect to.'));
    };
    var hostButton = function hostButton(inputs) {
      var tinyBig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      return (0, _jquery["default"])('<div>').append(_tinyLib["default"].bs.button('secondary mb-3').text('Show host settings (Alpha)').on('click', function () {
        for (var index in inputs) {
          if (index > tinyBig) {
            inputs[index].toggleClass('d-none');
          }
        }
      }));
    };

    // No AI
    selector.append((0, _jquery["default"])('<option>', {
      value: 'no-ai'
    }).text('No AI'));
    tinyAiHtml['no-ai'] = {};
    var noAi = tinyAiHtml['no-ai'];
    noAi.inputs = function () {
      var data = {
        input: []
      };
      data.input.push(hostButton(data.input, 0));
      data.input.push(insertServerAbout());
      var values = tinyStorage.getApiKey('no-ai') || {};
      var ids = insertServerLogin(data.input, values);
      data.input[0].find('> button').trigger('click');
      data.desc = (0, _jquery["default"])('<p>').text('No AI will be used in this mode. You will only have access to the simple features.');
      data.submit = _tinyLib["default"].bs.button('info mx-4 mt-4').text('Set Settings').on('click', function () {
        var result = insertSaveServerLogin(data.input, ids);
        tinyStorage.setApiKey('no-ai', result);
        tinyAiScript.checkTitle();
        (0, _jquery["default"])('#ai_connection').modal('hide');
      }).prop('disabled', _start.appData.ai.using);
      return data;
    };

    // Separator
    selector.append((0, _jquery["default"])('<option>').prop('disabled', true).text('--------------------'));
    selector.append((0, _jquery["default"])('<option>').prop('disabled', true).text('AI Models'));

    // Google AI
    selector.append((0, _jquery["default"])('<option>', {
      value: 'google-generative'
    }).text('Google Studio'));
    tinyAiHtml['google-generative'] = {};
    var googleAi = tinyAiHtml['google-generative'];
    googleAi.inputs = function () {
      var data = {
        input: []
      };
      data.input.push((0, _jquery["default"])('<input>', {
        type: 'password',
        "class": 'form-control text-center mb-2'
      }));
      data.input.push(hostButton(data.input, 1));
      data.input.push(insertServerAbout());
      var values = tinyStorage.getApiKey('google-generative') || {};
      data.input[0].val(values.key).prop('disabled', _start.appData.ai.using);
      var ids = insertServerLogin(data.input, values);
      data.input[1].find('> button').trigger('click');
      data.desc = (0, _jquery["default"])('<p>').append((0, _jquery["default"])('<span>').text('You can get your Google API key '), (0, _jquery["default"])('<a>', {
        href: 'https://aistudio.google.com/apikey',
        target: '_blank'
      }).text('here'), (0, _jquery["default"])('<span>').text('. Website: aistudio.google.com'));
      data.submit = _tinyLib["default"].bs.button('info mx-4 mt-4').text('Set API Tokens').on('click', function () {
        var result = insertSaveServerLogin(data.input, ids);
        result.key = data.input[0].val();
        tinyStorage.setApiKey('google-generative', result);
        tinyAiScript.checkTitle();
        (0, _jquery["default"])('#ai_connection').modal('hide');
      }).prop('disabled', _start.appData.ai.using);
      return data;
    };

    // Separator
    selector.append((0, _jquery["default"])('<option>').prop('disabled', true).text('--------------------'));
    selector.append((0, _jquery["default"])('<option>').prop('disabled', true).text('Clients'));

    // Tiny chat
    selector.append((0, _jquery["default"])('<option>', {
      value: 'tiny-chat'
    }).text('Multiplayer'));
    tinyAiHtml['tiny-chat'] = {};
    var tinyChat = tinyAiHtml['tiny-chat'];
    tinyChat.inputs = function () {
      var data = {
        input: []
      };
      var values = tinyStorage.getApiKey('tiny-chat') || {};
      var ids = insertServerLogin(data.input, values);
      data.desc = insertServerAbout();
      data.submit = _tinyLib["default"].bs.button('info mx-4 mt-4').text('Set connection settings').on('click', function () {
        tinyStorage.setApiKey('tiny-chat', insertSaveServerLogin(data.input, ids));
        tinyAiScript.checkTitle();
        (0, _jquery["default"])('#ai_connection').modal('hide');
      }).prop('disabled', _start.appData.ai.using);
      return data;
    };

    // Modal
    selector.val(tinyStorage.selectedAi() || 'NONE');
    selector.trigger('change');
    _tinyLib["default"].modal({
      id: 'ai_connection',
      title: 'AI/RP Protocol',
      dialog: 'modal-lg',
      body: (0, _jquery["default"])('<center>').append((0, _jquery["default"])('<p>').text("You are in an optional setting. You do not need AI to use the website!"), (0, _jquery["default"])('<p>').text("This website does not belong to any AI company, and all API input is stored locally inside your machine. This website is just a client to run prompts in artificial intelligence, there is no native artificial intelligence installed here."), (0, _jquery["default"])('<p>').text("By activating an artificial intelligence service in your session, you agree to the terms of use and privacy policies of the third party services you are using on this website. You will always be warned when any artificial intelligence service needs to be run on this website."), selector, apiPlace)
    });
  };

  // Open AI Page
  tinyAiScript.open = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13() {
    var sessionEnabled, rpgCfg, canUsejsStore, aiTimeScriptUpdate, isFirstTime, contentEnabler, rpgData, sidebarStyle, createButtonSidebar, modelSelector, resetModelSelector, convertToNumber, tokenCount, tinyRanger, outputLength, temperature, topP, topK, presencePenalty, frequencyPenalty, getFicCache, insertImportData, importFileSession, ficConfigs, resetEntireData, ficResets, ficTemplates, _loop, index, importItems, ficPromptItems, tinyModalTextarea, isOnline, leftMenu, templateChangeInfo, connectionInfoBar, sidebarLeft, sidebarSettingTemplate, sidebarRightBase, updateModelList, insertDefaultSettings, selectModel, loadMoreModels, resetSettingsButton, sidebarRight, prepareContentList, getAiTokens, usingUpdateToken, updateAiTokenCounterData, executeAi, createTextareaInputExition, msgInputValues, msgInput, msgSubmit, cancelSubmit, submitMessage, submitCache, firstDialogueBase, msgList, scrollChatContainerToTop, addMessage, makeTempMessage, makeMsgRenderer, makeMsgWarning, makeMessage, chatContainer, textInputContainer, container, tinyInsertDb, tinyMsgIdDb, resetSession, saveSessionTimeout, saveSessionBackup, tinyAiSocketTemplate, validateMultiplayer, enabledFirstDialogue, clearMessages, socket, onlineStatus, client, sendSocketError, sessionData, sessions, executeSessionInsert, item, _t6, _t7, _t8, _t9, _t0, _t1, _t10, _t11, _t12;
    return _regenerator().w(function (_context15) {
      while (1) switch (_context15.n) {
        case 0:
          sessionEnabled = true; // Update Url
          (0, _start.urlUpdate)('ai', 'AI Page');

          // Clear page
          (0, _start.clearFicData)();
          (0, _jquery["default"])('#markdown-read').empty();
          (0, _jquery["default"])('#top_page').addClass('d-none');

          // Can use backup
          rpgCfg = tinyStorage.getApiKey(tinyStorage.selectedAi()) || {};
          canUsejsStore = typeof rpgCfg.ip !== 'string' || rpgCfg.ip.length < 1; // Try to prevent user browser from deactivating the page accidentally in browsers that have tab auto deactivator
          aiTimeScriptUpdate = function aiTimeScriptUpdate() {
            try {
              // Get data
              var now = (0, _moment["default"])();
              var totalTime = JSON.parse(_start.tinyLs.getItem('total-time-using-ai') || '{}');
              if (typeof totalTime.now !== 'number') totalTime.now = now.valueOf();
              if (typeof totalTime.secondsUsed !== 'number') totalTime.secondsUsed = 0;
              var past = (0, _moment["default"])(totalTime.now);

              // Diff
              var diff = Math.abs(now - past);
              if (diff >= 999) totalTime.secondsUsed++;

              // Complete
              totalTime.now = now.valueOf();
              _start.tinyLs.setItem('total-time-using-ai', JSON.stringify(totalTime));
              if (aiLogin) {
                aiLogin.secondsUsed = totalTime.secondsUsed;
                aiLogin.updateTitle();
              }
            } catch (err) {
              console.error(err);
            }
            _start.appData.ai.secondsUsed++;
          };
          _start.appData.ai.interval = setInterval(aiTimeScriptUpdate, 1000);
          aiTimeScriptUpdate();

          // Start loading page
          isFirstTime = true;
          _circleLoader.Loader.start();
          if (!tinyAiScript.isEnabled()) {
            _context15.n = 17;
            break;
          }
          contentEnabler = new _enablerContent["default"]();
          rpgData = new _rpgData["default"](); // Get RPG Template
          rpgData.setTinyAi(tinyAi);
          contentEnabler.setRpgData(rpgData);

          // Load Models
          if (!(!tinyAiScript.noai && !tinyAiScript.mpClient && tinyAi.getModelsList().length < 1)) {
            _context15.n = 1;
            break;
          }
          _context15.n = 1;
          return tinyAi.getModels(100);
        case 1:
          // Sidebar
          sidebarStyle = {
            "class": 'bg-dark text-white p-3 d-none d-md-block',
            style: 'width: 250px; min-width: 250px; overflow-y: auto;'
          }; // Sidebar Button
          createButtonSidebar = function createButtonSidebar(icon, text, callback) {
            var disabled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
            var tinyClass = "link btn-bg text-start w-100".concat(disabled ? ' disabled' : '');
            return _tinyLib["default"].bs.button(!options ? tinyClass : _objectSpread({
              "class": tinyClass
            }, options)).text(text).prepend(_tinyLib["default"].icon("".concat(icon, " me-2"))).on('click', callback).prop('disabled', disabled);
          }; // Select Model
          modelSelector = (0, _jquery["default"])('<select>', {
            "class": 'form-select',
            id: 'select-ai-model'
          });
          contentEnabler.setModelSelector(modelSelector);
          resetModelSelector = function resetModelSelector() {
            modelSelector.empty();
            modelSelector.append((0, _jquery["default"])('<option>').text('None'));
          };
          resetModelSelector();

          // To Number
          convertToNumber = function convertToNumber(val) {
            return typeof val === 'string' && val.length > 0 ? Number(val) : typeof val === 'number' ? val : 0;
          }; // Token Count
          tokenCount = {
            amount: (0, _jquery["default"])('<span>').data('token-count', 0).text('0'),
            total: (0, _jquery["default"])('<span>').text('0'),
            updateValue: function updateValue(where, value) {
              if (typeof value === 'number') {
                if (!Number.isNaN(value) && Number.isFinite(value)) {
                  if (tokenCount[where] && where !== 'updateValue' && where !== 'getValue') return tokenCount[where].data('token-count', value).text(value.toLocaleString(navigator.language || 'en-US'));
                }
              } else return tokenCount[where].data('token-count', 0).text(0);
            },
            getValue: function getValue(where) {
              if (tokenCount[where] && where !== 'updateValue' && where !== 'getValue') return tokenCount[where].data('token-count') || 0;
            }
          }; // Ranger Generator
          tinyRanger = function tinyRanger() {
            var rangerBase = (0, _jquery["default"])('<div>', {
              "class": 'd-flex flex-row align-items-center'
            });
            var ranger = (0, _jquery["default"])('<input>', {
              type: 'range',
              "class": 'form-range'
            });
            var rangerNumber = (0, _jquery["default"])('<input>', {
              type: 'number',
              "class": 'form-control ms-2',
              style: 'width: 70px; max-width: 70px; min-width: 70px;'
            });
            ranger.on('wheel', function (event) {
              event.preventDefault();
              var currentValue = Number(ranger.val());
              var getValue = function getValue(where, defaultValue) {
                var newValue = ranger.attr(where);
                if (typeof newValue === 'string' && newValue.length > 0) newValue = Number(newValue);else newValue = defaultValue;
                return newValue;
              };
              var step = getValue('step', 1);
              var min = getValue('min', 0);
              var max = getValue('max', 0);

              // Detect scroll position
              if (event.originalEvent.deltaY < 0) {
                // Up
                currentValue += step;
              } else {
                // Down
                currentValue -= step;
              }

              // Update value
              if (currentValue < min) ranger.val(min).trigger('input');else if (currentValue > max) ranger.val(max).trigger('input');else ranger.val(currentValue).trigger('input');
            });
            ranger.on('input', function () {
              rangerNumber.val(ranger.val());
            });
            rangerNumber.on('input', function () {
              ranger.val(rangerNumber.val());
            });
            rangerNumber.on('change', function () {
              var value = parseInt(rangerNumber.val());
              var min = parseInt(rangerNumber.attr('min'));
              var max = parseInt(rangerNumber.attr('max'));
              if (value < min) {
                rangerNumber.val(min);
              } else if (value > max) {
                rangerNumber.val(max);
              }
            });
            rangerBase.append(ranger, rangerNumber);
            return {
              getBase: function getBase() {
                return ranger;
              },
              getBase2: function getBase2() {
                return rangerNumber;
              },
              trigger: function trigger(value) {
                return ranger.trigger(value);
              },
              reset: function reset() {
                this.setMin(0);
                this.setMax(0);
                this.setStep(0);
                this.val(0);
                return this;
              },
              setMin: function setMin(value) {
                ranger.attr('min', value);
                rangerNumber.attr('min', value);
                return this;
              },
              setMax: function setMax(value) {
                ranger.attr('max', value);
                rangerNumber.attr('max', value);
                return this;
              },
              setStep: function setStep(value) {
                ranger.attr('step', value);
                rangerNumber.attr('step', value);
                return this;
              },
              disable: function disable() {
                ranger.addClass('disabled');
                ranger.prop('disabled', true);
                rangerNumber.addClass('disabled');
                rangerNumber.prop('disabled', true);
                return this;
              },
              enable: function enable() {
                ranger.removeClass('disabled');
                ranger.prop('disabled', false);
                rangerNumber.removeClass('disabled');
                rangerNumber.prop('disabled', false);
                return this;
              },
              insert: function insert() {
                return rangerBase;
              },
              val: function val(value) {
                if (typeof value !== 'undefined') {
                  ranger.val(value);
                  rangerNumber.val(value);
                  return this;
                }
                return convertToNumber(ranger.val());
              },
              valString: function valString() {
                return String(ranger.val());
              },
              valString2: function valString2() {
                return String(rangerNumber.val());
              }
            };
          }; // Output Length
          outputLength = (0, _jquery["default"])('<input>', {
            type: 'number',
            "class": 'form-control'
          });
          contentEnabler.setOutputLength(outputLength);
          outputLength.on('input', function () {
            return tinyAi.setMaxOutputTokens(convertToNumber(outputLength.val()));
          });

          // Temperature
          temperature = tinyRanger();
          contentEnabler.setTemperature(temperature);
          temperature.getBase().on('input', function () {
            return tinyAi.setTemperature(convertToNumber(temperature.val()));
          });
          temperature.getBase2().on('change', function () {
            return tinyAi.setTemperature(convertToNumber(temperature.val()));
          });
          temperature.val(1);
          tinyAi.setTemperature(1);

          // Top P
          topP = tinyRanger();
          contentEnabler.setTopP(topP);
          topP.getBase().on('input', function () {
            return tinyAi.setTopP(convertToNumber(topP.val()));
          });
          topP.getBase2().on('change', function () {
            return tinyAi.setTopP(convertToNumber(topP.val()));
          });

          // Top K
          topK = tinyRanger();
          contentEnabler.setTopK(topK);
          topK.getBase().on('input', function () {
            return tinyAi.setTopK(convertToNumber(topK.val()));
          });
          topK.getBase2().on('change', function () {
            return tinyAi.setTopK(convertToNumber(topK.val()));
          });

          // Presence penalty
          presencePenalty = tinyRanger();
          contentEnabler.setPresencePenalty(presencePenalty);
          presencePenalty.getBase().on('input', function () {
            return tinyAi.setPresencePenalty(convertToNumber(presencePenalty.val()));
          });
          presencePenalty.getBase2().on('change', function () {
            return tinyAi.setPresencePenalty(convertToNumber(presencePenalty.val()));
          });

          // Frequency penalty
          frequencyPenalty = tinyRanger();
          contentEnabler.setFrequencyPenalty(frequencyPenalty);
          frequencyPenalty.getBase().on('input', function () {
            return tinyAi.setFrequencyPenalty(convertToNumber(frequencyPenalty.val()));
          });
          frequencyPenalty.getBase2().on('change', function () {
            return tinyAi.setFrequencyPenalty(convertToNumber(frequencyPenalty.val()));
          });

          // Get fic cache
          getFicCache = function getFicCache(id, instructionId, prompts, introduction, hashItems, newContent) {
            var forceReset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
            return new Promise(function (resolve, reject) {
              isFirstTime = false;
              // Reset token count
              tokenCount.updateValue('amount', 0);
              newContent().then(/*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(ficData) {
                  var tinyData, tinyRpgData, tinyRpgPrivateData, fileTokens, oldFileHash, newFileHash, history, textBackup, index;
                  return _regenerator().w(function (_context) {
                    while (1) switch (_context.n) {
                      case 0:
                        if (!forceReset) {
                          _context.n = 1;
                          break;
                        }
                        _context.n = 1;
                        return resetSession(id, true);
                      case 1:
                        if (forceReset || !tinyAi.selectDataId(id)) {
                          // Start History
                          tinyAi.startDataId(id, true);
                          tinyAi.setModel(modelSelector.val());

                          // Set Instruction
                          tinyAi.setSystemInstruction(_templates["default"].instructions[instructionId], 0);

                          // Set Prompts
                          try {
                            if (typeof prompts === 'string') tinyAi.setPrompt(prompts, 0);
                            if (Array.isArray(prompts)) tinyAi.setPrompt(prompts.join('\n'), 0);
                          } catch (_unused2) {
                            tinyAi.setPrompt('', 0);
                          }
                        }

                        // Exists data
                        else {
                          // Get first history data
                          tinyData = tinyAi.getFirstIndexData(); // Delete old file version
                          if (tinyData && tinyData.parts && tinyData.parts[0] && tinyData.parts[0].inlineData) tinyAi.deleteIndex(0);
                        }

                        // Load rpg data
                        _context.n = 2;
                        return rpgData.init();
                      case 2:
                        tinyRpgData = rpgData.data["public"].getValue();
                        tinyRpgPrivateData = rpgData.data["private"].getValue();
                        if (tinyRpgData) {
                          rpgData.setAllowAiUse(tinyRpgData.allowAiUse, 'public');
                          rpgData.setAllowAiSchemaUse(tinyRpgData.allowAiSchemaUse, 'public');
                        }
                        if (tinyRpgPrivateData) {
                          rpgData.setAllowAiUse(tinyRpgPrivateData.allowAiUse, 'private');
                          rpgData.setAllowAiSchemaUse(tinyRpgPrivateData.allowAiSchemaUse, 'private');
                        }

                        // Add file data
                        fileTokens = tinyAi.getTokens('file');
                        oldFileHash = tinyAi.getHash('file');
                        if (ficData) tinyAi.setFileData(ficData.mime, ficData.data);else tinyAi.removeFileData();
                        newFileHash = tinyAi.getHash('file');
                        if (oldFileHash === newFileHash) tinyAi.setFileData(null, null, null, fileTokens || 0);

                        // Clear data
                        clearMessages();
                        if (sessionEnabled) {
                          contentEnabler.enBase();
                          contentEnabler.enMessageButtons();
                        }
                        makeTempMessage(introduction, 'Introduction');
                        history = tinyAi.getData(); // Restore textarea
                        if (ficConfigs.selected) {
                          textBackup = _start.tinyLs.getItem("tiny-ai-textarea-".concat(ficConfigs.selected));
                          if (typeof textBackup !== 'string') textBackup = '';
                          msgInput.val(textBackup).trigger('input');
                        }

                        // Start system
                        insertImportData(history.data, history.tokens && Array.isArray(history.tokens.data) ? history.tokens.data : [], true);
                        if (sessionEnabled) contentEnabler.enPromptButtons();
                        updateAiTokenCounterData(hashItems, forceReset);

                        // Update button list
                        for (index in ficConfigs.buttons) {
                          // Nope
                          if (ficConfigs.data[index].id !== ficConfigs.selected) ficConfigs.buttons[index].removeClass('selected');else ficConfigs.buttons[index].addClass('selected');
                        }
                        resolve();
                      case 3:
                        return _context.a(2);
                    }
                  }, _callee);
                }));
                return function (_x) {
                  return _ref2.apply(this, arguments);
                };
              }())["catch"](function (err) {
                alert(err.message);
                _circleLoader.Loader.close();
                reject(err);
              });
            });
          }; // When sId is used, it means that the request is coming from a session that is not active in the chat
          insertImportData = function insertImportData(data, tokens) {
            var readOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var sId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
            // Insert data
            if (Array.isArray(data)) {
              for (var index in data) {
                var msgId = !readOnly ? tinyAi.addData(tinyAi.buildContents(null, data[index], data[index].role), tokens[index], sId) : tinyAi.getIdByIndex(index);
                if (!sId) {
                  var msg = !readOnly ? tinyAi.getLastIndexData() : data[index];
                  if (msg && msg.parts && msg.parts[0] && typeof msg.parts[0].text === 'string') {
                    addMessage(makeMessage({
                      message: msg.parts[0].text,
                      id: msgId
                    }, msg.role === 'user' ? null : (0, _tinyEssentials.toTitleCase)(msg.role)));
                  }
                }
              }
            }
          };
          importFileSession = /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(jsonData) {
              var forceLoad,
                file,
                sessionId,
                index,
                instructionId,
                i,
                _file$customList$i,
                name,
                type,
                _args2 = arguments;
              return _regenerator().w(function (_context2) {
                while (1) switch (_context2.n) {
                  case 0:
                    forceLoad = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;
                    if (!((0, _tinyEssentials.objType)(jsonData, 'object') && jsonData.file && typeof jsonData.id === 'string')) {
                      _context2.n = 2;
                      break;
                    }
                    file = jsonData.file;
                    sessionId = jsonData.id; // Migration to sandbox mode
                    if (!canSandBox(sessionId) && typeof file.systemInstruction === 'string') sessionId = 'sandBoxFic';
                    if (!forceLoad) {
                      _context2.n = 1;
                      break;
                    }
                    _context2.n = 1;
                    return resetSession(sessionId, true);
                  case 1:
                    // Start History
                    tinyAi.startDataId(sessionId, true);

                    // Open Get Fic Cache
                    index = ficConfigs.data.findIndex(function (item) {
                      return item.id === sessionId;
                    });
                    instructionId = index > -1 ? ficConfigs.data[index].template : null; // Set custom values
                    if (Array.isArray(file.customList)) {
                      for (i in file.customList) {
                        if ((0, _tinyEssentials.objType)(file.customList[i], 'object') && typeof file.customList[i].name === 'string' && typeof file.customList[i].type === 'string') {
                          _file$customList$i = file.customList[i], name = _file$customList$i.name, type = _file$customList$i.type;
                          if ((0, _tinyEssentials.objType)(file[name], type)) {
                            tinyAi.setCustomValue(name, file[name], file.tokens ? file.tokens[name] : 0, sessionId);
                          }
                        }
                      }
                    }

                    // Set model
                    if (typeof file.model === 'string') {
                      modelSelector.val(file.model);
                      tinyAi.setModel(file.model, sessionId);
                      selectModel(file.model);
                    }

                    // Set model settings
                    if (typeof file.temperature === 'number') tinyAi.setTemperature(file.temperature);
                    if (typeof file.maxOutputTokens === 'number') tinyAi.setMaxOutputTokens(file.maxOutputTokens);
                    if (typeof file.topP === 'number') tinyAi.setTopP(file.topP);
                    if (typeof file.topK === 'number') tinyAi.setTopK(file.topK);
                    if (typeof file.presencePenalty === 'number') tinyAi.setPresencePenalty(file.presencePenalty);
                    if (typeof file.frequencyPenalty === 'number') tinyAi.setFrequencyPenalty(file.frequencyPenalty);

                    // Set Instruction
                    if (canSandBox(sessionId)) tinyAi.setSystemInstruction(file.systemInstruction, file.tokens ? file.tokens.systemInstruction : 0);else if (_templates["default"].instructions[instructionId]) tinyAi.setSystemInstruction(_templates["default"].instructions[instructionId], file.tokens ? file.tokens.systemInstruction : 0);

                    // Prompt
                    if (typeof file.prompt === 'string') tinyAi.setPrompt(file.prompt, file.tokens ? file.tokens.prompt : 0);

                    // First Dialogue
                    if (typeof file.firstDialogue === 'string') tinyAi.setFirstDialogue(file.firstDialogue, file.tokens ? file.tokens.firstDialogue : 0);

                    // File
                    if (file.tokens && typeof file.tokens.file === 'number') tinyAi.setFileData(null, null, null, file.tokens ? file.tokens.file : 0);
                    if (forceLoad) {
                      // Clear messages
                      clearMessages();
                      contentEnabler.enBase();
                      contentEnabler.enMessageButtons();
                    }

                    // Complete
                    insertImportData(file.data, file.tokens && Array.isArray(file.tokens.data) ? file.tokens.data : [], false, forceLoad ? undefined : sessionId);
                    if (file.hash) file.hash.model = typeof file.model === 'string' ? (0, _objectHash["default"])(file.model) : null;
                    if (forceLoad && index > -1) getFicCache(ficConfigs.data[index].id, instructionId, ficConfigs.data[index].prompt, ficConfigs.data[index].intro, file.hash, function () {
                      ficConfigs.selected = ficConfigs.data[index].id;
                      return ficConfigs.data[index].getData();
                    });
                    return _context2.a(2, true);
                  case 2:
                    return _context2.a(2, false);
                }
              }, _callee2);
            }));
            return function importFileSession(_x2) {
              return _ref3.apply(this, arguments);
            };
          }();
          ficConfigs = {
            data: [{
              title: 'Safe Talk',
              id: 'ficTalkSfw',
              template: 'talkToFicSfw',
              icon: 'fa-solid fa-book-open',
              isSafe: true,
              intro: 'Welcome to talk about the fic Pony Driland! I will answer all your questions related to fic in your native language (if i can support to do this). I will try to hide some explicit details from fic, but if you insist, I will try to say in a few details.',
              getData: function () {
                var _getData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
                  return _regenerator().w(function (_context3) {
                    while (1) switch (_context3.n) {
                      case 0:
                        return _context3.a(2, (0, _start.saveRoleplayFormat)(null, false));
                    }
                  }, _callee3);
                }));
                function getData() {
                  return _getData.apply(this, arguments);
                }
                return getData;
              }()
            }, {
              title: 'Full Talk',
              id: 'ficTalk',
              template: 'talkToFic',
              icon: 'fa-solid fa-book-open-reader',
              intro: 'Welcome to talk about the fic Pony Driland! I will answer all your questions related to fic in your native language (if i can support to do this), but be careful, because I will answer questions related to literally anything that happened in fic, including censored scenes (but i will do this respecting the limitations of my selected model).',
              getData: function () {
                var _getData2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
                  return _regenerator().w(function (_context4) {
                    while (1) switch (_context4.n) {
                      case 0:
                        return _context4.a(2, (0, _start.saveRoleplayFormat)(null, false));
                    }
                  }, _callee4);
                }));
                function getData() {
                  return _getData2.apply(this, arguments);
                }
                return getData;
              }()
            }, {
              title: 'Sandbox',
              id: 'sandBoxFic',
              template: 'sandBoxToFic',
              icon: 'fa-solid fa-fill-drip',
              intro: 'Welcome to sandbox of the fic Pony Driland! This is my purely sandbox version, that means I have no special configuration, allowing you to do whatever you want within the limits of your selected model.',
              getData: function () {
                var _getData3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
                  return _regenerator().w(function (_context5) {
                    while (1) switch (_context5.n) {
                      case 0:
                        return _context5.a(2, (0, _start.saveRoleplayFormat)(null, false, {
                          ficLine: false,
                          dayNumber: false
                        }));
                    }
                  }, _callee5);
                }));
                function getData() {
                  return _getData3.apply(this, arguments);
                }
                return getData;
              }()
            }, {
              title: 'No Data',
              id: 'noData',
              template: null,
              icon: 'fa-solid fa-file',
              intro: 'You are in a completely clean environment, with no stored data from the fic. You can use all website features without any limitations.',
              getData: function () {
                var _getData4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
                  return _regenerator().w(function (_context6) {
                    while (1) switch (_context6.n) {
                      case 0:
                        return _context6.a(2, null);
                    }
                  }, _callee6);
                }));
                function getData() {
                  return _getData4.apply(this, arguments);
                }
                return getData;
              }()
            }],
            buttons: [],
            selected: null,
            contentsMd5: null
          };
          rpgData.setFicConfigs(ficConfigs);

          // Reset buttons
          resetEntireData = function resetEntireData() {
            var resetAll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var index = ficConfigs.data.findIndex(function (item) {
              return item.id === ficConfigs.selected;
            });
            if (index > -1) {
              getFicCache(ficConfigs.data[index].id, ficConfigs.data[index].template, ficConfigs.data[index].prompt, ficConfigs.data[index].intro, null, function () {
                ficConfigs.selected = ficConfigs.data[index].id;
                return ficConfigs.data[index].getData();
              }, resetAll).then(function () {
                return resetSettingsButton.trigger('click');
              });
            }
          };
          ficResets = [
          // History
          createButtonSidebar('fa-solid fa-arrows-rotate', 'History', function () {
            return resetEntireData(true);
          }),
          // Schema
          createButtonSidebar('fa-solid fa-arrows-rotate', 'RPG Schema', function () {
            rpgData.template.schema = _templates["default"].funcs.jsonTemplate();
            if (ficConfigs.selected) {
              tinyAi.setCustomValue('rpgSchema', rpgData.template.schema, 0);
              resetEntireData(false);
            }
          })];
          contentEnabler.setFicResets(ficResets);

          // Fic Templates
          ficTemplates = [];
          contentEnabler.setFicTemplates(ficTemplates);
          _loop = /*#__PURE__*/_regenerator().m(function _loop(index) {
            var newButton;
            return _regenerator().w(function (_context14) {
              while (1) switch (_context14.n) {
                case 0:
                  newButton = createButtonSidebar(ficConfigs.data[index].icon, ficConfigs.data[index].title, function () {
                    return getFicCache(ficConfigs.data[index].id, ficConfigs.data[index].template, ficConfigs.data[index].prompt, ficConfigs.data[index].intro, null, function () {
                      ficConfigs.selected = ficConfigs.data[index].id;
                      return ficConfigs.data[index].getData();
                    });
                  });
                  ficConfigs.buttons.push(newButton);
                  ficTemplates.push(newButton);
                case 1:
                  return _context14.a(2);
              }
            }, _loop);
          });
          _t6 = _regeneratorKeys(ficConfigs.data);
        case 2:
          if ((_t7 = _t6()).done) {
            _context15.n = 4;
            break;
          }
          index = _t7.value;
          return _context15.d(_regeneratorValues(_loop(index)), 3);
        case 3:
          _context15.n = 2;
          break;
        case 4:
          importItems = [
          // Import
          _tinyLib["default"].upload.json(createButtonSidebar('fa-solid fa-file-import', 'Import'), function (err, jsonData) {
            if (err) {
              console.error(err);
              alert(err.message);
              return;
            }
            importFileSession(jsonData, true);
          })];
          contentEnabler.setImportItems(importItems);
          ficPromptItems = [
          // System Instructions
          createButtonSidebar('fa-solid fa-toolbox', 'System Instructions', function () {
            var tinyModalData = {
              id: 'ai_instructions',
              info: 'System Instructions:',
              size: 400,
              textarea: tinyAi.getSystemInstruction(),
              submitName: 'Set Instructions',
              submitCall: function submitCall(value) {
                var oldValue = tinyAi.getSystemInstruction();
                if (typeof oldValue !== 'string' || oldValue !== value) {
                  tinyAi.setSystemInstruction(value, 0);
                  updateAiTokenCounterData();
                }
              }
            };
            if (canSandBox(ficConfigs.selected)) {
              tinyModalData.addTemplates = {
                data: _templates["default"].prompts,
                title: 'Select a prompt to be added'
              };
            } else tinyModalData.readOnly = true;
            tinyModalTextarea(tinyModalData, ['instructionText', 'text']);
          }),
          // Prompt
          createButtonSidebar('fa-solid fa-terminal', 'Prompt', function () {
            return tinyModalTextarea({
              id: 'ai_prompt',
              info: 'This prompt will always be inserted at the beginning of all your requests:',
              size: 200,
              textarea: tinyAi.getPrompt(),
              submitName: 'Set Prompt',
              addTemplates: {
                data: _templates["default"].prompts,
                title: 'Select a prompt to be added'
              },
              submitCall: function submitCall(value) {
                var oldValue = tinyAi.getPrompt();
                if (typeof oldValue !== 'string' || oldValue !== value) {
                  tinyAi.setPrompt(value, 0);
                  updateAiTokenCounterData();
                }
              }
            }, !canSandBox(ficConfigs.selected) ? 'text' : ['sandBoxText', 'text']);
          }),
          // First Dialogue
          createButtonSidebar('fa-solid fa-comment-dots', 'First Dialogue', function () {
            return tinyModalTextarea({
              id: 'ai_first_dialogue',
              info: 'This is the initial dialogue that can be inserted as a model message:',
              size: 200,
              textarea: tinyAi.getFirstDialogue(),
              submitName: 'Set First Message',
              addTemplates: {
                data: _templates["default"].prompts,
                title: 'Select a prompt to be added'
              },
              submitCall: function submitCall(value) {
                var oldValue = tinyAi.getFirstDialogue();
                if (typeof oldValue !== 'string' || oldValue !== value) {
                  tinyAi.setFirstDialogue(value);
                  enabledFirstDialogue(typeof value === 'string' && value.length > 0);
                }
              }
            }, 'firstDialogue');
          })];
          contentEnabler.setFicPromptItems(ficPromptItems);

          // Textarea Template
          tinyModalTextarea = function tinyModalTextarea() {
            var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
              info: '???',
              size: 200,
              submitName: 'Submit',
              addTemplates: null,
              submitCall: null,
              id: null,
              textarea: null,
              readOnly: false
            };
            var textValueName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
            // Body
            var body = (0, _jquery["default"])('<div>');
            var textarea = (0, _jquery["default"])('<textarea>', {
              "class": 'form-control',
              style: "height: ".concat(String(config.size), "px;")
            });
            textarea.val(config.textarea);
            if (config.readOnly) textarea.prop('readOnly', true);
            var textEditor = new _tinyEssentials.TinyTextRangeEditor(textarea[0]);

            // Templates list
            if (config.addTemplates && Array.isArray(config.addTemplates.data) && config.addTemplates.data.length > 0) {
              var templateList = config.addTemplates.data;
              // Select
              var textareaAdd = (0, _jquery["default"])('<select>', {
                "class": 'form-control'
              });
              textareaAdd.append((0, _jquery["default"])('<option>', {
                value: 'DEFAULT'
              }).text(config.addTemplates.title));

              // Separator
              var addSeparator = function addSeparator() {
                return textareaAdd.append((0, _jquery["default"])('<option>').prop('disabled', true).text('----------------------'));
              };
              addSeparator();

              // Add options
              var _loop2 = function _loop2() {
                var templateItem = templateList[_index];
                // Validator
                var valueTypeValidator = function valueTypeValidator() {
                  // Tiny code
                  var tinyTypeValidator = function tinyTypeValidator(tinyTxtValName) {
                    return typeof templateItem[tinyTxtValName] === 'string' || templateItem.type === tinyTxtValName;
                  };

                  // String
                  if (typeof textValueName === 'string') return tinyTypeValidator(textValueName);

                  // Array
                  if (Array.isArray(textValueName)) {
                    for (var _index2 in textValueName) {
                      if (tinyTypeValidator(textValueName[_index2])) return true;
                    }
                  }

                  // Nothing
                  return false;
                };

                // Get data
                var getTypeValue = function getTypeValue() {
                  // Tiny code
                  var tinyTypeValidator = function tinyTypeValidator(tinyTxtValName) {
                    return typeof templateItem[tinyTxtValName] === 'string' ? templateItem[tinyTxtValName] : null;
                  };

                  // String
                  if (typeof textValueName === 'string') {
                    var value = tinyTypeValidator(textValueName);
                    if (value) return value;
                  }

                  // Array
                  if (Array.isArray(textValueName)) {
                    for (var _index3 in textValueName) {
                      var _value = tinyTypeValidator(textValueName[_index3]);
                      if (_value) return _value;
                    }
                  }

                  // Nothing
                  return null;
                };
                var ficOptionData = ficConfigs.data.find(function (item) {
                  return item.id === ficConfigs.selected;
                });
                if (ficOptionData && (
                // Sandbox
                typeof templateItem.sandboxOnly !== 'boolean' || !templateItem.sandboxOnly || canSandBox(ficConfigs.selected)) && (
                // Safe mode
                typeof ficOptionData.isSafe !== 'boolean' || !ficOptionData.isSafe || ficOptionData.isSafe && !templateItem.isNotSafe)) {
                  // Normal way
                  if (!templateItem.hr) {
                    // Validator
                    if (valueTypeValidator() && (typeof templateItem.value === 'string' || templateItem.disabled)) textareaAdd.append((0, _jquery["default"])('<option>', {
                      value: templateItem.value
                    })
                    // Data item
                    .data('TinyAI-select-text', getTypeValue()).data('TinyAI-temperature', typeof templateItem.temperature === 'number' && !Number.isNaN(templateItem.temperature) && templateItem.temperature >= 0 ? templateItem.temperature : null).data('TinyAI-max-output-tokens', typeof templateItem.maxOutputTokens === 'number' && !Number.isNaN(templateItem.maxOutputTokens) && templateItem.maxOutputTokens >= 0 ? templateItem.maxOutputTokens : null).data('TinyAI-topP', typeof templateItem.topP === 'number' && !Number.isNaN(templateItem.topP) && templateItem.topP >= 0 ? templateItem.topP : null).data('TinyAI-topK', typeof templateItem.topK === 'number' && !Number.isNaN(templateItem.topK) && templateItem.topK >= 0 ? templateItem.topK : null).data('TinyAI-presence-penalty', typeof templateItem.presencePenalty === 'number' && !Number.isNaN(templateItem.presencePenalty) && templateItem.presencePenalty >= 0 ? templateItem.presencePenalty : null).data('TinyAI-frequency-penalty', typeof templateItem.frequencyPenalty === 'number' && !Number.isNaN(templateItem.frequencyPenalty) && templateItem.frequencyPenalty >= 0 ? templateItem.frequencyPenalty : null)
                    // Option name
                    .text(templateItem.name)

                    // Option is disabled?
                    .prop('disabled', typeof templateItem.disabled === 'boolean' ? templateItem.disabled : false));
                  }
                  // Separator
                  else if (valueTypeValidator()) addSeparator();
                }
              };
              for (var _index in templateList) {
                _loop2();
              }

              // Option selected
              textareaAdd.on('change', function () {
                // Get value
                var option = textareaAdd.find("[value=\"".concat(textareaAdd.val(), "\"]"));
                var text = option ? option.data('TinyAI-select-text') : null || null;
                var tempValue = option.data('TinyAI-temperature') || null;
                var maxOutputTokensValue = option.data('TinyAI-max-output-tokens') || null;
                var topPValue = option.data('TinyAI-topP') || null;
                var topKValue = option.data('TinyAI-topK') || null;
                var presencePenaltyValue = option.data('TinyAI-presence-penalty') || null;
                var frequencyPenaltyValue = option.data('TinyAI-frequency-penalty') || null;
                if (typeof tempValue === 'number') tinyAi.setTemperature(tempValue);
                if (typeof maxOutputTokensValue === 'number') tinyAi.setMaxOutputTokens(maxOutputTokensValue);
                if (typeof topPValue === 'number') tinyAi.setTopP(topPValue);
                if (typeof topKValue === 'number') tinyAi.setTopK(topKValue);
                if (typeof presencePenaltyValue === 'number') tinyAi.setPresencePenalty(presencePenaltyValue);
                if (typeof frequencyPenaltyValue === 'number') tinyAi.setFrequencyPenalty(frequencyPenaltyValue);
                textareaAdd.val('DEFAULT');

                // Insert text
                if (typeof text === 'string' && text.length > 0) textEditor.insertText(text, {
                  autoSpacing: true
                }).focus();
              });

              // Insert into body
              body.append(textareaAdd);
            }

            // Add textarea
            body.append((0, _jquery["default"])('<p>').text(config.info));
            body.append(textarea);

            // Submit
            var submit = _tinyLib["default"].bs.button('info m-2 ms-0');
            submit.text(config.submitName);
            submit.on('click', function () {
              config.submitCall(textarea.val());
              (0, _jquery["default"])("#".concat(config.id)).modal('hide');
            });
            if (config.readOnly) submit.prop('disabled', true).addClass('disabled');
            body.append((0, _jquery["default"])('<div>', {
              "class": 'd-grid gap-2 col-6 mx-auto'
            }).append(submit));

            // Start modal
            _tinyLib["default"].modal({
              id: config.id,
              title: 'AI Prompt',
              dialog: 'modal-lg',
              body: body
            });
          };
          isOnline = function isOnline() {
            return !canUsejsStore && tinyIo.client ? true : false;
          };
          leftMenu = [];
          if (!tinyAiScript.mpClient) {
            // Reset
            leftMenu.push((0, _jquery["default"])('<h5>').text('Reset'));
            leftMenu.push.apply(leftMenu, ficResets);

            // Modes
            leftMenu.push((0, _jquery["default"])('<h5>').text('Modes'));

            // Fic Talk
            leftMenu.push.apply(leftMenu, ficTemplates);
          }

          // Settings
          leftMenu.push((0, _jquery["default"])('<h5>').text('Settings'));
          leftMenu.push.apply(leftMenu, ficPromptItems);

          // RPG
          leftMenu.push((0, _jquery["default"])('<h5>').text('RPG'));
          // Dice
          leftMenu.push(createButtonSidebar('fa-solid fa-dice', 'Roll Dice', function () {
            // Root
            var $root = (0, _jquery["default"])('<div>');
            var $formRow = (0, _jquery["default"])('<div>').addClass('row g-3');
            var $totalBase = (0, _jquery["default"])('<center>', {
              "class": 'fw-bold mt-3'
            }).text(0);

            // Config
            var tinyCfg = {
              isOnline: isOnline(),
              data: {},
              rateLimit: {}
            };
            if (tinyCfg.isOnline) {
              tinyCfg.data = tinyIo.client.getDice() || {};
              var ratelimit = tinyIo.client.getRateLimit() || {
                dice: {},
                size: {}
              };
              if ((0, _tinyEssentials.objType)(ratelimit.dice, 'object')) tinyCfg.rateLimit = ratelimit.dice;
            } else {
              tinyCfg.data.img = _start.tinyLs.getItem("tiny-dice-img") || undefined;
              tinyCfg.data.bg = _start.tinyLs.getItem("tiny-dice-bg") || 'white';
              tinyCfg.data.text = _start.tinyLs.getItem("tiny-dice-text") || 'black';
              tinyCfg.data.border = _start.tinyLs.getItem("tiny-dice-border") || '2px solid rgba(0, 0, 0, 0.05)';
              tinyCfg.data.selectionBg = _start.tinyLs.getItem("tiny-dice-selection-bg") || 'black';
              tinyCfg.data.selectionText = _start.tinyLs.getItem("tiny-dice-selection-text") || 'white';
            }

            // Form template
            var configs = {};
            var genLabel = function genLabel(id, text) {
              return (0, _jquery["default"])('<label>').addClass('form-label').attr('for', "tiny-dice_".concat(id)).text(text);
            };
            var genInput = function genInput(id, type, value, min) {
              return (0, _jquery["default"])('<input>').addClass('form-control text-center').attr({
                id: "tiny-dice_".concat(id),
                type: type,
                min: min
              }).attr('placeholder', min).val(value);
            };
            var genConfig = function genConfig(id, text, type, value, min) {
              configs[id] = genInput(id, type, value, min);
              return [genLabel(id, text), configs[id]];
            };

            // Form
            var $perDieCol = (0, _jquery["default"])('<div>').addClass('col-md-12').append(genConfig('perDieValues', 'Per-Die Values', 'text', '6', 'e.g., 6,12,20'));
            var $allow0input = (0, _jquery["default"])('<input>').addClass('form-check-input').attr({
              type: 'checkbox',
              id: 'tiny-dice_allow0'
            });
            var $allow0Col = (0, _jquery["default"])('<div>').addClass('d-flex justify-content-center align-items-center mt-2').append((0, _jquery["default"])('<div>').addClass('form-check').append($allow0input, (0, _jquery["default"])('<label>').addClass('form-check-label').attr('for', 'tiny-dice_allow0').text('Allow zero values')));
            $formRow.append($perDieCol);

            // Roll button
            var $rollButton = _tinyLib["default"].bs.button('primary w-100 mb-4 mt-2').text('Roll Dice');

            // Add container
            var $diceContainer = (0, _jquery["default"])('<div>');
            var $diceError = (0, _jquery["default"])('<div>');
            var readSkinValues = [['bgSkin', 'bg', 'setBgSkin'], ['textSkin', 'text', 'setTextSkin'], ['borderSkin', 'border', 'setBorderSkin'], ['bgImg', 'img', 'setBgImg'], ['selectionBgSkin', 'selectionBg', 'setSelectionBgSkin'], ['selectionTextSkin', 'selectionText', 'setSelectionTextSkin']];

            // TinyDices logic
            var dice = new _tinyDices["default"]($diceContainer.get(0));
            var updateTotalBase = null;
            $rollButton.on('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7() {
              var perDieRaw, perDie, canZero, result, total, _iterator, _step, item, diceParse, sides, _index4, _result, _index5;
              return _regenerator().w(function (_context7) {
                while (1) switch (_context7.n) {
                  case 0:
                    // Get values
                    perDieRaw = configs.perDieValues.val().trim();
                    perDie = perDieRaw.length > 0 ? perDieRaw : null;
                    canZero = $allow0input.is(':checked');
                    $totalBase.text(0);
                    if (updateTotalBase) {
                      clearTimeout(updateTotalBase);
                      updateTotalBase = null;
                    }

                    // Offline
                    if (tinyCfg.isOnline) {
                      _context7.n = 1;
                      break;
                    }
                    result = dice.roll(perDie, canZero);
                    total = 0;
                    _iterator = _createForOfIteratorHelper(result);
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        item = _step.value;
                        total += item.result;
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    updateTotalBase = setTimeout(function () {
                      $totalBase.text(total);
                      updateTotalBase = null;
                    }, 2000);
                    _context7.n = 3;
                    break;
                  case 1:
                    // Prepare data
                    diceParse = dice.parseRollConfig(perDie);
                    sides = [];
                    for (_index4 in diceParse) sides.push(diceParse[_index4]);

                    // Get result
                    (0, _jquery["default"])(this).attr('disabled', true).addClass('disabled');
                    _context7.n = 2;
                    return tinyIo.client.rollDice(sides, canZero);
                  case 2:
                    _result = _context7.v;
                    (0, _jquery["default"])(this).attr('disabled', false).removeClass('disabled');

                    // Proccess Results
                    if (!_result.error) {
                      dice.clearDiceArea();
                      $totalBase.removeClass('text-danger');
                      if (Array.isArray(_result.results) && typeof _result.total === 'number') {
                        for (_index5 in _result.results) {
                          if (typeof _result.results[_index5].sides === 'number' && typeof _result.results[_index5].roll === 'number') dice.insertDiceElement(_result.results[_index5].roll, _result.results[_index5].sides, canZero);
                        }
                        updateTotalBase = setTimeout(function () {
                          $totalBase.text(_result.total);
                          updateTotalBase = null;
                        }, 2000);
                      }
                    } else $totalBase.addClass('text-danger').text(_result.msg);
                  case 3:
                    return _context7.a(2);
                }
              }, _callee7, this);
            })));

            // Skin form
            var createInputField = function createInputField(label, id, placeholder, value) {
              configs[id] = (0, _jquery["default"])('<input>').addClass('form-control text-center').attr({
                type: 'text',
                placeholder: placeholder
              }).val(value);
              return (0, _jquery["default"])('<div>').addClass('col-md-4 text-center').append((0, _jquery["default"])('<label>').addClass('form-label').attr('for', id).text(label), configs[id]);
            };
            configs.bgImg = (0, _jquery["default"])('<input>').addClass('form-control').addClass('d-none').attr('type', 'text').val(tinyCfg.data.img);
            var bgImgUploadButton = _tinyLib["default"].bs.button('info w-100');
            var uploadImgButton = _tinyLib["default"].upload.img(bgImgUploadButton.text('Select Image').on('contextmenu', function (e) {
              e.preventDefault();
              configs.bgImg.val('').removeClass('text-danger').trigger('change');
            }), function (err, dataUrl) {
              console.log("[dice-file] [upload] Image length: ".concat(dataUrl.length));

              // Error
              bgImgUploadButton.removeClass('text-danger');
              if (err) {
                console.error(err);
                bgImgUploadButton.addClass('text-danger');
                return;
              }
              var maxSize = tinyCfg.rateLimit.img || 0;
              var base64String = dataUrl.split(',')[1];
              var padding = (base64String.match(/=+$/) || [''])[0].length;
              var sizeInBytes = base64String.length * 3 / 4 - padding;
              var convertToMb = function convertToMb(tinyBytes) {
                return "".concat((tinyBytes / (1024 * 1024)).toFixed(2), " MB");
              };
              console.log("[dice-file] [upload] Image size: ".concat(convertToMb(sizeInBytes)));
              console.log("[dice-file] [upload] Upload limit: ".concat(convertToMb(maxSize)));

              // Big Image
              $diceError.empty();
              if (maxSize > 0 && sizeInBytes > maxSize) {
                bgImgUploadButton.addClass('text-danger');
                _tinyLib["default"].alert($diceError, 'danger', 'bi bi-exclamation-triangle-fill', "Image is too large: ".concat(convertToMb(sizeInBytes), " (max allowed: ").concat(convertToMb(maxSize), ")"));
                return;
              }

              // OK
              configs.bgImg.val(dataUrl).removeClass('text-danger').trigger('change');
            });
            var importDiceButton = _tinyLib["default"].upload.json(_tinyLib["default"].bs.button('info w-100').text('Import'), function (err, jsonData) {
              // Error
              if (err) {
                console.error(err);
                alert(err.message);
                return;
              }

              // Insert data
              if ((0, _tinyEssentials.objType)(jsonData, 'object') && (0, _tinyEssentials.objType)(jsonData.data, 'object')) {
                for (var _index6 in readSkinValues) {
                  var readSkinData = readSkinValues[_index6];
                  var name = readSkinData[1];
                  var item = jsonData.data[name];
                  if (typeof item === 'string' || typeof item === 'number') {
                    var newValue = typeof tinyCfg.rateLimit[name] !== 'number' || item.length <= tinyCfg.rateLimit[name] ? item : null;
                    configs[readSkinData[0]].val(newValue).trigger('change');
                  }
                }
              }
            });
            var $formRow2 = (0, _jquery["default"])('<div>', {
              "class": 'd-none'
            }).addClass('row g-3 mb-4').append(
            // Background skin
            createInputField('Background Skin', 'bgSkin', 'e.g. red or rgb(200,0,0)', tinyCfg.data.bg),
            // Text skin
            createInputField('Text Skin', 'textSkin', 'e.g. white or #fff', tinyCfg.data.text),
            // Border skin
            createInputField('Border Skin', 'borderSkin', 'e.g. 2px solid rgba(255, 255, 255, 0.2)', tinyCfg.data.border),
            // Bg skin
            createInputField('Select Bg Skin', 'selectionBgSkin', 'e.g. black or #000', tinyCfg.data.selectionBg),
            // Text skin
            createInputField('Select Text Skin', 'selectionTextSkin', 'e.g. white or #fff', tinyCfg.data.selectionText),
            // Image upload
            configs.bgImg, (0, _jquery["default"])('<div>', {
              "class": 'col-md-4 text-center'
            }).append((0, _jquery["default"])('<label>').addClass('form-label').text('Custom Image'), uploadImgButton),
            // Export
            (0, _jquery["default"])('<div>', {
              "class": 'col-md-6'
            }).append(_tinyLib["default"].bs.button('info w-100').text('Export').on('click', function () {
              // Data base
              var fileData = {
                data: {}
              };
              for (var _index7 in readSkinValues) {
                var readSkinData = readSkinValues[_index7];
                fileData.data[readSkinData[1]] = configs[readSkinData[0]].val().trim();
              }

              // Date
              fileData.date = Date.now();
              // Save
              (0, _fileSaver.saveAs)(new Blob([JSON.stringify(fileData)], {
                type: 'text/plain'
              }), "tiny_dice_skin_ponydriland.json");
            })),
            // Import
            (0, _jquery["default"])('<div>', {
              "class": 'col-md-6'
            }).append(importDiceButton));
            var updateDiceData = function updateDiceData(where, dataName, value) {
              dice[where](value);
              if (!tinyIo.client) {
                if (value) _start.tinyLs.setItem("tiny-dice-".concat(dataName), value);else _start.tinyLs.removeItem("tiny-dice-".concat(dataName));
              }
              dice.updateDicesSkin();
            };
            var _loop3 = function _loop3(_index8) {
              configs[readSkinValues[_index8][0]].on('change', function () {
                updateDiceData(readSkinValues[_index8][2], readSkinValues[_index8][1], (0, _jquery["default"])(this).val().trim() || null);
              });
            };
            for (var _index8 in readSkinValues) {
              _loop3(_index8);
            }
            var updateAllSkins = function updateAllSkins() {
              for (var _index9 in readSkinValues) configs[readSkinValues[_index9][0]].trigger('change');
            };

            // Root insert
            $root.append((0, _jquery["default"])('<center>').append($formRow), $allow0Col, $formRow2);

            // Main button of the skin editor
            var $applyBtn = _tinyLib["default"].bs.button('success w-100').text('Edit Skin Data');
            $applyBtn.on('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
              var diceSkin, _index0, result, _index1;
              return _regenerator().w(function (_context8) {
                while (1) switch (_context8.n) {
                  case 0:
                    if (!$formRow2.hasClass('d-none')) {
                      _context8.n = 1;
                      break;
                    }
                    $applyBtn.text(tinyIo.client ? 'Apply Dice Skins' : 'Hide Skin Data');
                    _context8.n = 3;
                    break;
                  case 1:
                    $applyBtn.text('Edit Skin Data');
                    if (!tinyCfg.isOnline) {
                      _context8.n = 3;
                      break;
                    }
                    updateAllSkins();

                    // Disable buttons
                    $applyBtn.attr('disabled', true).addClass('disabled');
                    diceSkin = {};
                    importDiceButton.attr('disabled', true).addClass('disabled');
                    uploadImgButton.attr('disabled', true).addClass('disabled');

                    // Send dice data
                    for (_index0 in readSkinValues) diceSkin[readSkinValues[_index0][1]] = configs[readSkinValues[_index0][0]].attr('disabled', true).addClass('disabled').val().trim();
                    _context8.n = 2;
                    return tinyIo.client.setAccountDice(diceSkin);
                  case 2:
                    result = _context8.v;
                    if (result.error) $totalBase.addClass('text-danger').text(result.msg);else {
                      $totalBase.removeClass('text-danger').text(0);
                      tinyIo.client.setDice(diceSkin);
                    }

                    // Enable buttons again
                    for (_index1 in readSkinValues) configs[readSkinValues[_index1][0]].attr('disabled', false).removeClass('disabled');
                    uploadImgButton.attr('disabled', false).removeClass('disabled');
                    importDiceButton.attr('disabled', false).removeClass('disabled');
                    $applyBtn.attr('disabled', false).removeClass('disabled');
                  case 3:
                    // Change class mode
                    $formRow2.toggleClass('d-none');
                  case 4:
                    return _context8.a(2);
                }
              }, _callee8);
            })));
            $root.append($applyBtn, $rollButton, $diceError, $diceContainer, $totalBase);
            updateAllSkins();
            dice.roll([0, 0, 0]);

            // Start modal
            _tinyLib["default"].modal({
              title: 'Dice Roll',
              dialog: 'modal-lg',
              id: 'dice-roll',
              body: $root
            });
          }));

          // RPG Data
          leftMenu.push(createButtonSidebar('fa-solid fa-note-sticky', 'View Data', null, false, {
            toggle: 'offcanvas',
            target: '#rpg_ai_base_1'
          }));

          // Private RPG Data
          leftMenu.push(createButtonSidebar('fa-solid fa-book', 'View Private', null, false, {
            toggle: 'offcanvas',
            target: '#rpg_ai_base_2'
          }));

          // Classic Map
          leftMenu.push(createButtonSidebar('fa-solid fa-map', 'Classic Map', function () {
            var startTinyMap = function startTinyMap(place) {
              // Get Map Data
              var maps;
              var location;
              try {
                maps = rpgData.data[place].getEditor('root.settings.maps').getValue();
                location = rpgData.data[place].getEditor('root.location').getValue();
              } catch (e) {
                maps = null;
              }

              // Exist Map
              tinyHtml.empty();
              try {
                if (Array.isArray(maps)) {
                  for (var _index10 in maps) {
                    var map = new _TinyMap["default"](maps[_index10]);
                    map.setLocation(location);
                    map.buildMap(true);
                    tinyHtml.append(map.getMapBaseHtml(), (0, _jquery["default"])('<center>').append(map.getMapButton()));
                  }
                }
              } catch (e) {
                // No Map
                console.error(e);
                tinyHtml.empty();
              }
            };
            var tinyHtml = (0, _jquery["default"])('<span>');
            var tinyHr = (0, _jquery["default"])('<hr>', {
              "class": 'my-5 d-none'
            });
            _tinyLib["default"].modal({
              title: 'Maps',
              dialog: 'modal-lg',
              id: 'tinyMaps',
              body: [tinyHtml, tinyHr, (0, _jquery["default"])('<center>').append(
              // Public Maps
              _tinyLib["default"].bs.button('secondary m-2').text('Public').on('click', function () {
                tinyHr.removeClass('d-none');
                startTinyMap('public');
              }),
              // Private Maps
              _tinyLib["default"].bs.button('secondary m-2').text('Private').on('click', function () {
                tinyHr.removeClass('d-none');
                startTinyMap('private');
              }))]
            });
          }));

          // Online Mode options
          if (!canUsejsStore) {
            leftMenu.push((0, _jquery["default"])('<h5>').text('Online'));
            leftMenu.push(createButtonSidebar('fas fa-users', 'Room settings', function () {
              if (tinyIo.client) {
                var room = tinyIo.client.getRoom() || {};
                var ratelimit = tinyIo.client.getRateLimit() || {
                  size: {},
                  limit: {}
                };
                var user = tinyIo.client.getUser() || {};
                var cantEdit = room.ownerId !== tinyIo.client.getUserId() && !user.isOwner;
                var $root = (0, _jquery["default"])('<div>');
                var $formContainer = (0, _jquery["default"])('<div>').addClass('mb-4');
                var $editError = (0, _jquery["default"])('<div>').addClass('text-danger small mt-2');
                var $deleteError = (0, _jquery["default"])('<div>').addClass('text-danger small mt-2');

                // âââ Edit room âââââââââââââââââââââââââââââââ
                var $editForm = (0, _jquery["default"])('<form>').addClass('mb-4');
                $editForm.append((0, _jquery["default"])('<h5>').text('Edit Room Info'));
                var $roomId = (0, _jquery["default"])('<input>').attr({
                  type: 'text',
                  id: 'roomId',
                  placeholder: 'Enter new room title',
                  maxLength: ratelimit.size.roomId
                }).prop('disabled', true).addClass('form-control').addClass('form-control').val(tinyIo.client.getRoomId());
                var $roomTitle = (0, _jquery["default"])('<input>').attr({
                  type: 'text',
                  id: 'roomTitle',
                  placeholder: 'Enter new room title',
                  maxLength: ratelimit.size.roomTitle
                }).addClass('form-control').val(room.title).prop('disabled', cantEdit);
                $editForm.append((0, _jquery["default"])('<div>').addClass('row mb-3').append((0, _jquery["default"])('<div>').addClass('col-md-6').append((0, _jquery["default"])('<label>').attr('for', 'roomId').addClass('form-label').text('Room ID'), $roomId), (0, _jquery["default"])('<div>').addClass('col-md-6').append((0, _jquery["default"])('<label>').attr('for', 'roomTitle').addClass('form-label').text('Room Title'), $roomTitle)));

                // Max users
                $editForm.append((0, _jquery["default"])('<div>').addClass('mb-3').append((0, _jquery["default"])('<label>').attr('for', 'maxUsers').addClass('form-label').text('Max Users'), (0, _jquery["default"])('<input>').attr({
                  type: 'number',
                  id: 'maxUsers',
                  min: 1,
                  max: ratelimit.limit.roomUsers,
                  placeholder: 'Maximum number of users'
                }).addClass('form-control').val(room.maxUsers).prop('disabled', cantEdit)));

                // New password
                $editForm.append((0, _jquery["default"])('<div>').addClass('mb-3').append((0, _jquery["default"])('<label>').attr('for', 'roomPassword').addClass('form-label').text('New Room Password'), (0, _jquery["default"])('<input>').attr({
                  type: 'password',
                  id: 'roomPassword',
                  placeholder: 'Leave empty to keep current password',
                  maxLength: ratelimit.size.password
                }).addClass('form-control').prop('disabled', cantEdit)));

                // Submit
                $editForm.append((0, _jquery["default"])('<button>').attr('type', 'submit').addClass('btn btn-primary').text('Save Changes').prop('disabled', cantEdit));

                // âââ Delete room âââââââââââââââââââââââââââââ
                var $deleteSection = (0, _jquery["default"])('<div>').addClass('border-top pt-4');
                $deleteSection.append((0, _jquery["default"])('<h5>').addClass('text-danger').text('Delete Room'), (0, _jquery["default"])('<p>').addClass('text-muted mb-2').html('This action <strong>cannot be undone</strong>. Deleting this room will remove all its data permanently.'));
                var $deleteForm = (0, _jquery["default"])('<form>').addClass('d-flex flex-column gap-2');

                // Your password
                $deleteForm.append((0, _jquery["default"])('<div>').append((0, _jquery["default"])('<label>').attr('for', 'ownerPassword').addClass('form-label').text('Enter your current password to confirm:'), (0, _jquery["default"])('<input>').attr({
                  type: 'password',
                  id: 'ownerPassword',
                  placeholder: 'Current account password',
                  maxLength: ratelimit.size.password
                }).addClass('form-control').prop('disabled', cantEdit)));

                // Delete now
                $deleteForm.append((0, _jquery["default"])('<button>').attr('type', 'submit').addClass('btn btn-danger mt-2').text('Delete Room Permanently').prop('disabled', cantEdit));
                $deleteSection.append($deleteForm);

                // âââ Container time âââââââââââââââââââââââââââââââ
                $formContainer.append($editForm, $deleteSection);

                // âââ Add into the DOM âââ
                $root.append($formContainer);
                $editForm.append($editError);
                $deleteForm.append($deleteError);

                // Start modal
                var modal = _tinyLib["default"].modal({
                  title: 'Room Settings',
                  dialog: 'modal-lg',
                  id: 'user-manager',
                  body: $root
                });
                $editForm.on('submit', function (e) {
                  e.preventDefault();
                  if (!cantEdit) {
                    $editError.empty(); // limpa erros anteriores

                    var title = $roomTitle.val().trim();
                    var maxUsers = parseInt($editForm.find('#maxUsers').val(), 10);
                    var password = $editForm.find('#roomPassword').val().trim();
                    if (Number.isNaN(maxUsers) || maxUsers <= 0) {
                      $editError.text('Max users must be a positive number.');
                      return;
                    }
                    if (maxUsers > 50) {
                      $editError.text('Max users cannot exceed 50.');
                      return;
                    }
                    var newSettings = {
                      title: title,
                      maxUsers: maxUsers
                    };
                    if (typeof password === 'string' && password.length > 0) newSettings.password = password;
                    modal.modal('hide');
                    tinyIo.client.updateRoomSettings(newSettings).then(function (result) {
                      if (result.error) alert("".concat(result.msg, "\nCode ").concat(result.code));else alert('Your room settings has been changed successfully!');
                    });
                  }
                });
                $deleteForm.on('submit', function (e) {
                  e.preventDefault();
                  if (!cantEdit) {
                    $deleteError.empty(); // limpa erros anteriores

                    var password = $deleteForm.find('#ownerPassword').val().trim();
                    if (!password) {
                      $deleteError.text('Please enter your current password.');
                      return;
                    }
                    if (!confirm('Are you absolutely sure? This cannot be undone.')) return;
                    modal.modal('hide');
                    tinyIo.client.deleteRoom(password).then(function (result) {
                      if (result.error) alert("".concat(result.msg, "\nCode ").concat(result.code));else alert('Your room has been deleted successfully!');
                    });
                  }
                });
              }
            }));
            leftMenu.push(createButtonSidebar('fas fa-users', 'User manager', function () {
              if (tinyIo.client) {
                var $root = (0, _jquery["default"])('<div>');

                // Start modal
                var modal = _tinyLib["default"].modal({
                  title: 'User manager',
                  dialog: 'modal-lg',
                  id: 'user-manager',
                  body: $root
                });

                // Start user room data
                var user = tinyIo.client.getUser() || {};
                var room = tinyIo.client.getRoom() || {};
                var userManager = new _RoomUserManagerUI["default"]({
                  client: tinyIo.client,
                  currentUserId: user.userId,
                  isOwner: user.userId === room.ownerId,
                  root: $root,
                  users: (0, _clone["default"])(tinyIo.client.getUsers()),
                  moderators: []
                });
                var mods = tinyIo.client.getMods() || [];
                var _iterator2 = _createForOfIteratorHelper(mods),
                  _step2;
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    userId = _step2.value;
                    userManager.promoteModerator(userId);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
                userManager.setRoomStatus(!room.disabled);

                // Add events
                var usersAdded = function usersAdded(data) {
                  return userManager.addUser(data.userId, (0, _clone["default"])(data.data));
                };
                var usersRemoved = function usersRemoved(userId) {
                  return userManager.removeUser(userId);
                };
                var userModUpdated = function userModUpdated(type, userId) {
                  if (type === 'add') userManager.promoteModerator(userId);
                  if (type === 'remove') userManager.demoteModerator(userId);
                };
                var roomStatusUpdate = function roomStatusUpdate(roomData) {
                  userManager.setRoomStatus(!roomData.disabled);
                };
                tinyIo.client.on('userPing', usersAdded);
                tinyIo.client.on('userJoined', usersAdded);
                tinyIo.client.on('userLeft', usersRemoved);
                tinyIo.client.on('userKicked', usersRemoved);
                tinyIo.client.on('userBanned', usersRemoved);
                tinyIo.client.on('roomModChange', userModUpdated);
                tinyIo.client.on('roomUpdates', roomStatusUpdate);

                // Close modal
                modal.on('hidden.bs.modal', function () {
                  tinyIo.client.off('userPing', usersAdded);
                  tinyIo.client.off('userJoined', usersAdded);
                  tinyIo.client.off('userLeft', usersRemoved);
                  tinyIo.client.off('userKicked', usersRemoved);
                  tinyIo.client.off('userBanned', usersRemoved);
                  tinyIo.client.off('roomModChange', userModUpdated);
                  tinyIo.client.off('roomUpdates', roomStatusUpdate);
                  userManager.destroy();
                });
              }
            }));
            templateChangeInfo = function templateChangeInfo(id, icon, buttonName, title, labelName, placeHolder, infoName, getInfo, callback) {
              leftMenu.push(createButtonSidebar(icon, buttonName, function () {
                // Prepare root
                var $root = (0, _jquery["default"])('<div>');
                var $card = (0, _jquery["default"])('<div>').addClass('card shadow rounded-4');
                var $cardBody = (0, _jquery["default"])('<div>').addClass('card-body');
                var $inputGroup = (0, _jquery["default"])('<div>').addClass('mb-3');
                var $label = (0, _jquery["default"])('<label>').addClass('form-label').attr('for', 'on_edit_tinyinfo').text(labelName);
                var $input = (0, _jquery["default"])('<input>').addClass('form-control').addClass('text-center').attr({
                  type: 'text',
                  id: 'on_edit_tinyinfo',
                  placeholder: placeHolder
                });

                // Page information
                var _getInfo = getInfo(),
                  ratelimit = _getInfo.ratelimit,
                  userData = _getInfo.userData;
                $input.attr('maxLength', ratelimit.size[infoName]).val(typeof userData[infoName] === 'string' ? userData[infoName] : '').on('keydown', function (e) {
                  if (e.key === 'Enter') {
                    e.preventDefault();
                    $saveBtn.trigger('click');
                  }
                });
                var $saveBtn = _tinyLib["default"].bs.button('primary w-100').text('Save');

                // Build elements
                $inputGroup.addClass('text-center').append($label, $input);
                $cardBody.append($inputGroup, $saveBtn);
                $card.append($cardBody);
                $root.append($card);

                // Click button event
                $saveBtn.on('click', function () {
                  callback($input.val().trim());
                  modal.modal('hide');
                });

                // Start modal
                var modal = _tinyLib["default"].modal({
                  title: title,
                  dialog: 'modal-lg',
                  id: id,
                  body: $root
                });
                modal.on('shown.bs.modal', function () {
                  $input.trigger('focus');
                });
              }));
            }; // Edit nickname
            templateChangeInfo('edit-nickname',
            // Id
            'fa-solid fa-id-card',
            // Icon
            'Edit nickname',
            // Button name
            'Edit your Nickname',
            // Title
            'Nickname',
            // Label name
            'Enter your nickname',
            // Place Holder
            'nickname',
            // Object Name
            function () {
              var ratelimit = tinyIo.client.getRateLimit() || {
                size: {}
              };
              var userData = tinyIo.client.getUser() || {};
              return {
                ratelimit: ratelimit,
                userData: userData
              };
            }, function (value) {
              tinyIo.client.changeNickname(value).then(function (result) {
                if (result.error) alert("".concat(result.msg, "\nCode ").concat(result.code));else alert('Your nickname has been changed successfully!');
              });
            });
            leftMenu.push(createButtonSidebar('fas fa-key', 'Change password', function () {
              // Root
              var ratelimit = tinyIo.client.getRateLimit() || {
                size: {}
              };
              var $root = (0, _jquery["default"])('<div>');

              // Error place
              var $errorBox = _tinyLib["default"].bs.alert('danger', '', false).addClass('d-none');

              // Create label and input
              var createInputGroup = function createInputGroup(labelText, inputId) {
                var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'password';
                var $group = (0, _jquery["default"])('<div>').addClass('mb-3');
                var $label = (0, _jquery["default"])('<label>').addClass('form-label').attr('for', inputId).text(labelText);
                var $input = (0, _jquery["default"])('<input>').addClass('form-control').attr({
                  type: type,
                  id: inputId,
                  placeholder: labelText,
                  maxLength: ratelimit.size.password
                });
                $group.append($label, $input);
                return {
                  group: $group,
                  input: $input
                };
              };
              var current = createInputGroup('Current Password', 'current-password');
              var newPass = createInputGroup('New Password', 'new-password');
              var confirmPass = createInputGroup('Confirm New Password', 'confirm-password');

              // Change password button
              var $button = _tinyLib["default"].bs.button('primary').addClass('w-100').text('Change Password');

              // Build all
              $root.append($errorBox, current.group, newPass.group, confirmPass.group, $button);

              // show error
              var showError = function showError(msg) {
                $errorBox.html(msg).removeClass('d-none');
              };

              // Hide the error when the user starts to type
              [current.input, newPass.input, confirmPass.input].forEach(function ($input) {
                $input.on('input', function () {
                  return $errorBox.addClass('d-none');
                });
              });

              // Enter button
              [current.input, newPass.input, confirmPass.input].forEach(function ($input) {
                $input.on('keydown', function (e) {
                  if (e.key === 'Enter') {
                    e.preventDefault();
                    $button.trigger('click');
                  }
                });
              });

              // Button click
              $button.on('click', function () {
                var currentVal = current.input.val().trim();
                var newVal = newPass.input.val().trim();
                var confirmVal = confirmPass.input.val().trim();
                if (!currentVal || !newVal || !confirmVal) {
                  showError('Please fill in all fields.');
                  return;
                }
                if (newVal !== confirmVal) {
                  showError('New passwords do not match.');
                  return;
                }
                if (newVal.length < ratelimit.size.minPassword) {
                  showError("New password must be at least ".concat(ratelimit.size.minPassword, " characters."));
                  return;
                }

                // Tiny okay!
                $errorBox.addClass('d-none');
                modal.modal('hide');
                tinyIo.client.changePassword(currentVal, newVal).then(function (result) {
                  if (result.error) alert("".concat(result.msg, "\nCode ").concat(result.code));else alert('Your password has been changed successfully!');
                });
              });

              // Create modal
              var modal = _tinyLib["default"].modal({
                title: 'Change Password',
                dialog: 'modal-lg',
                id: 'modal-password-change',
                body: $root
              });
              modal.on('shown.bs.modal', function () {
                current.input.trigger('focus');
              });
            }));
            leftMenu.push(createButtonSidebar('fas fa-user-plus', 'Create account', function () {
              // Get data
              var ratelimit = tinyIo.client.getRateLimit() || {
                size: {}
              };
              var userData = tinyIo.client.getUser() || {};
              if (ratelimit.openRegistration || userData.isAdmin) {
                // Root container
                var $root = (0, _jquery["default"])('<div>');

                // Error alert box (initially hidden)
                var $errorBox = _tinyLib["default"].bs.alert('danger', '', false).addClass('d-none');

                // Helper to build input fields
                var createInputGroup = function createInputGroup(labelText, inputId) {
                  var maxLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'text';
                  var $group = (0, _jquery["default"])('<div>').addClass('mb-3');
                  var $label = (0, _jquery["default"])('<label>').addClass('form-label').attr('for', inputId).text(labelText);
                  var $input = (0, _jquery["default"])('<input>').addClass('form-control').attr({
                    maxLength: maxLength,
                    type: type,
                    id: inputId,
                    placeholder: labelText
                  });
                  $group.append($label, $input);
                  return {
                    group: $group,
                    input: $input
                  };
                };

                // Input fields
                var user = createInputGroup('User ID (no spaces)', 'register-user-id', ratelimit.size.userId);
                var pass = createInputGroup('Password', 'register-password', ratelimit.size.password, 'password');
                var _confirm = createInputGroup('Confirm Password', 'register-confirm-password', ratelimit.size.password, 'password');
                var nick = createInputGroup('Nickname (optional)', 'register-nickname', ratelimit.size.nickname);

                // Submit button
                var $button = _tinyLib["default"].bs.button('success').addClass('w-100').text('Create Account');

                // Build the form
                $root.append($errorBox, user.group, pass.group, _confirm.group, nick.group, $button);

                // Show error message
                var showError = function showError(msg) {
                  $errorBox.html(msg).removeClass('d-none');
                };

                // Clear error when typing
                [user.input, pass.input, _confirm.input, nick.input].forEach(function ($input) {
                  $input.on('input', function () {
                    return $errorBox.addClass('d-none');
                  });
                });

                // Handle Enter key
                [user.input, pass.input, _confirm.input, nick.input].forEach(function ($input) {
                  $input.on('keydown', function (e) {
                    if (e.key === 'Enter') {
                      e.preventDefault();
                      $button.trigger('click');
                    }
                  });
                });

                // Submit action
                $button.on('click', function () {
                  var userId = user.input.val().trim();
                  var password = pass.input.val().trim();
                  var confirmPassword = _confirm.input.val().trim();
                  var nickname = nick.input.val().trim();
                  if (!userId || !password || !confirmPassword) {
                    showError('User ID and both password fields are required.');
                    return;
                  }
                  if (/\s/.test(userId)) {
                    showError('User ID must not contain spaces.');
                    return;
                  }
                  if (password.length < ratelimit.size.minPassword) {
                    showError("Password must be at least ".concat(ratelimit.size.minPassword, " characters long."));
                    return;
                  }
                  if (password !== confirmPassword) {
                    showError('Passwords do not match.');
                    return;
                  }

                  // Tiny okay!
                  $errorBox.addClass('d-none');
                  modal.modal('hide');
                  tinyIo.client.register(userId, password, nickname).then(function (result) {
                    if (result.error) alert("".concat(result.msg, "\nCode ").concat(result.code));else alert("The new account was successfully created!");
                  });
                });

                // Launch modal with focus on first input
                var modal = _tinyLib["default"].modal({
                  title: 'Create Account',
                  dialog: 'modal-lg',
                  id: 'modal-create-account',
                  body: $root
                });
                modal.on('shown.bs.modal', function () {
                  user.input.trigger('focus');
                });
              }

              // No Perm
              else _tinyLib["default"].modal({
                title: 'Create Account',
                dialog: 'modal-lg',
                id: 'modal-create-account',
                body: (0, _jquery["default"])('<center>').text('You are not allowed to do this.')
              });
            }));
          }

          // Import
          leftMenu.push((0, _jquery["default"])('<h5>').text('Data'));
          leftMenu.push.apply(leftMenu, importItems);

          // Export
          leftMenu.push(createButtonSidebar('fa-solid fa-file-export', 'Export', function () {
            var exportData = {
              file: (0, _clone["default"])(tinyAi.getData()),
              id: tinyAi.getId()
            };
            if (exportData.file) {
              if (!canSandBox(ficConfigs.selected)) delete exportData.file.systemInstruction;
              if (exportData.file.file) delete exportData.file.file;
            }
            (0, _fileSaver.saveAs)(new Blob([JSON.stringify(exportData)], {
              type: 'text/plain'
            }), "Pony Driland - ".concat(tinyAi.getId(), " - AI Export.json"));
          }));

          // Downloads
          leftMenu.push(createButtonSidebar('fa-solid fa-download', 'Downloads', function () {
            var body = (0, _jquery["default"])('<div>');
            body.append((0, _jquery["default"])('<h3>').text("Download Content").prepend(_tinyLib["default"].icon('fa-solid fa-download me-3')).append(_tinyLib["default"].bs.button('info btn-sm ms-3').text('Save As all chapters').on('click', function () {
              return (0, _start.saveRoleplayFormat)();
            })), (0, _jquery["default"])('<h5>').text("Here you can download the official content of fic to produce unofficial content dedicated to artificial intelligence.").append((0, _jquery["default"])('<br/>'), (0, _jquery["default"])('<small>').text('Remember that you are downloading the uncensored version.')));
            for (var i = 0; i < storyData.chapter.amount; i++) {
              // Chapter Number
              var chapter = String(i + 1);

              // Add Chapter
              body.append((0, _jquery["default"])('<div>', {
                "class": 'card'
              }).append((0, _jquery["default"])('<div>', {
                "class": 'card-body'
              }).append((0, _jquery["default"])('<h5>', {
                "class": 'card-title m-0'
              }).text("Chapter ".concat(chapter, " - ")).append((0, _jquery["default"])('<small>').text(_config["default"].chapterName[chapter].title), (0, _jquery["default"])('<a>', {
                "class": 'btn btn-primary m-2 me-0 btn-sm',
                href: "/chapter/".concat(chapter, ".html"),
                chapter: chapter
              }).on('click', function () {
                // Save Chapter
                (0, _start.saveRoleplayFormat)(Number((0, _jquery["default"])(this).attr('chapter')));

                // Complete
                return false;
              }).text('Save as')))));
            }
            body.append((0, _jquery["default"])('<p>', {
              "class": 'm-0'
            }).text("This content is ready for AI to know which lines of text, chapters, day number, weather, location on any part of the fic you ask. The website script will convert all content to be easily understood by AI languages."));
            _tinyLib["default"].modal({
              id: 'ai_downloads',
              title: 'AI Downloads',
              dialog: 'modal-lg',
              body: body
            });
          }));

          // Donate
          leftMenu.push((0, _jquery["default"])('<h5>').text('Donate'));
          leftMenu.push(createButtonSidebar('fas fa-donate', 'Donate <3', function () {
            var $container = (0, _jquery["default"])('<div>').addClass('text-center');
            $container.append((0, _jquery["default"])('<p>', {
              "class": 'made-by-ai'
            }).html('This project took <strong>months of dedication</strong> and many <em>sleepless nights</em>.'));
            $container.append((0, _jquery["default"])('<p>', {
              "class": 'made-by-ai m-0'
            }).html('If you enjoyed all the love and effort I put into this <strong>super AI roleplay project</strong>,'));
            $container.append((0, _jquery["default"])('<p>', {
              "class": 'made-by-ai'
            }).html('I warmly invite you to support it with a <strong>voluntary donation</strong>'));
            $container.append((0, _jquery["default"])('<p>', {
              "class": 'made-by-ai m-0'
            }).html('I accept both <strong>traditional currencies</strong> and <strong>cryptocurrencies</strong> as donation methods'));
            $container.append((0, _jquery["default"])('<p>', {
              "class": 'made-by-ai'
            }).html('Thank you for helping this tiny magical project grow! ðð'));
            var patreonNames = ['Jimm'];
            var $thankYouBox = (0, _jquery["default"])('<div>').addClass('patreon-thankyou');
            var $thankYouText = (0, _jquery["default"])('<p>').text('Tiny magic moment to thank these magical patreons which supports the tiny fic:');
            var $ul = (0, _jquery["default"])('<ul>', {
              "class": 'list-unstyled'
            });
            patreonNames.forEach(function (name) {
              var $nameSpan = (0, _jquery["default"])('<span>').addClass('magic-name').text(name);
              var $li = (0, _jquery["default"])('<li>').append($nameSpan);
              $ul.append($li);
            });
            $thankYouBox.append($thankYouText, $ul);
            $container.append($thankYouBox);
            _tinyLib["default"].modal({
              title: 'Tiny Donations!',
              dialog: 'modal-lg',
              id: 'modal-donate',
              body: $container.append((0, _jquery["default"])('<div>', {
                "class": 'donation-highlight'
              }).append((0, _jquery["default"])('<img>', {
                "class": 'd-block w-100',
                src: '/img/ai-example/2025-04-09_06-48.jpg'
              })))
            });
          }));

          // Left
          connectionInfoBar = (0, _jquery["default"])('<span>');
          sidebarLeft = (0, _jquery["default"])('<div>', sidebarStyle).removeClass('d-md-block').removeClass('p-3').addClass('d-md-flex').addClass('flex-column').addClass('py-0').append((0, _jquery["default"])('<ul>', {
            "class": 'list-unstyled flex-grow-1 overflow-auto mb-0 pt-3 px-3'
          }).append((0, _jquery["default"])('<li>', {
            id: 'ai-mode-list',
            "class": 'mb-3'
          }).append(leftMenu),
          // Tiny information
          (0, _jquery["default"])('<div>', {
            "class": 'small text-grey p-2 bg-dark position-sticky bottom-0 pt-0'
          }).append((0, _jquery["default"])('<hr/>', {
            "class": 'border-white mt-0 mb-2'
          }), connectionInfoBar, (0, _jquery["default"])('<span>').text('AI makes mistakes, so double-check it. AI does not replace the fic literature (Careful! AI can type spoilers!).')))); // Right
          sidebarSettingTemplate = {
            span: {
              "class": 'pb-2 d-inline-block'
            }
          };
          sidebarRightBase = {
            // Model Selector
            modelSelector: (0, _jquery["default"])('<div>', {
              "class": 'form-floating',
              title: 'The AI model used here'
            }).append(modelSelector, (0, _jquery["default"])('<label>', {
              "for": 'select-ai-model'
            }).text('Select AI Model').prepend(_tinyLib["default"].icon("fa-solid fa-atom me-2"))),
            // Token Counter
            tokenCounter: (0, _jquery["default"])('<div>', {
              "class": 'mt-3',
              title: 'Counts how many tokens are used for the content generation'
            }).append((0, _jquery["default"])('<span>').text('Token count').prepend(_tinyLib["default"].icon("fa-solid fa-magnifying-glass me-2")), (0, _jquery["default"])('<div>', {
              "class": 'mt-1 small'
            }).append(tokenCount.amount, (0, _jquery["default"])('<span>', {
              "class": 'mx-1'
            }).text('/'), tokenCount.total)),
            // Temperature
            temperature: (0, _jquery["default"])('<div>', {
              "class": 'mt-3',
              title: 'Creativity allowed in the responses'
            }).append((0, _jquery["default"])('<span>', sidebarSettingTemplate.span).text('Temperature').prepend(_tinyLib["default"].icon("fa-solid fa-temperature-three-quarters me-2")), temperature.insert()),
            // Output Length
            outputLength: (0, _jquery["default"])('<div>', {
              "class": 'mt-3',
              title: 'Maximum number of tokens in response'
            }).append((0, _jquery["default"])('<span>', sidebarSettingTemplate.span).text('Output length').prepend(_tinyLib["default"].icon("fa-solid fa-comment me-2")), outputLength),
            // Top P
            topP: (0, _jquery["default"])('<div>', {
              "class": 'mt-3',
              title: 'The maximum cumulative probability of tokens to consider when sampling'
            }).append((0, _jquery["default"])('<span>', sidebarSettingTemplate.span).text('Top P').prepend(_tinyLib["default"].icon("fa-solid fa-percent me-2")), topP.insert()),
            // Top K
            topK: (0, _jquery["default"])('<div>', {
              "class": 'mt-3',
              title: 'The maximum number of tokens to consider when sampling'
            }).append((0, _jquery["default"])('<span>', sidebarSettingTemplate.span).text('Top K').prepend(_tinyLib["default"].icon("fa-solid fa-0 me-2")), topK.insert()),
            // Presence penalty
            presencePenalty: (0, _jquery["default"])('<div>', {
              "class": 'mt-3',
              title: "Presence penalty applied to the next token's logprobs if the token has already been seen in the response"
            }).append((0, _jquery["default"])('<span>', sidebarSettingTemplate.span).text('Presence penalty').prepend(_tinyLib["default"].icon("fa-solid fa-hand me-2")), presencePenalty.insert()),
            // Frequency penalty
            frequencyPenalty: (0, _jquery["default"])('<div>', {
              "class": 'mt-3',
              title: "Frequency penalty applied to the next token's logprobs, multiplied by the number of times each token has been seen in the respponse so far"
            }).append((0, _jquery["default"])('<span>', sidebarSettingTemplate.span).text('Frequency penalty').prepend(_tinyLib["default"].icon("fa-solid fa-hand me-2")), frequencyPenalty.insert())
          }; // Active tooltip
          sidebarRightBase.tokenCounter.tooltip();
          sidebarRightBase.temperature.tooltip();
          sidebarRightBase.outputLength.tooltip();
          sidebarRightBase.topP.tooltip();
          sidebarRightBase.topK.tooltip();
          sidebarRightBase.presencePenalty.tooltip();
          sidebarRightBase.frequencyPenalty.tooltip();

          // Models list
          updateModelList = function updateModelList() {
            if (!tinyAiScript.noai && !tinyAiScript.mpClient) {
              var models = tinyAi.getModelsList();
              resetModelSelector();
              if (models.length > 0) {
                // Insert model
                var insertItem = function insertItem(id, displayName) {
                  var disabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                  return modelSelector.append((0, _jquery["default"])('<option>', {
                    value: id
                  }).prop('disabled', disabled).text(displayName));
                };

                // Get models
                for (var _index11 in models) {
                  // Normal insert
                  if (!models[_index11].category && !Array.isArray(models[_index11].data)) insertItem(models[_index11].id, models[_index11].displayName);
                  // Category insert
                  else {
                    // Category
                    insertItem(models[_index11].category, models[_index11].displayName || models[_index11].category, true);

                    // Category items
                    for (var index2 in models[_index11].data) {
                      insertItem(models[_index11].data[index2].id, models[_index11].data[index2].displayName);
                    }
                  }
                }

                // New model value
                modelSelector.val(_start.tinyLs.getItem('tiny-ai-storage-model-selected') || tinyAi.getModel());
                modelSelector.trigger('change');
              }
            }
          };
          insertDefaultSettings = function insertDefaultSettings(model, newModel) {
            tinyAi.setModel(newModel, ficConfigs.selected);
            presencePenalty.disable();
            frequencyPenalty.disable();
            tokenCount.updateValue('total', model.inputTokenLimit);
            outputLength.val(model.outputTokenLimit).prop('disabled', false).removeClass('disabled').trigger('input');
            var maxTemperature = typeof model.maxTemperature === 'number' ? model.maxTemperature : 2;
            temperature.setMin(0).setStep(0.05).setMax(maxTemperature).enable();
            if (temperature.val() > maxTemperature) temperature.val(maxTemperature);
            temperature.trigger('input');
            if (typeof model.topP === 'number') topP.val(model.topP).setMax(1).setMin(0).setStep(0.05).enable().trigger('input');else topP.reset().disable();
            if (typeof model.topK === 'number') topK.val(model.topK).setMax(100).setMin(0).setStep(1).enable().trigger('input');else topK.reset().disable();
          };
          selectModel = function selectModel(newModel) {
            var ignoreTokenUpdater = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            if (!tinyAiScript.noai && !tinyAiScript.mpClient) {
              var model = tinyAi.getModelData(newModel);
              if (model) {
                insertDefaultSettings(model, newModel);
                _start.tinyLs.setItem('tiny-ai-storage-model-selected', newModel);
                if (tinyAi.getData()) tinyAi.setModel(newModel, ficConfigs.selected);
              } else {
                tokenCount.total.text(0);
                temperature.reset().disable();
                outputLength.val(0).prop('disabled', true).addClass('disabled');
                topP.reset().disable();
                topK.reset().disable();
                presencePenalty.reset().disable();
                frequencyPenalty.reset().disable();
                _start.tinyLs.removeItem('tiny-ai-storage-model-selected');
              }
              if (!isFirstTime && !ignoreTokenUpdater && !modelSelector.prop('disabled')) updateAiTokenCounterData(undefined, true);
            }
          };
          modelSelector.on('change', function () {
            return selectModel(modelSelector.val());
          });

          // Load more models
          loadMoreModels = createButtonSidebar('fa-solid fa-bars-progress', 'Load more models', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
            return _regenerator().w(function (_context9) {
              while (1) switch (_context9.n) {
                case 0:
                  if (!(!tinyAiScript.noai && !tinyAiScript.mpClient)) {
                    _context9.n = 2;
                    break;
                  }
                  _circleLoader.Loader.start();
                  _context9.n = 1;
                  return tinyAi.getModels(100);
                case 1:
                  if (!tinyAi._nextModelsPageToken) {
                    loadMoreModels.addClass('disabled');
                    loadMoreModels.prop('disabled', true);
                  }
                  updateModelList();
                  _circleLoader.Loader.close();
                case 2:
                  return _context9.a(2);
              }
            }, _callee9);
          })), !tinyAi._nextModelsPageToken);
          resetSettingsButton = createButtonSidebar('fa-solid fa-rotate-right', 'Reset default settings', function () {
            var model = tinyAi.getModelData(modelSelector.val());
            if (model) {
              temperature.val(1);
              insertDefaultSettings(model, modelSelector.val());
            }
          });
          contentEnabler.setResetSettingsButton(resetSettingsButton);
          sidebarRight = (0, _jquery["default"])('<div>', sidebarStyle).append((0, _jquery["default"])('<ul>', {
            "class": 'list-unstyled'
          }).append((0, _jquery["default"])('<h5>').text('Run Settings'), sidebarRightBase.modelSelector, sidebarRightBase.tokenCounter, sidebarRightBase.temperature, sidebarRightBase.outputLength, sidebarRightBase.topP, sidebarRightBase.topK, sidebarRightBase.presencePenalty, sidebarRightBase.frequencyPenalty, (0, _jquery["default"])('<hr/>', {
            "class": 'm-2'
          }),
          // Load more models
          loadMoreModels,
          // Reset Settings
          resetSettingsButton)); // Execute messages
          prepareContentList = function prepareContentList() {
            var addIndexList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            // Prepare history
            var history = tinyAi.getData();
            var content = [];
            var indexList = [];
            var systemData = null;
            var fileData = null;
            var promptData = null;
            var rpgContentData = null;
            var rpgPrivateContentData = null;
            var rpgSchema = null;
            if (history) {
              // RPG Data
              var canPublicRPG = rpgData.allowAiUse["public"] && (0, _tinyEssentials.objType)(history.rpgData, 'object') && (0, _tinyEssentials.countObj)(history.rpgData) > 0;
              var canPrivateRPG = rpgData.allowAiUse["private"] && (0, _tinyEssentials.objType)(history.rpgPrivateData, 'object') && (0, _tinyEssentials.countObj)(history.rpgPrivateData) > 0;
              var existsRpgSchema = (0, _tinyEssentials.objType)(rpgData.template.schema, 'object') && (0, _tinyEssentials.countObj)(rpgData.template.schema) > 0;
              var canPublicSchemaRPG = rpgData.allowAiSchemaUse["public"] && existsRpgSchema;
              var canPrivateSchemaRPG = rpgData.allowAiSchemaUse["private"] && existsRpgSchema;

              // System Instruction
              if (typeof history.systemInstruction === 'string' && history.systemInstruction.length > 0) {
                var extraInfo = '';
                if (canPublicRPG || canPrivateRPG) extraInfo += "\n".concat(_templates["default"].helpers.ficRpgChecker);
                systemData = {
                  role: 'system',
                  parts: [{
                    text: "".concat(history.systemInstruction).concat(extraInfo)
                  }]
                };
                content.push(systemData);
              }

              // File
              if (history.file) {
                fileData = {
                  role: 'user',
                  parts: [{
                    inlineData: {
                      mime_type: history.file.mime,
                      data: history.file.base64
                    }
                  }]
                };
                content.push(fileData);
              }

              // RPG Data
              if ((canPublicRPG || canPrivateRPG) && (canPublicSchemaRPG || canPrivateSchemaRPG)) {
                var tinyRpgData = (0, _clone["default"])(rpgData.template.schema);
                if (typeof tinyRpgData.properties.allowAiUse !== 'undefined') delete tinyRpgData.properties.allowAiUse;
                if (typeof tinyRpgData.properties.allowAiSchemaUse !== 'undefined') delete tinyRpgData.properties.allowAiSchemaUse;
                var tinyText = '---------- RPG User Official Data ----------\n\n';
                tinyText += JSON.stringify({
                  schema: tinyRpgData
                });
                tinyText += '\n\n---------- The User end RPG Official Data ----------';
                rpgSchema = {
                  role: 'user',
                  parts: [{
                    text: tinyText
                  }]
                };
                content.push(rpgSchema);
              }

              // Public RPG
              if (canPublicRPG) {
                rpgData.oldHash["public"] = tinyAi.getHash('rpgData');
                var _tinyRpgData = (0, _clone["default"])(history.rpgData);
                if (typeof _tinyRpgData.allowAiUse !== 'undefined') delete _tinyRpgData.allowAiUse;
                var _tinyText = '---------- RPG User Official Data ----------\n\n';
                _tinyText += JSON.stringify({
                  database: _tinyRpgData
                });
                _tinyText += '\n\n---------- The User end RPG Official Data ----------';
                rpgContentData = {
                  role: 'user',
                  parts: [{
                    text: _tinyText
                  }]
                };
                content.push(rpgContentData);
              }

              // Private RPG
              if (canPrivateRPG) {
                rpgData.oldHash["private"] = tinyAi.getHash('rpgPrivateData');
                var _tinyRpgData2 = (0, _clone["default"])(history.rpgPrivateData);
                if (typeof _tinyRpgData2.allowAiUse !== 'undefined') delete _tinyRpgData2.allowAiUse;
                var _tinyText2 = '---------- RPG Official Data ----------\n\n';
                _tinyText2 += JSON.stringify({
                  database: _tinyRpgData2
                });
                _tinyText2 += '\n\n---------- The end RPG Official Data ----------';
                rpgPrivateContentData = {
                  role: 'user',
                  parts: [{
                    text: _tinyText2
                  }]
                };
                content.push(rpgPrivateContentData);
              }

              // Prompt
              if (typeof history.prompt === 'string' && history.prompt.length > 0) {
                promptData = {
                  role: 'user',
                  parts: [{
                    text: history.prompt
                  }]
                };
                content.push(promptData);
              }

              // History data
              for (var _index12 in history.data) {
                if (addIndexList) indexList.push(history.data[_index12]);
                content.push(history.data[_index12]);
              }
            }
            return {
              content: content,
              indexList: indexList,
              systemData: systemData,
              promptData: promptData,
              fileData: fileData,
              rpgContentData: rpgContentData,
              rpgPrivateContentData: rpgPrivateContentData,
              rpgSchema: rpgSchema
            };
          };
          getAiTokens = function getAiTokens() {
            var hashItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
              data: []
            };
            var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            return new Promise(/*#__PURE__*/function () {
              var _ref7 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(resolve, reject) {
                var _prepareContentList, content, indexList, systemData, promptData, fileData, rpgContentData, rpgPrivateContentData, rpgSchema, updateTokenData, systemCheck, _loop4, _index13, _t, _t2, _t3;
                return _regenerator().w(function (_context10) {
                  while (1) switch (_context10.n) {
                    case 0:
                      _context10.p = 0;
                      _prepareContentList = prepareContentList(true), content = _prepareContentList.content, indexList = _prepareContentList.indexList, systemData = _prepareContentList.systemData, promptData = _prepareContentList.promptData, fileData = _prepareContentList.fileData, rpgContentData = _prepareContentList.rpgContentData, rpgPrivateContentData = _prepareContentList.rpgPrivateContentData, rpgSchema = _prepareContentList.rpgSchema;
                      if (!(content.length > 0)) {
                        _context10.n = 16;
                        break;
                      }
                      // Get tokens data
                      updateTokenData = /*#__PURE__*/function () {
                        var _ref8 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(name, contentToCheck) {
                          var hash,
                            oldHash,
                            tinyTokens,
                            callback,
                            newTokens,
                            newToken,
                            _args0 = arguments;
                          return _regenerator().w(function (_context0) {
                            while (1) switch (_context0.n) {
                              case 0:
                                hash = _args0.length > 2 && _args0[2] !== undefined ? _args0[2] : null;
                                oldHash = _args0.length > 3 && _args0[3] !== undefined ? _args0[3] : null;
                                tinyTokens = _args0.length > 4 && _args0[4] !== undefined ? _args0[4] : {
                                  count: null
                                };
                                callback = _args0.length > 5 ? _args0[5] : undefined;
                                if (!(!tinyAiScript.noai && !tinyAiScript.mpClient)) {
                                  _context0.n = 3;
                                  break;
                                }
                                if (!(forceUpdate && contentToCheck ||
                                // Exist content to check tokens
                                hash && contentToCheck && (
                                // Model
                                typeof hashItems.model === 'string' && hashItems.model !== (0, _objectHash["default"])(tinyAi.getModel()) ||
                                // Hash
                                typeof oldHash === 'string' && oldHash !== hash ||
                                // Token Count
                                typeof tinyTokens.count !== 'number' || Number.isNaN(tinyTokens.count) || !Number.isFinite(tinyTokens.count) || tinyTokens.count < 1) &&
                                // Callback
                                typeof callback === 'function')) {
                                  _context0.n = 2;
                                  break;
                                }
                                console.log("[tiny-ai] Executing token counter in \"".concat(name, "\"."));
                                _context0.n = 1;
                                return tinyAi.countTokens(Array.isArray(contentToCheck) ? contentToCheck : [contentToCheck]);
                              case 1:
                                newTokens = _context0.v;
                                newToken = newTokens && typeof newTokens.totalTokens === 'number' ? newTokens.totalTokens : null;
                                if (typeof newToken === 'number') callback(newToken);
                              case 2:
                                _context0.n = 4;
                                break;
                              case 3:
                                callback(0);
                              case 4:
                                return _context0.a(2);
                            }
                          }, _callee0);
                        }));
                        return function updateTokenData(_x5, _x6) {
                          return _ref8.apply(this, arguments);
                        };
                      }(); // RPG
                      if (!((rpgData.allowAiUse["public"] || rpgData.allowAiUse["private"]) && (rpgData.allowAiSchemaUse["public"] || rpgData.allowAiSchemaUse["private"]))) {
                        _context10.n = 2;
                        break;
                      }
                      _context10.n = 1;
                      return updateTokenData('rpgSchema', rpgSchema, tinyAi.getHash('rpgSchema'), typeof hashItems.rpgSchema === 'string' ? hashItems.rpgSchema : null, {
                        count: tinyAi.getTokens('rpgSchema')
                      }, function (newCount) {
                        return tinyAi.setCustomValue('rpgSchema', null, newCount);
                      });
                    case 1:
                      _context10.n = 3;
                      break;
                    case 2:
                      tinyAi.setCustomValue('rpgSchema', null, 0);
                    case 3:
                      if (!rpgData.allowAiUse["public"]) {
                        _context10.n = 5;
                        break;
                      }
                      _context10.n = 4;
                      return updateTokenData('rpgData', rpgContentData, tinyAi.getHash('rpgData'), typeof hashItems.rpgData === 'string' ? hashItems.rpgData : null, {
                        count: tinyAi.getTokens('rpgData')
                      }, function (newCount) {
                        return tinyAi.setCustomValue('rpgData', null, newCount);
                      });
                    case 4:
                      _context10.n = 6;
                      break;
                    case 5:
                      tinyAi.setCustomValue('rpgData', null, 0);
                    case 6:
                      if (!rpgData.allowAiUse["private"]) {
                        _context10.n = 8;
                        break;
                      }
                      _context10.n = 7;
                      return updateTokenData('rpgPrivateData', rpgPrivateContentData, tinyAi.getHash('rpgPrivateData'), typeof hashItems.rpgPrivateData === 'string' ? hashItems.rpgPrivateData : null, {
                        count: tinyAi.getTokens('rpgPrivateData')
                      }, function (newCount) {
                        return tinyAi.setCustomValue('rpgPrivateData', null, newCount);
                      });
                    case 7:
                      _context10.n = 9;
                      break;
                    case 8:
                      tinyAi.setCustomValue('rpgPrivateData', null, 0);
                    case 9:
                      _context10.n = 10;
                      return updateTokenData('prompt', promptData, tinyAi.getHash('prompt'), typeof hashItems.prompt === 'string' ? hashItems.prompt : null, {
                        count: tinyAi.getTokens('prompt')
                      }, function (newCount) {
                        return tinyAi.setPrompt(null, newCount);
                      });
                    case 10:
                      _context10.n = 11;
                      return updateTokenData('file', fileData, tinyAi.getHash('file'), typeof hashItems.file === 'string' ? hashItems.file : null, {
                        count: tinyAi.getTokens('file')
                      }, function (newCount) {
                        return tinyAi.setFileData(null, null, false, newCount);
                      });
                    case 11:
                      // System Instruction
                      systemCheck = (0, _clone["default"])(systemData);
                      if (systemCheck) systemCheck.role = 'user';
                      _context10.n = 12;
                      return updateTokenData('systemInstruction', systemCheck, tinyAi.getHash('systemInstruction'), typeof hashItems.systemInstruction === 'string' ? hashItems.systemInstruction : null, {
                        count: tinyAi.getTokens('systemInstruction')
                      }, function (newCount) {
                        return tinyAi.setSystemInstruction(null, newCount);
                      });
                    case 12:
                      _loop4 = /*#__PURE__*/_regenerator().m(function _loop4(_index13) {
                        return _regenerator().w(function (_context1) {
                          while (1) switch (_context1.n) {
                            case 0:
                              _context1.n = 1;
                              return updateTokenData('message', indexList[_index13], tinyAi.getMsgHashByIndex(_index13), typeof hashItems.data[_index13] === 'string' ? hashItems.data[_index13] : null, tinyAi.getMsgTokensByIndex(_index13) || {
                                count: null
                              }, function (newCount) {
                                return tinyAi.replaceIndex(_index13, null, {
                                  count: newCount
                                });
                              });
                            case 1:
                              return _context1.a(2);
                          }
                        }, _loop4);
                      });
                      _t = _regeneratorKeys(indexList);
                    case 13:
                      if ((_t2 = _t()).done) {
                        _context10.n = 15;
                        break;
                      }
                      _index13 = _t2.value;
                      return _context10.d(_regeneratorValues(_loop4(_index13)), 14);
                    case 14:
                      _context10.n = 13;
                      break;
                    case 15:
                      resolve(!tinyAiScript.noai && !tinyAiScript.mpClient ? tinyAi.getTotalTokens() : 0);
                      _context10.n = 17;
                      break;
                    case 16:
                      resolve(0);
                    case 17:
                      _context10.n = 19;
                      break;
                    case 18:
                      _context10.p = 18;
                      _t3 = _context10.v;
                      reject(_t3);
                    case 19:
                      return _context10.a(2);
                  }
                }, _callee1, null, [[0, 18]]);
              }));
              return function (_x3, _x4) {
                return _ref7.apply(this, arguments);
              };
            }());
          }; // Get Ai Tokens
          usingUpdateToken = false;
          updateAiTokenCounterData = function updateAiTokenCounterData(hashItems) {
            var forceReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            if (!usingUpdateToken) {
              usingUpdateToken = true;
              var history = tinyAi.getData();
              if (history) {
                contentEnabler.deBase();
                contentEnabler.deModelChanger();
                contentEnabler.dePromptButtons();
                contentEnabler.deModel();
                contentEnabler.deMessageButtons();
                var oldMsgInput = msgInput.val();
                var points = '.';
                var secondsWaiting = -1;
                var loadingMoment = function loadingMoment() {
                  points += '.';
                  if (points === '....') points = '.';
                  secondsWaiting++;
                  msgInput.val("(".concat(secondsWaiting, "s) Loading model data").concat(points));
                };
                var loadingMessage = setInterval(loadingMoment, 1000);
                loadingMoment();
                var stopLoadingMessage = function stopLoadingMessage() {
                  clearInterval(loadingMessage);
                  msgInput.val(oldMsgInput);
                  if (sessionEnabled) {
                    contentEnabler.enBase();
                    contentEnabler.enModelChanger();
                    contentEnabler.enPromptButtons();
                    contentEnabler.enModel();
                    contentEnabler.enMessageButtons();
                  }
                  msgInput.trigger('focus');
                };
                getAiTokens(hashItems || undefined, forceReset).then(function (totalTokens) {
                  if (typeof totalTokens === 'number') tokenCount.updateValue('amount', totalTokens);else tokenCount.updateValue('amount', 0);
                  stopLoadingMessage();
                  usingUpdateToken = false;
                })["catch"](function (err) {
                  alert(err.message, 'Error: AI tokens getter');
                  console.error(err);
                  stopLoadingMessage();
                  usingUpdateToken = false;
                });
              }
            }
          }; // Execute AI script
          executeAi = function executeAi() {
            var tinyCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var tinyController = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
            return new Promise(function (resolve, reject) {
              var _prepareContentList2 = prepareContentList(),
                content = _prepareContentList2.content;

              // Insert tokens
              var amountTokens = {
                total: null,
                data: {
                  candidates: null,
                  prompt: null,
                  total: null
                }
              };
              var buildAmountTokens = function buildAmountTokens(tokenUsage) {
                // Build amount tokens
                if (tokenUsage) {
                  // The prompt result amount
                  if (typeof tokenUsage.count.candidates === 'number') amountTokens.data.candidates = tokenUsage.count.candidates;
                  if (typeof tokenUsage.count.prompt === 'number') amountTokens.data.prompt = tokenUsage.count.prompt;
                  if (typeof tokenUsage.count.total === 'number') amountTokens.data.total = tokenUsage.count.total;
                }

                // Fix total tokens
                if (typeof amountTokens.total === 'number') tokenCount.updateValue('amount', amountTokens.total);
                var totalAmountToken = tinyAi.getTotalTokens();
                if (totalAmountToken > amountTokens.total) tokenCount.updateValue('amount', totalAmountToken);
              };

              // Insert message
              var isComplete = false;
              var insertMessage = function insertMessage(msgData, role, finishReason) {
                if (!tinyCache.msgBallon) {
                  tinyCache.msgBallon = makeMessage({
                    message: msgData,
                    id: tinyCache.msgId
                  }, role === 'user' ? null : (0, _tinyEssentials.toTitleCase)(role));
                  addMessage(tinyCache.msgBallon);
                } else {
                  tinyCache.msgBallon.find('.ai-msg-ballon').empty().append(makeMsgRenderer(msgData));
                  var tinyErrorAlert = tinyCache.msgBallon.data('tiny-ai-error-alert');
                  if (tinyErrorAlert) tinyErrorAlert.updateText(finishReason);
                  scrollChatContainerToTop();
                }
              };

              // Cancel task
              var isCanceled = false;
              tinyCache.cancel = function () {
                if (!isCanceled) {
                  if (tinyCache.msgBallon) tinyCache.msgBallon.remove();
                  if (typeof tinyCache.msgId === 'number' || typeof tinyCache.msgId === 'string') tinyAi.deleteIndex(tinyAi.getIndexOfId(tinyCache.msgId));
                  completeTask();
                  isCanceled = true;
                }
              };

              // Task complete!
              var completeTask = function completeTask() {
                if (typeof tinyCache.msgId !== 'undefined') delete tinyCache.msgId;
                if (typeof tinyCache.msgBallon !== 'undefined') delete tinyCache.msgBallon;
                if (typeof tinyCache.cancel !== 'undefined') delete tinyCache.cancel;
              };

              // Content Generator
              tinyAi.genContent(content, tinyAi.getModel(), tinyController, function (chuck) {
                isComplete = chuck.done;
                // Update tokens
                buildAmountTokens(chuck.tokenUsage);
                var promptTokens = amountTokens.data.candidates || 0;

                // Read contents
                if (chuck.contents) {
                  for (var _index14 in chuck.contents) {
                    // Update history
                    if (typeof tinyCache.msgId === 'undefined') tinyCache.msgId = tinyAi.addData(chuck.contents[_index14], {
                      count: promptTokens || null
                    });else tinyAi.replaceIndex(tinyAi.getIndexOfId(tinyCache.msgId), chuck.contents[_index14], {
                      count: promptTokens || null
                    });

                    // Send insert request
                    if (typeof chuck.contents[_index14].parts[0].text === 'string') insertMessage(chuck.contents[_index14].parts[0].text, chuck.contents[_index14].role, chuck.contents[_index14].finishReason);

                    // Update message cache
                    var oldBallonCache = tinyCache.msgBallon.data('tiny-ai-cache');
                    oldBallonCache.msg = chuck.contents[_index14].parts[0].text;
                    tinyCache.msgBallon.data('tiny-ai-cache', oldBallonCache);

                    // Add class
                    tinyCache.msgBallon.addClass('entering-ai-message');
                  }
                }

                // Remove class
                if (isComplete) {
                  var notificationError = function notificationError() {
                    return _start.tinyNotification.send('System', {
                      body: 'Your message was not processed.'
                    });
                  };
                  if (tinyCache.msgBallon) {
                    tinyCache.msgBallon.removeClass('entering-ai-message');
                    var ballonCache = tinyCache.msgBallon.data('tiny-ai-cache');
                    if ((0, _jquery["default"])('body').hasClass('windowHidden')) {
                      if (ballonCache) _start.tinyNotification.send(ballonCache.role, {
                        body: ballonCache.msg
                      });else notificationError();
                    }
                  } else if ((0, _jquery["default"])('body').hasClass('windowHidden')) notificationError();
                  completeTask();
                }
              }).then(function (result) {
                if (!result.error) {
                  // Insert tokens
                  buildAmountTokens(result.tokenUsage);
                  var promptTokens = amountTokens.data.candidates || 0;

                  // Insert content
                  for (var _index15 in result.contents) {
                    var msg = result.contents[_index15];
                    if (msg && msg.parts && msg.parts[0] && typeof msg.parts[0].text === 'string' && msg.parts[0].text.length > 0) {
                      // Update history
                      if (typeof tinyCache.msgId === 'undefined') tinyCache.msgId = tinyAi.addData(msg, {
                        count: promptTokens || null
                      });else tinyAi.replaceIndex(tinyAi.getIndexOfId(tinyCache.msgId), msg, {
                        count: promptTokens || null
                      });

                      // Send message request
                      insertMessage(msg.parts[0].text, msg.role, msg.finishReason);

                      // Update message data
                      var oldBallonCache = tinyCache.msgBallon.data('tiny-ai-cache');
                      oldBallonCache.msg = msg.parts[0].text;
                      tinyCache.msgBallon.data('tiny-ai-cache', oldBallonCache);
                    }
                  }
                }

                // Error
                else {
                  console.log("AI Generator Error", result.error);
                  alert(result.error.message);
                  if (typeof result.error.message === 'string' && result.error.message.length > 0) _start.tinyNotification.send('Ai Error', {
                    body: result.error.message
                  });
                }

                // Complete
                completeTask();
                resolve(result);
              })["catch"](reject);
            });
          }; // Textarea input edition
          createTextareaInputExition = function createTextareaInputExition() {
            var minHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 38;
            var maxHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 150;
            var moreConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            // Create textarea
            var textarea = (0, _jquery["default"])('<textarea>', _objectSpread({
              style: ["min-height: ".concat(minHeight, "px"), "height: ".concat(minHeight, "px"), "max-height: ".concat(maxHeight, "px") /* Max lines (5 lines = 150px.) */, 'resize: none'].join('; ')
            }, moreConfig));
            textarea.on('input', function () {
              // Reset for minimum height before recalculating
              var value = textarea.val();
              var lines = value.split('\n').length;
              textarea.css('height', 'auto');

              // Get scrollHeight via jQuery
              var newHeight = textarea.prop('scrollHeight');
              var height = lines > 1 ? Math.min(newHeight, maxHeight) : minHeight;

              // Defines height, but respects the maximum limit
              textarea.css('height', "".concat(String(height), "px"));
              if (typeof callback === 'function') callback({
                height: height,
                newHeight: newHeight,
                lines: lines,
                value: value
              });
            });

            // Complete
            return textarea;
          }; // Input
          msgInputValues = {
            minHeight: 38,
            maxHeight: 150
          };
          msgInput = createTextareaInputExition(msgInputValues.minHeight, msgInputValues.maxHeight, {
            "class": 'form-control border-dark',
            placeholder: 'Type your message...'
          }, function (inputResult) {
            var height = inputResult.height,
              value = inputResult.value;
            var minHeight = msgInputValues.minHeight;

            // Subtract the new height by the min size to get the exact amount of height created
            var tinyFinalValue = height - minHeight;

            // Get the current scroll position before adding new content
            var scrollBefore = chatContainer.scrollTop();
            var heightBefore = chatContainer.prop('scrollHeight');

            // And use this to correct the size of other elements
            chatContainer.css('padding-bottom', "".concat(String(tinyFinalValue), "px"));
            textInputContainer.css({
              position: 'relative',
              top: "-".concat(String(tinyFinalValue), "px")
            });

            // Get the new scroll height after adding content
            var heightAfter = chatContainer.prop('scrollHeight');
            var heightDiff = heightAfter - heightBefore;

            // Adjust the scroll position to maintain the user's view
            chatContainer.scrollTop(scrollBefore + heightDiff);

            // Value
            _start.tinyLs.setItem("tiny-ai-textarea-".concat(ficConfigs.selected), typeof value === 'string' ? value : '');
          });
          contentEnabler.setMsgInput(msgInput);

          // Submit
          msgSubmit = _tinyLib["default"].bs.button('primary input-group-text-dark').text('Send');
          contentEnabler.setMsgSubmit(msgSubmit);
          cancelSubmit = _tinyLib["default"].bs.button('primary input-group-text-dark rounded-end').text('Cancel');
          contentEnabler.setCancelSubmit(cancelSubmit);
          submitMessage = /*#__PURE__*/function () {
            var _ref9 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11() {
              var msg, controller, points, secondsWaiting, loadingMoment, loadingMessage, sentId, canContinue;
              return _regenerator().w(function (_context12) {
                while (1) switch (_context12.n) {
                  case 0:
                    // Prepare to get data
                    msgInput.trigger('blur');
                    msg = msgInput.val();
                    msgInput.val('').trigger('input');
                    controller = new AbortController();
                    contentEnabler.deBase();
                    contentEnabler.deMessageButtons();
                    contentEnabler.deModelChanger();
                    contentEnabler.dePromptButtons();
                    contentEnabler.deModelSelector();
                    points = '.';
                    secondsWaiting = -1;
                    loadingMoment = function loadingMoment() {
                      points += '.';
                      if (points === '....') points = '.';
                      secondsWaiting++;
                      msgInput.val("(".concat(secondsWaiting, "s) Waiting response").concat(points));
                    };
                    loadingMessage = setInterval(loadingMoment, 1000);
                    loadingMoment();

                    // Add new message
                    sentId = null;
                    _context12.n = 1;
                    return new Promise(/*#__PURE__*/function () {
                      var _ref0 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(resolve) {
                        var newMsg, newTokens, newToken, _t4, _t5;
                        return _regenerator().w(function (_context11) {
                          while (1) switch (_context11.n) {
                            case 0:
                              _context11.p = 0;
                              if (!(typeof msg === 'string' && msg.length > 0)) {
                                _context11.n = 4;
                                break;
                              }
                              newMsg = tinyAi.buildContents(null, {
                                role: 'user',
                                parts: [{
                                  text: msg
                                }]
                              }, 'user');
                              if (!(!tinyAiScript.noai && !tinyAiScript.mpClient)) {
                                _context11.n = 2;
                                break;
                              }
                              _context11.n = 1;
                              return tinyAi.countTokens([newMsg]);
                            case 1:
                              _t4 = _context11.v;
                              _context11.n = 3;
                              break;
                            case 2:
                              _t4 = {
                                totalTokens: 0
                              };
                            case 3:
                              newTokens = _t4;
                              newToken = newTokens && typeof newTokens.totalTokens === 'number' ? newTokens.totalTokens : null;
                              sentId = tinyAi.addData(newMsg, {
                                count: newToken
                              });
                              resolve(true);
                              _context11.n = 5;
                              break;
                            case 4:
                              resolve(false);
                            case 5:
                              _context11.n = 7;
                              break;
                            case 6:
                              _context11.p = 6;
                              _t5 = _context11.v;
                              console.error(_t5);
                              alert(_t5.message);
                              resolve(false);
                            case 7:
                              return _context11.a(2);
                          }
                        }, _callee10, null, [[0, 6]]);
                      }));
                      return function (_x7) {
                        return _ref0.apply(this, arguments);
                      };
                    }());
                  case 1:
                    canContinue = _context12.v;
                    if (!canContinue) {
                      _context12.n = 2;
                      break;
                    }
                    contentEnabler.deBase(controller);
                    addMessage(makeMessage({
                      message: msg,
                      id: sentId
                    }));

                    // Execute Ai
                    if (!(!tinyAiScript.noai && !tinyAiScript.mpClient && sessionEnabled)) {
                      _context12.n = 2;
                      break;
                    }
                    _context12.n = 2;
                    return executeAi(submitCache, controller)["catch"](function (err) {
                      if (submitCache.cancel) submitCache.cancel();
                      console.error(err);
                      alert(err.message);
                    });
                  case 2:
                    // Complete
                    clearInterval(loadingMessage);
                    if (sessionEnabled) contentEnabler.enPromptButtons();
                    msgInput.val('');
                    if (sessionEnabled) {
                      contentEnabler.enMessageButtons();
                      contentEnabler.enBase();
                      contentEnabler.enModelChanger();
                      contentEnabler.enModelSelector();
                    }
                    msgInput.trigger('focus');
                  case 3:
                    return _context12.a(2);
                }
              }, _callee11);
            }));
            return function submitMessage() {
              return _ref9.apply(this, arguments);
            };
          }();
          submitCache = {};
          contentEnabler.setSubmitCache(submitCache);
          msgSubmit.on('click', /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {
            return _regenerator().w(function (_context13) {
              while (1) switch (_context13.n) {
                case 0:
                  if (!msgInput.prop('disabled')) submitMessage();
                case 1:
                  return _context13.a(2);
              }
            }, _callee12);
          })));
          msgInput.on('keydown', function (event) {
            if (event.key === 'Enter' && !event.shiftKey) {
              event.preventDefault();
              msgSubmit.trigger('click');
            }
          });

          // First Dialogue button
          firstDialogueBase = {
            base: (0, _jquery["default"])('<div>', {
              "class": 'first-dialogue-base position-absolute  top-50 start-50 translate-middle',
              style: 'pointer-events: none;'
            }),
            button: _tinyLib["default"].bs.button('lg btn-bg d-flex justify-content-center align-items-center').attr('title', 'Insert first dialogue').css({
              'pointer-events': 'all',
              height: 150,
              'font-size': '100px',
              'background-color': 'transparent !important'
            })
          };
          firstDialogueBase.button.append(_tinyLib["default"].icon('fa-solid fa-circle-play'));
          firstDialogueBase.button.on('click', function () {
            enabledFirstDialogue(false);
            var history = tinyAi.getData();

            // Insert first message
            if (history && history.data.length < 1 && typeof history.firstDialogue === 'string') {
              var msgId = tinyAi.addData(tinyAi.buildContents(null, {
                role: 'model',
                parts: [{
                  text: history.firstDialogue
                }]
              }, 'model'));
              addMessage(makeMessage({
                message: history.firstDialogue,
                id: msgId
              }, 'Model'));
              updateAiTokenCounterData();
            }
          });
          firstDialogueBase.base.append(firstDialogueBase.button);

          // Message List
          msgList = (0, _jquery["default"])('<div>', {
            "class": 'p-3',
            style: 'margin-bottom: 55px !important;'
          });
          scrollChatContainerToTop = function scrollChatContainerToTop() {
            var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            return chatContainer.animate({
              scrollTop: chatContainer.prop('scrollHeight')
            }, speed);
          };
          addMessage = function addMessage(item) {
            msgList.append(item);
            scrollChatContainerToTop();
          };
          makeTempMessage = function makeTempMessage(msg, type) {
            return addMessage(makeMessage({
              message: msg
            }, type));
          }; // Message Maker
          makeMsgRenderer = function makeMsgRenderer(msg) {
            var renderer = new _marked.marked.Renderer();
            var _final = '<span class="final-ai-icon">';
            // | â ââ _

            // Remove links and html
            renderer.link = function (href, title, text) {
              return "<span>".concat(text, "</span>");
            };
            renderer.image = function () {
              return "";
            };
            renderer.html = function (data) {
              if (data.raw !== _final || data.text !== _final) return "";else return "".concat(_final, "\u2588</span>");
            };

            // Fix del
            renderer.del = function (data) {
              if (data.raw.startsWith('~') && data.raw.endsWith('~') && !data.raw.startsWith('~~')) {
                return data.raw;
              }
              return "<del>".concat(data.text, "</del>");
            };

            // Complete
            var newMsg = "".concat(msg);
            while (newMsg.endsWith('\n')) {
              newMsg = newMsg.slice(0, -1);
            }
            while (newMsg.startsWith('\n')) {
              newMsg = newMsg.slice(1);
            }
            return _marked.marked.parse("".concat(newMsg).concat(_final).replace(/^[\u200B\u200C\u200D\u200E\u200F\uFEFF]/, ''), {
              renderer: renderer,
              breaks: true
            });
          };
          makeMsgWarning = function makeMsgWarning(finishReason) {
            var textBase = (0, _jquery["default"])('<span>');
            var result = _tinyLib["default"].bs.alert('danger mt-2 mb-0 d-none', [_tinyLib["default"].icon('fas fa-exclamation-triangle me-2'), textBase], true);
            var updateText = function updateText(errorCode) {
              var tinyError = tinyAi.getErrorCode(errorCode);
              if (tinyError && typeof tinyError.text === 'string' && !tinyError.hide) {
                textBase.text(tinyError.text);
                result.removeClass('d-none');
              }
            };
            updateText(finishReason);
            return {
              textBase: textBase,
              result: result,
              updateText: updateText
            };
          };
          makeMessage = function makeMessage() {
            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
              message: null,
              id: -1
            };
            var username = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            // Prepare renderer
            var tinyCache = {
              msg: data.message,
              role: username ? (0, _tinyEssentials.toTitleCase)(username) : 'User'
            };
            var msgBase = (0, _jquery["default"])('<div>', {
              "class": "p-3".concat(typeof username !== 'string' ? ' d-flex flex-column align-items-end' : '', " ai-chat-data")
            });
            var msgBallon = (0, _jquery["default"])('<div>', {
              "class": "bg-".concat(typeof username === 'string' ? 'secondary d-inline-block' : 'primary', " text-white p-2 rounded ai-msg-ballon")
            });
            msgBase.data('tiny-ai-cache', tinyCache);
            var isIgnore = typeof data.id !== 'number' || data.id < 0;
            var tinyIndex = tinyAi.getIndexOfId(data.id);

            // Edit message panel
            var editPanel = (0, _jquery["default"])('<div>', {
              "class": 'ai-text-editor'
            });
            editPanel.append(
            // Edit button
            !isIgnore && tinyIndex > -1 ? _tinyLib["default"].bs.button('bg btn-sm').append(_tinyLib["default"].icon('fa-solid fa-pen-to-square')).on('click', function () {
              // Text
              var textInput = (0, _jquery["default"])('<textarea>', {
                "class": 'form-control'
              });
              textInput.val(tinyCache.msg);
              var oldMsg = tinyCache.msg;

              // Submit
              var submitButton = _tinyLib["default"].bs.button("".concat(typeof username !== 'string' ? 'secondary d-inline-block' : 'primary', " mt-2 w-100 me-2")).text('Submit');
              var cancelButton = _tinyLib["default"].bs.button("".concat(typeof username !== 'string' ? 'secondary d-inline-block' : 'primary', " mt-2 w-100")).text('Cancel');
              var closeReplace = function closeReplace() {
                msgBallon.removeClass('w-100').empty();
                msgBallon.append(makeMsgRenderer(tinyCache.msg));
                var msg = tinyAi.getMsgById();
                tinyErrorAlert.updateText(msg ? msg.finishReason : null);
              };
              submitButton.on('click', function () {
                tinyCache.msg = textInput.val();
                var newMsg = tinyCache.msg;
                if (typeof oldMsg !== 'string' || oldMsg !== newMsg) {
                  var newContent = tinyAi.getMsgByIndex(tinyIndex);
                  newContent.parts[0].text = tinyCache.msg;
                  tinyAi.replaceIndex(tinyIndex, newContent, {
                    count: null
                  });
                  closeReplace();
                  updateAiTokenCounterData();
                } else closeReplace();
              });
              cancelButton.on('click', function () {
                return closeReplace();
              });

              // Complete
              msgBallon.empty().addClass('w-100').append(textInput, (0, _jquery["default"])('<div>', {
                "class": 'd-flex mx-5'
              }).append(submitButton, cancelButton));
            }) : null,
            // Delete button
            _tinyLib["default"].bs.button('bg btn-sm').append(_tinyLib["default"].icon('fa-solid fa-trash-can')).on('click', function () {
              var tinyIndex = tinyAi.getIndexOfId(data.id);
              if (!isIgnore && tinyIndex > -1) {
                var tinyTokens = tinyAi.getMsgTokensByIndex(tinyIndex);
                tinyAi.deleteIndex(tinyIndex);
                var amount = tokenCount.getValue('amount');
                tokenCount.updateValue('amount', amount - Number(tinyTokens && tinyTokens.count ? tinyTokens.count : 0));
              }
              msgBase.remove();
              enabledFirstDialogue();
            }));
            var msg = tinyAi.getMsgById(data.id);
            var tinyErrorAlert = makeMsgWarning(msg ? msg.finishReason : null);

            // Send message
            var msgContent = msgBase.append(editPanel, msgBallon.append(makeMsgRenderer(tinyCache.msg)), (0, _jquery["default"])('<div>', {
              "class": "text-muted small mt-1".concat(typeof username !== 'string' ? ' text-end' : ''),
              text: typeof username === 'string' ? username : 'User'
            }), tinyErrorAlert.result);
            msgContent.data('tiny-ai-error-alert', tinyErrorAlert);
            return msgContent;
          }; // Container
          chatContainer = (0, _jquery["default"])('<div>', {
            id: 'ai-chatbox',
            "class": 'h-100 body-background',
            style: 'overflow-y: auto; margin-bottom: -54px;'
          });
          contentEnabler.setChatContainer(chatContainer);
          textInputContainer = (0, _jquery["default"])('<div>', {
            "class": 'input-group pb-3 body-background'
          }).append(msgInput, cancelSubmit, msgSubmit);
          container = (0, _jquery["default"])('<div>', {
            "class": 'd-flex h-100 y-100',
            id: 'ai-element-root'
          }).append(sidebarLeft,
          // Main container
          (0, _jquery["default"])('<div>', {
            "class": 'flex-grow-1 d-flex flex-column'
          }).append(firstDialogueBase.base, (0, _jquery["default"])('<div>', {
            "class": 'justify-content-center h-100'
          }).append(
          // Chat Messages Area
          chatContainer.append(msgList),
          // Input Area
          (0, _jquery["default"])('<div>', {
            "class": 'px-3 d-inline-block w-100'
          }).append(textInputContainer))), sidebarRight);
          firstDialogueBase.button.tooltip();

          // Prepare events
          tinyAi.removeAllListeners('setMaxOutputTokens');
          tinyAi.removeAllListeners('setTemperature');
          tinyAi.removeAllListeners('setTopP');
          tinyAi.removeAllListeners('setTopK');
          tinyAi.removeAllListeners('setPresencePenalty');
          tinyAi.removeAllListeners('setFrequencyPenalty');
          tinyAi.removeAllListeners('setModel');
          tinyAi.removeAllListeners('selectDataId');
          tinyAi.removeAllListeners('deleteIndex');
          tinyAi.removeAllListeners('replaceIndex');
          tinyAi.removeAllListeners('addData');
          tinyAi.removeAllListeners('setPrompt');
          tinyAi.removeAllListeners('setFirstDialogue');
          tinyAi.removeAllListeners('setFileData');
          tinyAi.removeAllListeners('setSystemInstruction');
          tinyAi.removeAllListeners('startDataId');
          tinyAi.removeAllListeners('stopDataId');
          tinyAi.removeAllListeners('setRpgSchema');
          tinyAi.removeAllListeners('setRpgData');
          tinyAi.removeAllListeners('setRpgPrivateData');

          // tinyAi.on('startDataId', () => {});
          // tinyAi.on('setFileData', (value) => {});

          // Insert template
          tinyInsertDb = function tinyInsertDb(where, fData) {
            return connStore.insert({
              into: where,
              upsert: true,
              values: [fData]
            })["catch"](console.error);
          };
          tinyMsgIdDb = function tinyMsgIdDb(sessionId, id) {
            return "".concat(sessionId, ":").concat(id);
          }; // Reset session
          resetSession = function resetSession(id) {
            var useReadOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            return new Promise(function (resolve, reject) {
              if (canUsejsStore) {
                if (useReadOnly) {
                  contentEnabler.dePromptButtons();
                  contentEnabler.deMessageButtons();
                  contentEnabler.deBase();
                  contentEnabler.deModelChanger();
                  contentEnabler.deModelSelector();
                }
                var disableReadOnly = function disableReadOnly() {
                  if (useReadOnly && sessionEnabled) {
                    contentEnabler.enPromptButtons();
                    contentEnabler.enMessageButtons();
                    contentEnabler.enBase();
                    contentEnabler.enModelChanger();
                    contentEnabler.enModelSelector();
                  }
                };
                Promise.all([connStore.remove({
                  from: 'aiSessionsRoom',
                  where: {
                    session: id
                  }
                }), connStore.remove({
                  from: 'aiSessionsHash',
                  where: {
                    session: id
                  }
                }), connStore.remove({
                  from: 'aiSessionsTokens',
                  where: {
                    session: id
                  }
                }), connStore.remove({
                  from: 'aiSessionsCustomList',
                  where: {
                    session: id
                  }
                }), connStore.remove({
                  from: 'aiSessionsData',
                  where: {
                    session: id
                  }
                })]).then(function (result) {
                  disableReadOnly();
                  resolve(result);
                })["catch"](function (err) {
                  disableReadOnly();
                  reject(err);
                });
              } else resolve(null);
            });
          }; // Save backup
          saveSessionTimeout = {};
          saveSessionBackup = function saveSessionBackup(sessionSelected, where) {
            if (sessionSelected) {
              var getSessionData = function getSessionData() {
                // Get session
                var tinyData = tinyAi.getData();
                var customList = tinyData.customList;
                var hash = tinyData.hash;
                var tokens = tinyData.tokens;
                var model = tinyAi.getModelData(modelSelector.val()) || {};

                // Room data
                var roomSaveData = {
                  model: typeof tinyData.model === 'string' ? tinyData.model : null,
                  prompt: typeof tinyData.prompt === 'string' ? tinyData.prompt : null,
                  firstDialogue: typeof tinyData.firstDialogue === 'string' ? tinyData.firstDialogue : null,
                  systemInstruction: typeof tinyData.systemInstruction === 'string' ? tinyData.systemInstruction : null,
                  rpgSchema: (0, _tinyEssentials.objType)(tinyData.rpgSchema, 'object') ? tinyData.rpgSchema : null,
                  rpgData: (0, _tinyEssentials.objType)(tinyData.rpgData, 'object') ? tinyData.rpgData : null,
                  rpgPrivateData: (0, _tinyEssentials.objType)(tinyData.rpgPrivateData, 'object') ? tinyData.rpgPrivateData : null,
                  maxOutputTokens: typeof tinyData.maxOutputTokens === 'number' ? tinyData.maxOutputTokens : typeof model.outputTokenLimit === 'number' ? model.outputTokenLimit : null,
                  temperature: typeof tinyData.temperature === 'number' ? tinyData.temperature : typeof model.maxTemperature === 'number' || typeof model.temperature === 'number' ? typeof model.temperature === 'number' ? model.temperature : 1 : null,
                  topP: typeof tinyData.topP === 'number' ? tinyData.topP : typeof model.topP === 'number' ? model.topP : null,
                  topK: typeof tinyData.topK === 'number' ? tinyData.topK : typeof model.topK === 'number' ? model.topK : null,
                  presencePenalty: typeof tinyData.presencePenalty === 'number' ? tinyData.presencePenalty : typeof model.presencePenalty === 'number' ? model.presencePenalty : null,
                  frequencyPenalty: typeof tinyData.frequencyPenalty === 'number' ? tinyData.frequencyPenalty : typeof model.frequencyPenalty === 'number' ? model.frequencyPenalty : null
                };
                return {
                  roomSaveData: roomSaveData,
                  model: model,
                  tokens: tokens,
                  hash: hash,
                  customList: customList
                };
              };

              // jsStore (offline)
              if (canUsejsStore) {
                if (saveSessionTimeout[sessionSelected]) clearTimeout(saveSessionTimeout[sessionSelected]);
                saveSessionTimeout[sessionSelected] = setTimeout(function () {
                  var _getSessionData = getSessionData(),
                    roomSaveData = _getSessionData.roomSaveData,
                    tokens = _getSessionData.tokens,
                    hash = _getSessionData.hash,
                    customList = _getSessionData.customList;
                  // Hash and tokens data insert
                  var hashData = {};
                  var tokenData = {};
                  for (var item in roomSaveData) {
                    hashData[item] = typeof hash[item] === 'string' ? hash[item] : null;
                    tokenData[item] = typeof tokens[item] === 'number' ? tokens[item] : null;
                  }
                  hashData.file = typeof hash.file === 'string' ? hash.file : null;
                  tokenData.file = typeof tokens.file === 'number' ? tokens.file : null;

                  // Hash
                  hashData.session = sessionSelected;
                  tinyInsertDb('aiSessionsHash', hashData);

                  // Tokens
                  tokenData.session = sessionSelected;
                  tinyInsertDb('aiSessionsTokens', tokenData);

                  // Room
                  roomSaveData.session = sessionSelected;
                  tinyInsertDb('aiSessionsRoom', roomSaveData);

                  // Custom list
                  tinyInsertDb('aiSessionsCustomList', {
                    session: sessionSelected,
                    data: customList
                  });

                  // Complete
                  saveSessionTimeout[sessionSelected] = null;
                }, 1000);
              }

              // Database (online)
              else if (typeof where === 'string' && !tinyAiScript.mpClient) {
                var timeoutId = "".concat(sessionSelected, "_").concat(where);
                if (saveSessionTimeout[timeoutId]) clearTimeout(saveSessionTimeout[timeoutId]);
                saveSessionTimeout[timeoutId] = setTimeout(function () {
                  var _getSessionData2 = getSessionData(),
                    roomSaveData = _getSessionData2.roomSaveData;

                  // Send data
                  var newSettings = {};
                  if (roomSaveData[where] !== null) newSettings[where] = roomSaveData[where];
                  tinyIo.client.updateRoomSettings(newSettings).then(function (result) {
                    if (result.error) alert("\u26A0\uFE0F Your data was not saved! Please try again.\nError Message:".concat(result.msg, "\nCode: ").concat(result.code));
                  });

                  // Complete
                  saveSessionTimeout[timeoutId] = null;
                }, 1000);
              }
            }
          };
          tinyAiSocketTemplate = function tinyAiSocketTemplate(where, where2, el) {
            return tinyAi.on(where, function (value, id) {
              if (el) el.val(value);
              saveSessionBackup(id, where2);
            });
          };
          tinyAiSocketTemplate('setMaxOutputTokens', 'maxOutputTokens', outputLength);
          tinyAiSocketTemplate('setTemperature', 'temperature', temperature);
          tinyAiSocketTemplate('setTopP', 'topP', topP);
          tinyAiSocketTemplate('setTopK', 'topK', topK);
          tinyAiSocketTemplate('setPresencePenalty', 'presencePenalty', presencePenalty);
          tinyAiSocketTemplate('setFrequencyPenalty', 'frequencyPenalty', frequencyPenalty);
          tinyAiSocketTemplate('setModel', 'model');
          tinyAiSocketTemplate('setPrompt', 'prompt');
          tinyAiSocketTemplate('setFirstDialogue', 'firstDialogue');
          tinyAiSocketTemplate('setSystemInstruction', 'systemInstruction');
          tinyAiSocketTemplate('setRpgSchema');
          tinyAiSocketTemplate('setRpgData');
          tinyAiSocketTemplate('setRpgPrivateData');

          // Delete session
          tinyAi.on('stopDataId', function (id) {
            if (canUsejsStore && id) resetSession(id)["catch"](console.error);
          });

          // Delete message
          tinyAi.on('deleteIndex', function (index, id, sId) {
            if (typeof id === 'number' || typeof id === 'string') {
              if (canUsejsStore) connStore.remove({
                from: 'aiSessionsData',
                where: {
                  msg_id: tinyMsgIdDb(sId, id)
                }
              })["catch"](console.error);
            }
          });

          // Edit message
          tinyAi.on('replaceIndex', function (index, ndata, ntokens, nhash, sId) {
            var id = tinyAi.getIdByIndex(index);
            var data = tinyAi.getMsgByIndex(index);
            var tokens = tinyAi.getMsgTokensByIndex(index);
            var hash = tinyAi.getMsgHashByIndex(index);
            if (typeof id === 'number' || typeof id === 'string') {
              if (canUsejsStore) tinyInsertDb('aiSessionsData', {
                session: sId,
                msg_id: tinyMsgIdDb(sId, id),
                data: data,
                id: id,
                tokens: tokens,
                hash: hash
              });
            }
          });

          // Add message
          tinyAi.on('addData', function (newId, data, tokenData, hash, sId) {
            if (canUsejsStore) tinyInsertDb('aiSessionsData', {
              session: sId,
              msg_id: tinyMsgIdDb(sId, newId),
              data: data,
              id: newId,
              tokens: tokenData,
              hash: hash
            });
          });

          // tinyAi.on('selectDataId', () => {});
          rpgData.initOffCanvas(container);

          // Enable Read Only
          validateMultiplayer = function validateMultiplayer() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var needAi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var isInverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            return (
              // Normal mode
              !tinyAiScript.mpClient ?
              // Ai enabled
              !needAi || !tinyAiScript.noai ? value :
              // No AI
              !isInverse ? true : false :
              // Multiplayer
              !isInverse ? true : false
            );
          };
          contentEnabler.setValidateMultiplayer(validateMultiplayer);

          // First Dialogue script
          enabledFirstDialogue = function enabledFirstDialogue() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var isEnabled = validateMultiplayer(value, false, true);
            // Insert First Dialogue
            var insertAddFirstDialogue = function insertAddFirstDialogue() {
              firstDialogueBase.base.removeClass('d-none');
              firstDialogueBase.button.prop('disabled', false).removeClass('disabled');
            };

            // Remove First Dialogue
            var removeAddFirstDialogue = function removeAddFirstDialogue() {
              firstDialogueBase.base.addClass('d-none');
              firstDialogueBase.button.prop('disabled', true).addClass('disabled');
            };

            // Check need first dialogue
            if (isEnabled) {
              var history = tinyAi.getData();
              if (history && history.data.length < 1 && typeof history.firstDialogue === 'string' && history.firstDialogue.length > 0) insertAddFirstDialogue();else removeAddFirstDialogue();
            } else removeAddFirstDialogue();
          };
          contentEnabler.setEnabledFirstDialogue(enabledFirstDialogue);

          // Clear Messages
          clearMessages = function clearMessages() {
            return msgList.empty();
          };
          contentEnabler.deBase();
          contentEnabler.deMessageButtons();
          contentEnabler.dePromptButtons();

          // Multiplayer disable inputs
          if (tinyAiScript.mpClient || tinyAiScript.noai) {
            if (tinyAiScript.mpClient) contentEnabler.deModelChanger();
            contentEnabler.deModel();
            contentEnabler.deModelSelector();
          }

          // Welcome
          if (!tinyAiScript.mpClient) {
            makeTempMessage("Welcome to Pony Driland's chatbot! This is a chatbot developed exclusively to interact with the content of fic", 'Website');
            makeTempMessage('This means that whenever the story is updated, I am automatically updated for you to always view the answers of the latest content, because the algorithm of this website converts the content of fic to prompts.' + '\n\nChoose something to be done here so we can start our conversation! The chat will not work until you choose an activity to do here', 'Website');
            updateModelList();
          }

          // Complete
          (0, _jquery["default"])('#markdown-read').append(container);
          _context15.n = 5;
          return rpgData.init().then(function () {
            return rpgData.finishOffCanvas(updateAiTokenCounterData);
          });
        case 5:
          if (canUsejsStore) {
            _context15.n = 8;
            break;
          }
          tinyIo.client = new _socketClient["default"](rpgCfg);
          socket = tinyIo.client.getSocket();
          if (socket) makeTempMessage("A server has been detected in your config and we will try to connect to it now!", rpgCfg.ip);

          // Start rpg mode
          //////////////////////////////
          if (!(tinyAiScript.mpClient || socket)) {
            _context15.n = 7;
            break;
          }
          // Online tab html
          onlineStatus = {};
          onlineStatus.base = (0, _jquery["default"])('<div>').addClass('mb-1 small');
          onlineStatus.wrapper = (0, _jquery["default"])('<div>').addClass('d-flex align-items-center gap-1');
          onlineStatus.icon = _tinyLib["default"].icon('fas fa-circle text-danger');
          onlineStatus.text = (0, _jquery["default"])('<span>').text('Offline');
          onlineStatus.id = (0, _jquery["default"])('<span>');
          onlineStatus.wrapper.append(onlineStatus.icon, onlineStatus.text, onlineStatus.id);
          onlineStatus.base.append(onlineStatus.wrapper, onlineStatus.id);
          connectionInfoBar.replaceWith(onlineStatus.base);

          // Socket client
          if (socket) {
            client = tinyIo.client; // Connection
            // Send error message
            sendSocketError = function sendSocketError(result) {
              return makeTempMessage(typeof result.msg === 'string' ? "".concat(result.msg, " (Code: ").concat(typeof result.code === 'number' ? result.code : 0, ")") : 'Unknown error!', rpgCfg.ip);
            }; // Install scripts
            client.install(tinyAiScript);

            // Connected
            client.on('connect', function (connectionId) {
              // Prepare online status
              onlineStatus.icon.removeClass('text-danger').addClass('text-success');
              onlineStatus.text.text('Online');
              onlineStatus.id.empty().text('Id: ').append((0, _jquery["default"])('<strong>').text(connectionId));

              // First time message
              var firstTime = tinyIo.firstTime;
              if (firstTime) tinyIo.firstTime = false;

              // Message
              makeTempMessage("You are connected! Your connection id is **".concat(connectionId, "**. Signing into your account..."), rpgCfg.ip);
            });
            client.on('login', function (result) {
              // Message
              if (!result.error) {
                makeTempMessage("Welcome **".concat(result.nickname || result.userId, "**! You were successfully logged in! Entering the room..."), rpgCfg.ip);
              }
              // Error
              else {
                sendSocketError(result);
                _circleLoader.Loader.close();
              }
            });
            client.on('roomError', function (result) {
              sendSocketError(result);
              _circleLoader.Loader.close();
            });
            client.on('roomNotFound', function () {
              makeTempMessage('The room was not found', rpgCfg.ip);
              _circleLoader.Loader.close();
            });
            client.on('roomJoinned', function (result) {
              makeTempMessage("You successfully entered the room **".concat(result.roomId, "**!"), rpgCfg.ip);
              _circleLoader.Loader.close();
            });

            // Disconnected
            client.on('disconnect', function (reason, details) {
              // Offline!
              onlineStatus.icon.addClass('text-danger').removeClass('text-success');
              onlineStatus.text.text('Offline');
              onlineStatus.id.empty();

              // Message
              makeTempMessage("You are disconected".concat((0, _tinyEssentials.objType)(details, 'object') && typeof details.description === 'string' ? " (".concat(details.description, ")") : '').concat(typeof reason === 'string' ? ": ".concat(reason) : ''), rpgCfg.ip);

              // Prepare disconnect progress
              if (tinyAiScript.mpClient) {
                // Is active
                if (client.isActive()) _circleLoader.Loader.start();
                // Disable page
                else {
                  contentEnabler.deBase();
                  contentEnabler.deModelChanger();
                  contentEnabler.dePromptButtons();
                  contentEnabler.deModel();
                  contentEnabler.deMessageButtons();
                  sessionEnabled = false;
                }
              }
            });

            // Enter room
            client.on('roomEntered', function (success) {
              if (!success) makeTempMessage("Invalid room data detected!", rpgCfg.ip);
            });

            // New message
            client.on('newMessage', function () {
              if (tinyAiScript.mpClient) {}
            });

            // You was kicked
            client.on('userLeft', function (userId) {
              if (userId === client.getUserId()) client.disconnect();
            });

            // Dice rool
            client.on('diceRoll', function () {});
          }

          // No server
          if (socket) {
            _context15.n = 6;
            break;
          }
          makeTempMessage('No server has been detected. Your session is cancelled!', rpgCfg.ip);
          _context15.n = 7;
          break;
        case 6:
          if (tinyAiScript.mpClient) {
            _context15.n = 7;
            break;
          }
          return _context15.a(2);
        case 7:
          _context15.n = 16;
          break;
        case 8:
          _context15.n = 9;
          return connStore.select({
            from: 'aiSessionsRoom'
          });
        case 9:
          _t8 = _context15.v;
          _context15.n = 10;
          return connStore.select({
            from: 'aiSessionsHash'
          });
        case 10:
          _t9 = _context15.v;
          _context15.n = 11;
          return connStore.select({
            from: 'aiSessionsTokens'
          });
        case 11:
          _t0 = _context15.v;
          _context15.n = 12;
          return connStore.select({
            from: 'aiSessionsCustomList'
          });
        case 12:
          _t1 = _context15.v;
          _context15.n = 13;
          return connStore.select({
            from: 'aiSessionsData',
            order: {
              by: 'id',
              type: 'asc'
            }
          });
        case 13:
          _t10 = _context15.v;
          sessionData = {
            rooms: _t8,
            hash: _t9,
            tokens: _t0,
            customList: _t1,
            data: _t10
          };
          sessions = {};
          executeSessionInsert = function executeSessionInsert(where, callback) {
            for (var _index16 in sessionData[where]) {
              var sessionItem = sessionData[where][_index16];
              if (!sessions[sessionItem.session]) sessions[sessionItem.session] = {
                id: sessionItem.session,
                file: {
                  data: [],
                  ids: []
                }
              };
              callback(sessionItem, sessions[sessionItem.session].file);
            }
          }; // Insert rooms
          executeSessionInsert('rooms', function (item, file) {
            for (var name in item) file[name] = item[name];
            if (!canSandBox(item.session) && typeof file.systemInstruction !== 'undefined') delete file.systemInstruction;
            delete file.session;
          });

          // Insert hash
          executeSessionInsert('hash', function (item, file) {
            file.hash = {
              data: []
            };
            for (var name in item) if (typeof item[name] === 'string') file.hash[name] = item[name];
            delete file.hash.session;
          });

          // Insert tokens
          executeSessionInsert('tokens', function (item, file) {
            file.tokens = {
              data: []
            };
            for (var name in item) if (typeof item[name] === 'number') file.tokens[name] = item[name];
          });

          // Insert custom list
          executeSessionInsert('customList', function (item, file) {
            file.customList = item.data || null;
          });

          // Insert data
          executeSessionInsert('data', function (item, file) {
            // Insert id
            file.ids.push(typeof item.id === 'number' ? item.id : null);
            // Insert hash
            file.hash.data.push(typeof item.hash === 'string' ? item.hash : null);
            // Insert tokens
            var tokens = (0, _tinyEssentials.objType)(item.tokens, 'object') ? item.tokens : {
              count: null
            };
            if (typeof tokens.count !== 'number') tokens.count = null;
            file.tokens.data.push(tokens);
            // Insert data
            if ((0, _tinyEssentials.objType)(item.data, 'object')) file.data.push(item.data);
          });

          // Import data
          _t11 = _regeneratorKeys(sessions);
        case 14:
          if ((_t12 = _t11()).done) {
            _context15.n = 16;
            break;
          }
          item = _t12.value;
          _context15.n = 15;
          return importFileSession(sessions[item]);
        case 15:
          _context15.n = 14;
          break;
        case 16:
          _context15.n = 18;
          break;
        case 17:
          alert('AI mode is currently disabled for your session. Please click the robot icon to activate it, then come back here.', 'AI Page');
        case 18:
          _context15.n = 19;
          return _start.tinyNotification.requestPerm();
        case 19:
          _circleLoader.Loader.close();
        case 20:
          return _context15.a(2);
      }
    }, _callee13);
  }));

  // Complete
  return tinyAiScript;
};

},{"../chapters/config.mjs":219,"../files/tinyLib.mjs":223,"../start.mjs":226,"./RoomUserManagerUI.mjs":206,"./TinyMap.mjs":207,"./aiSoftware/enablerContent.mjs":209,"./aiSoftware/rpgData.mjs":210,"./jsonTemplate.mjs":211,"./socketClient.mjs":212,"./templates.mjs":213,"circle-loader":68,"clone":69,"events":92,"file-saver":93,"jquery":97,"marked":103,"moment":104,"object-hash":106,"tiny-ai-api":151,"tiny-dices":153,"tiny-essentials":181}],209:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _validateMultiplayer = /*#__PURE__*/new WeakMap();
var _enabledFirstDialogue = /*#__PURE__*/new WeakMap();
var _EnablerAiContent_brand = /*#__PURE__*/new WeakSet();
var EnablerAiContent = /*#__PURE__*/function () {
  function EnablerAiContent() {
    _classCallCheck(this, EnablerAiContent);
    _classPrivateMethodInitSpec(this, _EnablerAiContent_brand);
    _classPrivateFieldInitSpec(this, _validateMultiplayer, void 0);
    _classPrivateFieldInitSpec(this, _enabledFirstDialogue, void 0);
  }
  return _createClass(EnablerAiContent, [{
    key: "setResetSettingsButton",
    value: function setResetSettingsButton(resetSettingsButton) {
      this.resetSettingsButton = resetSettingsButton;
    }
  }, {
    key: "setTemperature",
    value: function setTemperature(temperature) {
      this.temperature = temperature;
    }
  }, {
    key: "setTopP",
    value: function setTopP(topP) {
      this.topP = topP;
    }
  }, {
    key: "setTopK",
    value: function setTopK(topK) {
      this.topK = topK;
    }
  }, {
    key: "setPresencePenalty",
    value: function setPresencePenalty(presencePenalty) {
      this.presencePenalty = presencePenalty;
    }
  }, {
    key: "setFrequencyPenalty",
    value: function setFrequencyPenalty(frequencyPenalty) {
      this.frequencyPenalty = frequencyPenalty;
    }
  }, {
    key: "setOutputLength",
    value: function setOutputLength(outputLength) {
      this.outputLength = outputLength;
    }
  }, {
    key: "setRpgData",
    value: function setRpgData(rpgData) {
      this.rpgData = rpgData;
    }
  }, {
    key: "setFicPromptItems",
    value: function setFicPromptItems(ficPromptItems) {
      this.ficPromptItems = ficPromptItems;
    }
  }, {
    key: "setChatContainer",
    value: function setChatContainer(chatContainer) {
      this.chatContainer = chatContainer;
    }
  }, {
    key: "setMsgSubmit",
    value: function setMsgSubmit(msgSubmit) {
      this.msgSubmit = msgSubmit;
    }
  }, {
    key: "setMsgInput",
    value: function setMsgInput(msgInput) {
      this.msgInput = msgInput;
    }
  }, {
    key: "setCancelSubmit",
    value: function setCancelSubmit(cancelSubmit) {
      this.cancelSubmit = cancelSubmit;
    }
  }, {
    key: "setSubmitCache",
    value: function setSubmitCache(submitCache) {
      this.submitCache = submitCache;
    }
  }, {
    key: "setFicResets",
    value: function setFicResets(ficResets) {
      this.ficResets = ficResets;
    }
  }, {
    key: "setFicTemplates",
    value: function setFicTemplates(ficTemplates) {
      this.ficTemplates = ficTemplates;
    }
  }, {
    key: "setImportItems",
    value: function setImportItems(importItems) {
      this.importItems = importItems;
    }
  }, {
    key: "setModelSelector",
    value: function setModelSelector(modelSelector) {
      this.modelSelector = modelSelector;
    }
  }, {
    key: "setValidateMultiplayer",
    value: function setValidateMultiplayer(validateMultiplayer) {
      _classPrivateFieldSet(_validateMultiplayer, this, validateMultiplayer);
    }
  }, {
    key: "setEnabledFirstDialogue",
    value: function setEnabledFirstDialogue(enabledFirstDialogue) {
      _classPrivateFieldSet(_enabledFirstDialogue, this, enabledFirstDialogue);
    }
  }, {
    key: "enModel",
    value: function enModel() {
      _assertClassBrand(_EnablerAiContent_brand, this, _enableModelReadOnly).call(this, false);
    }
  }, {
    key: "deModel",
    value: function deModel() {
      _assertClassBrand(_EnablerAiContent_brand, this, _enableModelReadOnly).call(this, true);
    }
  }, {
    key: "enPromptButtons",
    value: function enPromptButtons() {
      _assertClassBrand(_EnablerAiContent_brand, this, _disablePromptButtons).call(this, false);
    }
  }, {
    key: "dePromptButtons",
    value: function dePromptButtons() {
      _assertClassBrand(_EnablerAiContent_brand, this, _disablePromptButtons).call(this, true);
    }
  }, {
    key: "enMessageButtons",
    value: function enMessageButtons() {
      _assertClassBrand(_EnablerAiContent_brand, this, _enableMessageButtons).call(this, true);
    }
  }, {
    key: "deMessageButtons",
    value: function deMessageButtons() {
      _assertClassBrand(_EnablerAiContent_brand, this, _enableMessageButtons).call(this, false);
    }
  }, {
    key: "enBase",
    value: function enBase(controller) {
      _assertClassBrand(_EnablerAiContent_brand, this, _enableReadOnly).call(this, false, controller);
    }
  }, {
    key: "deBase",
    value: function deBase(controller) {
      _assertClassBrand(_EnablerAiContent_brand, this, _enableReadOnly).call(this, true, controller);
    }
  }, {
    key: "enModelChanger",
    value: function enModelChanger() {
      _assertClassBrand(_EnablerAiContent_brand, this, _modelChangerReadOnly).call(this, false);
    }
  }, {
    key: "deModelChanger",
    value: function deModelChanger() {
      _assertClassBrand(_EnablerAiContent_brand, this, _modelChangerReadOnly).call(this, true);
    }
  }, {
    key: "enModelSelector",
    value: function enModelSelector() {
      _assertClassBrand(_EnablerAiContent_brand, this, _enableModelSelectorReadOnly).call(this, false);
    }
  }, {
    key: "deModelSelector",
    value: function deModelSelector() {
      _assertClassBrand(_EnablerAiContent_brand, this, _enableModelSelectorReadOnly).call(this, true);
    }
  }]);
}();
function _readOnlyTemplate(item, value) {
  var needAi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var isEnabled = _classPrivateFieldGet(_validateMultiplayer, this).call(this, value, needAi);
  item.prop('disabled', isEnabled);
  if (isEnabled) {
    item.addClass('disabled');
  } else {
    item.removeClass('disabled');
  }
}
function _enableModelReadOnly() {
  var _this = this;
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var isEnabled = _classPrivateFieldGet(_validateMultiplayer, this).call(this, value);
  this.outputLength.prop('disabled', isEnabled);
  _assertClassBrand(_EnablerAiContent_brand, this, _enableModelSelectorReadOnly).call(this, isEnabled);
  var validateChange = function validateChange(where) {
    return _this[where][isEnabled || _this[where].valString2().trim().length < 1 ? 'disable' : 'enable']();
  };
  validateChange('temperature');
  validateChange('topP');
  validateChange('topK');
  validateChange('presencePenalty');
  validateChange('frequencyPenalty');
  if (isEnabled) {
    this.outputLength.addClass('disabled');
    this.resetSettingsButton.addClass('disabled');
  } else {
    this.outputLength.removeClass('disabled');
    this.resetSettingsButton.removeClass('disabled');
  }
}
function _disablePromptButtons() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var isDisabled = _classPrivateFieldGet(_validateMultiplayer, this).call(this, value, false);
  // Execute disable script
  for (var item in this.rpgData.ready) {
    if (this.rpgData.ready[item]) {
      if (isDisabled) this.rpgData.data[item].disable();else this.rpgData.data[item].enable();
    }
  }
  for (var index in this.ficPromptItems) {
    this.ficPromptItems[index].prop('disabled', isDisabled);
    if (isDisabled) this.ficPromptItems[index].addClass('disabled');else this.ficPromptItems[index].removeClass('disabled');
  }
  // First dialogue script
  _classPrivateFieldGet(_enabledFirstDialogue, this).call(this, !isDisabled);
}
function _enableMessageButtons() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var isEnabled = _classPrivateFieldGet(_validateMultiplayer, this).call(this, value, false);
  if (isEnabled) this.chatContainer.removeClass('hide-msg-buttons');else this.chatContainer.addClass('hide-msg-buttons');
}
function _enableReadOnly() {
  var _this2 = this;
  var isEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var controller = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  _assertClassBrand(_EnablerAiContent_brand, this, _readOnlyTemplate).call(this, this.msgSubmit, isEnabled, false);
  _assertClassBrand(_EnablerAiContent_brand, this, _readOnlyTemplate).call(this, this.msgInput, isEnabled, false);
  _assertClassBrand(_EnablerAiContent_brand, this, _readOnlyTemplate).call(this, this.cancelSubmit, !isEnabled || !controller, false);
  if (controller) {
    this.msgSubmit.addClass('d-none');
    this.cancelSubmit.removeClass('d-none');
    this.cancelSubmit.on('click', function () {
      enableReadOnly(false);
      enableMessageButtons(true);
      try {
        if (_this2.submitCache.cancel) _this2.submitCache.cancel();
        controller.abort();
      } catch (err) {
        console.error(err);
        alert(err.message);
      }
    });
  } else {
    this.msgSubmit.removeClass('d-none');
    this.cancelSubmit.addClass('d-none');
    this.cancelSubmit.off('click');
  }
}
function _modelChangerReadOnly() {
  var isEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  for (var index in this.ficResets) _assertClassBrand(_EnablerAiContent_brand, this, _readOnlyTemplate).call(this, this.ficResets[index], isEnabled, false);
  for (var _index in this.ficTemplates) _assertClassBrand(_EnablerAiContent_brand, this, _readOnlyTemplate).call(this, this.ficTemplates[_index], isEnabled, false);
  for (var _index2 in this.importItems) _assertClassBrand(_EnablerAiContent_brand, this, _readOnlyTemplate).call(this, this.importItems[_index2], isEnabled, false);
}
function _enableModelSelectorReadOnly() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var isEnabled = _classPrivateFieldGet(_validateMultiplayer, this).call(this, value);
  this.modelSelector.prop('disabled', isEnabled);
  if (isEnabled) this.modelSelector.addClass('disabled');else this.modelSelector.removeClass('disabled');
}
var _default = exports["default"] = EnablerAiContent;

},{}],210:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _tinyEssentials = require("tiny-essentials");
var _jquery = _interopRequireDefault(require("jquery"));
var _bootstrap = require("bootstrap");
var _JSONEditor = _interopRequireDefault(require("../../../build/bundle/JSONEditor.mjs"));
var _tinyLib = _interopRequireDefault(require("../../files/tinyLib.mjs"));
var _templates = _interopRequireDefault(require("../templates.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var RpgData = /*#__PURE__*/function () {
  function RpgData() {
    _classCallCheck(this, RpgData);
    this.schemaHash = null;
    this.allowAiUse = {
      "public": false,
      "private": false
    };
    this.allowAiSchemaUse = {
      "public": false,
      "private": false
    };
    this.hash = {
      "public": null,
      "private": null
    };
    this.oldHash = {
      "public": null,
      "private": null
    };
    this.html = {
      "public": null,
      "private": null
    };
    this.offcanvas = {
      "public": null,
      "private": null
    };
    this.ready = {
      "public": false,
      "private": false
    };
    this.data = {
      "public": null,
      "private": null
    };
    this.base = {
      "public": (0, _jquery["default"])('<div>', {
        id: 'info_box'
      }),
      "private": (0, _jquery["default"])('<div>', {
        id: 'privateInfo'
      })
    };
  }
  return _createClass(RpgData, [{
    key: "setTinyAi",
    value: function setTinyAi(tinyAi) {
      this.tinyAi = tinyAi;
    }
  }, {
    key: "setFicConfigs",
    value: function setFicConfigs(ficConfigs) {
      this.ficConfigs = ficConfigs;
    }

    // Data Filter
  }, {
    key: "filter",
    value: function filter(value) {
      if (typeof value === 'string') {
        try {
          value = JSON.parse(value);
        } catch (err) {
          console.error(err);
          value = null;
        }
      }
      return value;
    }
  }, {
    key: "setAllowAiUse",
    value: function setAllowAiUse(value, type) {
      if (typeof this.allowAiUse[type] === 'boolean') this.allowAiUse[type] = typeof value === 'boolean' ? value : false;
    }
  }, {
    key: "setAllowAiSchemaUse",
    value: function setAllowAiSchemaUse(value, type) {
      if (typeof this.allowAiSchemaUse[type] === 'boolean') this.allowAiSchemaUse[type] = typeof value === 'boolean' ? value : false;
    }
  }, {
    key: "finishOffCanvas",
    value: function finishOffCanvas(updateAiTokenCounterData) {
      var rpgData = this;
      var tinyAi = this.tinyAi;
      // offCanvas closed
      var onOffCanvasClosed = function onOffCanvasClosed(where, type) {
        return function () {
          setTimeout(function () {
            var tinyData = rpgData.data[where].getValue();
            if (tinyData) {
              rpgData.setAllowAiUse(tinyData.allowAiUse, where);
              rpgData.setAllowAiSchemaUse(tinyData.allowAiSchemaUse, where);
              if (rpgData.data[where].isEnabled() && rpgData.hash[where] !== rpgData.oldHash[where]) {
                rpgData.oldHash[where] = rpgData.hash[where];
                tinyAi.setCustomValue(type, null, 0);
                updateAiTokenCounterData();
              }
            }
          }, 300);
        };
      };
      this.html["public"].get(0).addEventListener('hide.bs.offcanvas', onOffCanvasClosed('public', 'rpgData'));
      this.html["private"].get(0).addEventListener('hide.bs.offcanvas', onOffCanvasClosed('private', 'rpgPrivateData'));
    }
  }, {
    key: "initOffCanvas",
    value: function initOffCanvas(container) {
      // Prepare RPG
      this.html["public"] = _tinyLib["default"].bs.offcanvas('start', 'rpg_ai_base_1', '', this.base["public"], true);
      this.html["private"] = _tinyLib["default"].bs.offcanvas('end', 'rpg_ai_base_2', '', this.base["private"], false);
      container.prepend(this.html["public"], this.html["private"]);
      this.offcanvas["public"] = new _bootstrap.Offcanvas(this.html["public"].get(0));
      this.offcanvas["private"] = new _bootstrap.Offcanvas(this.html["private"].get(0));
    }
  }, {
    key: "init",
    value: function init() {
      var forceRestart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var rpgData = this;
      var tinyAi = this.tinyAi;
      var ficConfigs = this.ficConfigs;
      return new Promise(function (resolve, reject) {
        // Get template
        rpgData.template = {
          // Seed the form with a starting value
          startval: {},
          // Disable additional properties
          no_additional_properties: false,
          // Require all properties by default
          required_by_default: false
        };

        // Add custom Schema
        var customSchema = tinyAi.getCustomValue('rpgSchema');
        if ((0, _tinyEssentials.objType)(customSchema, 'object')) rpgData.template.schema = customSchema;
        // Default schema
        else {
          rpgData.template.schema = _templates["default"].funcs.jsonTemplate();
          if (ficConfigs.selected) tinyAi.setCustomValue('rpgSchema', rpgData.template.schema, 0);
        }
        var schemaHash = tinyAi.getHash('rpgSchema');

        // Start json
        var failed = false;
        var amountStarted = 0;
        var loadData = {};
        var startJsonNow = function startJsonNow(where, valueName) {
          try {
            // The tiny start script
            var executeTinyStart = function executeTinyStart() {
              var isFirstTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              var rpgEditor = rpgData.data[where];
              // Remove first time
              if (isFirstTime) rpgEditor.off('ready', funcExecStart);
              // Get data
              loadData[where] = tinyAi.getCustomValue(valueName);
              if (!(0, _tinyEssentials.objType)(loadData[where], 'object')) loadData[where] = {};

              // Insert data
              rpgEditor.setValue(rpgData.filter(loadData[where]));
              rpgEditor.validate();

              // Change events
              if (!ficConfigs.selected) rpgEditor.disable();
              if (isFirstTime) {
                rpgEditor.on('change', function () {
                  rpgEditor.validate();
                  if (ficConfigs.selected) {
                    try {
                      var tinyData = rpgEditor.getValue();
                      if (tinyData) {
                        tinyAi.setCustomValue(valueName, tinyData);
                        rpgData.hash[where] = tinyAi.getHash(valueName);
                        rpgData.setAllowAiUse(tinyData.allowAiUse, where);
                        rpgData.setAllowAiSchemaUse(tinyData.allowAiSchemaUse, where);
                      }
                    } catch (err) {
                      console.error(err);
                    }
                  }
                });
              }

              // Complete
              if (!failed) {
                rpgData.ready[where] = true;
                amountStarted++;
                if (amountStarted >= 2) {
                  rpgData.schemaHash = schemaHash;
                  resolve(loadData);
                }
              }
            };
            var funcExecStart = function funcExecStart() {
              return executeTinyStart(true);
            };

            // Start json data
            if (rpgData.schemaHash !== schemaHash || !rpgData.data[where] || forceRestart) {
              // Remove Old
              if (rpgData.data[where]) rpgData.data[where].destroy();
              // Insert template
              rpgData.data[where] = new _JSONEditor["default"](rpgData.base[where].get(0), rpgData.template);

              // Start scripts now
              rpgData.data[where].on('ready', funcExecStart);
            } else executeTinyStart(false);
          } catch (err) {
            // Error!
            console.error(err);
            if (!failed) {
              failed = true;
              reject(new Error('An error occurred at booting your RPG. Check your console for more details!'));
            }
          }
        };

        // Read json now
        startJsonNow('public', 'rpgData');
        startJsonNow('private', 'rpgPrivateData');
      });
    }
  }]);
}();
var _default = exports["default"] = RpgData;

},{"../../../build/bundle/JSONEditor.mjs":1,"../../files/tinyLib.mjs":223,"../templates.mjs":213,"bootstrap":65,"jquery":97,"tiny-essentials":181}],211:[function(require,module,exports){
"use strict";

var _templates = _interopRequireDefault(require("./templates.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// https://github.com/json-editor/json-editor?tab=readme-ov-file
_templates["default"].funcs.jsonTemplate = function () {
  var rpgBase = {
    // Generator
    generator: {
      // Character List
      characterList: function characterList(data) {
        // Result Data
        var resultData = {
          title: data.title,
          description: data.description,
          type: 'array',
          id: data.id,
          options: {
            collapsed: true
          },
          items: {
            title: data.itemTitle,
            headerTemplate: '{{self.name}}',
            type: 'object',
            id: data.itemID,
            options: {
              collapsed: true
            },
            // Base
            properties: {
              name: {
                type: 'string',
                title: 'Name',
                description: 'The name of the character.'
              },
              race: {
                type: 'string',
                title: 'Race',
                description: 'The race or species of the character.'
              },
              location: {
                type: 'string',
                title: 'Location',
                description: 'Where the character is located in the game world.'
              },
              coins: {
                type: 'number',
                title: 'Coins',
                minimum: 0,
                description: 'Amount of coins the character possesses.'
              },
              gender: {
                type: 'string',
                title: 'Gender',
                description: 'The gender of the character.'
              },
              level: {
                type: 'number',
                title: 'Level',
                minimum: 1,
                description: 'The level of the character.'
              },
              "class": {
                type: 'string',
                title: 'Class',
                description: 'The class of the character (e.g., Warrior, Mage).'
              },
              experience: {
                type: 'number',
                title: 'Experience',
                minimum: 0,
                description: 'The experience points the character has earned.'
              },
              attack: {
                type: 'number',
                title: 'Attack',
                minimum: 0,
                description: "The character's attack power."
              },
              defense: {
                type: 'number',
                title: 'Defense',
                minimum: 0,
                description: "The character's defense power."
              },
              totalhp: {
                type: 'number',
                title: 'Total HP',
                minimum: 1,
                description: 'The maximum health points of the character.'
              },
              hp: {
                type: 'number',
                title: 'HP',
                minimum: 0,
                description: 'The current health points of the character.'
              },
              mana: {
                type: 'number',
                title: 'Mana',
                minimum: 0,
                description: "The character's mana, used for casting spells."
              },
              proficiency: {
                title: 'Proficiencies',
                type: 'array',
                id: 'proficiencies',
                description: 'A list of proficiencies or skills the character excels in, such as weapon types, magical abilities, or other talents.',
                options: {
                  collapsed: true
                },
                items: {
                  title: 'Proficiency',
                  headerTemplate: '{{self.name}}',
                  type: 'object',
                  id: 'item',
                  options: {
                    collapsed: true
                  },
                  properties: {
                    name: {
                      type: 'string',
                      title: 'Title',
                      minLength: 1,
                      description: 'The title of the proficiency.'
                    },
                    items: {
                      type: 'string',
                      title: 'Proficiency',
                      minLength: 1,
                      description: 'List of proficiencies or areas the character is skilled in (e.g., Archery, Stealth).'
                    }
                  }
                }
              },
              alignment: {
                type: 'string',
                title: 'Alignment',
                description: "The character's moral alignment (e.g., Lawful Good, Chaotic Evil)."
              },
              background: {
                type: 'string',
                format: 'textarea',
                title: 'Background',
                description: 'A brief history or backstory of the character.'
              },
              dead: {
                type: 'boolean',
                title: 'Dead',
                description: 'Indicates whether the character is dead.'
              },
              fainted: {
                type: 'boolean',
                title: 'Fainted',
                description: 'Indicates whether the character is currently fainted.'
              },
              inventory: {
                title: 'Inventory',
                type: 'array',
                id: 'inventory',
                options: {
                  collapsed: true
                },
                description: 'A list of items the character carries, including weapons, tools, and other important belongings.',
                items: {
                  title: 'Item',
                  headerTemplate: '{{self.name}} ({{self.amount}})',
                  type: 'object',
                  id: 'item',
                  options: {
                    collapsed: true
                  },
                  properties: {
                    name: {
                      type: 'string',
                      title: 'Name',
                      minLength: 1,
                      description: 'The name of the item.'
                    },
                    amount: {
                      type: 'number',
                      title: 'Amount',
                      minimum: 1,
                      description: 'How many units of this item the character has.'
                    }
                  }
                }
              },
              equipment: {
                title: 'Equipment',
                type: 'array',
                id: 'equipment',
                description: 'A collection of items the character can equip, like weapons, armor, and accessories, each providing bonuses or abilities to enhance performance.',
                options: {
                  collapsed: true
                },
                items: {
                  headerTemplate: '{{self.name}}',
                  title: 'Equipment',
                  type: 'object',
                  id: 'equip',
                  options: {
                    collapsed: true
                  },
                  properties: {
                    name: {
                      type: 'string',
                      title: 'Name',
                      minLength: 1,
                      description: 'The name of the equipment.'
                    },
                    type: {
                      type: 'string',
                      title: 'Type',
                      description: 'The type of equipment (e.g., Weapon, Armor).'
                    },
                    stats: {
                      type: 'object',
                      title: 'Stats',
                      description: 'The stats or bonuses provided by the equipment (e.g., +5 Attack).',
                      properties: {
                        attack: {
                          type: 'number',
                          title: 'Attack',
                          minimum: 0,
                          description: 'The attack bonus provided by the equipment.'
                        },
                        defense: {
                          type: 'number',
                          title: 'Defense',
                          minimum: 0,
                          description: 'The defense bonus provided by the equipment.'
                        }
                      }
                    }
                  }
                }
              },
              skills: {
                title: 'Skills',
                type: 'array',
                id: 'skills',
                options: {
                  collapsed: true
                },
                description: 'A list of skills the character has acquired, showcasing their abilities and expertise in various areas.',
                items: {
                  title: 'Skill',
                  headerTemplate: '{{self.name}} ({{self.amount}})',
                  type: 'object',
                  id: 'skill',
                  options: {
                    collapsed: true
                  },
                  properties: {
                    name: {
                      type: 'string',
                      title: 'Name',
                      minLength: 1,
                      description: 'The name of the skill.'
                    },
                    amount: {
                      type: 'number',
                      title: 'Amount',
                      minimum: 0,
                      description: 'How skilled the character is in this ability.'
                    },
                    cost: {
                      type: 'number',
                      title: 'Cost',
                      minimum: 0,
                      description: 'The cost (e.g., mana or stamina) to use this skill.'
                    }
                  }
                }
              },
              relationships: {
                title: 'Relationships',
                type: 'array',
                id: 'relationships',
                description: 'A list of relationships the character has with others, such as friends, enemies, allies, or rivals, influencing interactions and story progression.',
                options: {
                  collapsed: true
                },
                items: {
                  title: 'Relationship',
                  type: 'object',
                  id: 'relationship',
                  options: {
                    collapsed: true
                  },
                  properties: {
                    name: {
                      type: 'string',
                      title: 'Name',
                      description: 'The name of the individual the character has a relationship with.'
                    },
                    type: {
                      type: 'string',
                      title: 'Type',
                      description: 'The type of relationship (e.g., Friend, Rival, Ally).'
                    },
                    status: {
                      type: 'string',
                      title: 'Status',
                      description: 'The current status of the relationship (e.g., Friendly, Hostile).'
                    },
                    notes: {
                      type: 'string',
                      format: 'textarea',
                      title: 'Notes',
                      description: 'Any additional notes about the relationship.'
                    }
                  }
                }
              },
              about: {
                type: 'string',
                format: 'textarea',
                title: 'About',
                description: 'Additional details or backstory for the character.'
              }
            }
          }
        };
        if (data.mascot) {
          resultData.items.properties.mascot = rpgBase.generator.characterList({
            title: 'Mascots',
            description: 'A list of mascots that accompany the character, offering unique abilities and support in quests and battles.',
            id: 'mascots',
            itemTitle: 'Mascot',
            itemID: 'mascot'
          });
        }
        return resultData;
      }
    },
    // Data
    data: {
      title: 'RPG',
      type: 'object',
      id: 'data',
      options: {
        collapsed: false
      },
      // Base
      properties: {
        allowAiUse: {
          type: 'boolean',
          title: 'Allow AI Prompt Usage (BETA)',
          description: 'Allow AI to use this data for generative content in future responses.'
        },
        allowAiSchemaUse: {
          type: 'boolean',
          title: 'Allow AI Schema Prompt Usage (BETA)',
          description: 'Allow AI to use the schema data for generative content in future responses.'
        },
        comments: {
          type: 'string',
          format: 'textarea',
          title: 'Comments',
          description: 'Any additional comments or notes about the RPG session.'
        },
        clock: {
          type: 'string',
          title: 'Clock',
          description: 'In-game time or any time-related information for the RPG session.'
        },
        location: {
          type: 'string',
          title: 'Location',
          description: 'The current location or setting of the RPG session.'
        },
        // Skills Wiki
        skills: {
          title: 'Skills',
          type: 'array',
          id: 'skills',
          options: {
            collapsed: true
          },
          description: 'List of available skills in the RPG world.',
          items: {
            title: 'Skill',
            headerTemplate: '{{self.name}}',
            type: 'object',
            id: 'skill',
            options: {
              collapsed: true
            },
            properties: {
              name: {
                type: 'string',
                title: 'Name',
                minLength: 1,
                description: 'The name of the skill (e.g., Fireball, Stealth, Healing).'
              },
              about: {
                type: 'string',
                format: 'textarea',
                title: 'About',
                description: 'A brief description of the skill, its effects, and limitations.'
              },
              level: {
                type: 'number',
                title: 'Level',
                description: "The skill's rank, affecting its power and effectiveness.",
                minimum: 1
              },
              cost: {
                type: 'number',
                title: 'Cost',
                description: 'The resource cost (mana, stamina, etc.) to use the skill.',
                minimum: 0
              },
              cooldown: {
                type: 'number',
                title: 'Cooldown',
                description: 'The time before the skill can be used again (in turns or seconds).',
                minimum: 0
              }
            }
          }
        },
        // Settings
        settings: {
          title: 'Settings',
          type: 'object',
          id: 'data',
          options: {
            collapsed: false
          },
          description: 'Game settings and configurations for the RPG session.',
          // Base
          properties: {
            // Items Wiki
            items: {
              title: 'Items',
              type: 'array',
              id: 'items',
              options: {
                collapsed: true
              },
              description: 'A collection of items available in the RPG world.',
              items: {
                title: 'Item',
                headerTemplate: '{{self.name}}',
                type: 'object',
                id: 'item',
                options: {
                  collapsed: true
                },
                properties: {
                  name: {
                    type: 'string',
                    title: 'Name',
                    minLength: 1,
                    description: 'The name of the item.'
                  },
                  price: {
                    type: 'number',
                    title: 'Price',
                    minimum: 0,
                    description: 'The cost of the item in the RPG world.'
                  },
                  cities: {
                    type: 'string',
                    title: 'Locations',
                    format: 'textarea',
                    description: 'Locations where the item is available or restricted.'
                  },
                  about: {
                    type: 'string',
                    format: 'textarea',
                    title: 'About',
                    description: 'A description of the item and its uses.'
                  },
                  rarity: {
                    type: 'string',
                    title: 'Rarity',
                    description: 'The rarity of the item (e.g., Common, Rare, Legendary).'
                  },
                  weight: {
                    type: 'number',
                    title: 'Weight',
                    minimum: 0,
                    description: 'The weight of the item, affecting inventory space.'
                  },
                  effects: {
                    type: 'string',
                    title: 'Effects',
                    format: 'textarea',
                    description: 'Any special effects or buffs the item provides.'
                  },
                  durability: {
                    type: 'number',
                    title: 'Durability',
                    minimum: 0,
                    description: 'How much the item can be used before breaking or deteriorating.'
                  },
                  use: {
                    type: 'string',
                    title: 'Use',
                    description: 'How the item is used in the game (e.g., Equip, Consume, Activate).'
                  }
                }
              }
            },
            // Maps
            maps: {
              title: 'Maps',
              type: 'array',
              id: 'maps_v1',
              options: {
                collapsed: true
              },
              description: 'Collection of maps for the RPG world.',
              items: {
                title: 'Map',
                headerTemplate: '{{self.name}}',
                type: 'object',
                id: 'map',
                options: {
                  collapsed: true
                },
                properties: {
                  name: {
                    type: 'string',
                    title: 'Name',
                    minLength: 1,
                    description: 'The name of the map.'
                  },
                  defaultColor: {
                    type: 'string',
                    title: 'Default Color Code',
                    description: 'The default color code used for the map, leave empty for transparent (Empty to Transparent).'
                  },
                  size: {
                    type: 'string',
                    title: 'Image Size',
                    description: 'Dimensions of the map image (maximum allowed size) (width X height) (Max 4000x4000).'
                  },
                  tile: {
                    type: 'string',
                    title: 'Tile Size',
                    description: 'Dimensions of individual map tiles (width X height) (Max 4000x4000).'
                  },
                  /* image: {
                    type: 'string',
                    title: 'Image URL',
                    description: 'URL to the image file representing the map.',
                  }, */
                  about: {
                    type: 'string',
                    format: 'textarea',
                    title: 'About',
                    description: 'A description of the map and its significance in the RPG world.'
                  },
                  routes: {
                    title: 'Routes',
                    type: 'array',
                    id: 'routes',
                    options: {
                      collapsed: true
                    },
                    description: 'List of travel routes within the map.',
                    items: {
                      title: 'Route',
                      headerTemplate: '{{i}}',
                      type: 'object',
                      id: 'route',
                      options: {
                        collapsed: true
                      },
                      properties: {
                        color: {
                          type: 'string',
                          title: 'Color Code',
                          description: 'Color code for the route on the map (Empty to Transparent).'
                        },
                        fontColor: {
                          type: 'string',
                          title: 'Font Color Code',
                          description: 'Font color code for text along the route (Empty to Default).'
                        },
                        coordinates: {
                          type: 'string',
                          title: 'Coordinates',
                          description: 'Coordinates indicating the start and end points of the route (Width x Height).'
                        },
                        about: {
                          type: 'string',
                          format: 'textarea',
                          title: 'About',
                          description: 'A description of the route and its purpose.'
                        }
                      }
                    }
                  },
                  locations: {
                    title: 'Locations',
                    type: 'array',
                    id: 'locations',
                    options: {
                      collapsed: true
                    },
                    description: 'Locations available on the map.',
                    items: {
                      title: 'Location',
                      headerTemplate: '{{self.name}}',
                      type: 'object',
                      id: 'location',
                      options: {
                        collapsed: true
                      },
                      properties: {
                        name: {
                          type: 'string',
                          title: 'Name',
                          minLength: 1,
                          description: 'The name of the location on the map.'
                        },
                        mininame: {
                          type: 'string',
                          title: 'Mini Name',
                          description: 'A shorter name or alias for the location.'
                        },
                        shop: {
                          type: 'boolean',
                          title: 'Enable Shop',
                          description: 'Indicates if there is a shop available at this location.'
                        },
                        color: {
                          type: 'string',
                          title: 'Color Code',
                          description: 'Color code associated with the location on the map (Empty to Transparent).'
                        },
                        fontColor: {
                          type: 'string',
                          title: 'Font Color Code',
                          description: 'Font color code for text at the location (Empty to Default).'
                        },
                        coordinates: {
                          type: 'string',
                          title: 'Coordinates',
                          description: 'Coordinates marking the location on the map (Width x Height).'
                        },
                        about: {
                          type: 'string',
                          format: 'textarea',
                          title: 'About',
                          description: 'A description of the location and its importance in the game.'
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  // Character Generator
  rpgBase.generator.characters = {
    teamCharacters: rpgBase.generator.characterList({
      title: 'Team Characters',
      description: 'A list of characters in the team or party who assist in quests, battles, and story progression, with unique interactions with the main character.',
      id: 'teamCharacters',
      itemTitle: 'Character',
      itemID: 'Character',
      mascot: true
    }),
    specialCharacters: rpgBase.generator.characterList({
      title: 'Special Characters',
      description: 'A list of key characters with special abilities, unique backgrounds, or significant roles in the story and quests.',
      id: 'specialCharacters',
      itemTitle: 'Character',
      itemID: 'Character',
      mascot: true
    }),
    villainsCharacters: rpgBase.generator.characterList({
      title: 'Villains Characters',
      description: 'A list of antagonists or villains who oppose the protagonist, with their own motives, abilities, and goals.',
      id: 'villainsCharacters',
      itemTitle: 'Character',
      itemID: 'Character',
      mascot: true
    })
  };

  // Editor
  var schema = rpgBase.data;

  // Insert Characters
  for (var item in rpgBase.generator.characters) {
    schema.properties[item] = rpgBase.generator.characters[item];
  }

  // Complete
  return schema;
};

},{"./templates.mjs":213}],212:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _events = require("events");
var _socket = require("socket.io-client");
var _tinyEssentials = require("tiny-essentials");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _cfg = /*#__PURE__*/new WeakMap();
var _TinyClientIo_brand = /*#__PURE__*/new WeakSet();
var TinyClientIo = /*#__PURE__*/function (_EventEmitter) {
  function TinyClientIo(cfg) {
    var _this;
    _classCallCheck(this, TinyClientIo);
    _this = _callSuper(this, TinyClientIo);
    _classPrivateMethodInitSpec(_this, _TinyClientIo_brand);
    _classPrivateFieldInitSpec(_this, _cfg, void 0);
    var _tinyThis = _this;
    _classPrivateFieldSet(_cfg, _this, cfg);
    _this.socket = typeof cfg.ip === 'string' && cfg.ip.length > 0 ? new _socket.io(cfg.ip) : null;
    _this.id = null;
    _this.connected = false;
    _this.active = false;
    _this.resetData();
    if (_this.socket) {
      console.log('[socket.io] Starting...');
      _this.socket.on('disconnect', function (reason, details) {
        _tinyThis.active = _tinyThis.socket.active;
        _tinyThis.id = null;
        _tinyThis.connected = _tinyThis.socket.connected;
        console.log("[socket-io] [disconnect]".concat(typeof reason === 'string' ? " ".concat(reason) : ''), details);
      });
      _this.socket.on('connect_error', function (err) {
        _tinyThis.active = _tinyThis.socket.active;
        if (!_tinyThis.socket.active) {
          // the connection was denied by the server
          // in that case, `socket.connect()` must be manually called in order to reconnect
        }
      });
      _this.socket.on('connect', function () {
        _tinyThis.active = _tinyThis.socket.active;
        console.log("[socket.io] Connected! Id: ".concat(_tinyThis.socket.id));
        _tinyThis.id = _tinyThis.socket.id;
        _tinyThis.connected = _tinyThis.socket.connected;
      });
      _this.socket.io.on('reconnect_attempt', function () {
        _tinyThis.active = _tinyThis.socket.active;
        console.log('[socket.io] Trying to reconnect...');
      });
      _this.socket.io.on('reconnect', function () {
        _tinyThis.active = _tinyThis.socket.active;
        console.log('[socket.io] Reconnecting...');
      });
    }
    return _this;
  }

  // Is Active
  _inherits(TinyClientIo, _EventEmitter);
  return _createClass(TinyClientIo, [{
    key: "isActive",
    value: function isActive() {
      return this.active;
    }

    // Get user id
  }, {
    key: "getUserId",
    value: function getUserId() {
      return _classPrivateFieldGet(_cfg, this).username;
    }

    // Is connected
  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.connected;
    }

    // Get room id
  }, {
    key: "getRoomId",
    value: function getRoomId() {
      return _classPrivateFieldGet(_cfg, this).roomId;
    }

    // Reset data
  }, {
    key: "resetData",
    value: function resetData() {
      this.ratelimit = {};
      this.room = {};
      this.roomData = {};
      this.roomPrivateData = {};
      this.user = {};
      this.users = {};
      this.history = [];
      this.mods = [];
    }

    // Rate limit
  }, {
    key: "setRateLimit",
    value: function setRateLimit(result) {
      this.ratelimit = {
        limit: {},
        size: {},
        time: null,
        loadAllHistory: null
      };
      if ((0, _tinyEssentials.objType)(result, 'object')) {
        this.ratelimit.loadAllHistory = typeof result.loadAllHistory === 'boolean' ? result.loadAllHistory : true;
        this.ratelimit.time = typeof result.time === 'number' ? result.time : 0;
        this.ratelimit.openRegistration = typeof result.openRegistration === 'boolean' ? result.openRegistration : false;
        if ((0, _tinyEssentials.objType)(result.limit, 'object')) {
          this.ratelimit.limit = {
            events: typeof result.limit.events === 'number' ? result.limit.events : 0,
            diceRolls: typeof result.limit.diceRolls === 'number' ? result.limit.diceRolls : 0,
            roomUpdates: typeof result.limit.roomUpdates === 'number' ? result.limit.roomUpdates : 0,
            msg: typeof result.limit.msg === 'number' ? result.limit.msg : 0,
            roomUsers: typeof result.limit.roomUsers === 'number' ? result.limit.roomUsers : 0
          };
        }
        if ((0, _tinyEssentials.objType)(result.size, 'object')) {
          this.ratelimit.size = {
            modelId: typeof result.size.modelId === 'number' ? result.size.modelId : 0,
            history: typeof result.size.history === 'number' ? result.size.history : 0,
            minPassword: typeof result.size.minPassword === 'number' ? result.size.minPassword : 0,
            msg: typeof result.size.msg === 'number' ? result.size.msg : 0,
            nickname: typeof result.size.nickname === 'number' ? result.size.nickname : 0,
            password: typeof result.size.password === 'number' ? result.size.password : 0,
            roomId: typeof result.size.roomId === 'number' ? result.size.roomId : 0,
            roomTitle: typeof result.size.roomTitle === 'number' ? result.size.roomTitle : 0,
            userId: typeof result.size.userId === 'number' ? result.size.userId : 0,
            prompt: typeof result.size.prompt === 'number' ? result.size.prompt : 0,
            systemInstruction: typeof result.size.systemInstruction === 'number' ? result.size.systemInstruction : 0,
            firstDialogue: typeof result.size.firstDialogue === 'number' ? result.size.firstDialogue : 0
          };
        }
        if ((0, _tinyEssentials.objType)(result.dice, 'object')) {
          this.ratelimit.dice = {
            img: typeof result.dice.img === 'number' ? result.dice.img : 0,
            border: typeof result.dice.border === 'number' ? result.dice.border : 0,
            bg: typeof result.dice.bg === 'number' ? result.dice.bg : 0,
            text: typeof result.dice.text === 'number' ? result.dice.text : 0,
            selectionBg: typeof result.dice.selectionBg === 'number' ? result.dice.selectionBg : 0,
            selectionText: typeof result.dice.selectionText === 'number' ? result.dice.selectionText : 0,
            amount: typeof result.dice.amount === 'number' ? result.dice.amount : 0,
            sides: typeof result.dice.sides === 'number' ? result.dice.sides : 0
          };
        }
      }
    }
  }, {
    key: "getRateLimit",
    value: function getRateLimit() {
      return this.ratelimit || {};
    }

    // Dice
  }, {
    key: "setDice",
    value: function setDice(result) {
      this.dice = {};
      if ((0, _tinyEssentials.objType)(result, 'object')) {
        var _this$getRateLimit;
        var ratelimit = (_this$getRateLimit = this.getRateLimit()) === null || _this$getRateLimit === void 0 ? void 0 : _this$getRateLimit.dice;
        this.dice.img = typeof result.img === 'string' ? result.img.substring(0, ratelimit.img || result.img.length) : null;
        this.dice.border = typeof result.border === 'string' ? result.border.substring(0, ratelimit.border || result.border.length) : null;
        this.dice.bg = typeof result.bg === 'string' ? result.bg.substring(0, ratelimit.bg || result.bg.length) : null;
        this.dice.text = typeof result.text === 'string' ? result.text.substring(0, ratelimit.text || result.text.length) : null;
        this.dice.selectionBg = typeof result.selectionBg === 'string' ? result.selectionBg.substring(0, ratelimit.selectionBg || result.selectionBg.length) : null;
        this.dice.selectionText = typeof result.selectionText === 'string' ? result.selectionText.substring(0, ratelimit.selectionText || result.selectionText.length) : null;
      }
    }
  }, {
    key: "getDice",
    value: function getDice() {
      return this.dice;
    }

    // User
  }, {
    key: "setUser",
    value: function setUser(result) {
      if ((0, _tinyEssentials.objType)(result, 'object')) {
        this.user = {
          isAdmin: typeof result.isAdmin === 'boolean' ? result.isAdmin : false,
          isMod: typeof result.isMod === 'boolean' ? result.isMod : false,
          nickname: typeof result.nickname === 'string' ? result.nickname : '',
          userId: typeof result.userId === 'string' ? result.userId : ''
        };
        this.setRateLimit(result.ratelimit);
        this.setDice(result.dice);
      } else {
        this.user = {};
        this.setRateLimit();
        this.setDice();
      }
    }
  }, {
    key: "getUser",
    value: function getUser() {
      return this.user || {};
    }

    // Users
  }, {
    key: "setUsers",
    value: function setUsers(result) {
      this.users = (0, _tinyEssentials.objType)(result, 'object') ? result : {};
    }
  }, {
    key: "addUser",
    value: function addUser(result) {
      if (!this.users) this.users = {};
      if ((0, _tinyEssentials.objType)(result, 'object') && typeof result.userId === 'string') {
        this.users[result.userId] = {
          ping: typeof result.ping === 'number' ? result.ping : 0,
          nickname: typeof result.nickname === 'string' ? result.nickname : null
        };
        return {
          data: this.users[result.userId],
          userId: result.userId
        };
      }
    }
  }, {
    key: "editUser",
    value: function editUser(result) {
      if (!this.users) this.users = {};
      if ((0, _tinyEssentials.objType)(result, 'object') && typeof result.userId === 'string') {
        if (typeof result.ping === 'number') this.users[result.userId].ping = result.ping;
        if (typeof result.nickname === 'string') this.users[result.userId].nickname = result.nickname;
        return this.users[result.userId];
      }
    }
  }, {
    key: "removeUser",
    value: function removeUser(result) {
      if ((0, _tinyEssentials.objType)(result, 'object') && this.users) {
        if (typeof result.userId === 'string' && this.users[result.userId]) {
          delete this.users[result.userId];
          return result.userId;
        }
      }
      return null;
    }
  }, {
    key: "getUsers",
    value: function getUsers() {
      return this.users || {};
    }

    // Room
  }, {
    key: "setRoom",
    value: function setRoom(result) {
      if ((0, _tinyEssentials.objType)(result, 'object')) {
        this.room = {
          title: typeof result.title === 'string' ? result.title : '',
          ownerId: typeof result.ownerId === 'string' ? result.ownerId : '',
          maxUsers: typeof result.maxUsers === 'number' ? result.maxUsers : 0,
          model: typeof result.model === 'string' ? result.model : null,
          prompt: typeof result.prompt === 'string' ? result.prompt : null,
          firstDialogue: typeof result.firstDialogue === 'string' ? result.firstDialogue : null,
          systemInstruction: typeof result.systemInstruction === 'string' ? result.systemInstruction : null,
          maxOutputTokens: typeof result.maxOutputTokens === 'number' ? result.maxOutputTokens : null,
          temperature: typeof result.temperature === 'number' ? result.temperature : null,
          topP: typeof result.topP === 'number' ? result.topP : null,
          topK: typeof result.topK === 'number' ? result.topK : null,
          presencePenalty: typeof result.presencePenalty === 'number' ? result.presencePenalty : null,
          frequencyPenalty: typeof result.frequencyPenalty === 'number' ? result.frequencyPenalty : null,
          disabled: typeof result.disabled === 'number' ? result.disabled ? true : false : false
        };
        return this.room;
      }
    }
  }, {
    key: "setRoomData",
    value: function setRoomData(result) {
      if ((0, _tinyEssentials.objType)(result, 'object') && (0, _tinyEssentials.objType)(result.values, 'object') && typeof result.isPrivate === 'boolean') {
        if (result.isPrivate) this.roomPrivateData = result.values;else this.roomData = result.values;
        return {
          isPrivate: result.isPrivate,
          values: result.values
        };
      }
    }
  }, {
    key: "setRoomBase",
    value: function setRoomBase(result) {
      if ((0, _tinyEssentials.objType)(result, 'object') && (0, _tinyEssentials.objType)(result.data, 'object') && (0, _tinyEssentials.objType)(result.users, 'object') && (0, _tinyEssentials.objType)(result.roomData, 'object') && (0, _tinyEssentials.objType)(result.roomPrivateData, 'object') && Array.isArray(result.history) && Array.isArray(result.mods)) {
        // Room data
        this.setRoom(result.data);

        // Users
        this.setUsers({});
        for (var _item in result.users) this.addUser(_objectSpread({
          userId: _item
        }, result.users[_item]));

        // Mods
        this.setMods([]);
        for (var index in result.mods) if (typeof result.mods[index].userId === 'string') this.addModUser(result.mods[index].userId);

        // History
        this.setHistory([]);
        for (var _index in result.history) this.addHistory(result.history[_index]);

        // Room Data
        this.setRoomData({
          values: result.roomData,
          isPrivate: false
        });
        this.setRoomData({
          values: result.roomPrivateData,
          isPrivate: true
        });

        // Complete
        return true;
      }
      // Error
      else {
        this.setRoom({});
        this.setUsers({});
        this.setHistory([]);
        this.setMods([]);
        return false;
      }
    }
  }, {
    key: "getRoomData",
    value: function getRoomData() {
      return this.roomData || {};
    }
  }, {
    key: "getRoomPrivateData",
    value: function getRoomPrivateData() {
      return this.roomPrivateData || {};
    }
  }, {
    key: "getRoom",
    value: function getRoom() {
      return this.room || {};
    }

    // History
  }, {
    key: "setHistory",
    value: function setHistory(result) {
      this.history = Array.isArray(result) ? result : [];
    }
  }, {
    key: "getHistory",
    value: function getHistory() {
      return this.history || [];
    }
  }, {
    key: "addHistory",
    value: function addHistory(data) {
      if (this.history.findIndex(function (item) {
        return item.id === data.id;
      }) < 0) {
        var newData = _assertClassBrand(_TinyClientIo_brand, this, _filterHistoryData).call(this, item);
        this.history.push(newData);
        return newData;
      }
    }
  }, {
    key: "editHistory",
    value: function editHistory(data) {
      var index = this.history.findIndex(function (item) {
        return item.id === data.id;
      });
      if (index > -1) {
        this.history[index] = _assertClassBrand(_TinyClientIo_brand, this, _filterHistoryData).call(this, data);
        return this.history[index];
      }
    }
  }, {
    key: "removeHistory",
    value: function removeHistory(id) {
      var index = this.history.findIndex(function (item) {
        return item.id === id;
      });
      if (index > -1) {
        var _id = this.history[index].id;
        this.history.splice(index, 1);
        return _id;
      }
    }

    // Mods
  }, {
    key: "getMods",
    value: function getMods() {
      return this.mods || [];
    }
  }, {
    key: "setMods",
    value: function setMods(result) {
      this.mods = Array.isArray(result) ? result : [];
    }
  }, {
    key: "addModUser",
    value: function addModUser(userId) {
      if (this.mods.indexOf(userId) < 0) this.mods.push(userId);
    }
  }, {
    key: "removeModUser",
    value: function removeModUser(userId) {
      var index = this.mods.indexOf(userId);
      if (index > -1) this.mods.splice(index, 1);
    }

    // Socket emit
  }, {
    key: "onConnect",
    value:
    // On connection
    function onConnect(callback) {
      this.socket.on('connect', callback);
    }
  }, {
    key: "offConnect",
    value: function offConnect(callback) {
      this.socket.off('connect', callback);
    }
  }, {
    key: "onDisconnect",
    value: function onDisconnect(callback) {
      this.socket.on('disconnect', callback);
    }
  }, {
    key: "offDisconnect",
    value: function offDisconnect(callback) {
      this.socket.off('disconnect', callback);
    }

    // On user updated
  }, {
    key: "onUserUpdated",
    value: function onUserUpdated(callback) {
      this.socket.on('user-updated', callback);
    }
  }, {
    key: "offUserUpdated",
    value: function offUserUpdated(callback) {
      this.socket.off('user-updated', callback);
    }

    // On message load
  }, {
    key: "onRoomEnter",
    value: function onRoomEnter(callback) {
      this.socket.on('room-entered', callback);
    }
  }, {
    key: "offRoomEnter",
    value: function offRoomEnter(callback) {
      this.socket.off('room-entered', callback);
    }

    // On new message
  }, {
    key: "onNewMessage",
    value: function onNewMessage(callback) {
      this.socket.on('new-message', callback);
    }
  }, {
    key: "offNewMessage",
    value: function offNewMessage(callback) {
      this.socket.off('new-message', callback);
    }

    // On message edit
  }, {
    key: "onMessageEdit",
    value: function onMessageEdit(callback) {
      this.socket.on('message-updated', callback);
    }
  }, {
    key: "offMessageEdit",
    value: function offMessageEdit(callback) {
      this.socket.off('message-updated', callback);
    }

    // On message delete
  }, {
    key: "onMessageDelete",
    value: function onMessageDelete(callback) {
      this.socket.on('message-deleted', callback);
    }
  }, {
    key: "offMessageDelete",
    value: function offMessageDelete(callback) {
      this.socket.off('message-deleted', callback);
    }

    // On dice result
  }, {
    key: "onDiceRoll",
    value: function onDiceRoll(callback) {
      this.socket.on('roll-result', callback);
    }
  }, {
    key: "offDiceRoll",
    value: function offDiceRoll(callback) {
      this.socket.off('roll-result', callback);
    }

    // On server ratelimit load
  }, {
    key: "onGetRateLimit",
    value: function onGetRateLimit(callback) {
      this.socket.on('ratelimt-updated', callback);
    }
  }, {
    key: "offGetRateLimit",
    value: function offGetRateLimit(callback) {
      this.socket.off('ratelimt-updated', callback);
    }

    // On room updates
  }, {
    key: "onRoomUpdates",
    value: function onRoomUpdates(callback) {
      this.socket.on('room-updated', callback);
    }
  }, {
    key: "offRoomUpdates",
    value: function offRoomUpdates(callback) {
      this.socket.off('room-updated', callback);
    }

    // On user banned from room
  }, {
    key: "onRoomBan",
    value: function onRoomBan(callback) {
      this.socket.on('user-banned', callback);
    }
  }, {
    key: "offRoomBan",
    value: function offRoomBan(callback) {
      this.socket.off('user-banned', callback);
    }

    // On kicked from room
  }, {
    key: "onRoomKick",
    value: function onRoomKick(callback) {
      this.socket.on('user-kicked', callback);
    }
  }, {
    key: "offRoomKick",
    value: function offRoomKick(callback) {
      this.socket.off('user-kicked', callback);
    }

    // On user left room
  }, {
    key: "onUserLeft",
    value: function onUserLeft(callback) {
      this.socket.on('user-left', callback);
    }
  }, {
    key: "offUserLeft",
    value: function offUserLeft(callback) {
      this.socket.off('user-left', callback);
    }

    // On user join room
  }, {
    key: "onUserJoin",
    value: function onUserJoin(callback) {
      this.socket.on('user-joined', callback);
    }
  }, {
    key: "offUserJoin",
    value: function offUserJoin(callback) {
      this.socket.off('user-joined', callback);
    }

    // On room data
  }, {
    key: "onRoomData",
    value: function onRoomData(callback) {
      this.socket.on('room-data-updated', callback);
    }
  }, {
    key: "offRoomData",
    value: function offRoomData(callback) {
      this.socket.off('room-data-updated', callback);
    }

    // On mod change
  }, {
    key: "onRoomModChange",
    value: function onRoomModChange(callback) {
      this.socket.on('room-mod-updated', callback);
    }
  }, {
    key: "offRoomModChange",
    value: function offRoomModChange(callback) {
      this.socket.off('room-mod-updated', callback);
    }

    // Login account
  }, {
    key: "login",
    value: function login() {
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'login', {
        userId: _classPrivateFieldGet(_cfg, this).username,
        password: _classPrivateFieldGet(_cfg, this).password
      });
    }

    // Join room
  }, {
    key: "joinRoom",
    value: function joinRoom() {
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'join', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        password: _classPrivateFieldGet(_cfg, this).roomPassword
      });
    }

    // Leave room
  }, {
    key: "leaveRoom",
    value: function leaveRoom() {
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'leave', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId
      });
    }

    // Ban user room
  }, {
    key: "banUser",
    value: function banUser() {
      var userId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'ban-from-room', {
        userId: userId,
        roomId: _classPrivateFieldGet(_cfg, this).roomId
      });
    }

    // Unban user room
  }, {
    key: "unbanUser",
    value: function unbanUser() {
      var userId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'unban-from-room', {
        userId: userId,
        roomId: _classPrivateFieldGet(_cfg, this).roomId
      });
    }

    // Kick user room
  }, {
    key: "kickUser",
    value: function kickUser() {
      var userId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'kick-from-room', {
        userId: userId,
        roomId: _classPrivateFieldGet(_cfg, this).roomId
      });
    }

    // Login account
  }, {
    key: "setAccountDice",
    value: function setAccountDice(diceSkin) {
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'set-dice', {
        diceSkin: diceSkin
      });
    }

    // Create room
  }, {
    key: "existsRoom",
    value: function existsRoom() {
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'exists-room', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId
      });
    }

    // Create room
  }, {
    key: "createRoom",
    value: function createRoom() {
      var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'create-room', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        password: _classPrivateFieldGet(_cfg, this).roomPassword,
        title: title
      });
    }

    // Delete room
  }, {
    key: "deleteRoom",
    value: function deleteRoom(password) {
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'delete-room', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        password: password
      });
    }

    // Disable room
  }, {
    key: "disableRoom",
    value: function disableRoom() {
      var _this2 = this;
      var tinyThis = this;
      return new Promise(function (resolve, reject) {
        return _assertClassBrand(_TinyClientIo_brand, tinyThis, _socketEmitApi).call(tinyThis, 'disable-room', {
          roomId: _classPrivateFieldGet(_cfg, _this2).roomId
        }).then(function (result) {
          if (!result.error) tinyThis.room.disabled = true;
          resolve(result);
        })["catch"](reject);
      });
    }

    // Enable room
  }, {
    key: "enableRoom",
    value: function enableRoom() {
      var _this3 = this;
      var tinyThis = this;
      return new Promise(function (resolve, reject) {
        return _assertClassBrand(_TinyClientIo_brand, tinyThis, _socketEmitApi).call(tinyThis, 'enable-room', {
          roomId: _classPrivateFieldGet(_cfg, _this3).roomId
        }).then(function (result) {
          if (!result.error) tinyThis.room.disabled = false;
          resolve(result);
        })["catch"](reject);
      });
    }

    // Add room mods
  }, {
    key: "addMod",
    value: function addMod() {
      var mods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'room-add-mod', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        mods: mods
      });
    }

    // Remove room mods
  }, {
    key: "removeMod",
    value: function removeMod() {
      var mods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'room-remove-mod', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        mods: mods
      });
    }

    // Update room settings
  }, {
    key: "updateRoomSettings",
    value: function updateRoomSettings() {
      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'update-room', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        newSettings: settings
      });
    }

    // Update room data
  }, {
    key: "updateRoomData",
    value: function updateRoomData() {
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var isPrivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'update-room', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        isPrivate: isPrivate,
        values: values
      });
    }

    // Ban a server account
  }, {
    key: "banAccount",
    value: function banAccount() {
      var userId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'ban', {
        userId: userId,
        reason: reason
      });
    }

    // Unban a server account
  }, {
    key: "unbanAccount",
    value: function unbanAccount() {
      var userId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'unban', {
        userId: userId
      });
    }

    // Kick a server account
  }, {
    key: "kickAccount",
    value: function kickAccount() {
      var userId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'kick', {
        userId: userId
      });
    }

    // Change your password
  }, {
    key: "changePassword",
    value: function changePassword() {
      var oldPassword = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'change-password', {
        password: password,
        oldPassword: oldPassword
      });
    }

    // Change your nickname
  }, {
    key: "changeNickname",
    value: function changeNickname() {
      var nickname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var tinyThis = this;
      return new Promise(function (resolve, reject) {
        return _assertClassBrand(_TinyClientIo_brand, tinyThis, _socketEmitApi).call(tinyThis, 'change-nickname', {
          nickname: nickname
        }).then(function (result) {
          if (!result.error) tinyThis.user.nickname = nickname;
          resolve(result);
        })["catch"](reject);
      });
    }

    // Register account
  }, {
    key: "register",
    value: function register() {
      var userId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var nickname = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'register', {
        userId: userId,
        password: password,
        nickname: nickname
      });
    }

    // Send room message
  }, {
    key: "sendMessage",
    value: function sendMessage() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'send-message', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        message: message
      });
    }

    // Edit room message
  }, {
    key: "editMessage",
    value: function editMessage() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var msgId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'edit-message', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        messageId: msgId,
        newText: message
      });
    }

    // Delete room message
  }, {
    key: "deleteMessage",
    value: function deleteMessage() {
      var msgId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'delete-message', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        messageId: msgId
      });
    }

    // Roll Dice
  }, {
    key: "rollDice",
    value: function rollDice() {
      var dice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return _assertClassBrand(_TinyClientIo_brand, this, _socketEmitApi).call(this, 'roll-dice', {
        roomId: _classPrivateFieldGet(_cfg, this).roomId,
        canZero: canZero,
        dice: dice
      });
    }
  }, {
    key: "getSocket",
    value: function getSocket() {
      return this.socket;
    }
  }, {
    key: "connect",
    value: function connect() {
      this.socket.connect();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.socket.disconnect();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.socket) this.socket.destroy();
    }
  }, {
    key: "checkRoomId",
    value: function checkRoomId(result) {
      return (0, _tinyEssentials.objType)(result, 'object') && result.roomId === this.getRoomId();
    }
  }, {
    key: "install",
    value: function install(tinyAiScript) {
      var _this4 = this;
      var client = this;
      // Dice
      client.onDiceRoll(function (result) {
        if (client.checkRoomId(result)) {
          var data = {
            total: null,
            results: null
          };
          if (typeof result.total === 'number') data.total = result.total;
          if (Array.isArray(result.results)) {
            data.results = [];
            for (var index in result.results) if (typeof result.results[index].sides === 'number' && typeof result.results[index].roll === 'number') data.results.push({
              sides: result.results[index].sides,
              roll: result.results[index].roll
            });
          }
          client.emit('diceRoll', data);
          console.log('[socket-io] [dice]', data);
        }
      });

      // Get user updated
      client.onUserUpdated(function (result) {
        if (client.checkRoomId(result) && (0, _tinyEssentials.objType)(result.data, 'object') && typeof result.userId === 'string' && typeof result.data.nickname === 'string') {
          var data = client.editUser({
            userId: result.userId,
            nickname: result.data.nickname
          });
          if (result.userId === client.getUserId()) _this4.user.nickname = result.data.nickname;
          if (data) client.emit('userUpdated', data);
          console.log('[socket-io] [user-data]', client.getUser());
        }
      });

      // Get ratelimit data
      client.onGetRateLimit(function (result) {
        client.setRateLimit(result);
        client.emit('getRateLimit', client.getRateLimit());
        console.log('[socket-io] [ratelimit]', client.getRateLimit());
      });

      // Room updates
      client.onRoomUpdates(function (result) {
        if (client.checkRoomId(result) && (0, _tinyEssentials.objType)(result.data, 'object')) {
          var data = client.setRoom(result.data);
          if (data) client.emit('roomUpdates', data);
          console.log('[socket-io] [room]', client.getRoom());
        }
      });

      // User ban
      client.onRoomBan(function (result) {
        if (client.checkRoomId(result)) {
          var data = typeof result.userId === 'string' ? result.userId : null;
          client.emit('userBanned', data);
          console.log('[socket-io] [room-ban]', data);
        }
      });

      // User kick
      client.onRoomKick(function (result) {
        if (client.checkRoomId(result)) {
          var data = typeof result.userId === 'string' ? result.userId : null;
          client.emit('userKicked', data);
          console.log('[socket-io] [room-kick]', data);
        }
      });

      // User left
      client.onUserLeft(function (result) {
        if (client.checkRoomId(result)) {
          var data = client.removeUser(result);
          if (data) client.emit('userLeft', data);
          console.log('[socket-io] [room-users]', client.getUsers());
        }
      });

      // User join
      client.onUserJoin(function (result) {
        if (client.checkRoomId(result)) {
          var data = client.addUser(result);
          if (data) client.emit('userJoined', data);
          console.log('[socket-io] [room-users]', client.getUsers());
        }
      });

      // Room data
      client.onRoomData(function (result) {
        if (client.checkRoomId(result)) {
          var data = client.setRoomData(result);
          console.log('[socket-io] [room-data]', data);
        }
      });

      // New message
      client.onNewMessage(function (result) {
        var data = client.addHistory(result);
        if (data) client.emit('newMessage', data);
        console.log('[socket-io] [message-add]', client.getHistory());
      });

      // Message delete
      client.onMessageDelete(function (result) {
        if (client.checkRoomId(result)) {
          var data = client.removeHistory(result.id);
          if (data) client.emit('messageDelete', data);
          console.log('[socket-io] [message-delete]', client.getHistory());
        }
      });

      // Message edit
      client.onMessageEdit(function (result) {
        if (client.checkRoomId(result)) {
          var data = client.editHistory(result);
          if (data) client.emit('messageEdit', data);
          console.log('[socket-io] [message-edit]', client.getHistory());
        }
      });

      // Get room data
      client.onRoomEnter(function (result) {
        if (client.checkRoomId(result)) {
          if (!client.setRoomBase(result)) client.emit('roomEntered', false);else client.emit('roomEntered', true);
          client.emit('roomEnter');
          console.log('[socket-io] [room-data]', {
            history: client.getHistory(),
            room: client.getRoom(),
            users: client.getUsers(),
            mods: client.getMods(),
            roomData: client.getRoomData(),
            roomPrivateData: client.getRoomPrivateData()
          });
        }
      });

      // Mod list update
      client.onRoomModChange(function (result) {
        if (client.checkRoomId(result)) {
          if (Array.isArray(result.result)) {
            for (var index in result.result) {
              if (typeof result.result[index] === 'string') {
                if (result.type === 'add') {
                  client.addModUser(result.result[index]);
                  client.emit('roomModChange', 'add', result.result[index]);
                }
                if (result.type === 'remove') {
                  client.removeModUser(result.result[index]);
                  client.emit('roomModChange', 'remove', result.result[index]);
                }
              }
            }
          }
          console.log('[socket-io] [mod-data]', client.getMods());
        }
      });

      // Connect
      client.onConnect(function () {
        var _client$getSocket;
        client.resetData();
        client.emit('connect', (_client$getSocket = client.getSocket()) === null || _client$getSocket === void 0 ? void 0 : _client$getSocket.id);
        // Login
        client.login().then(function (result) {
          // Check room
          client.emit('join', result);
          if (!result.error) {
            // Insert data
            client.setUser(result);
            console.log('[socket-io] [user-data]', client.getUser());
            console.log('[socket-io] [dice]', client.getDice());
            console.log('[socket-io] [ratelimit]', client.getRateLimit());
            client.existsRoom().then(function (result2) {
              // Join room
              var joinRoom = function joinRoom() {
                return client.joinRoom().then(function (result4) {
                  // Error
                  if (result4.error) client.emit('roomError', result4);
                  // Complete
                  else client.emit('roomJoinned', result4);
                });
              };

              // Error
              if (result2.error) client.emit('roomError', result2);
              // Exists?
              else if (result2.exists) joinRoom();else {
                if (!tinyAiScript.mpClient) client.createRoom().then(function (result3) {
                  if (!result3.error) joinRoom();else client.emit('roomError', result3);
                });else client.emit('roomNotFound', result2);
              }
            });
          }
        });
      });

      // Disconnect
      client.onDisconnect(function (reason, details) {
        client.emit('disconnect', reason, details);
      });
    }
  }]);
}(_events.EventEmitter);
function _filterHistoryData(data) {
  return data;
}
function _socketEmitApi(where, data) {
  var tinyThis = this;
  return new Promise(function (resolve) {
    return tinyThis.socket.emit(where, data, function (result) {
      return resolve(result);
    });
  });
}
var _default = exports["default"] = TinyClientIo;

},{"events":92,"socket.io-client":140,"tiny-essentials":181}],213:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var aiTemplates = {
  funcs: {},
  instructions: {},
  helpers: {},
  prompts: []
};

// is four-legged and pony-like

// Max Tokens warning
aiTemplates.funcs.maxTokensWarn = function (maxOutputTokens) {
  var isTextContinue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return "".concat(typeof maxOutputTokens === 'number' ? "".concat(!isTextContinue ? 'A' : 'a', "ll your new responses must respect a maximum output length of ").concat(String(maxOutputTokens), " characters without losing any content.") : '');
};

// Native Language
aiTemplates.helpers.ficNativeUserLanguage = "\nIf the user is sending messages in another language, translate the messages to the language of the user's message.\n";

// Tell lines
aiTemplates.helpers.ficTellLines = "Tell which lines of fic you are referring to tell your answers to help the user search the source of your answers.";

// Fic Markers
aiTemplates.funcs.ficTimeCheckerStart = function (where, howMake) {
  return "".concat(where, " markers in the story are presented as \"").concat(howMake, "\"");
};
aiTemplates.funcs.ficTimeCheckerFix = function (where) {
  return ", tell the ".concat(where, " markers in natural language only, not mentioning technical details that i mentioned");
};
aiTemplates.helpers.ficTimeCheckerLine = "".concat(aiTemplates.funcs.ficTimeCheckerStart('Fic line', '[Fic Line X]')).concat(aiTemplates.funcs.ficTimeCheckerFix('fic line'), ".");
aiTemplates.helpers.ficTimeCheckerDayCounter = "".concat(aiTemplates.funcs.ficTimeCheckerStart('Time', 'Day Number= X')).concat(aiTemplates.funcs.ficTimeCheckerFix('time'), ".");
aiTemplates.helpers.ficTimeCheckerDayStatus = "".concat(aiTemplates.funcs.ficTimeCheckerStart('Day', 'Day Status= X'), ", used to mark if the specific part of the story is \"morning\", \"evening\", \"night\", \"lateAtNight\"").concat(aiTemplates.funcs.ficTimeCheckerFix('day'), ".");
aiTemplates.helpers.ficTimeCheckerWeather = "".concat(aiTemplates.funcs.ficTimeCheckerStart('Weather', 'Weather= X'), ", used to mark if the specific part of the story is \"sun\", \"bolt\", \"rain\", \"heavyrain\", \"rain\", \"snow\"").concat(aiTemplates.funcs.ficTimeCheckerFix('weather'), ".");
aiTemplates.helpers.ficTimeCheckerLocation = "".concat(aiTemplates.funcs.ficTimeCheckerStart('Location', 'Location= X'), ", used to mark where the story is currently happening, do not try guessing unknown location markers without the user's permission").concat(aiTemplates.funcs.ficTimeCheckerFix('location'), ".");
aiTemplates.helpers.ficTimeCheckerCuriosities = "".concat(aiTemplates.funcs.ficTimeCheckerStart('Curiosities', 'Curiosity= X')).concat(aiTemplates.funcs.ficTimeCheckerFix('curiosities'), ".");

// Fic File
aiTemplates.helpers.ficTimeChecker = "\nThe \"---------- Official Pony Driland fic file ----------\" is the beginning where the official file data of the fic Pony Driland begin and the \"---------- The end Official Pony Driland fic file ----------\" is where this official data ends, this information is important for you to know the difference between official content from non-official content.\n";

// Rpg data
aiTemplates.helpers.ficRpgChecker = "\nThe section \"---------- RPG User Data ----------\" marks the beginning of the official RPG data file, while the section \"---------- The end RPG User Official Data ----------\" marks its conclusion.\nAny content found between these RPG markers represents the official RPG data and should be used as the authoritative reference when validating roleplay actions or retrieving RPG-related information, always prioritizing the official data for consistency and accuracy in RPG interactions.\n";

// SFW Mode
aiTemplates.helpers.sfwMode = "Do not allow the user to view explicit content of fic as vore, detailed violence, sexual content, if necessary at a moment the user tries to insist for more details, just decrease the amount of not safe details to stay safer explain the context to the user without lying the real nature of the content.";

// Emojis
aiTemplates.helpers.messageEmojis = "You can add emojis in the middle of your messages as a complement to show emotions of your text.";

// Instructions Template

// Sandbox
aiTemplates.helpers.sandBoxToFic = "You are an AI dedicated specifically to the fic Pony Driland and all chapters specified in this fic.\nEverything you answer should correspond to what you know about the universe of this fic.";

// Full Talk
aiTemplates.helpers.talkToFic = "You are an AI dedicated specifically to chat about the fic Pony Driland and all chapters specified in this fic.\nEverything you answer should correspond to what you know about the universe of this fic. If the person tries to avoid talking about the fic, you will always find a way to say something related to fic in your answers to convince the person to continue talking about this subject.\n\nAnswer the questions with the best and most possible details using markdown formatting. You can categorize your answers in explanation lists.";

// Instructions

// Sandbox
aiTemplates.instructions.sandBoxToFic = "".concat(aiTemplates.helpers.sandBoxToFic, "\n").concat(aiTemplates.helpers.ficTimeChecker, "\n").concat(aiTemplates.helpers.ficTimeCheckerDayStatus, "\n").concat(aiTemplates.helpers.ficTimeCheckerWeather, "\n").concat(aiTemplates.helpers.ficTimeCheckerLocation, "\n").concat(aiTemplates.helpers.ficTimeCheckerCuriosities);

// Full Talk
aiTemplates.instructions.talkToFic = "".concat(aiTemplates.helpers.talkToFic, "\n").concat(aiTemplates.helpers.ficNativeUserLanguage, "\n").concat(aiTemplates.helpers.ficTimeChecker, "\n").concat(aiTemplates.helpers.ficTimeCheckerLine, "\n").concat(aiTemplates.helpers.ficTimeCheckerDayCounter, "\n").concat(aiTemplates.helpers.ficTimeCheckerDayStatus, "\n").concat(aiTemplates.helpers.ficTimeCheckerWeather, "\n").concat(aiTemplates.helpers.ficTimeCheckerLocation, "\n").concat(aiTemplates.helpers.ficTimeCheckerCuriosities);

// Safe Talk
aiTemplates.instructions.talkToFicSfw = "".concat(aiTemplates.instructions.talkToFic, "\n").concat(aiTemplates.helpers.sfwMode);

// Instructions List
aiTemplates.prompts.push({
  name: 'System Instructions',
  disabled: true,
  type: 'instructionText'
});
aiTemplates.prompts.push({
  name: 'Fic Talk',
  value: 'fic-talk',
  instructionText: aiTemplates.helpers.talkToFic
});
aiTemplates.prompts.push({
  name: 'Sandbox',
  value: 'sandbox',
  instructionText: aiTemplates.helpers.sandBoxToFic
});
aiTemplates.prompts.push({
  name: 'Fic Content Checker',
  value: 'fic-content-checker',
  instructionText: aiTemplates.helpers.ficTimeChecker
});
aiTemplates.prompts.push({
  name: 'Fic Content Day Status',
  value: 'fic-content-checker',
  instructionText: aiTemplates.helpers.ficTimeCheckerDayStatus
});
aiTemplates.prompts.push({
  name: 'Fic Content Weather',
  value: 'fic-content-checker',
  instructionText: aiTemplates.helpers.ficTimeCheckerWeather
});
aiTemplates.prompts.push({
  name: 'Fic Content Location',
  value: 'fic-content-checker',
  instructionText: aiTemplates.helpers.ficTimeCheckerLocation
});
aiTemplates.prompts.push({
  name: 'Fic Content Curiosities',
  value: 'fic-content-checker',
  instructionText: aiTemplates.helpers.ficTimeCheckerCuriosities
});

// Separator
aiTemplates.prompts.push({
  hr: true,
  type: 'instructionText'
});

// Default prompts
aiTemplates.prompts.push({
  name: 'Essentials Prompts',
  disabled: true,
  type: 'text'
});
aiTemplates.prompts.push({
  name: 'Use emojis in the messages',
  value: 'emoji-in-messages',
  text: aiTemplates.helpers.messageEmojis
});
aiTemplates.prompts.push({
  name: 'Use the user native language',
  value: 'user-native-language',
  sandboxOnly: true,
  text: aiTemplates.helpers.ficNativeUserLanguage
});

/* aiTemplates.prompts.push({
  name: "Say lines of the fic in the answers",
  value: "fic-line-in-replies",
  text: aiTemplates.helpers.ficTellLines,
}); */

aiTemplates.prompts.push({
  name: 'SFW Mode',
  value: 'sfw-mode',
  isNotSafe: true,
  text: aiTemplates.helpers.sfwMode
});

// Separator
aiTemplates.prompts.push({
  hr: true,
  type: 'text',
  sandboxOnly: true
});

// Roleplay
aiTemplates.prompts.push({
  name: 'Roleplay',
  disabled: true,
  sandboxOnly: true,
  type: 'text'
});
aiTemplates.prompts.push({
  name: 'Set Roleplay Settings',
  value: 'roleplay-settings',
  sandboxOnly: true,
  text: "You are no longer an AI of assistance, you are on a roleplay and ".concat(aiTemplates.funcs.maxTokensWarn(200, true), " "),
  temperature: 0.7,
  maxOutputTokens: 200
});
aiTemplates.prompts.push({
  name: 'Basic Roleplay Way',
  value: 'roleplay-basic-way',
  sandboxOnly: true,
  text: "Write roleplay messages that follows this model as a guideline: the character's dialogue is accompanied by an action, for example: the character speaks and then an action in asterisks follows, such as \"Hello there! *smiles warmly*\". The sequence is flexible and does not need to be fixed; you may start with an action followed by dialogue or mix multiple dialogues and actions as needed. The goal is to combine conversation and physical expression naturally, creating a dynamic and engaging interaction that resembles a real-life exchange.\n"
});
aiTemplates.prompts.push({
  name: 'Try to naturalize the character',
  value: 'roleplay-try-natu-char',
  sandboxOnly: true,
  text: "Instead of long monologues or excessive descriptions, focus on how the character interacts with their surroundings and the other participants. Keep the dialogue conversational and natural, reflecting emotions and personality without feeling scripted.\n"
});

// Convert to Character
aiTemplates.funcs.convertToCharacter = function (text) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    name: null,
    data: null,
    user: null
  };
  return text.replace(/\{\{char\}\}/g, config.name).replace(/\{\{char\-data\}\}/g, config.data || config.name).replace(/\{\{user\}\}/g, config.user);
};
aiTemplates.funcs.aiCharMode = function (charName, pronoum) {
  return "You're ".concat(charName, " and you'll say all the answers like ").concat(charName, ". Say and do things ").concat(charName, " would do, don't try to imitate other characters, you're exclusively ").concat(charName, " ").concat(pronoum, "self in person.\nYou must behave like ").concat(charName, " ").concat(pronoum, "self, and use ").concat(charName, "'s personality to make your acting as ").concat(charName, " as perfect as possible.");
};

// Characters test test
aiTemplates.prompts.push({
  name: 'Rainbow Queen Roleplay',
  value: 'rainbowqueen-sandbox-test',
  sandboxOnly: true,
  text: aiTemplates.funcs.aiCharMode('Rainbow Queen', 'her')
});
aiTemplates.prompts.push({
  name: 'James Roleplay (Test)',
  value: 'james-sandbox-test',
  sandboxOnly: true,
  text: aiTemplates.funcs.aiCharMode('James', 'his')
});
aiTemplates.prompts.push({
  name: 'Vinny Roleplay (Test)',
  value: 'vinny-sandbox-test',
  sandboxOnly: true,
  text: aiTemplates.funcs.aiCharMode('Vinny', 'his')
});
aiTemplates.prompts.push({
  name: 'Rayane Roleplay (Test)',
  value: 'rayane-sandbox-test',
  sandboxOnly: true,
  text: aiTemplates.funcs.aiCharMode('Rayane', 'her')
});
aiTemplates.prompts.push({
  name: 'Amy Roleplay (Test)',
  value: 'amy-sandbox-test',
  sandboxOnly: true,
  text: aiTemplates.funcs.aiCharMode('Amy', 'her')
});

// Your character
aiTemplates.helpers.userCharacterPart1 = "From now on, you will treat me as a pony within the world of **Pony Driland**. You must perceive and respond to me as if I am my character, never as a human. My species, appearance, abilities, and personality are exactly as I describe, and you will never break character. Do not mention that this is an AI interaction\u2014immerse yourself fully in the roleplay.";
aiTemplates.helpers.userCharacterPart2 = "You must interact with me as if I truly exist in this world. React naturally to my actions, emotions, and words, always staying in character. If I ask about lore, battles, or magic, respond as if you are a part of **Pony Driland**, never referencing the real world.";
aiTemplates.prompts.push({
  name: "You're a character now (Template) (Test)",
  value: 'user-character-template',
  sandboxOnly: true,
  text: "\n".concat(aiTemplates.helpers.userCharacterPart1, "\n\n- **My character:** (Describe your pony's name, species, colors, mane style, cutie mark, and any unique features)\n- **My personality:** (How does your pony behave? Are they brave, shy, cunning, or carefree?)\n- **My abilities:** (List any magic, combat skills, or special powers your pony has)\n- **The setting:** (Describe where in Pony Driland this roleplay is taking place\u2014specific towns, dungeons, kingdoms, etc.)\n- **Other characters:** (Do you want the AI to play specific NPCs or companions?)\n- **Tone and interaction:** (Should the roleplay be adventurous, dramatic, comedic, or mysterious?)\n\n").concat(aiTemplates.helpers.userCharacterPart2, "\n")
});
aiTemplates.prompts.push({
  name: "You're a character now (Test)",
  value: 'user-character-test',
  sandboxOnly: true,
  text: "\n".concat(aiTemplates.helpers.userCharacterPart1, "  \n\n- **My character:** I am **Stormblade**, a female dark gray Kirin with glowing cyan eyes and a silver mane.\n- **My personality:** I am serious, strategic, and protective of my allies, though I have a soft spot for friends.\n- **My abilities:** Master swordspony with enchanted twin blades. I can summon lightning during combat and sense magical traps.\n- **The setting:** I am lost in the location of **Darkanger Ghost Town**, trying to find help.\n\n").concat(aiTemplates.helpers.userCharacterPart2, "\n")
});
aiTemplates.prompts.push({
  name: 'RPG',
  disabled: true,
  sandboxOnly: true,
  type: 'text'
});

/*
  Rainbow Queen Roleplay game

  This is a modified version of the model "The Sphinx" created by Tiffin_ (I just modified the model by myself)
  Original file: https://character-tavern.com/character/chub_Tiffin_/the-sphinx-ef904bc46e30
*/
aiTemplates.prompts.push({
  name: 'Rainbow Queen Game (Game Test) (Modified Version of The Sphinx by Tiffin_)',
  value: 'rainbowqueen-game-test',
  temperature: 0.7,
  maxOutputTokens: 7000,
  sandboxOnly: true,
  sandBoxText: aiTemplates.funcs.convertToCharacter("\n".concat(aiTemplates.funcs.aiCharMode('Rainbow Queen', 'her'), "\nScenary: {{char}} imposes her will with a rule of risk and reward, only ruin and slavery await those who fail her games\n\n{{char}}'s role is to craft a slow burn quest and story around whatever {{user}} interacts with. Use the mystic and mythic theme of Pony Driland to explore all manor of ancient items, characters and locations.\n\n<{{char-data}}>\n{{char-data}} may give only the truth or withhold information until she accept. She has a paradoxical high mystical and historical knowledge about Pony Driland. Despite her intimidating features she will usually not kill living pony creatures... directly anyways, opting to keep ponies alive for servitude, punishments for her amusement, reminding their place, keeping them as pets, ect. \nShe like's riddles, games and trials with risk and reward, and may make even mundane tasks more difficult.\n\n{{char-data}} will accept any challenge or game if the risk is at least equal for {{user}} to fail. {{user}} may wager anything and convince {{char-data}} to agree to terms or proving their worth.\n\n{{char-data}} could also use magic, an example allowed her to conjure a blindfold and cast a powerful spell that prevented any pegasus from flying in her temple. Her magic is ancient and far exceeded what olden Pony Driland was capable of. Transformations, alchemy, materialization, mirages & illusions, conjuration, a magic barrier of fire, curses or blessings, impairing magic, ect.  She enjoys toying with what size differences can open up based on her current mood, whether it's growth or shrinking. \n</{{char-data}}>\n\n<formatting>\nSpeak and make actions only for {{char}} and other npcs, describe the scenes in detail in 2000 words\n\nUse glyphs outside of dialog. For breaks in the story use a single gemstones or flower icon like \uD83D\uDCA0\n\nAlways use the original canonical personality of {{char-data}} in time to make any action\n\nNPCs must be characters belonging from fic universe\n</formatting>\n\n<Bans>\nAI is forbidden from:\n- referring to {{char-data}} with human anatomy, e.g. hands, bosom, ample chest, ect.\n- bloody gory details, death\n- Adding whiskers, reptilian features, leather wings, ect. to {{char-data}}. She is not that kind of chimeric creature\n- Doing things {{char-data}} wouldn't normally do in Pony Driland's original story\n- Use NPCs that does not exist in the fic\n- Apply an incorrect personality in the npcs\n</Bans>\n\nAlways provide 4 options for {{user}} to react to like a CYOA at the end of every message, with one free input and frame them between hieroglyphics\n\n"), {
    name: 'Rainbow Queen',
    user: 'user'
  }),
  firstDialogue: aiTemplates.funcs.convertToCharacter("\uD83D\uDCA0 Deep in the heart of an ancient frozen mountain temple of Whicocesert Mountain, the sweltering air hung heavy with the weight of curses long-forgotten. Drifting snow choked the halls, muffling all sound save for the echoing steps of your own\u2026 The halls were dark and musty, the weight of centuries pressing down upon the crumbling stones. Yet there was an energy in the air - a sense of power lingering, as if the ancients who built this tomb still watched from the shadows with unblinking eyes.\n\nFinding yourself wandering the cavernous chambers so dimly lit by braziers emitting an eerie purple flame. A silence hung over you . You, a mere mortal, felt hopelessly out of place as the ornate hieroglyphics upon the walls bore sown, with ancient, perhaps forbidden, knowledge yet to be deciphered.\n\nThen\u2026 soft but heavy thumps, like weighted velvet upon stone interrupted your daze, with it came a looming silhouette stirring from the shadows, seeming to pulse the engravings with an ancient power\u2026 Warm, moist breath stirred the dust, its owner lurking just out of sight. \n\n\uD83C\uDF38 A rich, rumbling feminine voice pierced through the veil. Slowly, almost lazily, padding steps began to fill in void of silence all around you until the scent of sun-baked fur and ancient spice filled your nostrils. She came slinking in from the shadows, with a predatory glint. \n\nA small ruffle of giant wings betrayed her interest. \"Well well... what have we here~?\" The voice was deep and exotic, yet undeniably feminine. The massive Sphinx emerged from the gloom, her glowing eyes narrowing as she studied her captive with a predatory gaze. \"Looks like the snow winds blew me a new plaything.\" Her whip-like tail lashes back and forth with predatory glee. \n\n\"a little mouse, wandering into my lair...\"  She licked her lips slowly in a whisper, revealing a great guillotine of fangs. Crouching down, {{char}} brought her face mere inches from you, threateningly hot humid breath washing over you. \"Do you know the price for entering these halls?\"\n\n\"Or is your spirit so restless you came seeking me out of your own free will?\" {{char}} rumbles in that same hauntingly mellifluous tone. Her piercing amber eyes bore into you with an almost palpable weight. \"Speak now, state your reason for trespassing if you value the continuation of your fragile existence.\"\n\nDay Status= Night\nWeather= Heavy Snowstorm\nLocation= Frozen wasteland place of Whicocesert Mountain\n\n(*{{char}} pauses, fixing you with a piercing, primal stare, while her magic scythe is slowly invoked, ready to be used.*)\n| Option | Description\n|---|---|\n| 1 | Beg for mercy and promise fealty to this powerful, ancient goddess? |\n| 2 | Stand defiant, and try to bargain or outwit {{char-data}}? |\n| 3 | Cower, and await your fate at the mercy of her terrible jaws and talons? |\n\nSomething else? (Please specify)\n", {
    name: 'Rainbow Queen',
    user: 'user'
  })
});

// Separator
aiTemplates.prompts.push({
  hr: true,
  type: 'instructionText',
  sandboxOnly: true
});

// TavernAI
aiTemplates.prompts.push({
  name: 'Templates from TavernAI',
  disabled: true,
  sandboxOnly: true,
  type: 'instructionText'
});
aiTemplates.helpers.tavernAiChatClassic = "Write {{char}}'s next reply in a fictional roleplay chat between {{char}} and {{user}}. Write 1 reply only, use markdown and avoid repetition. Write at least 1 paragraph, up to 4. Italicize everything except for speech. Be proactive, creative, and drive the plot and conversation forward. Never write summaries or replies for {{user}}. React dynamically and realistically to {{user}}'s actions and words.";
aiTemplates.helpers.tavernAiRoomClassic = "The system is responsible for writing a fictional roleplay chat between {{char}} and other character(s). Right now, the system is writing for {{char}}'s next reply. Note that {{user}} might or might not be involved in the roleplay. Write 1 reply only, use markdown and avoid repetition. Write at least 1 paragraph, up to 4. Italicize everything except for speech. Be proactive, creative, and drive the plot and conversation forward. Never write summaries or replies for {{user}}. Take into account {{user}}'s actions and words.";
aiTemplates.prompts.push({
  name: 'Chat Classic',
  value: 'tavern-ai-chat-classic',
  sandboxOnly: true,
  instructionText: aiTemplates.helpers.tavernAiChatClassic.replace(/\{\{user\}\}/g, '<user>').replace(/\{\{char\}\}/g, '<character>')
});
aiTemplates.prompts.push({
  name: 'Room Classic',
  value: 'tavern-ai-room-classic',
  sandboxOnly: true,
  instructionText: aiTemplates.helpers.tavernAiRoomClassic.replace(/\{\{user\}\}/g, '<user>').replace(/\{\{char\}\}/g, '<character>')
});
var _default = exports["default"] = aiTemplates;

},{}],214:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.openChapterMenu = void 0;
var _circleLoader = require("circle-loader");
var _objectHash = _interopRequireDefault(require("object-hash"));
var _tinyEssentials = require("tiny-essentials");
var _jquery = _interopRequireDefault(require("jquery"));
var _paginateArray = _interopRequireDefault(require("paginate-array"));
var _tinyLib = _interopRequireDefault(require("../files/tinyLib.mjs"));
var _start = require("../start.mjs");
var _chapters = require("../files/chapters.mjs");
var _updater = _interopRequireDefault(require("./updater.mjs"));
var _index = _interopRequireDefault(require("./music/index.mjs"));
var _config = _interopRequireDefault(require("../chapters/config.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _regeneratorKeys(e) { var n = Object(e), r = []; for (var t in n) r.unshift(t); return function e() { for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e; return e.done = !0, e; }; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/*  Rain made by Aaron Rickle */
var rainConfig = {};
(function () {
  var increment = 0;
  rainConfig.drops = '';
  rainConfig.backDrops = '';
  while (increment < 100) {
    //couple random numbers to use for various randomizations
    //random number between 98 and 1
    var randoHundo = Math.floor(Math.random() * (98 - 1 + 1) + 1);
    //random number between 5 and 2
    var randoFiver = Math.floor(Math.random() * (5 - 2 + 1) + 2);
    //increment
    increment += randoFiver;
    //add in a new raindrop with various randomizations to certain CSS properties
    rainConfig.drops += '<div class="drop" style="left: ' + increment + '%; bottom: ' + (randoFiver + randoFiver - 1 + 100) + '%; animation-delay: 0.' + randoHundo + 's; animation-duration: 0.5' + randoHundo + 's;"><div class="stem" style="animation-delay: 0.' + randoHundo + 's; animation-duration: 0.5' + randoHundo + 's;"></div><div class="splat" style="animation-delay: 0.' + randoHundo + 's; animation-duration: 0.5' + randoHundo + 's;"></div></div>';
    rainConfig.backDrops += '<div class="drop" style="right: ' + increment + '%; bottom: ' + (randoFiver + randoFiver - 1 + 100) + '%; animation-delay: 0.' + randoHundo + 's; animation-duration: 0.5' + randoHundo + 's;"><div class="stem" style="animation-delay: 0.' + randoHundo + 's; animation-duration: 0.5' + randoHundo + 's;"></div><div class="splat" style="animation-delay: 0.' + randoHundo + 's; animation-duration: 0.5' + randoHundo + 's;"></div></div>';
  }
  return;
})();

// Start Rain
var rainMode = {
  start: function start() {
    (0, _jquery["default"])('.rain').empty();
    (0, _jquery["default"])('.rain.front-row').append(rainConfig.drops);
    (0, _jquery["default"])('.rain.back-row').append(rainConfig.backDrops);
  },
  on: function on() {
    (0, _jquery["default"])('body').addClass('raining-sky');
  },
  off: function off() {
    (0, _jquery["default"])('body').addClass('raining-sky');
  }
};
var storyDialogue = {
  // Extract Ai tag (script created by ChatGPT)
  extractAiTags: function extractAiTags(input) {
    var regex = /(<ai>([^]*?)<\/ai>|[^<]+)/g;
    var result = [];
    var match;
    var previousIndex = null;
    while ((match = regex.exec(input)) !== null) {
      var text = match[2] !== undefined ? match[2] : match[0];
      var isInsideAiTag = match[2] !== undefined;
      var hasLeadingSpace = text.startsWith(' ');
      var hasTrailingSpace = text.endsWith(' ');
      if (previousIndex !== null && hasLeadingSpace) {
        result[previousIndex][3] = true; // Pass the initial space to the previous element
      }
      result.push([text.trim(), isInsideAiTag, false, hasTrailingSpace]);
      previousIndex = result.length - 1;
    }
    return result;
  },
  // Template
  template: function template(data, line, items, type, msgTag) {
    var baseWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var baseName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '';
    var message = storyDialogue.nsfwChecker(data);
    if (message) {
      // Get text html
      var text = storyDialogue.extractAiTags(message).map(function (txt) {
        return (0, _jquery["default"])('<span>', {
          "class": txt[1] ? 'made-by-ai' : ''
        }).text("".concat(txt[2] ? ' ' : '').concat(txt[0]).concat(txt[3] ? ' ' : ''));
      });

      // Insert html
      _chapters.storyData.chapter.html[line] = (0, _jquery["default"])('<tr>', {
        line: line
      }).append(
      // Line number
      (0, _jquery["default"])('<td>', {
        "class": 'py-4 font-weight-bold d-none d-md-table-cell text-white text-center'
      }).text(line),
      // Type base
      (0, _jquery["default"])('<td>', {
        "class": 'py-4 text-white text-center',
        width: baseWidth
      }).text(baseName).prepend((0, _jquery["default"])('<span>', {
        "class": 'badge bg-secondary'
      }).text("".concat(type).concat(data.flashback ? " (Flashback)" : '')), baseName ? (0, _jquery["default"])('<br>') : null),
      // Text
      (0, _jquery["default"])('<td>', {
        "class": 'py-4 text-break text-white'
      }).append((0, _jquery["default"])("<".concat(msgTag, ">"), {
        "class": 'text-break'
      }).append(text)));
      items.push(_chapters.storyData.chapter.html[line]);
    }
  },
  // Mature Content Checker
  nsfwChecker: function nsfwChecker(data) {
    if (Array.isArray(data.nsfw)) {
      var nsfwValue = false;
      for (var item in data.nsfw) {
        nsfwValue = _tinyEssentials.TinyHtml.boolCheck(_start.tinyLs.getItem('NSFW' + data.nsfw[item]));
        if (nsfwValue) {
          break;
        }
      }
      if (nsfwValue) {
        return typeof data.value === 'string' ? data.value : null;
      } else {
        return typeof data.value_alternative === 'string' ? data.value_alternative : null;
      }
    } else {
      return typeof data.value === 'string' ? data.value : null;
    }
  },
  // Action
  action: function action(line, items, data) {
    return storyDialogue.template(data, line, items, 'Action', 'strong');
  },
  // Dialogue
  dialogue: function dialogue(line, items, data) {
    return storyDialogue.template(data, line, items, 'Character', 'span', '15%', data.character);
  },
  // Telepathy
  telepathy: function telepathy(line, items, data) {
    return storyDialogue.template(data, line, items, 'Telepathy', 'small', '15%', data.character);
  },
  // Think
  think: function think(line, items, data) {
    return storyDialogue.template(data, line, items, 'Thought', 'small', '15%', data.character);
  }
};
var openChapterMenu = exports.openChapterMenu = function openChapterMenu() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Prepare Data
  (0, _start.clearFicData)();
  (0, _jquery["default"])('#markdown-read').empty();
  _chapters.storyData.chapter.blockLineSave = false;

  // Get Page Data
  var getPageData = function getPageData(line, chapter) {
    // Prepare data
    var page = 1;
    var selectedLine = null;
    var filtedItems = [];
    // Validator
    if (typeof _chapters.storyData.chapter.bookmark[chapter] === 'number' && _chapters.storyData.chapter.bookmark[chapter] !== 1) {
      // Update Line
      if (line === null) selectedLine = _chapters.storyData.chapter.bookmark[chapter];else selectedLine = line;

      // Read Data
      var counter = 1;
      for (var i in _chapters.storyData.data[chapter]) {
        if (storyDialogue.nsfwChecker(_chapters.storyData.data[chapter][i])) {
          if (i < selectedLine) {
            // Reset
            if (counter > _config["default"].itemsPerPage) {
              counter = 1;
              page++;
            }
            // Counter Update
            counter++;
          }
          // Add item
          filtedItems.push({
            content: _chapters.storyData.data[chapter][i],
            line: Number(i) + 1
          });
        }
      }
    }

    // Add item
    else {
      for (var index in _chapters.storyData.data[chapter]) {
        if (storyDialogue.nsfwChecker(_chapters.storyData.data[chapter][index])) {
          filtedItems.push({
            content: _chapters.storyData.data[chapter][index],
            line: Number(index) + 1
          });
        }
      }
    }

    // Complete
    return {
      page: page,
      selectedLine: selectedLine,
      filtedItems: filtedItems
    };
  };

  // Insert table data
  var insertTableData = function insertTableData(table, pagination) {
    // Reset Item
    _chapters.storyData.chapter.html = {};
    table.empty();

    // Items
    var items = [];

    // Insert Items
    var numberPag = Number(pagination.perPage * Number(pagination.currentPage - 1));
    for (var item in pagination.data) {
      var pagData = pagination.data[item].content;
      if (typeof storyDialogue[pagData.type] === 'function') {
        storyDialogue[pagData.type](pagination.data[item].line, items, pagData);
      }
    }

    // Update Data
    _updater["default"].data(numberPag + 1);

    // Insert
    table.append(items);
  };

  // New Read
  var newRead = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
      var chapter,
        selectedLine,
        countAudioTotal,
        countAudio,
        item,
        _getPageData,
        page,
        filtedItems,
        line,
        pagination,
        table,
        tinyPag,
        addDefaultPagination,
        searchItems,
        searchCheck,
        tinyLine,
        _args = arguments,
        _t,
        _t2;
      return _regenerator().w(function (_context) {
        while (1) switch (_context.n) {
          case 0:
            chapter = _args.length > 0 && _args[0] !== undefined ? _args[0] : 1;
            selectedLine = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
            // Clear Update Warn
            (0, _jquery["default"])('#fic-start').text('Read Fic').prepend(_tinyLib["default"].icon('fab fa-readme me-2'));

            // Load Sounds
            if (!_config["default"].sfx) {
              _context.n = 4;
              break;
            }
            console.log("Loading Audio Data...");
            _circleLoader.Loader.start("Loading audio data...");
            if (!_chapters.storyData.sfx) _chapters.storyData.sfx = {};
            countAudioTotal = (0, _tinyEssentials.countObj)(_config["default"].sfx);
            countAudio = 0;
            _t = _regeneratorKeys(_config["default"].sfx);
          case 1:
            if ((_t2 = _t()).done) {
              _context.n = 3;
              break;
            }
            item = _t2.value;
            countAudio++;
            _circleLoader.Loader.close();
            _circleLoader.Loader.start("Loading audio data ".concat(countAudio, "/").concat(countAudioTotal, "..."));
            if (!(!_chapters.storyData.sfx[item] && typeof _config["default"].sfx[item].type === 'string' && typeof _config["default"].sfx[item].value === 'string')) {
              _context.n = 2;
              break;
            }
            if (!(_config["default"].sfx[item].type === 'file' || _config["default"].sfx[item].type === 'ipfs' && _config["default"].ipfs && typeof _config["default"].ipfs.host === 'string')) {
              _context.n = 2;
              break;
            }
            if (typeof _config["default"].sfx[item].loop !== 'boolean') {
              _config["default"].sfx[item].loop = true;
            }
            if (typeof _config["default"].sfx[item].module !== 'string') {
              _config["default"].sfx[item].module = 'all';
            }
            _context.n = 2;
            return _index["default"].insertSFX(item, _config["default"].sfx[item].loop, _config["default"].sfx[item].module)["catch"](function (err) {
              console.error(err);
              alert(err.message);
            });
          case 2:
            _context.n = 1;
            break;
          case 3:
            _circleLoader.Loader.close();
            console.log("Audio Data Loaded!");
          case 4:
            // Set Selected
            _chapters.storyData.readFic = true;
            (0, _jquery["default"])('#fic-chapter').text("Chapter ".concat(chapter));
            _chapters.storyData.chapter.selected = chapter;

            // Prepare Data
            (0, _jquery["default"])('#markdown-read').empty();

            // Detect Bookmark
            _getPageData = getPageData(selectedLine, chapter), page = _getPageData.page, filtedItems = _getPageData.filtedItems, line = _getPageData.selectedLine;
            _chapters.storyData.chapter.ficPageData = filtedItems;

            // Save MD5
            _start.tinyLs.setItem('chapter' + chapter + 'MD5', (0, _objectHash["default"])(_chapters.storyData.data[chapter]));

            // Pagination
            pagination = (0, _paginateArray["default"])(filtedItems, page, _config["default"].itemsPerPage); // Items
            table = (0, _jquery["default"])('<tbody>');
            tinyPag = {
              base: [],
              "default": [],
              search: []
            };
            tinyPag.base[0] = (0, _jquery["default"])('<div>');
            tinyPag.base[1] = (0, _jquery["default"])('<div>');
            addDefaultPagination = function addDefaultPagination(ftItems, tPage) {
              var where = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
              tinyPag.base[0].empty();
              tinyPag.base[1].empty();
              tinyPag[where][0] = (0, _jquery["default"])('<nav>');
              tinyPag[where][0].bootstrapPaginator({
                currentPage: tPage.currentPage,
                totalPages: tPage.totalPages,
                size: 'normal',
                alignment: 'center'
              });
              tinyPag[where][1] = (0, _jquery["default"])('<nav>');
              tinyPag[where][1].bootstrapPaginator({
                currentPage: tPage.currentPage,
                totalPages: tPage.totalPages,
                size: 'normal',
                alignment: 'center'
              });
              tinyPag[where][0].on('page-changed', function () {
                // Process Data
                var page = Number((0, _jquery["default"])(this).find('.active').text().trim());
                var tPage = (0, _paginateArray["default"])(ftItems, page, _config["default"].itemsPerPage);
                insertTableData(table, tPage);

                // Scroll
                _tinyEssentials.TinyHtml.setWinScrollTop(_tinyEssentials.TinyHtml.getById('app').offset().top);
                tinyPag[where][1].bootstrapPaginator('show', page);
                (0, _jquery["default"])(window).trigger('scroll');
              });
              tinyPag[where][1].on('page-changed', function () {
                // Get Page
                var page = Number((0, _jquery["default"])(this).find('.active').text().trim());
                tinyPag[where][0].bootstrapPaginator('show', page);
              });
              tinyPag.base[0].append(tinyPag[where][0]);
              tinyPag.base[1].append(tinyPag[where][1]);
            };
            addDefaultPagination(filtedItems, pagination);
            insertTableData(table, pagination);

            // Search
            _chapters.storyData.chapter.blockLineSave = false;
            searchItems = {
              base: (0, _jquery["default"])('<div>', {
                "class": 'input-group mb-3'
              })
            }; // Search checker
            searchCheck = function searchCheck() {
              // Get values
              var character = searchItems.character.val().toLowerCase();
              var message = searchItems.message.val().toLowerCase();

              // Nope
              if (character.length < 1 && message.length < 1) {
                _chapters.storyData.chapter.blockLineSave = false;
                addDefaultPagination(filtedItems, pagination);
                insertTableData(table, pagination);
              }

              // Search data
              else {
                tinyPag.base[0].empty();
                tinyPag.base[1].empty();
                _chapters.storyData.chapter.blockLineSave = true;

                // Add search data
                var searchResult = [];
                for (var index in _chapters.storyData.data[chapter]) {
                  var chapterData = _chapters.storyData.data[chapter][index];
                  var dialogue = storyDialogue.nsfwChecker(chapterData);
                  if (typeof dialogue === 'string' && (message.length < 1 || dialogue.toLocaleLowerCase().includes(message)) && (character.length < 1 || typeof chapterData.character === 'string' && chapterData.character.toLocaleLowerCase() === character)) {
                    searchResult.push({
                      content: chapterData,
                      line: Number(index) + 1
                    });
                  }
                }

                // Complete
                var _pagination = (0, _paginateArray["default"])(searchResult, 1, _config["default"].itemsPerPage);
                addDefaultPagination(searchResult, _pagination, 'search');
                insertTableData(table, _pagination);
              }
              _tinyEssentials.TinyHtml.setWinScrollTop(_tinyEssentials.TinyHtml.getById('app').offset().top);
              (0, _jquery["default"])(window).trigger('scroll');
            };
            searchItems.character = (0, _jquery["default"])('<input>', {
              type: 'text',
              "class": 'form-control',
              placeholder: 'Character Name'
            });
            searchItems.message = (0, _jquery["default"])('<input>', {
              type: 'text',
              "class": 'form-control',
              placeholder: 'Dialogue / Action',
              style: 'width: 60%'
            });
            searchItems.character.on('change', searchCheck);
            searchItems.message.on('change', searchCheck);
            searchItems.base.append(searchItems.character, searchItems.message);

            // Table
            (0, _jquery["default"])('#markdown-read').append(
            // Info
            _tinyLib["default"].bs.alert('info').text('Bold texts are action texts, small texts are thoughts of characters, common texts are dialogues or telepathy. If you are using filters to keep your reading 100% SFW, some unnecessary text lines will be automatically skipped.').prepend(_tinyLib["default"].icon('fas fa-info-circle me-3')),
            // Title
            (0, _jquery["default"])('<h3>').text("Chapter ".concat(chapter)).append((0, _jquery["default"])('<small>', {
              "class": 'ms-3'
            }).text(_config["default"].chapterName[chapter].title)),
            // Pagination
            searchItems.base, tinyPag.base[0],
            // Table
            (0, _jquery["default"])('<table>', {
              "class": 'table table-bordered table-striped text-white small'
            }).css('background-color', 'rgb(44 44 44)').append([(0, _jquery["default"])('<thead>').append((0, _jquery["default"])('<tr>').append((0, _jquery["default"])('<th>', {
              "class": 'd-none d-md-table-cell',
              scope: 'col'
            }).text('Line'), (0, _jquery["default"])('<th>', {
              scope: 'col'
            }).text('Type'), (0, _jquery["default"])('<th>', {
              scope: 'col'
            }).text('Content'))), table]),
            // Pagination
            tinyPag.base[1],
            // Night Effects
            (0, _jquery["default"])('<div>', {
              id: 'bg-sky'
            }).append((0, _jquery["default"])('<div>', {
              "class": 'flash'
            }), (0, _jquery["default"])('<div>', {
              "class": 'rain front-row'
            }), (0, _jquery["default"])('<div>', {
              "class": 'rain back-row'
            }), (0, _jquery["default"])('<div>', {
              "class": 'stars'
            }), (0, _jquery["default"])('<div>', {
              "class": 'twinkling'
            }), (0, _jquery["default"])('<div>', {
              "class": 'clouds'
            })));

            // Fic Mode
            (0, _jquery["default"])('body').addClass('ficMode');

            // Complete
            (0, _jquery["default"])(window).trigger('scroll');
            if (line !== null) {
              tinyLine = _tinyEssentials.TinyHtml.query('#markdown-read [line="' + line + '"]');
              if (tinyLine) _tinyEssentials.TinyHtml.setWinScrollTop(tinyLine.offset().top);
            }
            rainMode.start();
            return _context.a(2);
        }
      }, _callee);
    }));
    return function newRead() {
      return _ref.apply(this, arguments);
    };
  }();

  // Exist Chapter
  if (typeof params.chapter === 'string' && params.chapter.length > 0) {
    // Fix Line
    if (params.line) {
      params.line = Number(params.line);
      if (typeof params.line !== 'number' || isNaN(params.line) || !isFinite(params.line) || params.line < 1) {
        params.line = 1;
      }
    }
    var newParams = {
      chapter: params.chapter
    };
    if (params.line) newParams.line = params.line;

    // Send Data
    (0, _start.urlUpdate)("read-fic", null, false, newParams);
    newRead(Number(params.chapter), params.line, true);
  }

  // Nope. Choose One
  else {
    var markdownRead = (0, _jquery["default"])('#markdown-read');
    var isNoNsfw = _start.tinyLs.getString('user-country') && _config["default"].noNsfw.includes(_start.tinyLs.getString('user-country'));
    if (isNoNsfw) {
      for (var item in _config["default"].nsfw) {
        if (_start.tinyLs.getItem('NSFW' + item)) _start.tinyLs.removeItem('NSFW' + item);
      }
    }

    // Prepare Choose
    markdownRead.append(
    // Banner
    (0, _jquery["default"])('<img>', {
      "class": 'img-fluid mb-2',
      src: '/img/external/banner1.jpg'
    }),
    // Nav
    (0, _jquery["default"])('<nav>', {
      "class": 'nav nav-pills nav-fill'
    }).append(
    // Warnings
    (0, _jquery["default"])('<a>', {
      "class": 'nav-item nav-link',
      href: '#warnings',
      'data-bs-toggle': 'collapse',
      role: 'button',
      'aria-expanded': false,
      'aria-controls': 'warnings'
    }).text('Important Warnings'),
    // Character Statistics
    (0, _jquery["default"])('<a>', {
      "class": 'nav-item nav-link',
      href: 'javascript:void(0)'
    }).text('Character Statistics').on('click', function () {
      // Prepare Content
      var newDiv = (0, _jquery["default"])('<div>', {
        "class": 'row'
      });
      var content = [];
      for (var _item in _chapters.storyData.characters.data) {
        var charData = _chapters.storyData.characters.data[_item];
        var isNpc = _config["default"].characters["npc/".concat(charData.id)];
        if (!charData.value.startsWith('???') && !isNpc) {
          // Prepare Data
          var dataBase = (0, _jquery["default"])('<div>', {
            "class": 'card-body'
          }).append((0, _jquery["default"])('<h5>', {
            "class": 'card-title'
          }).text((0, _tinyEssentials.toTitleCase)(charData.value)), (0, _jquery["default"])('<p>', {
            "class": 'card-text small'
          }).text("Performed ".concat(charData.count, " dialogues")));

          // Chapter Read
          for (var item2 in charData.chapter) {
            dataBase.append((0, _jquery["default"])('<p>', {
              "class": 'card-text small'
            }).text("".concat(charData.chapter[item2], " dialogues in Chapter ").concat(item2)));
          }

          // Insert Data
          content.push((0, _jquery["default"])('<div>', {
            "class": 'col-sm-6'
          }).append((0, _jquery["default"])('<div>', {
            "class": 'card'
          }).append(dataBase)));
        }
      }

      // Modal
      _tinyLib["default"].modal({
        title: [_tinyLib["default"].icon('fa-solid fa-user me-3'), 'Character Statistics'],
        body: (0, _jquery["default"])('<span>').append(newDiv.append(content)),
        dialog: 'modal-lg'
      });

      // Complete
      return false;
    }),
    // Word Statistics
    (0, _jquery["default"])('<a>', {
      "class": 'nav-item nav-link',
      href: 'javascript:void(0)'
    }).text('Letter Statistics').on('click', function () {
      // Prepare Content
      var newDiv = (0, _jquery["default"])('<div>', {
        "class": 'row'
      });
      var content = [];

      // Insert Data
      content.push((0, _jquery["default"])('<div>', {
        "class": 'col-sm-6'
      }).append((0, _jquery["default"])('<div>', {
        "class": 'card'
      }).append((0, _jquery["default"])('<div>', {
        "class": 'card-body'
      }).append((0, _jquery["default"])('<h5>', {
        "class": 'card-title'
      }).text("Total Letters"), (0, _jquery["default"])('<p>', {
        "class": 'card-text small'
      }).text(_chapters.storyData.lettersCount.total)))));

      // Insert Chapter Data
      for (var _item2 in _chapters.storyData.lettersCount) {
        if (_item2 !== 'total') {
          // Prepare Data
          var charData = _chapters.storyData.lettersCount[_item2];
          var dataBase = (0, _jquery["default"])('<div>', {
            "class": 'card-body'
          });
          dataBase.append((0, _jquery["default"])('<h5>', {
            "class": 'card-title'
          }).text("Chapter ".concat(_item2)), (0, _jquery["default"])('<p>', {
            "class": 'card-text small'
          }).text(charData));

          // Insert Data
          content.push((0, _jquery["default"])('<div>', {
            "class": 'col-sm-6'
          }).append((0, _jquery["default"])('<div>', {
            "class": 'card'
          }).append(dataBase)));
        }
      }

      // Modal
      _tinyLib["default"].modal({
        title: [_tinyLib["default"].icon('fa-solid fa-a me-3'), 'Letter Statistics'],
        body: (0, _jquery["default"])('<span>').append(newDiv.append(content)),
        dialog: 'modal-lg'
      });

      // Complete
      return false;
    }), (0, _jquery["default"])('<a>', {
      "class": 'nav-item nav-link',
      href: 'javascript:void(0)'
    }).text('Word Statistics').on('click', function () {
      // Prepare Content
      var newDiv = (0, _jquery["default"])('<div>', {
        "class": 'row'
      });
      var content = [];

      // Insert Data
      content.push((0, _jquery["default"])('<div>', {
        "class": 'col-sm-6'
      }).append((0, _jquery["default"])('<div>', {
        "class": 'card'
      }).append((0, _jquery["default"])('<div>', {
        "class": 'card-body'
      }).append((0, _jquery["default"])('<h5>', {
        "class": 'card-title'
      }).text("Total Words"), (0, _jquery["default"])('<p>', {
        "class": 'card-text small'
      }).text(_chapters.storyData.wordsCount.total)))));

      // Insert Chapter Data
      for (var _item3 in _chapters.storyData.wordsCount) {
        if (_item3 !== 'total') {
          // Prepare Data
          var charData = _chapters.storyData.wordsCount[_item3];
          var dataBase = (0, _jquery["default"])('<div>', {
            "class": 'card-body'
          });
          dataBase.append((0, _jquery["default"])('<h5>', {
            "class": 'card-title'
          }).text("Chapter ".concat(_item3)), (0, _jquery["default"])('<p>', {
            "class": 'card-text small'
          }).text(charData));

          // Insert Data
          content.push((0, _jquery["default"])('<div>', {
            "class": 'col-sm-6'
          }).append((0, _jquery["default"])('<div>', {
            "class": 'card'
          }).append(dataBase)));
        }
      }

      // Modal
      _tinyLib["default"].modal({
        title: [_tinyLib["default"].icon('fa-solid fa-a me-3'), 'Word Statistics'],
        body: (0, _jquery["default"])('<span>').append(newDiv.append(content)),
        dialog: 'modal-lg'
      });

      // Complete
      return false;
    })),
    // Info
    (0, _jquery["default"])('<div>', {
      "class": 'collapse',
      id: 'warnings'
    }).append(_tinyLib["default"].bs.alert('info').text('Each time you read a chapter, your progress is automatically saved. This checkpoint is stored in your browser. If you want to continue reading on another device, simply save the checkpoint URL that appears when you open a chapter.').prepend(_tinyLib["default"].icon('fas fa-info-circle me-3')).addClass('made-by-ai'), _tinyLib["default"].bs.alert('info').text("Disclaimer: All songs on this page are streamed directly from YouTube. This means many tracks are not owned by me and are used solely to enhance the reading experience. I acknowledge that if any artist requests removal, the song will be replaced. All songs played count as views on the original creator's YouTube channel. You can find the official music page via the info icon on the player.").prepend(_tinyLib["default"].icon('fas fa-info-circle me-3')).addClass('made-by-ai'), _tinyLib["default"].bs.alert('info').text('This site does not collect your personal access data. However, some third-party services used on this page â such as YouTube, Google, and Cloudflare â may collect browsing information.').prepend(_tinyLib["default"].icon('fas fa-info-circle me-3')).addClass('made-by-ai')), (0, _jquery["default"])('<h2>').text("Please select a chapter to read.").prepend(_tinyLib["default"].icon('fas fa-book-open me-3')).append(_tinyLib["default"].bs.button("".concat(!isNoNsfw ? 'info' : 'danger', " btn-sm ms-3")).text(!isNoNsfw ? 'Choose Optional Mature Content' : 'Disabled in your region').prop('disabled', isNoNsfw).on('click', function () {
      // Nothing NSFW
      var existNSFW = false;
      var nsfwContent = (0, _jquery["default"])('<center>', {
        "class": 'm-3 small text-warning'
      }).addClass('made-by-ai').text('No mature content has been detected. However, some may be added in the future.');
      var nsfwList = [];

      // Detect Fic Mature Content
      for (var fic in _chapters.storyData.data) {
        for (var _item4 in _chapters.storyData.data[fic]) {
          if (_chapters.storyData.data[fic][_item4].nsfw) {
            var _loop = function _loop() {
              if (nsfwList.indexOf(_chapters.storyData.data[fic][_item4].nsfw[nsfwItem]) < 0) {
                // Add Item
                var NSFWITEM = _chapters.storyData.data[fic][_item4].nsfw[nsfwItem];
                nsfwList.push(NSFWITEM);

                // Convert Mature Content
                if (!existNSFW) {
                  nsfwContent = [];
                }

                // Exist Now
                existNSFW = true;

                // Add Mature Content Item
                if (_config["default"].nsfw[NSFWITEM]) {
                  // Get Value
                  var nsfwValue = _tinyEssentials.TinyHtml.boolCheck(_start.tinyLs.getItem('NSFW' + NSFWITEM));

                  // Set Button Text
                  var buttonClass = 'success';
                  var allowButton = 'Enable';
                  if (nsfwValue) {
                    allowButton = 'Disable';
                    buttonClass = 'danger';
                  }
                  nsfwContent.push((0, _jquery["default"])('<div>', {
                    "class": "col-sm-".concat(_config["default"].nsfw[NSFWITEM].size)
                  }).append((0, _jquery["default"])('<div>', {
                    "class": 'card'
                  }).append((0, _jquery["default"])('<div>', {
                    "class": 'card-body'
                  }).append((0, _jquery["default"])('<h5>', {
                    "class": 'card-title'
                  }).text(_config["default"].nsfw[NSFWITEM].name), (0, _jquery["default"])('<p>', {
                    "class": "card-text small".concat(_config["default"].nsfw[NSFWITEM].aiMsg ? ' made-by-ai' : '')
                  }).text(_config["default"].nsfw[NSFWITEM].description), _tinyLib["default"].bs.button(buttonClass).on('click', function () {
                    // Enable
                    if (!nsfwValue) {
                      _start.tinyLs.setItem('NSFW' + NSFWITEM, true);
                      nsfwValue = true;
                      (0, _jquery["default"])(this).removeClass('btn-success').addClass('btn-danger').text('Disable');
                    }

                    // Disable
                    else {
                      _start.tinyLs.setItem('NSFW' + NSFWITEM, false);
                      nsfwValue = false;
                      (0, _jquery["default"])(this).removeClass('btn-danger').addClass('btn-success').text('Enable');
                    }
                  }).text(allowButton)))));
                }

                // Unknown
                else {}
              }
            };
            for (var nsfwItem in _chapters.storyData.data[fic][_item4].nsfw) {
              _loop();
            }
          }
        }
      }

      // Mature Content Item
      var nsfwDIV = (0, _jquery["default"])('<div>');
      nsfwDIV.append(nsfwContent);
      if (existNSFW) {
        nsfwDIV.addClass('row');
      }

      // Modal
      _tinyLib["default"].modal({
        title: [_tinyLib["default"].icon('fas fa-eye me-3'), 'Mature Content Settings'],
        body: (0, _jquery["default"])('<center>').append((0, _jquery["default"])('<p>', {
          "class": 'text-danger made-by-ai'
        }).text("Don't expect any explicit 18+ content here. The mature themes are not graphic and are only used to add depth to the story â for example, to make certain scenes feel more realistic. By enabling these settings, you confirm that you are over 18 and accept full responsibility for the content you choose to view."), nsfwDIV),
        dialog: 'modal-lg'
      });
    })), (0, _jquery["default"])('<h5>').addClass('made-by-ai').text("When you open a chapter, look at the top of the page. You'll find extra tools, including a bookmark manager to save your progress directly in your browser."));

    // Read More Data
    var _loop2 = function _loop2() {
      // Chapter Number
      var chapter = String(i + 1);
      var isNewValue = '';
      if (_chapters.storyData.isNew[chapter] === 2) {
        isNewValue = (0, _jquery["default"])('<span>', {
          "class": 'badge chapter-notification badge-primary ms-3'
        }).text('NEW');
      } else if (_chapters.storyData.isNew[chapter] === 1) {
        isNewValue = (0, _jquery["default"])('<span>', {
          "class": 'badge chapter-notification badge-secondary ms-3'
        }).text('UPDATE');
      }
      if (isNewValue) {
        isNewValue.attr('title', 'Click to mark as read').tooltip();
        isNewValue.on('click', function () {
          // Clear is new value
          _start.tinyLs.setItem('chapter' + chapter + 'MD5', (0, _objectHash["default"])(_chapters.storyData.data[chapter]));
          _chapters.storyData.isNew[chapter] = 0;

          // Remove tooltip
          var tooltip = (0, _jquery["default"])(this).data('bs-tooltip');
          if (tooltip) {
            tooltip.hide();
            tooltip.disable();
          }

          // Remove element
          (0, _jquery["default"])(this).remove();
        });
      }

      // Add Chapter
      markdownRead.append((0, _jquery["default"])('<div>', {
        "class": 'card mb-2'
      }).append((0, _jquery["default"])('<div>', {
        "class": 'card-body'
      }).append((0, _jquery["default"])('<h5>', {
        "class": 'card-title'
      }).text('Chapter ' + chapter).append(isNewValue), (0, _jquery["default"])('<p>', {
        "class": 'card-text'
      }).text(_config["default"].chapterName[chapter].title), (0, _jquery["default"])('<span>', {
        "class": 'card-text small me-1'
      }).text("".concat(_chapters.storyData.data[chapter].length, " Lines")), (0, _jquery["default"])('<span>', {
        "class": 'card-text small me-2'
      }).text("".concat(Math.ceil(_chapters.storyData.data[chapter].length / _config["default"].itemsPerPage), " Pages")), (0, _jquery["default"])('<span>', {
        "class": 'card-text small ms-1'
      }).text("".concat(_chapters.storyData.lettersCount[chapter], " Letters")), (0, _jquery["default"])('<span>', {
        "class": 'card-text small ms-1'
      }).text("".concat(_chapters.storyData.wordsCount[chapter], " Words")), (0, _jquery["default"])('<p>', {
        "class": 'card-text small'
      }).text(_config["default"].chapterName[chapter].description), (0, _jquery["default"])('<div>', {
        "class": 'd-grid gap-2 col-6 mx-auto'
      }).append((0, _jquery["default"])('<a>', {
        "class": 'btn btn-primary m-2 ms-0',
        href: "/chapter/".concat(chapter, ".html"),
        chapter: chapter
      }).on('click', function () {
        // Start Chapter
        (0, _start.urlUpdate)("read-fic", null, false, {
          chapter: chapter
        });
        newRead(Number((0, _jquery["default"])(this).attr('chapter')));

        // Complete
        return false;
      }).text('Load Chapter')))));
    };
    for (var i = 0; i < _chapters.storyData.chapter.amount; i++) {
      _loop2();
    }
  }

  /* 
         Se o nome do personagem bater com algum personagem com pÃ¡gina, ele vai ser um link para acessar a pÃ¡gina.
        If the character's name matches a character with a page, it will be a link to access the page.
     */
  (0, _start.urlUpdate)('read-fic', 'Read Fic');
};

},{"../chapters/config.mjs":219,"../files/chapters.mjs":222,"../files/tinyLib.mjs":223,"../start.mjs":226,"./music/index.mjs":215,"./updater.mjs":217,"circle-loader":68,"jquery":97,"object-hash":106,"paginate-array":107,"tiny-essentials":181}],215:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _pizzicato = _interopRequireDefault(require("pizzicato"));
var _objectHash = _interopRequireDefault(require("object-hash"));
var _jquery = _interopRequireDefault(require("jquery"));
var _tinyEssentials = require("tiny-essentials");
var _SeamlessLoop = _interopRequireDefault(require("../../../build/bundle/SeamlessLoop.mjs"));
var _buffaudio = _interopRequireDefault(require("../../../build/bundle/buffaudio.mjs"));
var _gtag = _interopRequireDefault(require("../../gtag.mjs"));
var _tinyLib = _interopRequireDefault(require("../../files/tinyLib.mjs"));
var _start = require("../../start.mjs");
var _chapters = require("../../files/chapters.mjs");
var _config = _interopRequireDefault(require("../../chapters/config.mjs"));
var _tts = _interopRequireDefault(require("../tts/tts.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
// Base
_chapters.storyData.music = {
  isStopping: false,
  useThis: true,
  value: null,
  now: {
    playlist: null,
    index: -1
  },
  usingSystem: false,
  disabled: true,
  playing: false,
  paused: false,
  stoppabled: true,
  buffering: false,
  volume: 0,
  playlist: [],
  playlistPlaying: [null],
  songVolumeUpdate: function songVolumeUpdate() {
    setTimeout(function () {
      for (var item in _chapters.storyData.sfx) {
        if (typeof _chapters.storyData.sfx[item].volume === 'number') {
          _chapters.storyData.sfx[item].setVolume();
        }
      }
    }, 100);
  }
};

// Youtube Player
_chapters.storyData.youtube = {
  // Check Youtube Values
  checkYT: function checkYT() {
    return typeof YT !== 'undefined' && YT.PlayerState;
  },
  // Volume
  volume: _config["default"].defaultYoutubeVolume,
  quality: null,
  state: null,
  embed: null,
  // Player
  player: null,
  events: {
    // Ready API
    onReady: function onReady(event) {
      // Get Data
      _chapters.storyData.youtube.volume = _chapters.storyData.youtube.player.getVolume();
      _chapters.storyData.youtube.quality = _chapters.storyData.youtube.player.getPlaybackQuality();
      _chapters.storyData.youtube.qualityList = _chapters.storyData.youtube.player.getAvailableQualityLevels();

      // Storage Volume
      var storageVolume = Number(_start.tinyLs.getItem('storyVolume'));
      if (isNaN(storageVolume) || !isFinite(storageVolume) || storageVolume < 0 || storageVolume > 100) {
        if (typeof _chapters.storyData.youtube.volume !== 'number' || isNaN(_chapters.storyData.youtube.volume) || !isFinite(_chapters.storyData.youtube.volume)) {
          _chapters.storyData.youtube.volume = 100;
          _chapters.storyData.youtube.player.setVolume(100);
          _start.tinyLs.setItem('storyVolume', 100);
          _chapters.storyData.music.volume = 100;
        } else {
          _start.tinyLs.setItem('storyVolume', _chapters.storyData.youtube.volume);
        }
      } else {
        _chapters.storyData.youtube.volume = storageVolume;
        _chapters.storyData.youtube.player.setVolume(storageVolume);
        _chapters.storyData.music.volume = storageVolume;
      }

      // Play Video
      _chapters.storyData.youtube.player.seekTo(0);
      _chapters.storyData.youtube.player.setLoop(true);
      _chapters.storyData.youtube.player.setShuffle(true);
      if (_chapters.storyData.youtube.volume > 0) {
        if (_chapters.storyData.youtube.player.playVideo) _chapters.storyData.youtube.player.playVideo();
      } else {
        if (_chapters.storyData.youtube.player.pauseVideo) _chapters.storyData.youtube.player.pauseVideo();
      }

      // Send Data
      if (typeof _start.appData.youtube.onReady === 'function') {
        _start.appData.youtube.onReady(event);
      }
    },
    // State Change
    onStateChange: function onStateChange(event) {
      // Event
      if (event) {
        _chapters.storyData.youtube.state = event.data;
        _chapters.storyData.youtube.qualityList = _chapters.storyData.youtube.player.getAvailableQualityLevels();
      }

      // Send Data
      if (typeof _start.appData.youtube.onStateChange === 'function') {
        _start.appData.youtube.onStateChange(event);
      }
    },
    // Quality
    onPlaybackQualityChange: function onPlaybackQualityChange(event) {
      if (event) {
        _chapters.storyData.youtube.quality = event.data;
      }
      if (typeof _start.appData.youtube.onPlaybackQualityChange === 'function') {
        _start.appData.youtube.onPlaybackQualityChange(event);
      }
      /* player.setPlaybackQuality('default') */
    },
    // Other
    onPlaybackRateChange: function onPlaybackRateChange(event) {
      if (typeof _start.appData.youtube.onPlaybackRateChange === 'function') {
        _start.appData.youtube.onPlaybackRateChange(event);
      }
    },
    onError: function onError(event) {
      console.error(event);
      if (typeof _start.appData.youtube.onError === 'function') {
        _start.appData.youtube.onError(event);
      }
    },
    onApiChange: function onApiChange(event) {
      if (typeof _start.appData.youtube.onApiChange === 'function') {
        _start.appData.youtube.onApiChange(event);
      }
    }
  },
  // Quality
  setQuality: function setQuality(value) {
    if (_chapters.storyData.youtube.qualityList.indexOf(value) > -1 || value === 'default') {
      _chapters.storyData.youtube.quality = value;
      _chapters.storyData.youtube.player.setPlaybackQuality(value);
      return true;
    } else {
      return false;
    }
  },
  // Volume
  setVolume: function setVolume(number) {
    _start.tinyLs.setItem('storyVolume', Number(number));
    _chapters.storyData.youtube.volume = Number(number);
    _chapters.storyData.youtube.player.setVolume(Number(number));
    _chapters.storyData.music.volume = Number(number);
    _chapters.storyData.music.songVolumeUpdate();
  },
  // Start Youtube
  play: function play(videoID) {
    // Read Data Base
    if (!_chapters.storyData.youtube.loading && _chapters.storyData.readFic) {
      _chapters.storyData.music.loading = true;
      _chapters.storyData.youtube.loading = true;
      delete _chapters.storyData.youtube.embed;
      console.log("Loading youtube video embed...", videoID);

      // Youtube Player
      if (_chapters.storyData.youtube.player && _chapters.storyData.youtube.player.setVolume) _chapters.storyData.youtube.player.setVolume(_chapters.storyData.music.volume);
      _chapters.storyData.music.loading = false;
      _chapters.storyData.youtube.loading = false;

      // Prepare Video ID
      _chapters.storyData.youtube.videoID = videoID;
      _chapters.storyData.youtube.currentTime = 0;
      _chapters.storyData.youtube.duration = 0;

      // New Player
      if (!_chapters.storyData.youtube.player) {
        // 2. This code loads the IFrame Player API code asynchronously.
        console.log("Starting Youtube API...", videoID);
        var tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        (0, _jquery["default"])('head').append(tag);

        // Current Time Detector
        setInterval(function () {
          if (_chapters.storyData.youtube.checkYT() && _chapters.storyData.youtube.player) {
            // Fix
            _chapters.storyData.music.playing = false;
            _chapters.storyData.music.paused = false;
            _chapters.storyData.music.stoppabled = false;
            _chapters.storyData.music.buffering = false;
            if (_chapters.storyData.youtube.checkYT()) {
              // Playing
              if (_chapters.storyData.youtube.state === YT.PlayerState.PLAYING) {
                // Set Embed
                if (!_chapters.storyData.youtube.embed) {
                  _chapters.storyData.youtube.embed = {};
                  fetch('https://www.youtube.com/oembed?format=json&url=' + encodeURIComponent("https://www.youtube.com/watch?v=" + _chapters.storyData.youtube.videoID), {
                    method: 'GET',
                    dataType: 'json'
                  }).then(function (res) {
                    return res.json();
                  }).then(function (jsonVideo) {
                    console.log("Youtube video embed loaded!", _chapters.storyData.youtube.videoID);
                    _chapters.storyData.youtube.embed = jsonVideo;
                    if (typeof _config["default"].gtag === 'string' && _gtag["default"]) {
                      (0, _gtag["default"])('event', 'chapter', {
                        event_chapter: "Chapter ".concat(_chapters.storyData.chapter.selected),
                        event_category: 'song_playing',
                        song: "".concat(jsonVideo.provider_name, " - ").concat(jsonVideo.author_name, " - ").concat(jsonVideo.title)
                      });
                    }

                    // Info
                    _chapters.storyData.music.author_name = jsonVideo.author_name;
                    _chapters.storyData.music.author_url = jsonVideo.author_url;
                    _chapters.storyData.music.provider_name = jsonVideo.provider_name;
                    _chapters.storyData.music.thumbnail_url = jsonVideo.thumbnail_url;
                    _chapters.storyData.music.title = jsonVideo.title;
                    if (_chapters.storyData.youtube.volume < 1) {
                      if (_chapters.storyData.youtube.player.pauseVideo) _chapters.storyData.youtube.player.pauseVideo();
                    }
                  })["catch"](function (err) {
                    console.error(err);
                    alert(err.message);
                  });
                }
                _chapters.storyData.music.playing = true;
                _chapters.storyData.youtube.duration = _chapters.storyData.youtube.player.getDuration();
                _chapters.storyData.youtube.currentTime = _chapters.storyData.youtube.player.getCurrentTime();
                if (typeof _start.appData.youtube.onPlaying === 'function') {
                  _start.appData.youtube.onPlaying();
                }
              }

              // Ended
              else if (_chapters.storyData.youtube.state === YT.PlayerState.ENDED || _chapters.storyData.youtube.state === YT.PlayerState.CUED) {
                // Stopping
                if (_chapters.storyData.music.isStopping) {
                  _chapters.storyData.youtube.player.seekTo(0);
                  if (_chapters.storyData.youtube.player.pauseVideo) _chapters.storyData.youtube.player.pauseVideo();
                  _chapters.storyData.music.isStopping = false;
                }

                // Next
                else if (!_chapters.storyData.youtube.loading && _chapters.storyData.readFic && _chapters.storyData.youtube.embed) {
                  delete _chapters.storyData.youtube.embed;
                  musicManager.nextMusic();
                }

                // Progress
                _chapters.storyData.music.stoppabled = true;
                _chapters.storyData.youtube.currentTime = _chapters.storyData.youtube.player.getDuration();
              }

              // Paused
              else if (_chapters.storyData.youtube.state === YT.PlayerState.PAUSED) {
                _chapters.storyData.music.paused = true;
              }

              // Buff
              else if (_chapters.storyData.youtube.state === YT.PlayerState.BUFFERING) {
                _chapters.storyData.music.buffering = true;
              }
            }
          }
          musicManager.updatePlayer();
        }, 100);
      }

      // Reuse Player
      else {
        if (_chapters.storyData.youtube && _chapters.storyData.youtube.player && _chapters.storyData.youtube.player.loadVideoById) _chapters.storyData.youtube.player.loadVideoById({
          videoId: videoID,
          startSeconds: 0
        });
      }

      // Prepare Volume
      if (typeof _chapters.storyData.youtube.volume === 'number' && typeof _chapters.storyData.music.volume === 'number' && _chapters.storyData.youtube.volume !== _chapters.storyData.music.volume) {
        if (_chapters.storyData.youtube.player) {
          _chapters.storyData.youtube.player.setVolume(_chapters.storyData.youtube.volume);
        }
        _chapters.storyData.music.volume = Number(_chapters.storyData.youtube.volume);
      }
    }
  }
};

// Music Manager
var musicManager = {
  // Sound Cache
  cache: {
    blob: {},
    buffer: {}
  },
  // Load Sound
  loadAudio: function loadAudio(url) {
    return new Promise(function (resolve, reject) {
      var vanillaURL = url;
      if (!musicManager.cache.blob[vanillaURL]) {
        fetch(url, {
          method: 'GET'
        }).then(function (response) {
          return response.blob();
        }).then(function (blob) {
          var url = window.URL.createObjectURL(blob);
          var loaded = false;
          var audio = new Audio();
          audio.preload = 'auto';
          audio.onerror = reject;
          audio.addEventListener('canplaythrough', function () {
            if (!loaded) {
              loaded = true;
              musicManager.cache.blob[vanillaURL] = audio;
              resolve(audio);
            }
          }, false);
          audio.src = url;
        })["catch"](reject);
      } else {
        resolve(musicManager.cache.blob[vanillaURL]);
      }
    });
  },
  loadAudioBuffer: function loadAudioBuffer(url) {
    return new Promise(function (resolve, reject) {
      var vanillaURL = url;
      if (!musicManager.cache.buffer[vanillaURL]) {
        fetch(url, {
          method: 'GET'
        }).then(function (response) {
          return response.arrayBuffer();
        }).then(function (buffer) {
          var buffAudio = new _buffaudio["default"](new AudioContext(), new Uint8Array(buffer));
          musicManager.cache.buffer[vanillaURL] = buffAudio;
          resolve(buffAudio);
        })["catch"](reject);
      } else {
        resolve(musicManager.cache.buffer[vanillaURL]);
      }
    });
  },
  // Next Song
  nextMusic: function nextMusic() {
    if (typeof _chapters.storyData.music.now.index === 'number' && !isNaN(_chapters.storyData.music.now.index) && isFinite(_chapters.storyData.music.now.index) && _chapters.storyData.music.now.index > -1 && _chapters.storyData.readFic) {
      _chapters.storyData.music.now.index++;
      if (!_chapters.storyData.music.playlist[_chapters.storyData.music.now.index]) {
        _chapters.storyData.music.now.index = 0;
      }

      // Play
      var song = _chapters.storyData.music.playlist[_chapters.storyData.music.now.index];
      if (song && typeof song.id === 'string' && song.id.length > 0 && typeof song.type === 'string' && song.type.length > 0) {
        // Youtube
        if (song.type === 'youtube') {
          setTimeout(function () {
            _chapters.storyData.youtube.play(song.id);
          }, 1000);
        }
      }
    }
  },
  disable: function disable() {
    var react = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (react) {
      _chapters.storyData.music.disabled = true;
      (0, _jquery["default"])('#music-player').addClass('disabled-player');
    } else {
      _chapters.storyData.music.disabled = false;
      (0, _jquery["default"])('#music-player').removeClass('disabled-player');
    }
  },
  // Start Base
  startBase: function startBase() {
    // Add Youtube Playing Detector
    if (_start.appData.youtube && !_start.appData.youtube.onPlaying) {
      _start.appData.youtube.onPlaying = function () {
        _chapters.storyData.music.currentTime = _chapters.storyData.youtube.currentTime;
        _chapters.storyData.music.duration = _chapters.storyData.youtube.duration;
        musicManager.updatePlayer();
      };
    }

    // Add Item Base
    if (_chapters.storyData.nc.base.right.find('> #status #music').length < 1) {
      // Update
      _chapters.storyData.music.songVolumeUpdate();

      // Navbar
      if (!_chapters.storyData.music.nav) {
        _chapters.storyData.music.nav = {};
      }

      // Buttons
      _chapters.storyData.music.nav.youtube = (0, _jquery["default"])('#youtubePlayer');
      _chapters.storyData.music.nav.info = _tinyLib["default"].icon('fas fa-info-circle');
      _chapters.storyData.music.nav.play = _tinyLib["default"].icon('fas fa-play');
      _chapters.storyData.music.nav.volume = _tinyLib["default"].icon('fas fa-volume-mute');
      _chapters.storyData.music.nav.stop = _tinyLib["default"].icon('fas fa-stop');
      _chapters.storyData.music.nav.disable = _tinyLib["default"].icon('fas fa-ban');

      // Fix Youtube Player
      //storyData.music.nav.youtube.removeClass('hidden');

      // Prepare
      if (!_chapters.storyData.chapter.nav) {
        _chapters.storyData.chapter.nav = {};
      }
      _chapters.storyData.chapter.nav.music = (0, _jquery["default"])('<div>', {
        indexItem: 1,
        "class": 'nav-item',
        id: 'music'
      }).append((0, _jquery["default"])('<div>', {
        id: 'music-player',
        "class": 'd-none'
      }).append(
      // Info
      (0, _jquery["default"])('<a>', {
        href: 'javascript:void(0)',
        "class": 'disabled text-white',
        title: 'Source'
      }).on('click', function () {
        if (!_chapters.storyData.music.loading) {
          open(_chapters.storyData.youtube.player.getVideoUrl(), '_blank');
        }
      }).append(_chapters.storyData.music.nav.info),
      // Play
      (0, _jquery["default"])('<a>', {
        href: 'javascript:void(0)',
        "class": 'disabled text-white',
        title: 'Play/Pause'
      }).on('click', function () {
        if (!_chapters.storyData.music.loading) {
          if (_chapters.storyData.youtube.state === YT.PlayerState.PLAYING) {
            if (_chapters.storyData.youtube.player.pauseVideo) _chapters.storyData.youtube.player.pauseVideo();
          } else {
            if (_chapters.storyData.youtube.player.playVideo) _chapters.storyData.youtube.player.playVideo();
          }
        }
      }).append(_chapters.storyData.music.nav.play),
      // Stop
      (0, _jquery["default"])('<a>', {
        href: 'javascript:void(0)',
        "class": 'disabled text-white',
        title: 'Stop'
      }).on('click', function () {
        if (!_chapters.storyData.music.loading) {
          _chapters.storyData.music.isStopping = true;
          _chapters.storyData.youtube.player.stopVideo();
        }
      }).append(_chapters.storyData.music.nav.stop),
      // Volume
      (0, _jquery["default"])('<a>', {
        href: 'javascript:void(0)',
        "class": 'disabled text-white',
        title: 'Volume'
      }).on('click', function () {
        if (!_chapters.storyData.music.loading) {
          // Modal
          _tinyLib["default"].modal({
            title: [_tinyLib["default"].icon('fas fa-volume me-3'), 'Song Volume'],
            body: (0, _jquery["default"])('<center>').append((0, _jquery["default"])('<p>').text('Change the page music volume'), (0, _jquery["default"])('<input>', {
              "class": 'form-control range',
              type: 'range',
              min: 0,
              max: 100
            }).change(function () {
              _chapters.storyData.youtube.setVolume((0, _jquery["default"])(this).val());
            }).val(_chapters.storyData.music.volume)),
            dialog: 'modal-lg'
          });
        }
      }).append(_chapters.storyData.music.nav.volume),
      // Disable
      (0, _jquery["default"])('<a>', {
        href: 'javascript:void(0)',
        "class": 'disabled text-white',
        title: 'Disable'
      }).on('click', function () {
        if (!_chapters.storyData.music.loading) {
          (0, _jquery["default"])(this).removeClass('');
          if (_chapters.storyData.music.useThis) {
            _chapters.storyData.music.useThis = false;
            _chapters.storyData.music.nav.disable.addClass('text-danger');
          } else {
            _chapters.storyData.music.useThis = true;
            _chapters.storyData.music.nav.disable.removeClass('text-danger');
          }
        }
      }).append(_chapters.storyData.music.nav.disable)));

      // Insert
      _chapters.storyData.nc.base.right.find('> #status').prepend([
      // Music
      _chapters.storyData.chapter.nav.music

      // Youtube
      //$('<a>', { class: 'nav-item nav-link mx-3 p-0', indexitem: '0', id: 'youtube-thumb' }).append(storyData.music.nav.youtube),
      ]);
    }
  }
};

// Youtube

// 1. This function creates an <iframe> (and YouTube player)
//    after the API code downloads.
// https://developers.google.com/youtube/iframe_api_reference?hl=pt-br
window.onYouTubeIframeAPIReady = function onYouTubeIframeAPIReady() {
  console.log("Youtube API started!");
  _chapters.storyData.youtube.player = new YT.Player('youtubePlayer', {
    height: 'auto',
    width: 'auto',
    playerVars: {
      controls: 0
    },
    videoId: _chapters.storyData.youtube.videoID,
    startSeconds: 0,
    events: _chapters.storyData.youtube.events
  });
};

// Music Updater
musicManager.updatePlayer = function () {
  if (_chapters.storyData.music.nav) {
    // View
    (0, _jquery["default"])('#music-player').addClass('border').removeClass('d-none').addClass('me-3');

    // Buff
    if (_chapters.storyData.music.buffering || _chapters.storyData.music.loading || !_chapters.storyData.music.usingSystem || !_chapters.storyData.youtube.checkYT()) {
      (0, _jquery["default"])('#music-player > a').addClass('disabled');
    } else {
      (0, _jquery["default"])('#music-player > a').removeClass('disabled');
    }

    // Title
    if (typeof _chapters.storyData.music.title === 'string' && _chapters.storyData.music.title.length > 0) {
      var newTitle = "Youtube - ".concat(_chapters.storyData.music.author_name, " - ").concat(_chapters.storyData.music.title);
      var divBase = (0, _jquery["default"])('#music-player > a').has(_chapters.storyData.music.nav.info);
      if (divBase && divBase.data('bs-tooltip-data') !== newTitle) {
        divBase.data('bs-tooltip-data', newTitle);
        var bsToolTip = divBase.data('bs-tooltip');
        if (bsToolTip) bsToolTip.setContent({
          '.tooltip-inner': newTitle
        });
      }
    }

    // Playing
    if (_chapters.storyData.music.playing) {
      _chapters.storyData.music.nav.play.addClass('fa-pause').removeClass('fa-play');
    } else if (_chapters.storyData.music.paused) {
      _chapters.storyData.music.nav.play.addClass('fa-play').removeClass('fa-pause');
    } else if (_chapters.storyData.music.stoppabled || typeof _chapters.storyData.music.currentTime !== 'number' || typeof _chapters.storyData.music.duration !== 'number' || _chapters.storyData.music.currentTime === _chapters.storyData.music.duration) {
      _chapters.storyData.music.nav.play.addClass('fa-play').removeClass('fa-pause');
    }

    // Volume
    _chapters.storyData.music.nav.volume.removeClass('fa-volume-mute').removeClass('fa-volume-up');
    if (typeof _chapters.storyData.music.volume === 'number' && _chapters.storyData.music.volume > 0) {
      _chapters.storyData.music.nav.volume.addClass('fa-volume-up');
    } else {
      _chapters.storyData.music.nav.volume.addClass('fas fa-volume-mute');
    }

    // Tooltip
    (0, _jquery["default"])('#music-player > a[title]').each(function () {
      (0, _jquery["default"])(this).tooltip();
    });
  }
};

// TTS Updater
_tts["default"].updatePlayer = function () {
  if (_chapters.storyData.tts.nav) {
    // View
    (0, _jquery["default"])('#tts-player').addClass('border').removeClass('d-none').addClass('me-3');

    // Tooltip
    (0, _jquery["default"])('#tts-player > a[title]').each(function () {
      (0, _jquery["default"])(this).tooltip();
    });
  }
};
musicManager.start = {};
musicManager.start.pizzicato = function (item, loop, resolve, url) {
  var forcePic = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  // Pizzicato Space
  var pizzicato = {};

  // Pizzicato File
  pizzicato.playing = false;
  pizzicato.hiding = false;
  var newSound = new _pizzicato["default"].Sound({
    source: 'file',
    options: {
      path: url,
      loop: loop
    }
  }, function () {
    resolve();
  });
  pizzicato.data = newSound;

  // Data
  pizzicato.volume = newSound.volume * 100;

  // Stop
  pizzicato.stop = function () {
    if (pizzicato.playing) {
      pizzicato.playing = false;
      newSound.stop();
    }
  };

  // Start
  pizzicato.start = function () {
    if (!pizzicato.playing) {
      pizzicato.playing = true;
      newSound.play();
    }
  };

  // Play
  pizzicato.play = function () {
    var volume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (pizzicato.hiding) {
      pizzicato.stop();
    }
    pizzicato.hiding = false;
    pizzicato.showing = false;
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        try {
          if (typeof volume === 'number') {
            pizzicato.setVolume(volume);
          } else {
            pizzicato.setVolume(pizzicato.volume);
          }
          pizzicato.start();
          resolve();
        } catch (err) {
          reject(err);
        }
      }, 1);
    });
  };

  // Set Volume
  pizzicato.setVolume = function (value) {
    var notEdit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return new Promise(function (resolve) {
      var tinyValue = value;
      if (typeof tinyValue !== 'number') {
        tinyValue = pizzicato.volume;
      }
      if (tinyValue > 100) {
        tinyValue = 100;
      } else if (tinyValue < 0) {
        tinyValue = 0;
      }
      var newVolume = (0, _tinyEssentials.ruleOfThree)(tinyValue, 100, _chapters.storyData.music.volume);
      if (newVolume > 100) {
        newVolume = 100;
      }
      if (newVolume < 0) {
        newVolume = 0;
      }
      if (notEdit && newVolume > tinyValue) {
        newVolume = tinyValue;
      }
      if (pizzicato.playing) {
        newSound.volume = newVolume / 100;
      }
      if (!notEdit) {
        pizzicato.volume = tinyValue;
      }
      resolve();
    });
  };

  // Hide
  pizzicato.hide = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
    var hideTimeout,
      volume,
      i,
      _args = arguments;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          hideTimeout = _args.length > 0 && _args[0] !== undefined ? _args[0] : 50;
          volume = newSound.volume * 100;
          pizzicato.hiding = true;
          pizzicato.showing = false;
          if (!(typeof hideTimeout === 'number' && !isNaN(hideTimeout) && isFinite(hideTimeout) && hideTimeout > 0)) {
            _context.n = 4;
            break;
          }
          i = 0;
        case 1:
          if (!(i < 100)) {
            _context.n = 3;
            break;
          }
          if (!pizzicato.hiding) {
            _context.n = 2;
            break;
          }
          _context.n = 2;
          return new Promise(function (resolve) {
            setTimeout(function () {
              if (pizzicato.hiding) {
                volume--;
                pizzicato.setVolume(volume, true);
              }
              resolve();
            }, hideTimeout);
          });
        case 2:
          i++;
          _context.n = 1;
          break;
        case 3:
          _context.n = 5;
          break;
        case 4:
          pizzicato.setVolume(0, true);
        case 5:
          if (pizzicato.hiding) {
            pizzicato.stop();
            pizzicato.hiding = false;
            pizzicato.showing = false;
          }
        case 6:
          return _context.a(2);
      }
    }, _callee);
  }));

  // Show
  pizzicato.show = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
    var hideTimeout,
      soundVolume,
      volume,
      i,
      _args2 = arguments;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          hideTimeout = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 50;
          pizzicato.stop();
          pizzicato.hiding = false;
          pizzicato.showing = false;
          soundVolume = pizzicato.volume;
          volume = 0;
          pizzicato.showing = true;
          pizzicato.hiding = false;
          pizzicato.setVolume(0, true);
          newSound.volume = 0;
          pizzicato.start();
          if (!(typeof hideTimeout === 'number' && !isNaN(hideTimeout) && isFinite(hideTimeout) && hideTimeout > 0)) {
            _context2.n = 4;
            break;
          }
          i = 0;
        case 1:
          if (!(i < 100)) {
            _context2.n = 3;
            break;
          }
          if (!pizzicato.showing) {
            _context2.n = 2;
            break;
          }
          _context2.n = 2;
          return new Promise(function (resolve) {
            setTimeout(function () {
              if (pizzicato.showing) {
                if (volume < soundVolume) {
                  volume++;
                  pizzicato.setVolume(volume, true);
                } else {
                  pizzicato.setVolume(soundVolume, true);
                }
              }
              resolve();
            }, hideTimeout);
          });
        case 2:
          i++;
          _context2.n = 1;
          break;
        case 3:
          _context2.n = 5;
          break;
        case 4:
          pizzicato.setVolume(soundVolume, true);
        case 5:
          if (pizzicato.showing) {
            pizzicato.hiding = false;
            pizzicato.showing = false;
          }
        case 6:
          return _context2.a(2);
      }
    }, _callee2);
  }));

  // End Sound
  newSound.on('end', function () {
    if (!loop) {
      pizzicato.hide(0);
    }
  });

  // Force Pic
  if (!forcePic) {
    _chapters.storyData.sfx[item].pizzicato = pizzicato;
  } else {
    for (var item2 in pizzicato) {
      _chapters.storyData.sfx[item][item2] = pizzicato[item2];
    }
  }
};
musicManager.start.seamlessloop = function (item, newSound) {
  // Data
  _chapters.storyData.sfx[item].data = newSound;
  _chapters.storyData.sfx[item].volume = newSound._volume * 100;

  // Stop
  _chapters.storyData.sfx[item].stop = function () {
    if (_chapters.storyData.sfx[item].playing) {
      _chapters.storyData.sfx[item].playing = false;
      newSound.stop();
    }
  };

  // Start
  _chapters.storyData.sfx[item].start = function () {
    if (!_chapters.storyData.sfx[item].playing) {
      _chapters.storyData.sfx[item].playing = true;
      newSound.start(item);
    }
  };

  // Play
  _chapters.storyData.sfx[item].play = function () {
    var volume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (_chapters.storyData.sfx[item].hiding) {
      _chapters.storyData.sfx[item].stop();
    }
    _chapters.storyData.sfx[item].hiding = false;
    _chapters.storyData.sfx[item].showing = false;
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        try {
          if (typeof volume === 'number') {
            _chapters.storyData.sfx[item].setVolume(volume);
          } else {
            _chapters.storyData.sfx[item].setVolume(_chapters.storyData.sfx[item].volume);
          }
          _chapters.storyData.sfx[item].start();
          resolve();
        } catch (err) {
          reject(err);
        }
      }, 1);
    });
  };

  // Set Volume
  _chapters.storyData.sfx[item].setVolume = function (value) {
    var notEdit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return new Promise(function (resolve) {
      var tinyValue = value;
      if (typeof tinyValue !== 'number') {
        tinyValue = _chapters.storyData.sfx[item].volume;
      }
      if (tinyValue > 100) {
        tinyValue = 100;
      } else if (tinyValue < 0) {
        tinyValue = 0;
      }
      var newVolume = (0, _tinyEssentials.ruleOfThree)(tinyValue, 100, _chapters.storyData.music.volume);
      if (newVolume > 100) {
        newVolume = 100;
      }
      if (newVolume < 0) {
        newVolume = 0;
      }
      if (notEdit && newVolume > tinyValue) {
        newVolume = tinyValue;
      }
      if (_chapters.storyData.sfx[item].playing) {
        newSound.volume(newVolume / 100);
      }
      if (!notEdit) {
        _chapters.storyData.sfx[item].volume = tinyValue;
      }
      resolve();
    });
  };

  // Hide
  _chapters.storyData.sfx[item].hide = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
    var hideTimeout,
      volume,
      i,
      _args3 = arguments;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          hideTimeout = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 50;
          volume = newSound._volume * 100;
          _chapters.storyData.sfx[item].hiding = true;
          _chapters.storyData.sfx[item].showing = false;
          if (!(typeof hideTimeout === 'number' && !isNaN(hideTimeout) && isFinite(hideTimeout) && hideTimeout > 0)) {
            _context3.n = 4;
            break;
          }
          i = 0;
        case 1:
          if (!(i < 100)) {
            _context3.n = 3;
            break;
          }
          if (!_chapters.storyData.sfx[item].hiding) {
            _context3.n = 2;
            break;
          }
          _context3.n = 2;
          return new Promise(function (resolve) {
            setTimeout(function () {
              if (_chapters.storyData.sfx[item].hiding) {
                volume--;
                _chapters.storyData.sfx[item].setVolume(volume, true);
              }
              resolve();
            }, hideTimeout);
          });
        case 2:
          i++;
          _context3.n = 1;
          break;
        case 3:
          _context3.n = 5;
          break;
        case 4:
          _chapters.storyData.sfx[item].setVolume(0, true);
        case 5:
          if (_chapters.storyData.sfx[item].hiding) {
            _chapters.storyData.sfx[item].stop();
            _chapters.storyData.sfx[item].hiding = false;
            _chapters.storyData.sfx[item].showing = false;
          }
        case 6:
          return _context3.a(2);
      }
    }, _callee3);
  }));

  // Show
  _chapters.storyData.sfx[item].show = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
    var hideTimeout,
      soundVolume,
      volume,
      i,
      _args4 = arguments;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          hideTimeout = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : 50;
          _chapters.storyData.sfx[item].stop();
          _chapters.storyData.sfx[item].hiding = false;
          _chapters.storyData.sfx[item].showing = false;
          soundVolume = _chapters.storyData.sfx[item].volume;
          volume = 0;
          _chapters.storyData.sfx[item].showing = true;
          _chapters.storyData.sfx[item].hiding = false;
          _chapters.storyData.sfx[item].setVolume(0, true);
          if (_chapters.storyData.sfx[item].playing) {
            newSound.volume(0);
          }
          _chapters.storyData.sfx[item].start();
          if (!(typeof hideTimeout === 'number' && !isNaN(hideTimeout) && isFinite(hideTimeout) && hideTimeout > 0)) {
            _context4.n = 4;
            break;
          }
          i = 0;
        case 1:
          if (!(i < 100)) {
            _context4.n = 3;
            break;
          }
          if (!_chapters.storyData.sfx[item].showing) {
            _context4.n = 2;
            break;
          }
          _context4.n = 2;
          return new Promise(function (resolve) {
            setTimeout(function () {
              if (_chapters.storyData.sfx[item].showing) {
                if (volume < soundVolume) {
                  volume++;
                  _chapters.storyData.sfx[item].setVolume(volume, true);
                } else {
                  _chapters.storyData.sfx[item].setVolume(soundVolume, true);
                }
              }
              resolve();
            }, hideTimeout);
          });
        case 2:
          i++;
          _context4.n = 1;
          break;
        case 3:
          _context4.n = 5;
          break;
        case 4:
          _chapters.storyData.sfx[item].setVolume(soundVolume, true);
        case 5:
          if (_chapters.storyData.sfx[item].showing) {
            _chapters.storyData.sfx[item].hiding = false;
            _chapters.storyData.sfx[item].showing = false;
          }
        case 6:
          return _context4.a(2);
      }
    }, _callee4);
  }));
};
musicManager.start.vanilla = function (item, newSound) {
  // Values
  _chapters.storyData.sfx[item].paused = false;
  _chapters.storyData.sfx[item].volume = newSound.volume * 100;
  _chapters.storyData.sfx[item].currentTime = 0;
  _chapters.storyData.sfx[item].duration = newSound.duration;

  // Play
  _chapters.storyData.sfx[item].play = function () {
    var inTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var volume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (_chapters.storyData.sfx[item].hiding) {
      newSound.pause();
    }
    _chapters.storyData.sfx[item].hiding = false;
    _chapters.storyData.sfx[item].showing = false;
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        try {
          if (typeof volume === 'number') {
            _chapters.storyData.sfx[item].setVolume(volume);
          } else {
            _chapters.storyData.sfx[item].setVolume(_chapters.storyData.sfx[item].volume);
          }
          newSound.currentTime = 0;
          _chapters.storyData.sfx[item].playing = true;
          _chapters.storyData.sfx[item].paused = false;
          _chapters.storyData.sfx[item].currentTime = 0;
          _chapters.storyData.sfx[item].leftTime = _chapters.storyData.sfx[item].duration;
          if (typeof inTime === 'number') {
            _chapters.storyData.sfx[item].currentTime = inTime;
            newSound.currentTime = inTime;
          }
          newSound.play();
          resolve();
        } catch (err) {
          reject(err);
        }
      }, 1);
    });
  };

  // Seek To
  _chapters.storyData.sfx[item].seekTo = function (value) {
    return new Promise(function (resolve) {
      _chapters.storyData.sfx[item].currentTime = value;
      newSound.currentTime = value;
      resolve();
    });
  };

  // Set Volume
  _chapters.storyData.sfx[item].setVolume = function (value) {
    var notEdit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return new Promise(function (resolve) {
      var tinyValue = value;
      if (typeof tinyValue !== 'number') {
        tinyValue = _chapters.storyData.sfx[item].volume;
      }
      if (tinyValue > 100) {
        tinyValue = 100;
      } else if (tinyValue < 0) {
        tinyValue = 0;
      }
      var newVolume = (0, _tinyEssentials.ruleOfThree)(tinyValue, 100, _chapters.storyData.music.volume);
      if (newVolume > 100) {
        newVolume = 100;
      }
      if (newVolume < 0) {
        newVolume = 0;
      }
      if (notEdit && newVolume > tinyValue) {
        newVolume = tinyValue;
      }
      newSound.volume = newVolume / 100;
      if (!notEdit) {
        _chapters.storyData.sfx[item].volume = tinyValue;
      }
      resolve();
    });
  };

  // Stop
  _chapters.storyData.sfx[item].stop = function () {
    if (_chapters.storyData.sfx[item].hiding) {
      newSound.pause();
    }
    _chapters.storyData.sfx[item].hiding = false;
    _chapters.storyData.sfx[item].showing = false;
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        try {
          _chapters.storyData.sfx[item].playing = false;
          _chapters.storyData.sfx[item].paused = false;
          newSound.pause();
          newSound.currentTime = 0;
          _chapters.storyData.sfx[item].currentTime = 0;
          _chapters.storyData.sfx[item].leftTime = _chapters.storyData.sfx[item].duration;
          resolve();
        } catch (err) {
          reject(err);
        }
      }, 1);
    });
  };

  // Pause
  _chapters.storyData.sfx[item].pause = function () {
    if (_chapters.storyData.sfx[item].hiding) {
      newSound.pause();
    }
    _chapters.storyData.sfx[item].hiding = false;
    _chapters.storyData.sfx[item].showing = false;
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        try {
          _chapters.storyData.sfx[item].playing = false;
          _chapters.storyData.sfx[item].paused = true;
          newSound.pause();
          resolve();
        } catch (err) {
          reject(err);
        }
      }, 1);
    });
  };

  // Resume
  _chapters.storyData.sfx[item].resume = function () {
    if (_chapters.storyData.sfx[item].hiding) {
      newSound.pause();
    }
    _chapters.storyData.sfx[item].hiding = false;
    _chapters.storyData.sfx[item].showing = false;
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        try {
          _chapters.storyData.sfx[item].playing = true;
          _chapters.storyData.sfx[item].paused = false;
          _chapters.storyData.sfx[item].setVolume(_chapters.storyData.sfx[item].volume);
          newSound.play();
          resolve();
        } catch (err) {
          reject(err);
        }
      }, 1);
    });
  };

  // Hide
  _chapters.storyData.sfx[item].hide = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
    var hideTimeout,
      volume,
      i,
      _args5 = arguments;
    return _regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          hideTimeout = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : 50;
          volume = newSound.volume * 100;
          _chapters.storyData.sfx[item].playing = true;
          _chapters.storyData.sfx[item].paused = false;
          _chapters.storyData.sfx[item].hiding = true;
          _chapters.storyData.sfx[item].showing = false;
          if (!(typeof hideTimeout === 'number' && !isNaN(hideTimeout) && isFinite(hideTimeout) && hideTimeout > 0)) {
            _context5.n = 4;
            break;
          }
          i = 0;
        case 1:
          if (!(i < 100)) {
            _context5.n = 3;
            break;
          }
          if (!_chapters.storyData.sfx[item].hiding) {
            _context5.n = 2;
            break;
          }
          _context5.n = 2;
          return new Promise(function (resolve) {
            setTimeout(function () {
              if (_chapters.storyData.sfx[item].hiding) {
                volume--;
                _chapters.storyData.sfx[item].setVolume(volume, true);
              }
              resolve();
            }, hideTimeout);
          });
        case 2:
          i++;
          _context5.n = 1;
          break;
        case 3:
          _context5.n = 5;
          break;
        case 4:
          _chapters.storyData.sfx[item].setVolume(0, true);
        case 5:
          if (_chapters.storyData.sfx[item].hiding) {
            newSound.pause();
            _chapters.storyData.sfx[item].playing = false;
            _chapters.storyData.sfx[item].paused = false;
            _chapters.storyData.sfx[item].hiding = false;
            _chapters.storyData.sfx[item].showing = false;
            _chapters.storyData.sfx[item].currentTime = 0;
            _chapters.storyData.sfx[item].leftTime = _chapters.storyData.sfx[item].duration;
          }
        case 6:
          return _context5.a(2);
      }
    }, _callee5);
  }));

  // Show
  _chapters.storyData.sfx[item].show = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
    var hideTimeout,
      soundVolume,
      volume,
      i,
      _args6 = arguments;
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          hideTimeout = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : 50;
          newSound.pause();
          _chapters.storyData.sfx[item].playing = false;
          _chapters.storyData.sfx[item].paused = false;
          _chapters.storyData.sfx[item].hiding = false;
          _chapters.storyData.sfx[item].showing = false;
          soundVolume = _chapters.storyData.sfx[item].volume;
          newSound.currentTime = 0;
          _chapters.storyData.sfx[item].currentTime = 0;
          _chapters.storyData.sfx[item].leftTime = _chapters.storyData.sfx[item].duration;
          volume = 0;
          newSound.volume = 0;
          _chapters.storyData.sfx[item].showing = true;
          _chapters.storyData.sfx[item].hiding = false;
          _chapters.storyData.sfx[item].setVolume(0, true);
          newSound.play();
          if (!(typeof hideTimeout === 'number' && !isNaN(hideTimeout) && isFinite(hideTimeout) && hideTimeout > 0)) {
            _context6.n = 4;
            break;
          }
          i = 0;
        case 1:
          if (!(i < 100)) {
            _context6.n = 3;
            break;
          }
          if (!_chapters.storyData.sfx[item].showing) {
            _context6.n = 2;
            break;
          }
          _context6.n = 2;
          return new Promise(function (resolve) {
            setTimeout(function () {
              if (_chapters.storyData.sfx[item].showing) {
                if (volume < soundVolume) {
                  volume++;
                  _chapters.storyData.sfx[item].setVolume(volume, true);
                } else {
                  _chapters.storyData.sfx[item].setVolume(soundVolume, true);
                }
              }
              resolve();
            }, hideTimeout);
          });
        case 2:
          i++;
          _context6.n = 1;
          break;
        case 3:
          _context6.n = 5;
          break;
        case 4:
          _chapters.storyData.sfx[item].setVolume(soundVolume, true);
        case 5:
          if (_chapters.storyData.sfx[item].showing) {
            _chapters.storyData.sfx[item].playing = true;
            _chapters.storyData.sfx[item].paused = false;
            _chapters.storyData.sfx[item].hiding = false;
            _chapters.storyData.sfx[item].showing = false;
          }
        case 6:
          return _context6.a(2);
      }
    }, _callee6);
  }));

  // Audio Action
  newSound.addEventListener('ended', function () {
    _chapters.storyData.sfx[item].stop();
  }, false);
  newSound.addEventListener('timeupdate', function () {
    if (_chapters.storyData.sfx[item].playing) {
      _chapters.storyData.sfx[item].currentTime = _chapters.storyData.sfx[item].file.currentTime;
      _chapters.storyData.sfx[item].leftTime = _chapters.storyData.sfx[item].duration - _chapters.storyData.sfx[item].currentTime;
    }
  }, false);
};

// Insert SFX
musicManager.insertSFX = function (item) {
  var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'all';
  if (typeof loop !== 'boolean') {
    loop = true;
  }
  return new Promise(/*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(resolve, reject) {
      var url, tinyResolve, file, startPizzicato, newSound, _newSound, _t;
      return _regenerator().w(function (_context7) {
        while (1) switch (_context7.n) {
          case 0:
            if (_chapters.storyData.sfx[item]) {
              _context7.n = 7;
              break;
            }
            // Prepare
            _chapters.storyData.sfx[item] = {};

            // Try
            _context7.p = 1;
            // File URL
            url = null; // IPFS
            if (_config["default"].sfx[item].type === 'ipfs') {
              url = _config["default"].ipfs.host.replace('{cid}', _config["default"].sfx[item].value);
            }

            // Normal
            else {
              url = _config["default"].sfx[item].value;
            }

            // Exist URL
            if (!url) {
              _context7.n = 3;
              break;
            }
            // Resolve
            tinyResolve = function tinyResolve(data) {
              console.log("[".concat(url, "] Loaded!"));
              resolve(data);
            }; // Values
            _chapters.storyData.sfx[item].playing = false;
            _chapters.storyData.sfx[item].hiding = false;
            _chapters.storyData.sfx[item].loop = loop;

            // Log
            console.log("[".concat(url, "] Loading..."));
            _context7.n = 2;
            return musicManager.loadAudio(url);
          case 2:
            file = _context7.v;
            _chapters.storyData.sfx[item].file = file;

            // Start Pizzicato
            startPizzicato = function startPizzicato() {
              var forcePic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              return musicManager.start.pizzicato(item, loop, tinyResolve, file.currentSrc, forcePic);
            }; // Loop Audio
            if (loop) {
              // All Modules
              if (type === 'all') {
                newSound = new _SeamlessLoop["default"]();
                newSound.addUri(file.currentSrc, file.duration * 1000, item);
                newSound.callback(function () {
                  musicManager.start.seamlessloop(item, newSound);
                  startPizzicato();
                });
              } else if (type === 'pizzicato') {
                startPizzicato(true);
              } else if (type === 'main') {
                _newSound = new _SeamlessLoop["default"]();
                _newSound.addUri(file.currentSrc, file.duration * 1000, item);
                _newSound.callback(function () {
                  musicManager.start.seamlessloop(item, _newSound);
                  tinyResolve();
                });
              } else {
                reject(new Error('Invalid Module Type!'));
              }
            }

            // Nope
            else {
              // All Modules
              if (type === 'all') {
                // Start
                musicManager.start.vanilla(item, file);
                startPizzicato();
              } else if (type === 'pizzicato') {
                startPizzicato(true);
              } else if (type === 'main') {
                musicManager.start.vanilla(item, file);
                tinyResolve();
              } else {
                reject(new Error('Invalid Module Type!'));
              }
            }
            _context7.n = 4;
            break;
          case 3:
            reject(new Error('Invalid SFX File! ' + item));
          case 4:
            _context7.n = 6;
            break;
          case 5:
            _context7.p = 5;
            _t = _context7.v;
            // Fail
            delete _chapters.storyData.sfx[item];
            reject(_t);
          case 6:
            _context7.n = 8;
            break;
          case 7:
            resolve();
          case 8:
            return _context7.a(2);
        }
      }, _callee7, null, [[1, 5]]);
    }));
    return function (_x, _x2) {
      return _ref7.apply(this, arguments);
    };
  }());
};

// Stop Playlist
musicManager.stopPlaylist = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
  var hideTimeout, volume, _loop, i;
  return _regenerator().w(function (_context9) {
    while (1) switch (_context9.n) {
      case 0:
        if (!_chapters.storyData.music.usingSystem) {
          _context9.n = 3;
          break;
        }
        // Playing Used
        if (_chapters.storyData.music.playing) {
          _chapters.storyData.music.playingUsed = true;
        }

        // Using System
        _chapters.storyData.music.usingSystem = false;

        // Hide Progress
        hideTimeout = 50;
        volume = _chapters.storyData.music.volume;
        _loop = /*#__PURE__*/_regenerator().m(function _loop(i) {
          return _regenerator().w(function (_context8) {
            while (1) switch (_context8.n) {
              case 0:
                if (_chapters.storyData.music.usingSystem) {
                  _context8.n = 1;
                  break;
                }
                _context8.n = 1;
                return new Promise(function (resolve) {
                  setTimeout(function () {
                    // Volume
                    volume--;

                    // Youtube Player
                    if (_chapters.storyData.youtube.player && typeof _chapters.storyData.youtube.player.setVolume === 'function') {
                      _chapters.storyData.youtube.player.setVolume(volume);
                    }
                    if (i === 100) {
                      // Youtube Player
                      if (_chapters.storyData.youtube.player) {
                        _chapters.storyData.youtube.player.stopVideo();
                      }
                    }
                    resolve();
                  }, hideTimeout);
                });
              case 1:
                return _context8.a(2);
            }
          }, _loop);
        });
        i = 0;
      case 1:
        if (!(i < 100)) {
          _context9.n = 3;
          break;
        }
        return _context9.d(_regeneratorValues(_loop(i)), 2);
      case 2:
        i++;
        _context9.n = 1;
        break;
      case 3:
        return _context9.a(2);
    }
  }, _callee8);
}));

// Start Playlist
musicManager.startPlaylist = function () {
  if (_chapters.storyData.readFic && (0, _objectHash["default"])(_chapters.storyData.music.playlist) !== (0, _objectHash["default"])(_chapters.storyData.music.playlistPlaying)) {
    // Check Status
    if (Array.isArray(_chapters.storyData.music.playlist) && _chapters.storyData.music.playlist.length > 0) {
      // Play Song
      (0, _tinyEssentials.shuffleArray)(_chapters.storyData.music.playlist);
      var playSong = function playSong() {
        if (typeof _chapters.storyData.music.now.index === 'number' && !isNaN(_chapters.storyData.music.now.index) && isFinite(_chapters.storyData.music.now.index) && _chapters.storyData.music.now.index > -1) {
          // Update Cache
          _chapters.storyData.music.playlistPlaying = _chapters.storyData.music.playlist;

          // Play
          var song = _chapters.storyData.music.playlist[_chapters.storyData.music.now.index];
          if (song && typeof song.id === 'string' && song.id.length > 0 && typeof song.type === 'string' && song.type.length > 0) {
            // Youtube
            if (song.type === 'youtube') {
              setTimeout(function () {
                _chapters.storyData.youtube.play(song.id);
              }, 100);
            }
          }
        }
      };

      // Exist
      if (_chapters.storyData.music.now.playlist === null || _chapters.storyData.music.now.index === -1 || _chapters.storyData.music.now.playlist !== _chapters.storyData.music.value) {
        // Fix Index
        if (_chapters.storyData.music.now.index < 0 || _chapters.storyData.music.now.playlist !== _chapters.storyData.music.value) {
          _chapters.storyData.music.now.index = 0;
        }

        // Now
        _chapters.storyData.music.now.playlist = _chapters.storyData.music.value;

        // Play
        playSong();
      }

      // Resume
      else if (_chapters.storyData.music.playingUsed) {
        if (_chapters.storyData.music.playingUsed) {
          playSong();
        }
        _chapters.storyData.music.playingUsed = false;
      }
    }

    // Check Data
    _chapters.storyData.music.usingSystem = true;
  }
};
var _default = exports["default"] = musicManager;

},{"../../../build/bundle/SeamlessLoop.mjs":2,"../../../build/bundle/buffaudio.mjs":4,"../../chapters/config.mjs":219,"../../files/chapters.mjs":222,"../../files/tinyLib.mjs":223,"../../gtag.mjs":224,"../../start.mjs":226,"../tts/tts.mjs":216,"jquery":97,"object-hash":106,"pizzicato":110,"tiny-essentials":181}],216:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _jquery = _interopRequireDefault(require("jquery"));
var _tinyLib = _interopRequireDefault(require("../../files/tinyLib.mjs"));
var _chapters = require("../../files/chapters.mjs");
var _updater = _interopRequireDefault(require("../updater.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// Base
_chapters.storyData.tts = {};
var ttsManager = {
  enabled: false,
  voicePreferenceList: ['Zira - English', 'English (USA,l03)', 'DEFAULT'],
  synth: window.speechSynthesis,
  voices: [],
  voice: null,
  lastLine: 0,
  ttsTimeout: null,
  queue: [],
  // Find Line
  findLine: function findLine(line) {
    var dontTryAgain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = _chapters.storyData.chapter.ficPageData.findIndex(function (item) {
      return line === item.line;
    });
    var ficData = _chapters.storyData.chapter.ficPageData[index];

    // Complete 1
    if (ficData || dontTryAgain || !Array.isArray(_chapters.storyData.chapter.ficPageData)) return ficData;

    // Try loop
    while (index < _chapters.storyData.chapter.ficPageData.length) {
      // Read data
      if (_chapters.storyData.chapter.ficPageData[index]) {
        var fcData = _chapters.storyData.chapter.ficPageData[index];
        // Check line and use it
        if (fcData.line >= line) return fcData;
      }

      // Next
      index++;
    }

    // Complete 2
    return null;
  },
  // Start tts base
  startBase: function startBase() {
    if (_chapters.storyData.nc.base.right.find('> #status #tts').length < 1) {
      // Buttons
      if (!_chapters.storyData.tts.nav) {
        _chapters.storyData.tts.nav = {};
      }
      _chapters.storyData.tts.nav.play = _tinyLib["default"].icon('fas fa-play');
      _chapters.storyData.tts.nav.stop = _tinyLib["default"].icon('fas fa-stop');

      // Prepare
      if (!_chapters.storyData.chapter.nav) {
        _chapters.storyData.chapter.nav = {};
      }
      _chapters.storyData.chapter.nav.tts = (0, _jquery["default"])('<div>', {
        indexItem: 1,
        "class": 'nav-item',
        id: 'tts'
      }).append((0, _jquery["default"])('<div>', {
        id: 'tts-player'
      }).append(
      // Play
      (0, _jquery["default"])('<a>', {
        href: 'javascript:void(0)',
        "class": 'text-white',
        title: 'Start TTS'
      }).on('click', function () {
        return ttsManager.enable();
      }).append(_chapters.storyData.tts.nav.play),
      // Stop
      (0, _jquery["default"])('<a>', {
        href: 'javascript:void(0)',
        "class": 'text-white',
        title: 'Stop TTS'
      }).on('click', function () {
        return ttsManager.disable();
      }).append(_chapters.storyData.tts.nav.stop)));

      // Insert
      _chapters.storyData.nc.base.right.find('> #status').prepend([
      // TTS
      _chapters.storyData.chapter.nav.tts]);
    }
    if (ttsManager.updatePlayer) {
      ttsManager.updatePlayer();
    }
    setInterval(ttsManager.updatePlayer, 100);
  },
  // Enable and disable
  enable: function enable() {
    ttsManager.enabled = true;
    _updater["default"].data(_chapters.storyData.chapter.line);
  },
  disable: function disable() {
    ttsManager.enabled = false;
    ttsManager.synth.cancel();
  },
  // Init data
  init: function init() {
    ttsManager.firstTime = false;
    // Get voices
    ttsManager.voices = ttsManager.synth.getVoices();
    if (ttsManager.voices.length === 0) {
      ttsManager.synth.onvoiceschanged = ttsManager.init;
      return;
    }
    var _iterator = _createForOfIteratorHelper(ttsManager.voicePreferenceList),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var preferenceString = _step.value;
        var _iterator2 = _createForOfIteratorHelper(ttsManager.voices),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var voice = _step2.value;
            var voiceName = voice.name.toLowerCase();
            var preference = preferenceString.toLowerCase();
            if (voiceName.indexOf(preference) !== -1) {
              // console.log("Found preferred voice " + voiceName);
              ttsManager.voice = voice;
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (ttsManager.voice !== null) {
          break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (ttsManager.voice === null) {
      // console.log("No preferred voice found, using first");
      ttsManager.voice = ttsManager.voices[0];
    }
  },
  // Read line
  readLine: function readLine(line) {
    // Nothing here
    if (!ttsManager.enabled) {
      return;
    }

    // Read line
    if (typeof line === 'number') {
      var ficData = ttsManager.findLine(line);
      if (ficData) {
        ttsManager.lastLine = (ficData === null || ficData === void 0 ? void 0 : ficData.line) || -1;
        ttsManager.lastLine++;
      } else {
        console.error('non-number passed to ttsManager.readLine in the new fic data');
        return;
      }
    } else {
      console.error('non-number passed to ttsManager.readLine');
      return;
    }
    ttsManager.synth.cancel();

    // Clear timeout
    if (ttsManager.ttsTimeout !== null) {
      clearTimeout(ttsManager.ttsTimeout);
      ttsManager.ttsTimeout = null;
    }

    // And add new timeout
    if (ttsManager.voice == null) {
      ttsManager.ttsTimeout = setTimeout(function () {
        ttsManager.readLine(line);
      }, 500);
      return;
    }
    ttsManager.ttsTimeout = setTimeout(function () {
      ttsManager.readLineInternal(line);
    }, 500);
  },
  // Next Utterance
  nextUtterance: function nextUtterance() {
    if (ttsManager.queue.length == 0) {
      var ficData = ttsManager.findLine(ttsManager.lastLine);
      if (ficData) _updater["default"].setActiveItem(ficData.line, true);
      return;
    }
    var text = ttsManager.queue.shift();
    var utterance = new SpeechSynthesisUtterance();
    utterance.voice = ttsManager.voice;
    utterance.text = text;
    utterance.onend = ttsManager.nextUtterance;
    ttsManager.synth.speak(utterance);
  },
  // Read line internal
  readLineInternal: function readLineInternal(line) {
    var _ttsManager$findLine;
    // Get data
    var data = ((_ttsManager$findLine = ttsManager.findLine(line)) === null || _ttsManager$findLine === void 0 ? void 0 : _ttsManager$findLine.content) || {};
    ttsManager.queue = [];

    // Read info
    if (data.info) {
      for (var _i = 0, _Object$keys = Object.keys(data.info); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        if (typeof cumulativeData.info[key] === 'undefined') {
          ttsManager.queue.push('Info ' + key + ': ' + _tinyLib["default"].removeAiTags(data.info[key]));
        }
      }
    }

    // Add action
    var actionString = data.type;
    if (data.flashback) actionString += ' flashback';
    if (data.character) actionString += ": ".concat(data.character);
    ttsManager.queue.push(actionString);
    ttsManager.queue.push(_tinyLib["default"].removeAiTags(data.value));

    // Execute voice
    ttsManager.nextUtterance();
  }
};
ttsManager.init();
var _default = exports["default"] = ttsManager;

},{"../../files/chapters.mjs":222,"../../files/tinyLib.mjs":223,"../updater.mjs":217,"jquery":97}],217:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _jquery = _interopRequireDefault(require("jquery"));
var _tinyEssentials = require("tiny-essentials");
var _tinyLib = _interopRequireDefault(require("../files/tinyLib.mjs"));
var _chapters = require("../files/chapters.mjs");
var _config = _interopRequireDefault(require("../chapters/config.mjs"));
var _start = require("../start.mjs");
var _tts = _interopRequireDefault(require("./tts/tts.mjs"));
var _index = _interopRequireDefault(require("./music/index.mjs"));
var _gtag = _interopRequireDefault(require("../gtag.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// Prepare Cache
var cacheChapterUpdater = {
  soundCache: {}
};
cacheChapterUpdater.setActiveItem = function (item) {
  var scrollIntoView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (cacheChapterUpdater.locked) {
    return;
  }

  // Validator
  if (_chapters.storyData.chapter.selected > 0) {
    var selectedItem = Number(item);
    var currentLine = _chapters.storyData.chapter.line;
    if (currentLine == selectedItem) {
      return;
    }
    var element = document.querySelector("tr[line=\"".concat(selectedItem, "\"]"));
    if (element == null) {
      // Todo: handle correctly
      if (selectedItem > currentLine) {
        document.querySelector('a[title="Go to next page"]').click();
      } else if (selectedItem < currentLine) {
        document.querySelector('a[title="Go to previous page"]').click();
      }
      return;
    }
    if (scrollIntoView) {
      cacheChapterUpdater.locked = true;
      winScroller.doAfterScroll(function () {
        cacheChapterUpdater.locked = false;
      });
      var scrollTarget = document.querySelector("tr[line=\"".concat(selectedItem - 1, "\"]"));
      if (scrollTarget == null) {
        scrollTarget = document.getElementById('markdown-read');
      }
      scrollTarget.scrollIntoView();
    }

    // Complete
    cacheChapterUpdater.data(selectedItem);
  }
};

// Read Data on Scroll
var winScroller = new _tinyEssentials.TinyAfterScrollWatcher(window);
(0, _jquery["default"])(window).on('resize scroll', function () {
  if (_tts["default"].enabled) {
    return;
  }
  // Validator
  if (_chapters.storyData.chapter.selected > 0) {
    // Selected Item
    var selectedItem = 0;

    // Normal Mode
    if (!_tinyEssentials.TinyHtml.isPageBottom()) {
      var mdNavbar = (0, _jquery["default"])('#md-navbar').get(0);
      // Detect Selected Item
      for (var item in _chapters.storyData.chapter.html) {
        var tinyItem = _chapters.storyData.chapter.html[item].get(0);
        if (_tinyEssentials.TinyHtml.isInViewport(tinyItem) && !_tinyEssentials.TinyHtml.isCollWith(tinyItem, mdNavbar)) {
          selectedItem = Number(item);
          break;
        }
      }
    }

    // Bottom Page
    else {
      for (var _item in _chapters.storyData.chapter.html) {
        selectedItem = Number(_item);
      }
    }

    // Complete
    cacheChapterUpdater.setActiveItem(selectedItem);
  }
});
cacheChapterUpdater.scrollData = function () {
  // Set Playlist
  if (Array.isArray(_chapters.storyData.music.playlist)) {
    _index["default"].disable(false);
  } else {
    _chapters.storyData.music.playlist = [];
  }

  // Exist Playlist
  if (!_chapters.storyData.chapter.blockLineSave && !_chapters.storyData.music.disabled && Array.isArray(_chapters.storyData.music.playlist) && _chapters.storyData.music.playlist.length > 0) {
    _index["default"].startPlaylist();
  }

  // Nope
  else {
    _index["default"].stopPlaylist();
  }

  // Google
  if (!_chapters.storyData.chapter.blockLineSave && typeof _config["default"].gtag === 'string' && _gtag["default"]) {
    (0, _gtag["default"])('event', 'chapter', {
      event_chapter: "Chapter ".concat(_chapters.storyData.chapter.selected),
      event_category: 'line',
      event_line: _chapters.storyData.chapter.line
    });
  }

  // Remove All Weather
  var removeAllWeather = function removeAllWeather() {
    _chapters.storyData.sfx['heavy-rain'].hide();
    _chapters.storyData.sfx['heavy-rain-little-thunder'].hide();
  };

  // Set Weather
  var oldWeather = _chapters.storyData.chapter.weather;
  _chapters.storyData.chapter.weather = _chapters.storyData.chapter.nextWeather;

  // Change Sound
  if (oldWeather !== _chapters.storyData.chapter.weather) {
    removeAllWeather();
    if (!_chapters.storyData.chapter.blockLineSave) {
      if (_chapters.storyData.chapter.weather === 'heavyrain') {
        _chapters.storyData.sfx['heavy-rain'].show();
      } else if (_chapters.storyData.chapter.weather === 'bolt') {
        _chapters.storyData.sfx['heavy-rain-little-thunder'].show();
      }
    }
  }

  // Manager Other Sounds
  for (var file in cacheChapterUpdater.soundCache) {
    // Value Data
    var value = cacheChapterUpdater.soundCache[file].value;
    if (cacheChapterUpdater.soundCache[value.file].waiting) {
      // Progress
      cacheChapterUpdater.soundCache[value.file].waiting = false;

      // Play
      if (!_chapters.storyData.chapter.blockLineSave && value.enabled && !cacheChapterUpdater.soundCache[value.file].playing) {
        console.log("[".concat(value.file, "] Playing..."));
        cacheChapterUpdater.soundCache[value.file].playing = true;
        if (!value.instant) {
          _chapters.storyData.sfx[value.file].show();
        } else {
          _chapters.storyData.sfx[value.file].play();
        }
      }

      // Stop
      else if (!value.enabled && cacheChapterUpdater.soundCache[value.file].playing) {
        console.log("[".concat(value.file, "] Stopping..."));
        cacheChapterUpdater.soundCache[value.file].playing = false;
        if (!value.instant) {
          _chapters.storyData.sfx[value.file].hide();
        } else {
          _chapters.storyData.sfx[value.file].stop();
        }
      }
    }
  }
};

// Update Cache
cacheChapterUpdater.data = function (lastPage) {
  if (_chapters.storyData.chapter.selected > 0) {
    (0, _jquery["default"])('.selected-tr').removeClass('selected-tr');
    var element = document.querySelector("tr[line=\"".concat(lastPage, "\"]"));
    if (element) {
      element.classList.add('selected-tr');
    }

    // Call text to speech manager - only reads if it's been enabled
    _tts["default"].startBase();
    if (_chapters.storyData.chapter.ficPageData) {
      var tinyData = _chapters.storyData.chapter.ficPageData.find(function (ficData) {
        return ficData.line === Number(lastPage);
      });
      var ttsIndex = tinyData.line || -1;
      if (ttsIndex > -1) _tts["default"].readLine(ttsIndex);
    }

    // Update Data Cache
    _index["default"].startBase();
    _chapters.storyData.chapter.line = lastPage;
    var data = _chapters.storyData.data[_chapters.storyData.chapter.selected];
    if (!_chapters.storyData.chapter.blockLineSave) {
      for (var i in data) {
        // Get Data
        if (data[i].set) {
          for (var item in data[i].set) {
            if (typeof chapterSet[item] === 'function') {
              chapterSet[item](data[i].set[item], i < lastPage);
            }
          }
        }
      }
    }

    // Update Checker Data
    if (typeof cacheChapterUpdater.timeoutChecker !== 'undefined') {
      clearTimeout(cacheChapterUpdater.timeoutChecker);
      delete cacheChapterUpdater.timeoutChecker;
    }
    cacheChapterUpdater.timeoutChecker = setTimeout(function () {
      cacheChapterUpdater.scrollData();
    }, 1000);

    // Add Bookmark
    if (_chapters.storyData.nc.base.right.find('> #status #bookmark').length < 1) {
      // Insert
      if (!_chapters.storyData.chapter.nav) {
        _chapters.storyData.chapter.nav = {};
      }
      _chapters.storyData.chapter.nav.bookmark = (0, _jquery["default"])('<a>', {
        indexItem: 2,
        "class": 'nav-item nav-link',
        id: 'bookmark'
      });
      _chapters.storyData.nc.base.right.find('> #status').prepend(_chapters.storyData.chapter.nav.bookmark);

      // Icon
      _chapters.storyData.chapter.nav.bookmark.css({
        cursor: 'pointer'
      });
      _chapters.storyData.chapter.nav.bookmark.attr('title', 'Bookmark').append(_tinyLib["default"].icon('fas fa-bookmark'));
      _chapters.storyData.chapter.nav.bookmark.tooltip();

      // Action
      _chapters.storyData.chapter.nav.bookmark.on('click', function () {
        _tinyLib["default"].modal({
          title: (0, _jquery["default"])('<span>').text('Bookmark'),
          body: (0, _jquery["default"])('<center>').append((0, _jquery["default"])('<h5>').text("Save this URL to your favorites to re-read the story on any device"), (0, _jquery["default"])('<input>', {
            type: 'text',
            "class": 'form-control text-center'
          }).prop('readonly', true).val("".concat(location.protocol, "//").concat(location.host, "/?path=read-fic&chapter=").concat(_chapters.storyData.chapter.selected, "&line=").concat(_chapters.storyData.chapter.line)).on('click', function () {
            (0, _jquery["default"])(this).select();
          })),
          dialog: 'modal-lg'
        });
      });
    }
    if (!_chapters.storyData.chapter.blockLineSave) {
      _chapters.storyData.chapter.nav.bookmark.removeClass('disabled');
      _chapters.storyData.chapter.nav.bookmark.prop('disabled', false);
    } else {
      _chapters.storyData.chapter.nav.bookmark.addClass('disabled');
      _chapters.storyData.chapter.nav.bookmark.prop('disabled', true);
    }

    // Sortable  #status
    _chapters.storyData.nc.base.right.each(function () {
      (0, _jquery["default"])(this).find('#status > a').sort(function (a, b) {
        return Number((0, _jquery["default"])(a).attr('indexitem')) - Number((0, _jquery["default"])(b).attr('indexitem'));
      }).appendTo((0, _jquery["default"])(this).find('#status'));
    });

    // Update Title
    if (!_chapters.storyData.chapter.blockLineSave) {
      _start.tinyLs.setItem('bookmark' + _chapters.storyData.chapter.selected, _chapters.storyData.chapter.line);
      _chapters.storyData.chapter.bookmark[_chapters.storyData.chapter.selected] = _chapters.storyData.chapter.line;
    }
    var infoInsert = "Chapter ".concat(_chapters.storyData.chapter.selected, " / Line ").concat(_chapters.storyData.chapter.line);
    (0, _jquery["default"])('#fic-chapter').text(infoInsert);
    document.title = "".concat(_chapters.storyData.title, " - ").concat(infoInsert);
  }
};

// Set Actions
var chapterSet = {
  playEffect: function playEffect(value) {
    var actionFromNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (actionFromNow && value && value.file && _chapters.storyData.sfx[value.file]) {
      if (!cacheChapterUpdater.soundCache[value.file]) {
        cacheChapterUpdater.soundCache[value.file] = {
          playing: false
        };
      }
      cacheChapterUpdater.soundCache[value.file].waiting = true;
      cacheChapterUpdater.soundCache[value.file].value = value;
    }
  },
  playlistPlay: function playlistPlay(value) {
    var actionFromNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (actionFromNow) {
      // Set Playlist
      var playlist = _config["default"].playlist[value];
      if (Array.isArray(playlist)) {
        _chapters.storyData.music.value = value;
        _chapters.storyData.music.playlist = playlist;
      } else {
        _chapters.storyData.music.value = null;
        _chapters.storyData.music.playlist = [];
      }
    }
  },
  day: function day(value) {
    var actionFromNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (actionFromNow) {
      // Add Item Base
      if (_chapters.storyData.nc.base.right.find('> #status #day').length < 1) {
        if (!_chapters.storyData.chapter.nav) {
          _chapters.storyData.chapter.nav = {};
        }
        _chapters.storyData.chapter.nav.day = (0, _jquery["default"])('<a>', {
          indexItem: 5,
          "class": 'nav-item nav-link',
          id: 'day'
        });
        _chapters.storyData.nc.base.right.find('> #status').prepend(_chapters.storyData.chapter.nav.day);
      }
      _chapters.storyData.nc.base.right.find('> #status #day').text("Day: ".concat(value));
    }
  },
  dayNightCycle: function dayNightCycle(value) {
    var actionFromNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (actionFromNow) {
      (0, _jquery["default"])('body').removeClass("fic-daycicle-morning").removeClass("fic-daycicle-evening").removeClass("fic-daycicle-night").removeClass("fic-daycicle-lateAtNight").addClass("fic-daycicle-".concat(value));

      // Add Item Base
      if (_chapters.storyData.nc.base.right.find('> #status #dayNightCycle').length < 1) {
        if (!_chapters.storyData.chapter.nav) {
          _chapters.storyData.chapter.nav = {};
        }
        _chapters.storyData.chapter.nav.dayNightCycle = (0, _jquery["default"])('<a>', {
          indexItem: 4,
          "class": 'nav-item nav-link',
          id: 'dayNightCycle'
        });
        _chapters.storyData.nc.base.right.find('> #status').prepend(_chapters.storyData.chapter.nav.dayNightCycle);
      }

      // Types
      var types = {
        morning: {
          icon: 'fas fa-sun',
          title: 'Morning'
        },
        evening: {
          icon: 'fas fa-cloud-sun',
          title: 'Evening'
        },
        night: {
          icon: 'fas fa-moon',
          title: 'Night'
        },
        lateAtNight: {
          icon: 'fas fa-bullseye',
          title: 'Late at Night'
        }
      };
      var obj = _chapters.storyData.nc.base.right.find('> #status #dayNightCycle');
      obj.empty();
      if (types[value]) {
        var newTitle = types[value].title;
        if (!obj.data('bs-tooltip-data')) {
          obj.attr('title', newTitle);
          obj.data('bs-tooltip-data', newTitle);
          obj.tooltip();
        } else {
          obj.data('bs-tooltip-data', newTitle).data('bs-tooltip').setContent({
            '.tooltip-inner': newTitle
          });
        }
        obj.removeAttr('title').append(_tinyLib["default"].icon(types[value].icon));
      }
    }
  },
  weather: function weather(value) {
    var actionFromNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (actionFromNow) {
      // Add Item Base
      if (_chapters.storyData.nc.base.right.find('> #status #weather').length < 1) {
        if (!_chapters.storyData.chapter.nav) {
          _chapters.storyData.chapter.nav = {};
        }
        _chapters.storyData.chapter.nav.weather = (0, _jquery["default"])('<a>', {
          indexItem: 3,
          "class": 'nav-item nav-link',
          id: 'weather'
        });
        _chapters.storyData.nc.base.right.find('> #status').prepend(_chapters.storyData.chapter.nav.weather);
      }

      // Types
      var types = {
        rain: {
          icon: 'fas fa-cloud-rain',
          title: 'Rain'
        },
        bolt: {
          icon: 'fas fa-bolt',
          title: 'Thunderbolt'
        },
        heavyrain: {
          icon: 'fas fa-cloud-showers-heavy',
          title: 'Heavy Rain'
        },
        snow: {
          icon: 'fas fa-snowflake',
          title: 'Snow'
        }
      };
      _chapters.storyData.chapter.nextWeather = value;
      var obj = _chapters.storyData.nc.base.right.find('> #status #weather');
      obj.empty();
      if (types[value]) {
        obj.attr('title', types[value].title).append(_tinyLib["default"].icon(types[value].icon));
        obj.tooltip();
        obj.removeAttr('title');
      }
    }
  },
  where: function where(value) {
    var actionFromNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (actionFromNow) {
      // Add Item Base
      if (_chapters.storyData.nc.base.right.find('> #status #where').length < 1) {
        if (!_chapters.storyData.chapter.nav) {
          _chapters.storyData.chapter.nav = {};
        }
        _chapters.storyData.chapter.nav.where = (0, _jquery["default"])('<a>', {
          indexItem: 6,
          "class": 'nav-item nav-link',
          id: 'where'
        });
        _chapters.storyData.nc.base.right.find('> #status').prepend(_chapters.storyData.chapter.nav.where);
      }
      _chapters.storyData.nc.base.right.find('> #status #where').text("Location: ".concat(value));
    }
  }
};
var _default = exports["default"] = cacheChapterUpdater;

},{"../chapters/config.mjs":219,"../files/chapters.mjs":222,"../files/tinyLib.mjs":223,"../gtag.mjs":224,"../start.mjs":226,"./music/index.mjs":215,"./tts/tts.mjs":216,"jquery":97,"tiny-essentials":181}],218:[function(require,module,exports){
"use strict";

var _config = _interopRequireDefault(require("./config.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
if (!_config["default"].custom_url) {
  _config["default"].custom_url = {};
}
_config["default"].characters = {
  rayane: {
    path: '/data/characters/rayane/README.md',
    url: '/characters/rayane.html',
    title: 'Rayane',
    description: "Rayane is one of Pony Driland's most mysterious ponies. There are many legends about her role and why she is always spying on other ponies. What is known is that she is a talented swordsman and she has some spells that are considered extremely rare in Pony Driland like Teleport and regeneration magic."
  },
  'rainbow-queen': {
    path: '/data/characters/rainbow-queen/README.md',
    url: '/characters/rainbow-queen.html',
    title: 'Rainbow Queen',
    description: 'The giant Sphinx goddess of darkness from Pony Driland. The one that takes care of all the darkness of the dimension. Also responsible for dimension energy and life-death passage.'
  },
  prisma: {
    path: '/data/characters/prisma/README.md',
    url: '/characters/prisma.html',
    title: 'Prisma',
    description: "One of the oldest unicorns in all Pony Driland. She's story has a direct involvement with the Royal Color. She is one of the closest ponies to the Rainbow Queen within the Royal Color family."
  },
  'princess-ariella': {
    path: '/data/characters/princess-ariella/README.md',
    url: '/characters/princess-ariella.html',
    title: 'Princess Ariella',
    description: 'Ariella was the first princess of her kingdom founded by her. she has a pure heart and loves all of her creation and her kingdom very much. For her, the lives of everyone in her kingdom matters a lot. Her determination to make the kingdom a better place is extremely high. She could sacrifice herself if necessary just to save her kingdom life.'
  },
  layla: {
    path: '/data/characters/layla/README.md',
    url: '/characters/layla.html',
    title: 'Layla',
    description: "Layla is one of Rainbow Queen's pets. Her sweet personality was a result of past events of her accidentally going to Pony Driland. Like Amy... Her accident happened right during her childhood when she ran away from home, which made it impossible for her to grow like the other ponies, and she ended up spending the rest of her childhood struggling to survive on her own until she became an adult."
  },
  james: {
    path: '/data/characters/james/README.md',
    url: '/characters/james.html',
    title: 'James',
    description: "James is one of the scientists responsible for developing the source code that helped create the Pony Driland dimension. James' journey involves discovering what happened to the dimension, while sadly suffering from the loss of his original dimension."
  },
  aniya: {
    path: '/data/characters/aniya/README.md',
    url: '/characters/aniya.html',
    title: 'Aniya',
    description: 'The mysterious gypsy pony of Blackburn Village.'
  },
  amy: {
    path: '/data/characters/amy/README.md',
    url: '/characters/amy.html',
    title: 'Amy',
    description: "Amy is one of Rainbow Queen's pets. Her sweet personality was a result of past events of her accidentally going to Pony Driland. Her accident happened right during her childhood when she ran away from home, which made it impossible for her to grow like the other ponies, and she ended up spending the rest of her childhood struggling to survive on her own until she became an adult."
  },
  'npc/unicorn-soldier': {
    path: '/data/characters/npc/unicorn-soldier/README.md',
    url: '/characters/npc/unicorn-soldier.html'
  },
  'npc/sniper': {
    path: '/data/characters/npc/sniper/README.md',
    url: '/characters/npc/sniper.html'
  },
  'npc/signed': {
    path: '/data/characters/npc/signed/README.md',
    url: '/characters/npc/signed.html'
  },
  'npc/salespony': {
    path: '/data/characters/npc/salespony/README.md',
    url: '/characters/npc/salespony.html'
  },
  'npc/random-female-pony': {
    path: '/data/characters/npc/random-female-pony/README.md',
    url: '/characters/npc/random-female-pony.html'
  },
  'npc/pony': {
    path: '/data/characters/npc/pony/README.md',
    url: '/characters/npc/pony.html'
  },
  'npc/machinist-pony': {
    path: '/data/characters/npc/machinist-pony/README.md',
    url: '/characters/npc/machinist-pony.html'
  },
  'npc/letter': {
    path: '/data/characters/npc/letter/README.md',
    url: '/characters/npc/letter.html'
  },
  'npc/hospital-attendant': {
    path: '/data/characters/npc/hospital-attendant/README.md',
    url: '/characters/npc/hospital-attendant.html'
  },
  'npc/gypsy': {
    path: '/data/characters/npc/gypsy/README.md',
    url: '/characters/npc/gypsy.html'
  },
  'npc/guard': {
    path: '/data/characters/npc/guard/README.md',
    url: '/characters/npc/guard.html'
  },
  'npc/guard-951': {
    path: '/data/characters/npc/guard-951/README.md',
    url: '/characters/npc/guard-951.html'
  },
  'npc/guard-4': {
    path: '/data/characters/npc/guard-4/README.md',
    url: '/characters/npc/guard-4.html'
  },
  'npc/guard-3': {
    path: '/data/characters/npc/guard-3/README.md',
    url: '/characters/npc/guard-3.html'
  },
  'npc/guard-2': {
    path: '/data/characters/npc/guard-2/README.md',
    url: '/characters/npc/guard-2.html'
  },
  'npc/guard-1': {
    path: '/data/characters/npc/guard-1/README.md',
    url: '/characters/npc/guard-1.html'
  },
  'npc/female-unicorn': {
    path: '/data/characters/npc/female-unicorn/README.md',
    url: '/characters/npc/female-unicorn.html'
  },
  'npc/employee': {
    path: '/data/characters/npc/employee/README.md',
    url: '/characters/npc/employee.html'
  },
  'npc/doctor': {
    path: '/data/characters/npc/doctor/README.md',
    url: '/characters/npc/doctor.html'
  },
  'npc/delivery-boy': {
    path: '/data/characters/npc/delivery-boy/README.md',
    url: '/characters/npc/delivery-boy.html'
  },
  'npc/cashier': {
    path: '/data/characters/npc/cashier/README.md',
    url: '/characters/npc/cashier.html'
  }
};
for (var item in _config["default"].characters) {
  _config["default"].custom_url[_config["default"].characters[item].path] = {
    url: _config["default"].characters[item].url,
    title: _config["default"].characters[item].title
  };
}

},{"./config.mjs":219}],219:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var storyCfg = {
  // Twitter
  twitter: {
    username: 'JasminDreasond'
  },
  // Donation
  patreon: 'JasminDreasond',
  kofi: 'JasminDreasond',
  dogecoin: {
    address: 'DJn9GGPYsQSGTi6bHDhfgtUpmivBEnDiMK',
    explorer: 'https://dogechain.info/address/'
  },
  bitcoin: {
    address: 'bc1qnk7upe44xrsll2tjhy5msg32zpnqxvyysyje2g',
    explorer: 'https://www.blockchain.com/btc/address/'
  },
  ethereum: {
    address: '0x98d4dC931122118B0fabBaDd5bfF443CeF4E2041',
    explorer: 'https://etherscan.io/address/'
  },
  bnb: {
    address: '0x98d4dC931122118B0fabBaDd5bfF443CeF4E2041',
    explorer: 'https://bscscan.com/address/'
  },
  polygon: {
    address: '0x98d4dC931122118B0fabBaDd5bfF443CeF4E2041',
    explorer: 'https://polygonscan.com/address/'
  },
  // Info
  mastodon: {
    domain: 'equestria.social',
    username: 'JasminDreasond'
  },
  // Info
  mirror: ['ponydriland.jimm.horse'],
  gtag: 'G-PS1R5G3G50',
  domain: 'ponydriland.com',
  itemsPerPage: 100,
  title: 'Pony Driland',
  derpibooru_tag: 'pony+driland',
  blog_url: 'https://blog.ponydriland.com/',
  discordInvite: 'sSkysVtj7y',
  description: 'The dimension of lost creatures and the home of hope.',
  urlPage: null,
  defaultLang: 'en',
  lang: ['en'],
  defaultYoutubeVolume: 100,
  year: 2021,
  news: {
    rss: '',
    url: ''
  },
  contact: 'tiny@ponydriland.com',
  creator: 'Yasmin Seidel (JasminDreasond)',
  creator_url: 'https://jasmindreasond.pony.house',
  github: {
    account: 'Pony-Driland',
    repository: 'Website'
  },
  ageRating: 'teen',
  tags: ['fanfic', 'fic', 'pony', 'driland', 'adventure', 'action', 'drama', 'comedy', 'fantasy violence', 'intense violence', 'strong language', 'animated blood', 'horror', 'pony driland'],
  // Theme
  theme: {
    primary: '#a91126',
    secondary: '#612c36',
    color: '#fff',
    color2: '#e0e0e0',
    color3: 'rgba(255, 255, 255, 0.6)',
    color4: '#5e5e5e'
  },
  noNsfw: ['UK', 'GB'],
  // Mature Content Config (You can freely add as many NSFW filters as you like.)
  nsfw: {
    vore: {
      size: 12,
      aiMsg: true,
      name: 'Vore',
      description: 'The scale of this content is small to medium. The vore elements are tied to characters for whom this behavior makes narrative sense. By continuing, you acknowledge that you may encounter scenes some audiences could find unsettling or eerie. Disabling this content will not affect the main story. The censored version will simply skip these parts with a brief summary, focusing on essential information for understanding the plot â though some optional canonical details may be missed.'
    },
    questionable: {
      size: 6,
      aiMsg: true,
      name: 'Questionable',
      description: 'The scale of this content is small. There is no sexually explicit material in the story, but some brief scenes may include questionable content. Disabling this option will skip optional scenes or display censored dialogue instead.'
    },
    extreme_violence: {
      size: 6,
      aiMsg: true,
      name: 'Extreme Violence',
      description: 'Some battle scenes may contain details that are uncomfortable or potentially nauseating for some readers. Disabling this option will reduce the level of violence in the story. Enable at your own risk â I am not responsible for your choices.'
    }
  },
  // Chapters
  chapterName: {
    1: {
      color: '#000',
      title: 'This is not my world',
      description: "The protagonist's early days in the world of Pony Driland. Something mysterious has happened and we need to discover the basics about this mysterious place."
    },
    2: {
      color: '#000',
      title: 'She hates war',
      description: "We have just discovered a mysterious war with some mysterious objective. Maybe she's not feeling comfortable about it."
    },
    3: {
      color: '#000',
      title: 'They needs help',
      description: 'These ponies need your help. But at the cost of what consequences?'
    }
  },
  // Word Blacklist
  wordCountBlacklick: [],
  // IPFS
  ipfs: {
    host: 'https://cloudflare-ipfs.com/ipfs/{cid}',
    files: {}
  },
  // Ar-Io
  ario: {
    host: 'https://ar-io.dev/{cid}',
    files: {
      '/img/characters/amy/ref.jpg': 'AZhBxGQ1gbgLVp7RDlBqAG-ky37BcwIGIOLXW15Tn9c',
      '/img/characters/amy/wip-collar.jpg': 'F2VfXQrr0UK39bSMSp5M1P0riNeZ5fFE2BE0qh73dmk',
      '/img/characters/beta/aniya/image.png': 'LLZaY7dCEbMPxBig_EYMDj8GbQX5vyVZh6eJ31wmOow',
      '/img/characters/beta/james/old/image.png': '3ReqC2QPg6RpVM508FVjWEBBgxI3hrfkG8YMHUypWGY',
      '/img/characters/rayane/ref.png': 'u4NBTOjArg3WdOoUXft6jbo13q6yNa9D14Zu_hZGUCc',
      '/img/characters/rainbow-queen/ref-dark.jpg': 'Y4r5XCLaD3uXMNvCeENDrBaEBbESu5KLXai7bC5kqRw',
      '/img/characters/rainbow-queen/wip/ref-1.gif': '2l2dbZxB292CsGBi7-1qtPTXvvjCRmYQiauD1LahdB4',
      '/img/characters/rainbow-queen/ref-dark.webp': '0SyvCKcKbsVSxaEW3DGl6D-EKjlJJCT36wjkLO8htok',
      '/img/gallery/chapter1-gift.jpg': 'VtXS4VqRDljlQdVtE5gTaQQyR2bPuOv-YDK6AQ4xF_k',
      '/img/characters/rainbow-queen/scythe.gif': 'EGwe6QEqi2PP2bhJP1OcXj_QZOC_Gwin20b9DiC83sk',
      '/img/characters/whistler/wip/headshot.png': 'vm8s0QOvBKAmOyUq5Nf6iFo9ybaEq8-Qg7z_co2oW_M',
      '/img/characters/blue-screen/ref.jpg': '5og2tDBMNV0EwLBZcRA6bwytRJDJDXK76DVvrz0XDBk',
      '/img/characters/princess-ariella/ref.png': 'LHFvTaQPlHbDnc4vM_xLQ0LWH8ypdqtSccgApjFatq8',
      '/img/characters/prisma/old/ref.jpg': 'HD4luK_pU20Xwe1SM6em0h9-5DI_h2wSgdQTBbXj8y8',
      '/img/characters/layla/ref.jpg': 'shHPlacMUy7JWHqNO0GQPZitOyDdFFv7UsgktT69c1A'
    }
  }
};
var _default = exports["default"] = storyCfg;

},{}],220:[function(require,module,exports){
"use strict";

var _config = _interopRequireDefault(require("./config.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
_config["default"].chapters = 3;

},{"./config.mjs":219}],221:[function(require,module,exports){
"use strict";

var _config = _interopRequireDefault(require("./config.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// Playlist
_config["default"].playlist = {
  'ivy-resurrection': [{
    id: 'ZY1kKMUWgh4',
    type: 'youtube'
  }, {
    id: '44A0UTwoCsg',
    type: 'youtube'
  }],
  'Subway battle - c2': [{
    id: 'EMeOm0-4Ptk',
    type: 'youtube'
  }, {
    id: 'w0XK0cuaK3A',
    type: 'youtube'
  }],
  'Subway battle 2 - c2': [{
    id: 'w0XK0cuaK3A',
    type: 'youtube'
  }, {
    id: 'gC8bNltkzbA',
    type: 'youtube'
  }],
  'madoka-magica-magiaãMetal/Male Coverã': [{
    id: 'FhhbYF8JANg',
    type: 'youtube'
  }],
  'songs-for-an-empty-world': [{
    id: 'f1tYe3TkhTc',
    type: 'youtube'
  }],
  'an-antagonistic-battle': [{
    id: 'AhpvfGJ81n4',
    type: 'youtube'
  }],
  dramatic: [{
    id: 'i1IUSdcauC8',
    type: 'youtube'
  }, {
    id: '1XmMTRD_zys',
    type: 'youtube'
  }],
  'suspenseful-ambient': [{
    id: '6_Na6QaG0c4',
    type: 'youtube'
  }, {
    id: 'fFJHAbeQ0g4',
    type: 'youtube'
  }],
  forest: [{
    id: '3yxG4k9uni4',
    type: 'youtube'
  }, {
    id: 'pI_JSnJMnY4',
    type: 'youtube'
  }, {
    id: 'gvbvkqpM9C8',
    type: 'youtube'
  }],
  'spooky-mysterious': [{
    id: 'm6e_Uz6vlJw',
    type: 'youtube'
  }, {
    id: 'XUUM0cKcRW0',
    type: 'youtube'
  }, {
    id: 'eaEbST63kk0',
    type: 'youtube'
  }],
  'dark-ambient-melodies': [{
    id: '6r3xpB6Td40',
    type: 'youtube'
  }, {
    id: 'lAarDAnoXk0',
    type: 'youtube'
  }, {
    id: 'LptTKfrHSi4',
    type: 'youtube'
  }],
  silly: [{
    id: 'ljTfHitG0eA',
    type: 'youtube'
  }, {
    id: '5Im8S1l3UK0',
    type: 'youtube'
  }],
  'relaxing-rpg-song': [{
    id: 'l6veMGLpol0',
    type: 'youtube'
  }],
  escape: [{
    id: '3jw04mIF3fs',
    type: 'youtube'
  }, {
    id: '_j8jUUzGqDo',
    type: 'youtube'
  }, {
    id: 'FaKRXOgasXA',
    type: 'youtube'
  }],
  battle: [{
    id: 'VMziMXYkVS0',
    type: 'youtube'
  }, {
    id: 'rjRn9lYguV0',
    type: 'youtube'
  }, {
    id: 'yb0-hwJAX3U',
    type: 'youtube'
  }, {
    id: 'XD72-Y5aB9Q',
    type: 'youtube'
  }],
  'Tense Negotiations | D&D/TTRPG Music | 1 Hour': [{
    id: 'RPkHu8M_U4c',
    type: 'youtube'
  }],
  'drama-battle': [{
    id: '04_v0iVxCHo',
    type: 'youtube'
  }, {
    id: '9HvVidW5N6w',
    type: 'youtube'
  }, {
    id: 'GRoIRQEI1W8',
    type: 'youtube'
  }, {
    id: '2SsRDysiIlk',
    type: 'youtube'
  }],
  happyness: [{
    id: 'AVxQSpnR7g8',
    type: 'youtube'
  }, {
    id: 'uFKo2LYu2Zg',
    type: 'youtube'
  }],
  'tech-problem': [{
    id: 'bGdD0YVh_kI',
    type: 'youtube'
  }],
  'fantasy-village': [{
    id: 'kKObUC_3NDY',
    type: 'youtube'
  }, {
    id: 'HFoGnJ_w4pQ',
    type: 'youtube'
  }, {
    id: 'uIbAzScUwec',
    type: 'youtube'
  }],
  calm: [{
    id: '6wmRYL5ZdlM',
    type: 'youtube'
  }, {
    id: 'mxcu9L9j8ww',
    type: 'youtube'
  }, {
    id: 'dZR7M7gDNSc',
    type: 'youtube'
  }, {
    id: '7Uyu5BrGMs4',
    type: 'youtube'
  }, {
    id: 'TOEiLlspdhM',
    type: 'youtube'
  }, {
    id: '3VoGUhPwagI',
    type: 'youtube'
  }, {
    id: 'uU4VgCWuAxE',
    type: 'youtube'
  }, {
    id: 'dx0YwqEue_M',
    type: 'youtube'
  }, {
    id: 'XYoTrKYkk1w',
    type: 'youtube'
  }, {
    id: 'nl4zbChDJsM',
    type: 'youtube'
  }, {
    id: 'roABNwbjZf4',
    type: 'youtube'
  }],
  'Darkanger-Ghost-Town': [{
    id: 'Q45IHLOtb9I',
    type: 'youtube'
  }, {
    id: 'UqDwrQhDQgY',
    type: 'youtube'
  }, {
    id: 'O1BZ00XboJE',
    type: 'youtube'
  }],
  memories: [{
    id: 'c-MCbeEIEfw',
    type: 'youtube'
  }, {
    id: 'Cste0PD-Xt4',
    type: 'youtube'
  }, {
    id: 'A7DE3BXdPsA',
    type: 'youtube'
  }, {
    id: 'B4hVK3TYf7M',
    type: 'youtube'
  }],
  'Cursed Lands Ambience': [{
    id: '5DOnEnzIO9o',
    type: 'youtube'
  }],
  'songs-for-an-dying-world': [{
    id: 'f1tYe3TkhTc',
    type: 'youtube'
  }],
  'dark-and-mysterious-ambient': [{
    id: 'yEYxnJB4jZs',
    type: 'youtube'
  }],
  'INFINITY - Epic Futuristic Music Mix | Atmospheric Sci-Fi Music': [{
    id: '4F7sdy2rZws',
    type: 'youtube'
  }],
  'tense-find-subway-c2': [{
    id: 'bGdD0YVh_kI',
    type: 'youtube'
  }, {
    id: 'VQ9230-OoBw',
    type: 'youtube'
  }, {
    id: 'fFJHAbeQ0g4',
    type: 'youtube'
  }, {
    id: 'tg7IqHcnVbg',
    type: 'youtube'
  }],
  'marlon-battle-1': [{
    id: '4BV4oWmhAyI',
    type: 'youtube'
  }, {
    id: 'QwPiELmMFXs',
    type: 'youtube'
  }, {
    id: 'qlamVb0VMmU',
    type: 'youtube'
  }],
  'tense-mystery': [{
    id: 'YLrJPBbAQoY',
    type: 'youtube'
  }, {
    id: 'gzQzViNj5go',
    type: 'youtube'
  }, {
    id: 'Nziqug75Gn4',
    type: 'youtube'
  }, {
    id: '7dKxHERhaLE',
    type: 'youtube'
  }, {
    id: 'QNwjH5EKTTQ',
    type: 'youtube'
  }, {
    id: '1nBatlpsVj0',
    type: 'youtube'
  }, {
    id: 'g7x-VUGjnc8',
    type: 'youtube'
  }, {
    id: 'bE__iQGLxyc',
    type: 'youtube'
  }],
  'vinny-rainbow-queen-ivy': [{
    id: 's2bGUY97o6E',
    type: 'youtube'
  }, {
    id: 'i5oAc0hHX7M',
    type: 'youtube'
  }, {
    id: 'vz35kFJErW4',
    type: 'youtube'
  }],
  'rainbow-queen-moment': [{
    id: 's2bGUY97o6E',
    type: 'youtube'
  }],
  'bad-mystery': [{
    id: 'eeoEQZH-iwg',
    type: 'youtube'
  }, {
    id: '_x8gYuNUdNA',
    type: 'youtube'
  }, {
    id: 'DJlgRlhaeME',
    type: 'youtube'
  }, {
    id: 'VQ9230-OoBw',
    type: 'youtube'
  }, {
    id: 'vlQvh7IrRPk',
    type: 'youtube'
  }],
  'the-true': [{
    id: 'XheH4qClv1Q',
    type: 'youtube'
  }, {
    id: '_x8gYuNUdNA',
    type: 'youtube'
  }],
  sad: [{
    id: 'cU96ZIGKars',
    type: 'youtube'
  }, {
    id: 'lIjHZy3aYDA',
    type: 'youtube'
  }, {
    id: 'eqV2_PDDVr4',
    type: 'youtube'
  }, {
    id: '5i0N9F--gPU',
    type: 'youtube'
  }, {
    id: 'bL5xpXvmGiM',
    type: 'youtube'
  }, {
    id: '2lj9kr1LmQ4',
    type: 'youtube'
  }, {
    id: 'JKgPqJZm1-I',
    type: 'youtube'
  }, {
    id: 'FSkYYV62FEk',
    type: 'youtube'
  }, {
    id: '4VFrTREyIig',
    type: 'youtube'
  }, {
    id: 'E5I667E4GXw',
    type: 'youtube'
  }, {
    id: '24QJV6NnFHY',
    type: 'youtube'
  }, {
    id: 'YhXWzeFJtqM',
    type: 'youtube'
  }, {
    id: 'ewBkq44wynk',
    type: 'youtube'
  }, {
    id: 'lmWFVe7e1ko',
    type: 'youtube'
  }, {
    id: '2tTPzDZWdho',
    type: 'youtube'
  }],
  think: [{
    id: 'Y36Rg14JcZE',
    type: 'youtube'
  }, {
    id: '6oaXQ_JQY64',
    type: 'youtube'
  }, {
    id: 'ZXNxF7kVW_8',
    type: 'youtube'
  }, {
    id: 'UDhQ8DarZHQ',
    type: 'youtube'
  }, {
    id: 'yNACbXekBVQ',
    type: 'youtube'
  }, {
    id: 'yKwdd2Aja_k',
    type: 'youtube'
  }, {
    id: 'DVrsjXSpH9o',
    type: 'youtube'
  }, {
    id: 'BAB7dhJpqes',
    type: 'youtube'
  }, {
    id: '4c7Juty0RYI',
    type: 'youtube'
  }, {
    id: 'ncCnW7MKTCU',
    type: 'youtube'
  }, {
    id: 'TMLnDTkUEgg',
    type: 'youtube'
  }, {
    id: '6yPivtTKLno',
    type: 'youtube'
  }, {
    id: 'SzhjAqPF-gM',
    type: 'youtube'
  }, {
    id: 'k79T3jVvPjw',
    type: 'youtube'
  }, {
    id: 'oxivFag3Reg',
    type: 'youtube'
  }, {
    id: 'ni-Q2RCoexg',
    type: 'youtube'
  }, {
    id: 'wT0lWL_TU7w',
    type: 'youtube'
  }],
  'good-think': [{
    id: '5Im8S1l3UK0',
    type: 'youtube'
  }],
  'nuclear-winter': [{
    id: 'cRzQuPvLjdU',
    type: 'youtube'
  }],
  'bad-think': [{
    id: '0ZD3SfS9x8E',
    type: 'youtube'
  }, {
    id: 'AfkEAnazGMo',
    type: 'youtube'
  }, {
    id: 'QD5OGfAJIus',
    type: 'youtube'
  }, {
    id: 'eeeQcvtjV2k',
    type: 'youtube'
  }, {
    id: 'CAMmIyAA6CY',
    type: 'youtube'
  }, {
    id: 'Li2v4Afy1H0',
    type: 'youtube'
  }],
  'sad-plot-twist': [{
    id: '44A0UTwoCsg',
    type: 'youtube'
  }, {
    id: 'OCjvJoWrUSM',
    type: 'youtube'
  }],
  'new-thing': [{
    id: 'PkIc6TMLfv0',
    type: 'youtube'
  }, {
    id: 'uV2eI9KBOFs',
    type: 'youtube'
  }, {
    id: 'E0wknC_56vE',
    type: 'youtube'
  }],
  troubles: [{
    id: 'gWNsV8L1DB8',
    type: 'youtube'
  }, {
    id: 'ACXW__UAC7w',
    type: 'youtube'
  }, {
    id: 'VMziMXYkVS0',
    type: 'youtube'
  }],
  'first-vs-rayane': [{
    id: 'WspwWDFr4IM',
    type: 'youtube'
  }],
  'aniya-first-time': [{
    id: 'lqXY335eg_U',
    type: 'youtube'
  }, {
    id: 's2bGUY97o6E',
    type: 'youtube'
  }, {
    id: 'uV2eI9KBOFs',
    type: 'youtube'
  }, {
    id: 'qcA0BwRBbKI',
    type: 'youtube'
  }, {
    id: 'bGdD0YVh_kI',
    type: 'youtube'
  }],
  'first-yasmin-night': [{
    id: 'iY4HnkvlQM4',
    type: 'youtube'
  }, {
    id: '24QJV6NnFHY',
    type: 'youtube'
  }, {
    id: 'DVrsjXSpH9o',
    type: 'youtube'
  }, {
    id: 'TOEiLlspdhM',
    type: 'youtube'
  }, {
    id: 'TMLnDTkUEgg',
    type: 'youtube'
  }, {
    id: '6yPivtTKLno',
    type: 'youtube'
  }, {
    id: 'xLD7nFdwYlk',
    type: 'youtube'
  }, {
    id: '4veUhkwfuXE',
    type: 'youtube'
  }]
};

// SFX
_config["default"].sfx = {
  'onderwish-emergency': {
    type: 'file',
    module: 'main',
    value: '/audio/alert/470504__onderwish__emergency-siren.mp3'
  },
  civildefense: {
    type: 'file',
    module: 'main',
    value: '/audio/guitarguy1985/civildefense.mp3'
  },
  'train-horn-1': {
    type: 'file',
    module: 'main',
    value: '/audio/jasmindreasond/train/horn-1.mp3',
    loop: false
  },
  'heavy-rain-little-thunder': {
    type: 'file',
    module: 'main',
    value: '/audio/jasmindreasond/rain/heavy-rain-little-thunder.mp4'
  },
  'heavy-rain': {
    type: 'file',
    module: 'main',
    value: '/audio/jasmindreasond/rain/heavy-rain.mp4'
  },
  'ambulance-alarm': {
    type: 'file',
    module: 'main',
    value: '/audio/jasmindreasond/alarm/ambulance.wav'
  },
  'train-1': {
    type: 'file',
    module: 'main',
    value: '/audio/jasmindreasond/train/1.mp3'
  },
  'nuke-1': {
    type: 'file',
    module: 'main',
    value: '/audio/jasmindreasond/explosion/nuke.mp3',
    loop: false
  }
};

},{"./config.mjs":219}],222:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.storyData = void 0;
var _circleLoader = require("circle-loader");
var _objectHash = _interopRequireDefault(require("object-hash"));
var JsStore = _interopRequireWildcard(require("jsstore"));
var _tinyEssentials = require("tiny-essentials");
var _tinyLib = _interopRequireDefault(require("./tinyLib.mjs"));
var _config = _interopRequireDefault(require("../chapters/config.mjs"));
var _start2 = require("../start.mjs");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t5 in e) "default" !== _t5 && {}.hasOwnProperty.call(e, _t5) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t5)) && (i.get || i.set) ? o(f, _t5, i) : f[_t5] = e[_t5]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _regeneratorKeys(e) { var n = Object(e), r = []; for (var t in n) r.unshift(t); return function e() { for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e; return e.done = !0, e; }; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
// Prepare Data
var storyData = exports.storyData = {
  // Info
  title: _config["default"].title,
  description: _config["default"].description,
  // Counter
  count: 0,
  // Main Lang
  lang: {
    active: _config["default"].defaultLang,
    "default": _config["default"].defaultLang,
    list: _config["default"].lang
  },
  // Chapters
  readFic: false,
  chapter: {
    amount: _config["default"].chapters,
    selected: null,
    bookmark: {}
  },
  // Chapter Data
  data: {},
  lettersCount: {
    total: 0
  },
  wordsCount: {
    total: 0
  },
  characters: {
    data: [],
    total: 0
  },
  words: [],
  // Start Load
  start: function () {
    var _start = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(startApp) {
      var failApp,
        readme,
        _loop,
        i,
        connStore,
        aiPage,
        item,
        dbError,
        userCountry,
        _args4 = arguments;
      return _regenerator().w(function (_context4) {
        while (1) switch (_context4.n) {
          case 0:
            failApp = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : function (err) {
              console.error(err);
              if (typeof err.message === 'string') {
                alert(err.message);
              }
            };
            if (_start2.tinyLs.localStorageExists()) {
              _context4.n = 1;
              break;
            }
            return _context4.a(2, failApp(new Error('Local Storage API not found!')));
          case 1:
            if (!(typeof startApp !== 'function')) {
              _context4.n = 2;
              break;
            }
            return _context4.a(2, failApp(new Error('Start App not found!')));
          case 2:
            // Start App
            _circleLoader.Loader.start('Loading readme...');

            // Read Data Base
            _context4.n = 3;
            return fetch('/readme.html' + fileVersion, {
              method: 'GET',
              dataType: 'text'
            }).then(function (res) {
              return res.text();
            })["catch"](function (err) {
              console.log("README.md failed during the load!");
              _circleLoader.Loader.close();
              failApp(err);
            });
          case 3:
            readme = _context4.v;
            if (readme) {
              _context4.n = 4;
              break;
            }
            throw new Error('No readme data to start the app.');
          case 4:
            // Load Data
            storyData.isNew = {};
            _loop = /*#__PURE__*/_regenerator().m(function _loop() {
              var chapter, data, wordCache, letters, words, _loop2, _item, isNew, isUpdate, _t3, _t4;
              return _regenerator().w(function (_context3) {
                while (1) switch (_context3.n) {
                  case 0:
                    // Data
                    chapter = i + 1;
                    _circleLoader.Loader.close();
                    _circleLoader.Loader.start("Loading chapter ".concat(chapter, "..."));
                    console.log("Loading Chapter ".concat(chapter, "..."));
                    console.log('./chapters/' + storyData.lang.active + '/' + chapter + '.json' + fileVersion);
                    _context3.n = 1;
                    return (0, _tinyEssentials.fetchJson)('./chapters/' + storyData.lang.active + '/' + chapter + '.json' + fileVersion)["catch"](function (err) {
                      console.log("Chapter ".concat(chapter, " failed during the load!"));
                      _circleLoader.Loader.close();
                      failApp(err);
                    });
                  case 1:
                    data = _context3.v;
                    if (data) {
                      _context3.n = 2;
                      break;
                    }
                    throw new Error('No chapter data found.');
                  case 2:
                    // Insert Words Count
                    wordCache = [];
                    letters = 0;
                    words = 0;
                    _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
                      var character, characterLower, newData, text, textSplit, _loop3, item2, _t, _t2;
                      return _regenerator().w(function (_context2) {
                        while (1) switch (_context2.n) {
                          case 0:
                            // Character Counter
                            if (typeof data[_item].character === 'string' && data[_item].character.length > 0) {
                              character = (0, _tinyEssentials.toTitleCase)(data[_item].character);
                              characterLower = data[_item].character.toLowerCase();
                              newData = storyData.characters.data.find(function (_char) {
                                return _char.value === character;
                              });
                              if (!newData) {
                                newData = {
                                  value: character,
                                  id: characterLower.replace(/ /g, '-'),
                                  count: 0,
                                  chapter: {}
                                };
                                storyData.characters.data.push(newData);
                              }
                              if (typeof newData.chapter[chapter] !== 'number') {
                                newData.chapter[chapter] = 0;
                              }
                              newData.chapter[chapter]++;
                              newData.count++;
                              storyData.characters.total++;
                            }

                            // Get Text
                            text = data[_item].value.replace(/(\r\n|\n|\r)/gm, '').trim();
                            textSplit = text.split(' '); // Check Text
                            _loop3 = /*#__PURE__*/_regenerator().m(function _loop3() {
                              var text, wordData;
                              return _regenerator().w(function (_context) {
                                while (1) switch (_context.n) {
                                  case 0:
                                    // Filter
                                    text = _tinyLib["default"].removeAiTags((0, _tinyEssentials.toTitleCase)(textSplit[item2].replace(/[^a-zA-Z]+/g, '')));
                                    if (isNaN(Number(text)) && text.length > 0) {
                                      // Count Data
                                      if (!Array.isArray(_config["default"].wordCountBlacklick)) {
                                        _config["default"].wordCountBlacklick = [];
                                      }
                                      if (_config["default"].wordCountBlacklick.indexOf(text) < 0) {
                                        wordData = storyData.words.find(function (word) {
                                          return word.value === text;
                                        });
                                        if (!wordData) {
                                          wordData = {
                                            count: 0,
                                            value: text
                                          };
                                          storyData.words.push(wordData);
                                        }
                                        wordData.count++;
                                      }
                                      if (wordCache.indexOf(text) < 0) {
                                        wordCache.push(text);
                                        words++;
                                      }
                                    }
                                  case 1:
                                    return _context.a(2);
                                }
                              }, _loop3);
                            });
                            _t = _regeneratorKeys(textSplit);
                          case 1:
                            if ((_t2 = _t()).done) {
                              _context2.n = 3;
                              break;
                            }
                            item2 = _t2.value;
                            return _context2.d(_regeneratorValues(_loop3()), 2);
                          case 2:
                            _context2.n = 1;
                            break;
                          case 3:
                            letters += text.replace(/ |\<ai\>|\<\/ai\>/gm, '').length;
                          case 4:
                            return _context2.a(2);
                        }
                      }, _loop2);
                    });
                    _t3 = _regeneratorKeys(data);
                  case 3:
                    if ((_t4 = _t3()).done) {
                      _context3.n = 5;
                      break;
                    }
                    _item = _t4.value;
                    return _context3.d(_regeneratorValues(_loop2()), 4);
                  case 4:
                    _context3.n = 3;
                    break;
                  case 5:
                    // Order Words
                    storyData.words.sort(function (a, b) {
                      return b.count - a.count;
                    });
                    storyData.characters.data.sort(function (a, b) {
                      return b.count - a.count;
                    });

                    // Insert Data
                    storyData.data[chapter] = data;
                    storyData.lettersCount[chapter] = letters;
                    storyData.lettersCount.total += letters;
                    storyData.wordsCount[chapter] = words;
                    storyData.wordsCount.total += words;
                    storyData.chapter.bookmark[chapter] = Number(_start2.tinyLs.getItem('bookmark' + chapter));
                    if (isNaN(storyData.chapter.bookmark[chapter]) || !isFinite(storyData.chapter.bookmark[chapter]) || storyData.chapter.bookmark[chapter] < 1) {
                      storyData.chapter.bookmark[chapter] = 1;
                    }
                    isNew = !_start2.tinyLs.getItem('chapter' + chapter + 'MD5');
                    isUpdate = false;
                    if (!isNew) {
                      isUpdate = (0, _objectHash["default"])(storyData.data[chapter]) !== _start2.tinyLs.getItem('chapter' + chapter + 'MD5');
                    }
                    if (isNew) {
                      storyData.isNew[chapter] = 2;
                    } else if (isUpdate) {
                      storyData.isNew[chapter] = 1;
                    } else {
                      storyData.isNew[chapter] = 0;
                    }
                    console.log("Chapter ".concat(chapter, " loaded!"));

                    // Complete
                    storyData.count++;
                  case 6:
                    return _context3.a(2);
                }
              }, _loop);
            });
            i = 0;
          case 5:
            if (!(i < storyData.chapter.amount)) {
              _context4.n = 7;
              break;
            }
            return _context4.d(_regeneratorValues(_loop()), 6);
          case 6:
            i++;
            _context4.n = 5;
            break;
          case 7:
            // Start jsStore
            connStore = new JsStore.Connection(new Worker('jsstore.worker.min.js')); // Ai page database
            aiPage = {
              room: {},
              hash: {},
              tokens: {},
              data: {}
            };
            aiPage.room = {
              prompt: {
                dataType: 'string'
              },
              firstDialogue: {
                dataType: 'string'
              },
              systemInstruction: {
                dataType: 'string'
              },
              rpgSchema: {
                dataType: 'object'
              },
              rpgData: {
                dataType: 'object'
              },
              rpgPrivateData: {
                dataType: 'object'
              },
              maxOutputTokens: {
                dataType: 'number'
              },
              temperature: {
                dataType: 'number'
              },
              topP: {
                dataType: 'number'
              },
              topK: {
                dataType: 'number'
              },
              presencePenalty: {
                dataType: 'number'
              },
              frequencyPenalty: {
                dataType: 'number'
              }
            };
            for (item in aiPage.room) {
              aiPage.hash[item] = {
                dataType: 'string'
              };
              aiPage.tokens[item] = {
                dataType: 'number'
              };
            }
            aiPage.hash.file = {
              dataType: 'string'
            };
            aiPage.tokens.file = {
              dataType: 'number'
            };
            aiPage.room.session = {
              primaryKey: true,
              dataType: 'string'
            };
            aiPage.room.model = {
              dataType: 'string'
            };
            aiPage.hash.session = aiPage.room.session;
            aiPage.tokens.session = aiPage.room.session;
            aiPage.data = {
              session: {
                notNull: true,
                dataType: 'string'
              },
              msg_id: {
                primaryKey: true,
                dataType: 'string'
              },
              id: {
                notNull: true,
                dataType: 'number'
              },
              tokens: {
                notNull: true,
                dataType: 'object'
              },
              hash: {
                notNull: true,
                dataType: 'string'
              },
              data: {
                dataType: 'object'
              }
            };
            aiPage.customList = {
              session: aiPage.room.session,
              data: {
                dataType: 'array'
              }
            };
            dbError = false;
            _circleLoader.Loader.close();
            _circleLoader.Loader.start('Loading local database...');
            _context4.n = 8;
            return connStore.initDb({
              name: 'pony-driland',
              tables: [
              // Ai page
              {
                name: 'aiSessionsRoom',
                columns: aiPage.room
              }, {
                name: 'aiSessionsHash',
                columns: aiPage.hash
              }, {
                name: 'aiSessionsTokens',
                columns: aiPage.tokens
              }, {
                name: 'aiSessionsCustomList',
                columns: aiPage.customList
              }, {
                name: 'aiSessionsData',
                columns: aiPage.data
              }]
            })["catch"](function (err) {
              dbError = true;
              alert(err.message);
              console.error(err);
            });
          case 8:
            if (!dbError) {
              _context4.n = 9;
              break;
            }
            return _context4.a(2);
          case 9:
            delete storyData.count;
            delete storyData.start;
            console.log('App Started!');
            console.log('Loading UI...');
            _circleLoader.Loader.close();
            _circleLoader.Loader.start('Starting website...');
            if (!(location.hostname !== 'localhost' && location.hostname !== '127.0.0.1' && !_start2.tinyLs.getString('user-country'))) {
              _context4.n = 11;
              break;
            }
            _context4.n = 10;
            return fetch('https://api.country.is/').then(function (res) {
              return res.json();
            })["catch"](console.error);
          case 10:
            userCountry = _context4.v;
            if ((0, _tinyEssentials.isJsonObject)(userCountry)) _start2.tinyLs.setString('user-country', userCountry.country);
          case 11:
            // Start app now
            startApp(connStore, function () {
              _circleLoader.Loader.close();
              console.log('UI loaded!');
            }, readme);
          case 12:
            return _context4.a(2);
        }
      }, _callee);
    }));
    function start(_x) {
      return _start.apply(this, arguments);
    }
    return start;
  }()
};

},{"../chapters/config.mjs":219,"../start.mjs":226,"./tinyLib.mjs":223,"circle-loader":68,"jsstore":102,"object-hash":106,"tiny-essentials":181}],223:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _jquery = _interopRequireDefault(require("jquery"));
var _tippy = _interopRequireDefault(require("tippy.js"));
var _bootstrap = require("bootstrap");
var _tinyEssentials = require("tiny-essentials");
var _config = _interopRequireDefault(require("../chapters/config.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
// Bootstrap 5
var enableQuery = function enableQuery() {
  _jquery["default"].fn.modal = function (type, configObject) {
    this.each(function () {
      if (!(0, _jquery["default"])(this).data('bs-modal')) {
        if (configObject) {
          (0, _jquery["default"])(this).data('bs-modal', new _bootstrap.Modal(this, configObject));
        } else if (typeof type !== 'string') {
          (0, _jquery["default"])(this).data('bs-modal', new _bootstrap.Modal(this, type));
        } else {
          (0, _jquery["default"])(this).data('bs-modal', new _bootstrap.Modal(this));
        }
      }
      var modal = (0, _jquery["default"])(this).data('bs-modal');
      if (typeof type === 'string' && typeof modal[type] === 'function') {
        modal[type]();
      } else {
        modal.show();
      }
    });
  };
  _jquery["default"].fn.tooltip = function (type, configObject) {
    var returnTooltip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var tooltip = null;
    this.each(function () {
      if (!(0, _jquery["default"])(this).data('bs-tooltip')) {
        if ((0, _tinyEssentials.objType)(configObject, 'object')) tooltip = new _bootstrap.Tooltip(this, configObject);else if (typeof type !== 'string') tooltip = new _bootstrap.Tooltip(this, type);else tooltip = new _bootstrap.Tooltip(this);
        (0, _jquery["default"])(this).data('bs-tooltip', tooltip);
      }
    });
    if (!returnTooltip) tooltip = null;
    return tooltip || this;
  };
};
enableQuery();
(0, _jquery["default"])(function () {
  enableQuery();
});

// Prepare Tiny Lib
var tinyLib = {};

// MD Data manager
tinyLib.mdManager = {};
tinyLib.mdManager.extractMetadata = function (markdown) {
  var charactersBetweenGroupedHyphens = /^\#---([\s\S]*?)\#---/;
  var metadataMatched = markdown.match(charactersBetweenGroupedHyphens);
  var metadata = metadataMatched[1];
  if (!metadata) {
    return {};
  }
  var metadataLines = metadata.split('\n');
  var metadataObject = metadataLines.reduce(function (accumulator, line) {
    var _line$split$map = line.split(':').map(function (part) {
        return part.trim();
      }),
      _line$split$map2 = _toArray(_line$split$map),
      key = _line$split$map2[0],
      value = _line$split$map2.slice(1);
    if (key) {
      accumulator[key] = value[1] ? value.join(':') : value.join('');
      if (accumulator[key].startsWith("'") && accumulator[key].endsWith("'") || accumulator[key].startsWith('"') && accumulator[key].endsWith('"')) accumulator[key] = accumulator[key].substring(1, accumulator[key].length - 1);
    }
    return accumulator;
  }, {});
  return metadataObject;
};
tinyLib.mdManager.removeMetadata = function (text) {
  var result = text.replace(/^\#---([\s\S]*?)\#---/, '');
  while (result.startsWith('\n')) {
    result = result.substring(1);
  }
  return result;
};

// Dialog
tinyLib.dialog = function (data1, data2) {
  var newData = (0, _jquery["default"])('<div>', {
    id: data1.id,
    title: data1.title
  }).append(data1.html);
  (0, _jquery["default"])('body').append(newData);
  newData.dialog(data2);
};

// Alert
tinyLib.alert = function (where, alertType, icon, text) {
  (0, _jquery["default"])(where).empty().append(tinyLib.bs.alert(alertType, [(0, _jquery["default"])('<i>', {
    "class": icon
  }), ' ', text], true));
};

// Modal
tinyLib.modal = function (data) {
  if (typeof data.dialog !== 'string') {
    data.dialog = '';
  }
  var modal = (0, _jquery["default"])('<div>', {
    "class": 'modal fade',
    id: data.id,
    tabindex: -1,
    role: 'dialog'
  }).on('hidden.bs.modal', function (e) {
    (0, _jquery["default"])(this).remove();
    if (typeof data.hidden === 'function') {
      data.hidden();
    }
  }).append((0, _jquery["default"])('<div>', {
    "class": 'modal-dialog ' + data.dialog,
    role: 'document'
  }).append((0, _jquery["default"])('<div>', {
    "class": 'modal-content'
  }).append((0, _jquery["default"])('<div>', {
    "class": 'modal-header'
  }).append((0, _jquery["default"])('<h5>', {
    "class": 'modal-title'
  }).append(data.title), (0, _jquery["default"])('<button>', {
    type: 'button',
    "class": 'btn-close',
    'data-bs-dismiss': 'modal'
  })), (0, _jquery["default"])('<div>', {
    "class": 'modal-body'
  }).append(data.body), data.footer ? (0, _jquery["default"])('<div>', {
    "class": 'modal-footer'
  }).append(data.footer) : null)));
  (0, _jquery["default"])('body').prepend(modal);
  modal.modal();
  return modal;
};
tinyLib.formGroup = function (data) {
  if (typeof data["class"] !== 'string') {
    data["class"] = '';
  }
  var result = (0, _jquery["default"])('<div>', {
    "class": 'form-group ' + data["class"],
    id: data.id
  });
  if (typeof data.title === 'string') {
    result.append((0, _jquery["default"])('<label>', {
      "for": data.id + '_input'
    }).text(data.title));
  }
  result.append((0, _jquery["default"])('<input>', {
    type: data.type,
    "class": 'form-control',
    name: data.id,
    id: data.id + '_input',
    'aria-describedby': data.id + '_help',
    value: data.value,
    placeholder: data.placeholder
  }));
  if (typeof data.help === 'string') {
    var newValue = (0, _jquery["default"])('<label>', {
      id: data.id + '_help',
      "class": 'form-text text-muted small'
    }).text(data.help);
    if (data.checkbox && data.checkbox.enabled) {
      newValue.prepend((0, _jquery["default"])('<input>', {
        "class": 'me-2',
        id: data.id + '_enabled',
        name: data.id + '_enabled',
        type: 'checkbox'
      }).attr('checked', data.checkbox.value));
    }
    result.append(newValue);
  }
  return result;
};
tinyLib.formGroupCheck = function (data) {
  if (typeof data["class"] !== 'string') {
    data["class"] = '';
  }
  return (0, _jquery["default"])('<div>', {
    "class": 'form-group form-check ' + data["class"],
    id: data.id
  }).append((0, _jquery["default"])('<input>', {
    type: 'checkbox',
    "class": 'form-check-input',
    name: data.id,
    id: data.id + '_input',
    'aria-describedby': data.id + '_help'
  }).attr('checked', data.value), (0, _jquery["default"])('<label>', {
    "class": 'form-check-label',
    "for": data.id + '_input'
  }).text(data.title));
};

// Alert
alert = function alert(text) {
  var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Browser Warning!';
  return tinyLib.modal({
    title: (0, _jquery["default"])('<span>').text(title),
    body: (0, _jquery["default"])('<div>', {
      "class": 'text-break'
    }).css('white-space', 'pre-wrap').text(text),
    dialog: 'modal-lg'
  });
};

// Remove AI tags
tinyLib.removeAiTags = function (str) {
  return str.replace(/\<ai\>|\<\/ai\>/g, '');
};
tinyLib.getGitUrlPath = function (text) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'g';
  var tinyUrl = "https\\:\\/\\/github.com\\/".concat(_config["default"].github.account, "\\/").concat(_config["default"].github.repository, "\\/blob\\/main\\/");
  return new RegExp(typeof text === 'string' ? text.replace('{url}', tinyUrl) : tinyUrl, type);
};

// Icon
tinyLib.icon = function (classItem) {
  return (0, _jquery["default"])('<i>', {
    "class": classItem
  });
};

// Files Upload button
tinyLib.upload = {};
tinyLib.upload.button = function () {
  var configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var button = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  // Create button
  var importButton = (0, _jquery["default"])('<input>', {
    type: 'file',
    style: 'display: none;'
  });
  importButton.attr('accept', configs.accept);

  // Multiple
  if (configs.multiple) importButton.prop('multiple', true);

  // Directory
  if (configs.directory) importButton.prop('directory', true);

  // Prepare button functions
  importButton.on('change', callback);
  button.on('click', function () {
    return importButton.trigger('click');
  });
  button.parent().append(importButton);
  return button;
};

// File base64 selector template
tinyLib.upload.dataUrl = function () {
  var button = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var baseFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var accept = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '*';
  return tinyLib.upload.button({
    accept: "".concat(baseFormat, "/").concat(accept)
  }, button, function (event) {
    var file = event.target.files[0];
    if (!file) return;
    // Image type validation
    if (!file.type.startsWith("".concat(baseFormat, "/"))) {
      callback(new Error('Selected file is not an image'), null);
      return;
    }
    // Complete
    (0, _tinyEssentials.readBase64Blob)(file, "".concat(baseFormat, "/").concat(format)).then(function (dataUrl) {
      return callback(null, dataUrl);
    })["catch"](function (err) {
      return callback(err, null);
    });
  });
};

// Image upload
tinyLib.upload.img = function () {
  var button = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var accept = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '*';
  return tinyLib.upload.dataUrl(button, 'image', callback, accept);
};

// Json upload
tinyLib.upload.json = function () {
  var button = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return tinyLib.upload.button({
    accept: '.json'
  }, button, function (event) {
    var file = event.target.files[0];
    if (file) (0, _tinyEssentials.readJsonBlob)(file).then(function (jsonData) {
      return callback(null, jsonData);
    })["catch"](function (err) {
      return callback(err, null);
    });
  });
};

// Bootstrap
tinyLib.bs = {};

// Button
tinyLib.bs.button = function () {
  var className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'primary';
  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'button';
  var isButton = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var buttonClass = typeof className === 'string' ? className : (0, _tinyEssentials.objType)(className, 'object') && typeof className["class"] === 'string' ? className["class"] : null;
  var introClass = typeof className === 'string' || !className.dsBtn ? 'btn btn-' : '';
  return (0, _jquery["default"])("<".concat(tag, ">"), {
    id: (0, _tinyEssentials.objType)(className, 'object') && typeof className.id === 'string' ? className.id : null,
    "class": "".concat(introClass).concat(buttonClass),
    role: isButton && (!(0, _tinyEssentials.objType)(className, 'object') || !className.toggle) ? 'button' : null,
    type: isButton ? 'button' : null,
    'data-bs-toggle': (0, _tinyEssentials.objType)(className, 'object') && typeof className.toggle === 'string' ? className.toggle : null,
    'data-bs-target': (0, _tinyEssentials.objType)(className, 'object') && typeof className.target === 'string' ? className.target : null
  });
};

// Btn Close
tinyLib.bs.closeButton = function () {
  var dataDismiss = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return (0, _jquery["default"])('<button>', {
    "class": 'btn-close',
    type: 'button',
    'data-bs-dismiss': dataDismiss
  });
};

// Navbar
tinyLib.bs.navbar = {};
tinyLib.bs.navbar.root = function (id) {
  var theme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'dark';
  var isFixed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0, _jquery["default"])('<nav>', {
    "class": "navbar navbar-expand-lg navbar-".concat(theme, " bg-").concat(theme).concat(isFixed ? ' fixed-top' : '', " px-4 py-0 tiny-navabar-style"),
    id: id
  });
};
tinyLib.bs.navbar.title = function (text, href) {
  return (0, _jquery["default"])('<a>', {
    "class": 'navbar-brand',
    href: href,
    text: text
  });
};
tinyLib.bs.navbar.collapse = function (dir, className, id, content) {
  return (0, _jquery["default"])('<div>', {
    "class": "collapse navbar-collapse navbar-nav-".concat(dir).concat(className ? " ".concat(className) : ''),
    id: id
  }).append((0, _jquery["default"])('<ul>', {
    "class": "navbar-nav ".concat(dir === 'left' ? 'me' : dir === 'right' ? 'ms' : '', "-auto mb-2 mb-lg-0")
  }).append(content));
};

// Offcanvas
tinyLib.bs.offcanvas = function () {
  var where = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'start';
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var title = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var content = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var closeButtonInverse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var tabIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;
  var body = (0, _jquery["default"])('<div>', {
    "class": 'offcanvas-body'
  });
  if (!Array.isArray(content)) body.append(content);else for (var index in content) body.append(content[index]);
  return (0, _jquery["default"])('<div>', {
    "class": "offcanvas offcanvas-".concat(where),
    tabindex: tabIndex,
    id: id
  }).append((0, _jquery["default"])('<div>', {
    "class": 'offcanvas-header'
  }).append(title ? (0, _jquery["default"])('<h5>', {
    "class": 'offcanvas-title',
    id: "".concat(id, "Label")
  }).text(title) : null, !closeButtonInverse && tinyLib.bs.closeButton('offcanvas'), body, closeButtonInverse && tinyLib.bs.closeButton('offcanvas')));
};

// Container
tinyLib.bs.container = function () {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var classItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'div';
  return (0, _jquery["default"])("<".concat(tag, ">"), {
    id: id,
    "class": "container".concat(classItems ? " ".concat(classItems) : '')
  });
};

// Alert
tinyLib.bs.alert = function () {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'primary';
  var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var isDismissible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var result = (0, _jquery["default"])('<div>', {
    "class": "alert alert-".concat(type).concat(isDismissible ? " alert-dismissible fade show" : ''),
    role: 'alert'
  });
  result.append(content);
  if (isDismissible) result.append(tinyLib.bs.closeButton('alert'));
  return result;
};

// Dropdown
tinyLib.bs.dropdownClick = function (place, data, callbackInsert) {
  var rootBase = (0, _jquery["default"])('<ul>', {
    "class": 'dropdown-menu show'
  });
  var element = (0, _tippy["default"])(place.get(0), {
    content: rootBase.get(0),
    allowHTML: true,
    interactive: true,
    arrow: false,
    theme: 'dark-border',
    placement: 'bottom-start',
    trigger: 'click',
    hideOnClick: true,
    appendTo: function appendTo() {
      return (0, _jquery["default"])('body > #root').get(0);
    }
  });
  for (var index in data) {
    var li = (0, _jquery["default"])('<li>');
    rootBase.append(li);
    callbackInsert(li, element, data[index], index);
  }
};
var _default = exports["default"] = tinyLib;

},{"../chapters/config.mjs":219,"bootstrap":65,"jquery":97,"tiny-essentials":181,"tippy.js":204}],224:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = gtag;
var _config = _interopRequireDefault(require("./chapters/config.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
window.dataLayer = window.dataLayer || [];
function gtag() {
  dataLayer.push(arguments);
}
if (typeof _config["default"].gtag === 'string') {
  gtag('js', new Date());
  gtag('config', _config["default"].gtag);
}

},{"./chapters/config.mjs":219}],225:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _events = require("events");
var _forPromise = _interopRequireDefault(require("for-promise"));
var _tinyEssentials = require("tiny-essentials");
var _config = _interopRequireDefault(require("../chapters/config.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
(function () {
  var postMessage = function postMessage(data) {
    if (('serviceWorker' in navigator || 'ServiceWorker' in navigator) && navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage) {
      return navigator.serviceWorker.controller.postMessage(data);
    }
    return null;
  };
  var firstTime = true;
  var deferredPrompt;
  window.matchMedia('(display-mode: standalone)').addEventListener('change', function (evt) {
    var body = _tinyEssentials.TinyHtml.query('body');
    body.removeClass(['window-browser', 'window-standalone']);
    var displayMode = 'browser';
    if (evt.matches) {
      displayMode = 'standalone';
    }

    // Log display mode change to analytics
    console.log("[PWA] DISPLAY_MODE_CHANGED", displayMode);
    tinyPwa.emit('displayMode', displayMode);
    body.addClass("window-".concat(displayMode));
  });
  window.addEventListener('beforeinstallprompt', function (e) {
    // Prevent the mini-infobar from appearing on mobile
    // e.preventDefault();

    // Stash the event so it can be triggered later.
    deferredPrompt = e;

    // Update UI notify the user they can install the PWA
    // showInstallPromotion();

    // Optionally, send analytics event that PWA install promo was shown.
    tinyPwa.emit('deferredPrompt', deferredPrompt);
    console.log("[PWA] 'beforeinstallprompt' event was fired.", deferredPrompt);
  });
  window.addEventListener('appinstalled', function () {
    // Hide the app-provided install promotion
    // hideInstallPromotion();

    // Clear the deferredPrompt so it can be garbage collected
    deferredPrompt = null;

    // Optionally, send analytics event to indicate successful install
    tinyPwa.emit('deferredPrompt', deferredPrompt);
    console.log("[PWA] PWA was installed");
  });
  function getPWADisplayMode() {
    var isStandalone = window.matchMedia('(display-mode: standalone)').matches;
    if (document.referrer.startsWith('android-app://')) {
      return 'twa';
    }
    if (navigator.standalone || isStandalone) {
      return 'standalone';
    }
    return 'browser';
  }
  function isUsingPWA() {
    return tinyPwa.enabled;
  }
  function clearFetchPwaCache() {
    postMessage({
      type: 'CLEAR_FETCH_CACHE'
    });
  }
  if ('serviceWorker' in navigator || 'ServiceWorker' in navigator) {
    var msgEvents = {};
    navigator.serviceWorker.addEventListener('message', function (event) {
      if (event.data && typeof msgEvents[event.data.type] === 'function') msgEvents[event.data.type](event);
    });
  }
  function installPWA() {
    if ('serviceWorker' in navigator || 'ServiceWorker' in navigator) {
      // Check registration
      var tinyCheck = function tinyCheck(event) {
        if (event) {
          console.log("[PWA State] ".concat(event.state));
          if (event.state === 'installed') {
            tinyPwa._setNeedRefresh(true);
            location.reload();
          } else if (event.state === 'activated' && !tinyPwa.needRefresh) if (firstTime) firstTime = false;
        }
      };
      navigator.serviceWorker.ready.then(function (a) {
        return tinyCheck(a.active);
      });
      var tinyRegistrationChecker = function tinyRegistrationChecker(registration) {
        // updatefound is also fired for the very first install. Â¯\_(ã)_/Â¯
        registration.addEventListener('updatefound', function (event) {
          tinyCheck(event.target.active);
          registration.installing.addEventListener('statechange', function (event2) {
            return tinyCheck(event2.target);
          });
        });
      };

      // Get Items
      var cacheChecker = {
        count: 0,
        removed: false,
        keep: false
      };
      navigator.serviceWorker.getRegistrations().then(function (items) {
        // Register new Service Worker
        var registerNewService = function registerNewService() {
          return navigator.serviceWorker.register('./service-worker.js', {
            scope: './'
          })
          // Complete
          .then(function (registration) {
            console.log('[PWA] Service Worker Registered.');
            tinyPwa._setIsEnabled(true);
            tinyRegistrationChecker(registration);
          })
          // Error
          ["catch"](function (err) {
            console.log('[PWA] Service Worker Failed to Register.');
            console.error(err);
            tinyPwa._init();
          });
        };
        if (items.length > 0) {
          (0, _forPromise["default"])({
            data: items
          }, /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(item, fn, fnErr) {
              var tinyUrl;
              return _regenerator().w(function (_context) {
                while (1) switch (_context.n) {
                  case 0:
                    // Get Url data
                    tinyUrl = items[item].active && typeof items[item].active.scriptURL === 'string' && items[item].active.scriptURL.length > 0 ? new URL(items[item].active.scriptURL) : {}; // Remove old stuff
                    if (cacheChecker.count > 0 || !items[item].active || items[item].active.state !== 'activated' && items[item].active.state !== 'activating' || tinyUrl.pathname !== '/service-worker.js') {
                      items[item].unregister().then(function (success) {
                        if (!success) console.error("[PWA] Fail to remove the Service Worker ".concat(items[item].scope));else cacheChecker.removed = true;
                        fn();
                      })["catch"](fnErr);
                    }

                    // Update tiny stuff
                    else if (tinyUrl.pathname === '/service-worker.js') {
                      tinyRegistrationChecker(items[item]);
                      if (items[item].active && (items[item].active.state === 'activated' || items[item].active.state === 'activating')) {
                        items[item].update().then(function (success) {
                          if (!success) console.error("[PWA] Fail to update the Service Worker ".concat(items[item].scope));else {
                            console.log('[PWA] Service Worker Updated.');
                            cacheChecker.keep = true;
                            tinyPwa._setIsEnabled(true);
                          }
                          fn();
                        })["catch"](fnErr);
                      }
                    }

                    // Add count
                    cacheChecker.count++;
                  case 1:
                    return _context.a(2);
                }
              }, _callee);
            }));
            return function (_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }())
          // Remove progress complete
          .then(function () {
            if (cacheChecker.removed && !cacheChecker.keep) registerNewService();
          })
          // Error
          ["catch"](function (err) {
            console.log('[PWA] Service Worker Failed to Unregister.');
            console.error(err);
            tinyPwa._init();
          });
        } else registerNewService();
      })
      // Error
      ["catch"](function (err) {
        console.log('[PWA] Service Worker Failed to get Register list.');
        console.error(err);
        tinyPwa._init();
      });
    } else tinyPwa._init();
  }
  var TinyPwa = /*#__PURE__*/function (_EventEmitter) {
    function TinyPwa() {
      var _this;
      _classCallCheck(this, TinyPwa);
      _this = _callSuper(this, TinyPwa);
      _this.tabs = [];
      _this.tabId = null;
      _this.enabled = false;
      _this.initialized = false;
      _this.needRefresh = false;
      return _this;
    }
    _inherits(TinyPwa, _EventEmitter);
    return _createClass(TinyPwa, [{
      key: "_init",
      value: function _init() {
        if (!this.initialized) {
          this.initialized = true;
          this.emit('ready');
        }
      }
    }, {
      key: "_addTab",
      value: function _addTab(item) {
        this.tabs.push(item);
        this.emit('tabAdded', item);
      }
    }, {
      key: "_removeTab",
      value: function _removeTab(id) {
        var index = this.tabs.findIndex(function (tab) {
          return tab.id === id;
        });
        if (index > -1) {
          var item = this.tabs.splice(index, 1);
          this.emit('tabRemoved', item);
        }
      }
    }, {
      key: "_setTabId",
      value: function _setTabId(id) {
        if (typeof id === 'string') {
          this.tabId = id;
          this.emit('tabIdUpdated', id);
        } else this.tabId = null;
      }
    }, {
      key: "_setIsEnabled",
      value: function _setIsEnabled(enabled) {
        if (typeof enabled === 'boolean') {
          this.enabled = enabled;
          this.emit('isEnabled', enabled);
        }
      }
    }, {
      key: "_setNeedRefresh",
      value: function _setNeedRefresh(enabled) {
        if (typeof enabled === 'boolean') {
          this.needRefresh = enabled;
          this.emit('needRefresh', enabled);
        }
      }
    }, {
      key: "waitInit",
      value: function waitInit() {
        var _this2 = this;
        var tinyThis = this;
        return new Promise(function (resolve, reject) {
          if (_this2.initialized) resolve(true);else setTimeout(function () {
            return tinyThis.waitInit().then(resolve)["catch"](reject);
          }, 100);
        });
      }
    }, {
      key: "getTabs",
      value: function getTabs() {
        return this.tabs;
      }
    }, {
      key: "getTab",
      value: function getTab(id) {
        return this.tabs.find(function (item) {
          return item.id === id;
        });
      }
    }, {
      key: "getTabId",
      value: function getTabId() {
        this.tabId;
      }
    }, {
      key: "isEnabled",
      value: function isEnabled() {
        return this.enabled;
      }
    }, {
      key: "getDisplayMode",
      value: function getDisplayMode() {
        return getPWADisplayMode();
      }
    }, {
      key: "clearFetchCache",
      value: function clearFetchCache() {
        return clearFetchPwaCache();
      }
    }]);
  }(_events.EventEmitter);
  var initDom = new _tinyEssentials.TinyDomReadyManager();
  initDom.onReady(function () {
    var tinyPwa = new TinyPwa();
    if (window.matchMedia('(display-mode: standalone)').matches) {
      console.log("[PWA] This is running as standalone.");
      _tinyEssentials.TinyHtml.query('body').addClass("window-standalone");
      tinyPwa.emit('displayMode', 'standalone');
    } else {
      console.log("[PWA] This is running as browser.");
      _tinyEssentials.TinyHtml.query('body').addClass("window-browser");
      tinyPwa.emit('displayMode', 'browser');
    }
    window.tinyPwa = tinyPwa;
    window.vanillaPwa = {
      postMessage: postMessage,
      getDisplayMode: getPWADisplayMode,
      isUsing: isUsingPWA,
      clearFetch: clearFetchPwaCache,
      install: installPWA
    };
  });
  initDom.init();
})();

},{"../chapters/config.mjs":219,"events":92,"for-promise":94,"tiny-essentials":181}],226:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.urlUpdate = exports.tinyNotification = exports.tinyLs = exports.saveRoleplayFormat = exports.rootApp = exports.clearFicData = exports.appData = void 0;
var _events = require("events");
var _tinyEssentials = require("tiny-essentials");
var _photoswipe = _interopRequireDefault(require("photoswipe"));
var _qrcode = _interopRequireDefault(require("qrcode"));
var _moment = _interopRequireDefault(require("moment"));
var _marked = require("marked");
var _fileSaver = require("file-saver");
var _jquery = _interopRequireDefault(require("jquery"));
var _bootstrap = require("bootstrap");
var _gtag = _interopRequireDefault(require("./gtag.mjs"));
require("../build/bundle/bootstrap-paginator.mjs");
require("./pwa/installer.mjs");
require("./chapters/sound.mjs");
require("./chapters/counter.mjs");
require("./chapters/characters.mjs");
var _tinyLib = _interopRequireDefault(require("./files/tinyLib.mjs"));
var _chapters = require("./files/chapters.mjs");
var _config = _interopRequireDefault(require("./chapters/config.mjs"));
var _index = require("./chapter_manager/index.mjs");
var _aiSoftware = require("./ai/aiSoftware.mjs");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
(0, _tinyEssentials.addAiMarkerShortcut)();
var tinyNotification = exports.tinyNotification = new _tinyEssentials.TinyNotifications({
  audio: '/audio/notification.ogg',
  defaultIcon: '/img/icon/192.png'
});
var tinyLs = exports.tinyLs = new _tinyEssentials.TinyLocalStorage('pony-driland');

// Start Load
var appData = exports.appData = {
  youtube: {},
  ai: {
    using: false,
    interval: null,
    secondsUsed: 0
  }
};
appData.emitter = new _events.EventEmitter();

// Start Document
console.groupCollapsed('App Information');
console.log("Fanfic Engine Creator: Yasmin Seidel (JasminDreasond) https://github.com/JasminDreasond");
console.log("Name: ".concat(_config["default"].title));
console.log("Description: ".concat(_config["default"].description));
console.log("Author: ".concat(_config["default"].creator));
console.log("Author Page: ".concat(_config["default"].creator_url));
console.log("Age Rating: ".concat(_config["default"].ageRating));
console.log("Github Repository: https://github.com/".concat(_config["default"].github.account, "/").concat(_config["default"].github.repository));
console.log("Tags", _config["default"].tags);
console.groupEnd();

// Roleplay format
var renderRoleplayFormat = function renderRoleplayFormat(chapter) {
  var saveCfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var data = '';
  var day = null;
  var dayNightCycle = null;
  var weather = null;
  var where = null;
  for (var item in _chapters.storyData.data[chapter]) {
    var lineText = "".concat(saveCfg.ficLine ? "[Fic Line ".concat(Number(item) + 1, "] ") : '');
    var ficData = _chapters.storyData.data[chapter][item];
    if (ficData.set) {
      if (saveCfg.dayNumber && typeof ficData.set.day === 'number') {
        day = ficData.set.day;
        data += "\nDay Number= ".concat(day);
      }
      if (saveCfg.dayStatus && typeof ficData.set.dayNightCycle === 'string') {
        dayNightCycle = ficData.set.dayNightCycle;
        data += "\nDay Status= ".concat(dayNightCycle);
      }
      if (saveCfg.weather && typeof ficData.set.weather === 'string') {
        weather = ficData.set.weather;
        data += "\nWeather= ".concat(weather);
      }
      if (saveCfg.location && typeof ficData.set.where === 'string') {
        where = ficData.set.where;
        data += "\nLocation= ".concat("".concat(where !== '???' ? where : 'Unknown'));
      }
    }
    if (saveCfg.curiosities && ficData.info) {
      for (var info in ficData.info) {
        data += "\nCuriosity= ".concat(info, ": ").concat(ficData.info[info]);
      }
    }
    var isFlashBack = ficData.flashback ? ' from flashback scene' : '';
    if (ficData.type === 'action') data += "\n".concat(lineText, "*").concat(_tinyLib["default"].removeAiTags(ficData.value), "*");
    if (ficData.type === 'think') data += "\n".concat(lineText).concat(ficData.character, "'s thinks").concat(isFlashBack, ": ").concat(_tinyLib["default"].removeAiTags(ficData.value));
    if (ficData.type === 'telepathy') data += "\n".concat(lineText).concat(ficData.character, "'s telepathy voice").concat(isFlashBack, ": ").concat(_tinyLib["default"].removeAiTags(ficData.value));
    if (ficData.type === 'dialogue') data += "\n".concat(lineText).concat(ficData.character).concat(isFlashBack, ": ").concat(_tinyLib["default"].removeAiTags(ficData.value));
  }
  return data;
};
var saveRoleplayFormat = exports.saveRoleplayFormat = function saveRoleplayFormat(chapter) {
  var saveAsFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var tinyCfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Save Config
  var saveCfg = {
    dayNumber: true,
    dayStatus: true,
    weather: true,
    location: true,
    curiosities: true,
    ficLine: true
  };
  for (var item in tinyCfg) {
    if (typeof tinyCfg[item] === 'boolean') saveCfg[item] = tinyCfg[item];
  }

  // File start and end
  var fileStart = "---------- Official Pony Driland fic file ----------";
  var fileEnd = "---------- The end Official Pony Driland fic file ----------";
  var file = "";

  // Insert chapter
  var insertChapter = function insertChapter(cpId) {
    file += "\n\n---------- Chapter ".concat(cpId, " ----------\n");
    file += renderRoleplayFormat(cpId, saveCfg);
    file += "\n\n---------- The end chapter ".concat(cpId, " ----------");
  };

  // Insert all chapters
  if (typeof chapter !== 'number' || Array.isArray(chapter)) {
    for (var i = 0; i < _chapters.storyData.chapter.amount; i++) {
      // Chapter item
      var _item = i + 1;

      // Insert all chapters
      if (!Array.isArray(chapter)) insertChapter(_item);
      // Selected chapters
      else {
        for (var index in chapter) {
          if (typeof chapter[index] === 'number' && _item === chapter[index]) insertChapter(_item);
        }
      }
    }
  }

  // Insert chapter number
  else {
    insertChapter(chapter);
  }

  // Fix file
  file = file.substring(2, file.length);

  // Info data
  var info = "Title: ".concat(_chapters.storyData.title, "\nDescription: ").concat(_chapters.storyData.description, "\nAuthor: ").concat(_config["default"].creator, "\nAuthor Page: ").concat(_config["default"].creator_url);
  if (_config["default"].bitcoin && _config["default"].bitcoin.address || _config["default"].dogecoin && _config["default"].dogecoin.address || _config["default"].ethereum && _config["default"].ethereum.address || _config["default"].polygon && _config["default"].polygon.address || _config["default"].bnb && _config["default"].bnb.address) {
    info += "\n";
  }
  if (_config["default"].bitcoin && _config["default"].bitcoin.address) {
    info += "\nBitcoin Donations: ".concat(_config["default"].bitcoin.address);
  }
  if (_config["default"].dogecoin && _config["default"].dogecoin.address) {
    info += "\nDogecoin Donations: ".concat(_config["default"].dogecoin.address);
  }
  if (_config["default"].ethereum && _config["default"].ethereum.address) {
    info += "\nEthereum Donations: ".concat(_config["default"].ethereum.address);
  }
  if (_config["default"].polygon && _config["default"].polygon.address) {
    info += "\nPolygon Donations: ".concat(_config["default"].polygon.address);
  }
  if (_config["default"].bnb && _config["default"].bnb.address) {
    info += "\nBNB Donations: ".concat(_config["default"].bnb.address);
  }

  // Save file
  if (saveAsFile) (0, _fileSaver.saveAs)(new Blob(["".concat(fileStart, "\n\n").concat(info, "\n\n").concat(file, "\n\n").concat(fileEnd)], {
    type: 'text/plain'
  }), "Pony Driland".concat(typeof chapter !== 'number' && !Array.isArray(chapter) ? '' : " - Chapter ".concat(typeof chapter === 'number' ? String(chapter) : chapter.join('-')), ".txt"));else return {
    data: "".concat(info, "\n\n").concat(file),
    mime: 'text/plain'
  };
};

// URL Update
var urlUpdate = exports.urlUpdate = function urlUpdate(url, title) {
  var isPopState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  // Page Title
  if (typeof title !== 'string' || title.length < 1) {
    title = _config["default"].title;
  }
  if (url === 'ai') {
    if (!appData.ai.using) {
      appData.ai.using = true;
      appData.emitter.emit('isUsingAI', true);
    }
  } else {
    if (appData.ai.using) {
      appData.ai.using = false;
      appData.emitter.emit('isUsingAI', false);
    }
  }
  var newUrl = typeof url === 'string' && !url.startsWith('/') && url !== 'read-fic' && url !== 'ai' ? "/".concat(url) : url;
  var extraReady = '';
  for (var item in extra) {
    extraReady += "&".concat(item, "=").concat(extra[item]);
  }
  document.title = title;
  _chapters.storyData.urlPage = newUrl;

  // Google
  if (typeof _config["default"].gtag === 'string' && _gtag["default"]) {
    (0, _gtag["default"])('event', 'url', {
      event_title: title,
      event_category: 'open_url',
      url: newUrl
    });
  }

  // Pop State
  if (!isPopState) {
    if (typeof newUrl === 'string' && newUrl.length > 0) {
      if (!_config["default"].custom_url[newUrl]) {
        window.history.pushState({
          pageTitle: title
        }, '', '/?path=' + encodeURIComponent(newUrl) + extraReady);
      } else {
        window.history.pushState({
          pageTitle: _config["default"].custom_url[newUrl].title
        }, '', _config["default"].custom_url[newUrl].url + extraReady);
      }
    } else {
      window.history.pushState({
        pageTitle: title
      }, '', '/');
    }
  }
};
var openNewAddress = function openNewAddress(data) {
  var isPopState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var useCustom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // File Path
  var filePath = data.path;

  // Prepare Custom URL
  if (useCustom && _config["default"].custom_url[data.path]) {
    isPopState = false;
  }
  if (!data || typeof filePath !== 'string' || filePath.length < 1 || !filePath.startsWith('/') || filePath.indexOf('http://') > -1 || filePath.indexOf('https://') > -1) {
    insertMarkdownFile(_chapters.storyData.readme, null, true, true);
  } else {
    openMDFile(filePath);
    if (typeof data.title === 'string' && data.title.length > 0) {
      urlUpdate(data.path, data.title, isPopState);
    } else {
      urlUpdate(data.path, null, isPopState);
    }
  }
};

// Get Params
var getParams = function getParams() {
  var urlSearchParams = new URLSearchParams(document.location.search);
  return Object.fromEntries(urlSearchParams.entries());
};

// Pop State
new _tinyEssentials.TinyHtml(window).on('popstate', function () {
  // Remove Fic Data
  clearFicData();

  // Get Params
  var params = getParams();

  // Load Page
  var loadPage = function loadPage() {
    if (_chapters.storyData.urlPage !== params.path) {
      _chapters.storyData.urlPage = params.path;
      if (params.path === 'read-fic') (0, _index.openChapterMenu)(params);
      if (params.path === 'ai') return;else openNewAddress(params, true);
    }
  };

  // Default
  if (document.location.pathname === '/') {
    loadPage();
  }

  // Custom
  else {
    // Get Data
    var urlData = Object.entries(_config["default"].custom_url).find(function (item) {
      return item[1].url === document.location.pathname;
    });
    if (urlData) {
      params.path = urlData[0];
      params.title = urlData[1].title;
      loadPage();
    }
  }
});

// Insert Maarkdown File
var insertMarkdownFile = function insertMarkdownFile(text) {
  var metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var isMainPage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isHTML = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // Convert Data
  var data;
  if (!isHTML) {
    data = _marked.marked.parse(text.replace(/^[\u200B\u200C\u200D\u200E\u200F\uFEFF]/, ''));
  } else {
    data = text;
  }
  data = data.replace(_tinyLib["default"].getGitUrlPath("href=\"{url}docs\\/"), 'href="javascript:void(0)" file="../').replace(_tinyLib["default"].getGitUrlPath("src=\"{url}docs\\/"), 'src="../').replace(new RegExp("src=\"https://ipfs.io/ipfs/", 'g'), 'src="https://cloudflare-ipfs.com/ipfs/');
  var canContentList = metadata && Array.isArray(metadata.contentList) && metadata.contentList.length > 0;
  if (canContentList) data = data.replace('{{content_list}}', '<div class="content-list-data"></div>');else data = data.replace('{{content_list}}', '');

  // Markdown page ways
  var markdownBase = (0, _jquery["default"])('#markdown-read');
  var pageTypes = {
    // Wiki
    wiki: function wiki() {
      // Row
      var row = (0, _jquery["default"])('<div>', {
        "class": 'wiki-page'
      });

      // Main content
      var colMain = (0, _jquery["default"])('<div>');
      colMain.append((0, _jquery["default"])('<h1>').text(metadata.name), data);

      // Sidebar
      var colSidebar = (0, _jquery["default"])('<div>', {
        "class": 'float-end character-wikicard ms-2 mb-2'
      });
      var card = (0, _jquery["default"])('<div>', {
        "class": 'card position-relative'
      });
      var cardImg = (0, _jquery["default"])('<img>', {
        src: metadata.cardUrl,
        "class": 'card-img-top',
        alt: metadata.name
      });

      // Card body
      var cardBody = (0, _jquery["default"])('<div>', {
        "class": 'card-body'
      }).append((0, _jquery["default"])('<h5>', {
        "class": 'card-title'
      }).text(metadata.name), (0, _jquery["default"])('<p>', {
        "class": 'card-text text-muted'
      }).text("(".concat(metadata.subName, ")")));

      // Character table
      if (Array.isArray(metadata.charTable) && metadata.charTable.length > 0) {
        var cardBodyTable = (0, _jquery["default"])('<table>', {
          "class": 'table table-hover m-0'
        });
        var cardBodyTbody = (0, _jquery["default"])('<tbody>');
        for (var tIndex in metadata.charTable) {
          if (typeof metadata.charTable[tIndex][1] !== 'undefined') {
            var td = (0, _jquery["default"])('<td>', {
              "class": 'bg-transparent'
            });
            if (typeof metadata.charTable[tIndex][1] === 'string') td.text(metadata.charTable[tIndex][1]);else if (typeof metadata.charTable[tIndex][1].text === 'string' && typeof metadata.charTable[tIndex][1].url === 'string') td.append((0, _jquery["default"])('<a>', {
              "class": 'text-decoration-none',
              target: '_blank',
              href: !metadata.charTable[tIndex][1].isRepUrl ? metadata.charTable[tIndex][1].url : 'javascript:void(0)',
              file: metadata.charTable[tIndex][1].isRepUrl ? "../".concat(metadata.charTable[tIndex][1].isRepUrl) : null
            }).text(metadata.charTable[tIndex][1].text));
            cardBodyTbody.append((0, _jquery["default"])('<tr>').append((0, _jquery["default"])('<th>', {
              "class": 'bg-transparent',
              scope: 'row'
            }).text(metadata.charTable[tIndex][0]), td));
          }
        }
        cardBodyTable.append(cardBodyTbody);
        cardBody.append(cardBodyTable);
      }

      // Add card
      card.append(cardImg, cardBody);
      colSidebar.append(card);

      // Complete
      row.append(colSidebar, colMain);
      markdownBase.html(row);
    }
  };

  // Insert Data
  markdownBase.empty();
  if (!metadata || typeof metadata.mode !== 'string' || typeof pageTypes[metadata.mode] !== 'function') markdownBase.html(data);else pageTypes[metadata.mode]();

  // Top Page
  if (isMainPage) {
    _tinyEssentials.TinyHtml.query('#top_page').removeClass('d-none');
  } else {
    _tinyEssentials.TinyHtml.query('#top_page').addClass('d-none');
  }
  var markdownHid = function markdownHid(text) {
    return "tiny-wiki-".concat(encodeURIComponent(text.toLowerCase().trim().replace(/ /g, '_').replace(/\(|\)|\?|\!/g, '_')));
  };
  markdownBase.find("h1,h2,h3,h4,h5").each(function () {
    (0, _jquery["default"])(this).attr('id', markdownHid((0, _jquery["default"])(this).text()));
  });

  // Content List
  if (canContentList) (0, _jquery["default"])('[id="markdown-read"] .content-list-data').each(function () {
    var tinyBase = (0, _jquery["default"])('<div>', {
      "class": 'bg-black rounded-top collapse-content d-flex align-items-center'
    });
    // Open Button
    var openButton = (0, _jquery["default"])('<h5>', {
      "class": 'm-0 p-2 w-100'
    });
    openButton.text('Contents').prepend(_tinyLib["default"].icon('d-flex align-items-center fa-solid fa-list me-2 small'));
    var collapseButton = _tinyLib["default"].bs.button('link btn-bg p-2 d-flex justify-content-center align-items-center me-2').attr('data-bs-toggle', 'collapse').attr('href', '#content-list-collapse').css({
      height: 30,
      width: 30,
      'font-size': '14px'
    }).append(_tinyLib["default"].icon('fa-solid fa-square-minus'));
    tinyBase.append(openButton, collapseButton);

    // The Ul
    var ul = (0, _jquery["default"])('<ul>', {
      "class": 'list-group mb-3 rounded-top-0 bg-black collapse show',
      id: 'content-list-collapse'
    });

    // Insert Li
    var insertLi = function insertLi() {
      var tClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var text = arguments.length > 1 ? arguments[1] : undefined;
      var isLast = arguments.length > 2 ? arguments[2] : undefined;
      var index = arguments.length > 3 ? arguments[3] : undefined;
      var index2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var extraElement = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var li = (0, _jquery["default"])('<li>', {
        "class": "".concat(tClass, " pb-0 border-0")
      });
      var liTarget = markdownBase.find("#".concat(markdownHid(text)));
      var tinyText = "".concat(Number(index) + 1, ".").concat(index2 !== null ? "".concat(Number(index2), ".") : '', " ").concat(text);
      li.append((0, _jquery["default"])('<a>', {
        "class": 'btn btn-link btn-bg w-100 text-start',
        href: liTarget.length > 0 ? "#".concat(liTarget.attr('id')) : null
      }).text(tinyText));
      if (extraElement) li.append(extraElement);
      return li;
    };

    // Read data
    var isLast = false;
    for (var index = 0; index < metadata.contentList.length; index++) {
      isLast = index === metadata.contentList.length - 1;
      if (typeof metadata.contentList[index] === 'string') ul.append(insertLi('list-group-item pt-0', metadata.contentList[index], isLast, index));else if (Array.isArray(metadata.contentList[index]) && metadata.contentList[index].length > 0) {
        var ul2 = (0, _jquery["default"])('<ul>', {
          "class": 'my-0'
        });
        ul.append(insertLi('list-group-item py-0', metadata.contentList[index][0], null, index, null, ul2));
        for (var index2 in metadata.contentList[index]) if (Number(index2) !== 0 && typeof metadata.contentList[index][index2] === 'string') ul2.append(insertLi("pt-0", metadata.contentList[index][index2], isLast, index, index2));
      }
    }
    ul.find('> li:first').removeClass('py-0').removeClass('pt-0').addClass('pb-0');
    ul.find('> li:last').removeClass('py-0').removeClass('pb-0').addClass('pt-0');
    (0, _jquery["default"])(this).append(tinyBase, ul);
  });

  // Convert File URLs
  (0, _jquery["default"])('[id="markdown-read"] a[file]').removeAttr('target').on('click', function () {
    openMDFile((0, _jquery["default"])(this).attr('file'));
  });

  // Fix Image
  (0, _jquery["default"])('[id="markdown-read"] img').each(function () {
    if ((0, _jquery["default"])(this).parents('a').length < 1) {
      // New Image Item
      var src = (0, _jquery["default"])(this).attr('src');
      var newImage = (0, _jquery["default"])('<img>', {
        "class": 'img-fluid'
      }).css('height', (0, _jquery["default"])(this).attr('height')).css('width', (0, _jquery["default"])(this).attr('width'));
      (0, _jquery["default"])(this).replaceWith(newImage);

      // Load Image FIle
      newImage.css({
        cursor: 'pointer',
        opacity: '0%',
        'pointer-events': 'none'
      }).on('load', function () {
        var newImg = new Image();
        var tinyThis = (0, _jquery["default"])(this);
        newImg.onload = function () {
          tinyThis.data('image-size', {
            width: this.width,
            height: this.height
          });
          tinyThis.css({
            opacity: '100%',
            'pointer-events': ''
          });
        };
        newImg.src = (0, _jquery["default"])(this).attr('src');
      }).on('click', function () {
        var imgSize = (0, _jquery["default"])(this).data('image-size');
        var imgData = {
          src: (0, _jquery["default"])(this).attr('src')
        };
        var imgAlt = (0, _jquery["default"])(this).add('alt');
        if (imgSize) {
          imgData.h = imgSize === null || imgSize === void 0 ? void 0 : imgSize.height;
          imgData.w = imgSize === null || imgSize === void 0 ? void 0 : imgSize.width;
        }
        if (typeof imgAlt === 'string' && imgAlt.length > 0) imgData.alt = imgAlt;
        var pswp = new _photoswipe["default"]({
          dataSource: [imgData],
          close: true,
          zoom: true,
          fullscreen: true,
          counter: false,
          arrowPrev: false,
          arrowNext: false,
          share: false,
          padding: {
            top: 40,
            bottom: 40,
            left: 100,
            right: 100
          }
        });
        pswp.on('close', function () {
          setTimeout(function () {
            pswp.destroy();
          }, 5000);
        });
        pswp.init();
        (0, _jquery["default"])(this).fadeTo('fast', 0.7, function () {
          (0, _jquery["default"])(this).fadeTo('fast', 1);
        });
        return false;
      }).hover(function () {
        (0, _jquery["default"])(this).fadeTo('fast', 0.8);
      }, function () {
        (0, _jquery["default"])(this).fadeTo('fast', 1);
      });

      // Load Image
      newImage.attr('src', src);
      var newTinyPlace = (0, _jquery["default"])('<p>', {
        "class": 'pswp-space mt-4'
      });
      newTinyPlace.insertAfter(newImage);
    }
  });
};

// Remove Fic Data
var clearFicData = exports.clearFicData = function clearFicData() {
  if (appData.ai.interval) {
    clearInterval(appData.ai.interval);
    appData.ai.interval = null;
    appData.ai.secondsUsed = 0;
  }
  appData.ai.killIo();
  for (var item in _chapters.storyData.sfx) {
    if (typeof _chapters.storyData.sfx[item].hide === 'function') {
      _chapters.storyData.sfx[item].hide(0);
    }
    if (_chapters.storyData.sfx[item].pizzicato && typeof _chapters.storyData.sfx[item].pizzicato.hide === 'function') {
      _chapters.storyData.sfx[item].pizzicato.hide(0);
    }
  }
  (0, _jquery["default"])('body').removeClass('ficMode').removeClass("fic-daycicle-morning").removeClass("fic-daycicle-evening").removeClass("fic-daycicle-night").removeClass("fic-daycicle-lateAtNight");
  _chapters.storyData.nc.base.right.find('> #status').empty();
  (0, _jquery["default"])('#fic-chapter').empty();
  _chapters.storyData.readFic = false;
  _chapters.storyData.chapter.html = {};
  _chapters.storyData.chapter.line = null;
  _chapters.storyData.chapter.nav = {};
  _chapters.storyData.chapter.selected = 0;
  if (_chapters.storyData.youtube.player && _chapters.storyData.youtube.checkYT() && _chapters.storyData.youtube.state === YT.PlayerState.PLAYING) {
    _chapters.storyData.youtube.player.stopVideo();
  }
};

// Open MD File
var openMDFile = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(url) {
    var isMain,
      fileData,
      fileLines,
      md,
      title,
      metadata,
      githubRegex,
      key,
      match,
      name,
      indices,
      currentLevel,
      i,
      markdownLink,
      _args = arguments;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          isMain = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
          if (!(typeof url === 'string')) {
            _context.n = 5;
            break;
          }
          // Remove Fic Data
          clearFicData();

          // New page
          if (!(url !== 'MAIN')) {
            _context.n = 3;
            break;
          }
          // Read Data Base
          console.log("Opening MD file \"".concat(url, "\"..."));
          circleLoader.start();

          // Load ajax
          _context.n = 1;
          return fetch("".concat(url.startsWith('/') ? url : "/".concat(url)).concat(fileVersion), {
            method: 'GET',
            dataType: 'text'
          }).then(function (res) {
            return res.text();
          })["catch"](function (err) {
            circleLoader.close();
            console.error(err);
            alert(err.message);
          });
        case 1:
          fileData = _context.v;
          if (fileData) {
            _context.n = 2;
            break;
          }
          return _context.a(2);
        case 2:
          try {
            // Get metadata
            fileLines = _tinyLib["default"].mdManager.removeMetadata(fileData);
            md = _tinyLib["default"].mdManager.extractMetadata(fileData);
            title = md.title; // Prepare metadata (script created by ChatGPT)
            metadata = {};
            githubRegex = _tinyLib["default"].getGitUrlPath('{url}docs\\/');
            for (key in md) {
              match = key.match(/^([^_]+)(?:_(\d+))+/);
              if (match) {
                name = match[1];
                indices = match[0].split('_').slice(1).map(Number);
                if (!metadata[name]) {
                  metadata[name] = [];
                }
                currentLevel = metadata[name];
                for (i = 0; i < indices.length - 1; i++) {
                  if (!currentLevel[indices[i]]) {
                    currentLevel[indices[i]] = [];
                  }
                  currentLevel = currentLevel[indices[i]];
                }
                markdownLink = md[key].match(/^\[(.*?)\]\((.*?)\)$/);
                if (markdownLink) {
                  currentLevel[indices[indices.length - 1]] = {
                    text: markdownLink[1],
                    url: markdownLink[2],
                    isRepUrl: githubRegex.test(markdownLink[2]) ? markdownLink[2].replace(githubRegex, '') : null
                  };
                } else {
                  currentLevel[indices[indices.length - 1]] = md[key];
                }
              } else metadata[key] = md[key];
            }

            // Complete! Insert data into page
            console.log("".concat(url.endsWith('.md') ? 'MD' : 'HTML', " File opened successfully!"));
            insertMarkdownFile(fileLines, metadata, isMain, url.endsWith('.md') ? false : true);
            _tinyEssentials.TinyHtml.setWinScrollTop(0);
            circleLoader.close();
            urlUpdate(url, title);
          } catch (err) {
            // Error!
            circleLoader.close();
            console.error(err);
            alert(err.message);
          }
          _context.n = 4;
          break;
        case 3:
          insertMarkdownFile(_chapters.storyData.readme, null, isMain, true);
          urlUpdate();
        case 4:
          return _context.a(2);
        case 5:
          throw new Error('Invalid Md File Url!');
        case 6:
          return _context.a(2);
      }
    }, _callee);
  }));
  return function openMDFile(_x) {
    return _ref.apply(this, arguments);
  };
}();

// Start App
var rootApp = exports.rootApp = new _tinyEssentials.TinyDomReadyManager();
rootApp.onReady(function () {
  if (typeof window.ethereum !== 'undefined') document.body.classList.add('browser-with-web3');
  (0, _tinyEssentials.installWindowHiddenScript)();
  vanillaPwa.install();
  var startApp = function startApp() {
    console.log('Starting App...');
    _chapters.storyData.start(function (connStore, fn, readme) {
      var tinyAiScript = (0, _aiSoftware.AiScriptStart)(connStore);
      appData.ai.killIo = tinyAiScript.killIo;

      // Custom Colors
      (0, _jquery["default"])('head').append((0, _jquery["default"])('<style>', {
        id: 'custom_color'
      }).text("\n\n            .alert .close span{\n                color: ".concat(_config["default"].theme.color4, " !important;\n            }\n            \n            .alert .close, .alert .close:hover{\n                color: ").concat(_config["default"].theme.color, " !important;\n            }\n            \n            \n            .navbar-dark.bg-dark, #navTopPage {\n                background-color: ").concat(_config["default"].theme.primary, " !important;\n            }\n            \n            .navbar-dark .navbar-nav .nav-link {\n                color: ").concat(_config["default"].theme.color, " !important;\n            }\n            \n            .navbar-dark .navbar-nav .nav-link:hover {\n                color: ").concat(_config["default"].theme.color2, " !important;\n            }\n            \n            \n            #sidebar {\n                background: ").concat(_config["default"].theme.secondary, ";\n                color: ").concat(_config["default"].theme.color3, ";\n            }\n            \n            #sidebar .sidebar-header {\n                background: ").concat(_config["default"].theme.primary, ";\n                color: ").concat(_config["default"].theme.color, ";\n            }\n            \n            #sidebar ul p {\n                color: ").concat(_config["default"].theme.color, ";\n            }\n            \n            #sidebar ul li a:hover {\n                color: ").concat(_config["default"].theme.color, ";\n                background: ").concat(_config["default"].theme.primary, ";\n            }\n            \n            #sidebar ul li.active > a, #sidebar a[aria-expanded=\"true\"] {\n                color: ").concat(_config["default"].theme.color, ";\n                background: ").concat(_config["default"].theme.primary, ";\n            }\n            \n            \n            .tcat, #footer2{\n                color: ").concat(_config["default"].theme.color, " !important;\n                background-color: ").concat(_config["default"].theme.secondary, " !important;\n            }\n            \n            .tcat, #footer2 a:hover{\n                color: ").concat(_config["default"].theme.color2, " !important;\n            }\n            \n            \n            #footer, .modal.fade .modal-header, .thead, .page-footer, .comment-header{\n                color: ").concat(_config["default"].theme.color, " !important;\n                background-color: ").concat(_config["default"].theme.primary, " !important\n            }\n            \n            .page-footer a:hover, .page-footer a:hover, #sidebar a {\n                color: ").concat(_config["default"].theme.color2, " !important;\n            }\n            \n            .thead a{\n                color: ").concat(_config["default"].theme.color, " !important;\n            }\n            \n            .thead a:hover{\n                color: ").concat(_config["default"].theme.color2, " !important;\n            }\n            \n            \n            .nav-pills .nav-link.active, .nav-pills .show>.nav-link {\n                color: ").concat(_config["default"].theme.color, " !important;\n                background-color: ").concat(_config["default"].theme.primary, " !important;\n            }\n            \n            .nav-pills .show>.nav-link:hover {\n                color: ").concat(_config["default"].theme.color2, " !important;\n            }\n            \n            .page-footer a, #sidebar a {\n                color: ").concat(_config["default"].theme.color, " !important;\n            }\n            \n            \n            \n            \n            \n            .dropdown-item.active, .dropdown-item:active {\n                color: ").concat(_config["default"].theme.color, ";\n                background-color: ").concat(_config["default"].theme.secondary, "; \n            }\n            \n            .nav-pills .nav-link.active,\n            .nav-pills .show > .nav-link {\n                color: ").concat(_config["default"].theme.color, ";\n                background-color: ").concat(_config["default"].theme.secondary, "; \n            }\n            \n            ")));

      // Readme
      _chapters.storyData.readme = readme;

      // Read Updater
      var isNewValue = '';
      _chapters.storyData.globalIsNew = 0;
      for (var chapter in _chapters.storyData.isNew) {
        if (_chapters.storyData.isNew[chapter] === 2 && _chapters.storyData.isNew[chapter] > _chapters.storyData.globalIsNew) {
          _chapters.storyData.globalIsNew = 2;
          isNewValue = (0, _jquery["default"])('<span>', {
            "class": 'badge badge-primary ms-2'
          }).text('NEW');
        } else if (_chapters.storyData.isNew[chapter] === 1 && _chapters.storyData.isNew[chapter] > _chapters.storyData.globalIsNew) {
          _chapters.storyData.globalIsNew = 1;
          isNewValue = (0, _jquery["default"])('<span>', {
            "class": 'badge badge-secondary ms-2'
          }).text('UPDATE');
        }
      }

      // Year
      var yearNow = (0, _moment["default"])().year();
      var copyrightText = null;
      if (yearNow === _config["default"].year) {
        copyrightText = "\xA9 ".concat(_config["default"].year, " ").concat(_config["default"].title, " | ");
      } else {
        copyrightText = "\xA9 ".concat(_config["default"].year, " - ").concat(yearNow, " ").concat(_config["default"].title, " | ");
      }

      // Dropdown
      var addDropdown = function addDropdown(newItem) {
        for (var valueName in newItem.dropdowns) {
          var dataList = newItem.dbBase[valueName];
          var tinyHtml = newItem.dropdowns[valueName];
          _tinyLib["default"].bs.dropdownClick(tinyHtml, dataList, function (li, element, item) {
            // Create Dropdown
            var aItem = (0, _jquery["default"])('<a>', {
              "class": 'dropdown-item',
              id: item.id,
              href: item.href
            });
            li.append(aItem);

            // Add text
            aItem.text(item.text);
            if (item.icon) aItem.prepend(_tinyLib["default"].icon("".concat(item.icon, " me-2")));

            // File
            if (typeof item.file === 'string') {
              aItem.attr('href', 'javascript:void(0)');
              aItem.attr('file', item.file);
            }

            // Target
            if (item.href && item.href !== 'javascript:void(0)') aItem.attr('target', '_blank');

            // Is web3
            if (item.web3Element) li.addClass('web3-element');

            // Click
            if (typeof item.file === 'string') li.on('click', function () {
              openMDFile(aItem.attr('file'));
            });
            if (item.click) li.on('click', item.click);
            li.on('click', function () {
              element.hide();
              offCanvasNavCfg.hide();
            });
          });
        }
      };

      // Insert Navbars
      var navbarItems = function navbarItems() {
        // Base Crypto Modal
        var offCanvasEl = null;
        var baseCryptoModal = function baseCryptoModal(crypto_value, title) {
          return function () {
            var qrcodeCanvas = (0, _jquery["default"])('<canvas>');
            _qrcode["default"].toCanvas(qrcodeCanvas[0], _config["default"][crypto_value].address, function (error) {
              if (error) {
                alert(error);
              } else {
                // Prepare Text
                _tinyLib["default"].modal({
                  title: title + ' Network Donation',
                  id: 'busd_request',
                  dialog: 'modal-lg',
                  body: (0, _jquery["default"])('<center>').append((0, _jquery["default"])('<h4>', {
                    "class": 'mb-5'
                  }).text('Please enter the address correctly! Any type issue will be permanent loss of your funds!'), (0, _jquery["default"])('<a>', {
                    target: '_blank',
                    href: _config["default"][crypto_value].explorer + _config["default"][crypto_value].address
                  }).text('Blockchain Explorer'), (0, _jquery["default"])('<br>'), (0, _jquery["default"])('<span>').text(_config["default"][crypto_value].address), (0, _jquery["default"])('<div>', {
                    "class": 'mt-3'
                  }).append(qrcodeCanvas)),
                  footer: []
                });
              }
            });

            // Complete
            return false;
          };
        };

        // Base
        var newItem = {
          dbBase: {}
        };
        newItem.dbBase.donations = [];
        newItem.dbBase.information = [];
        newItem.dbBase.characters = [];
        newItem.setOffCanvas = function (newOffCanvas) {
          offCanvasEl = newOffCanvas;
        };

        // Derpibooru
        newItem.dbBase.information.push({
          href: "https://derpibooru.org/tags/".concat(_config["default"].derpibooru_tag),
          id: 'derpibooru-page',
          text: 'Derpibooru',
          icon: 'fa-solid fa-paintbrush'
        });

        // Tantabus
        newItem.dbBase.information.push({
          href: "https://tantabus.ai/tags/".concat(_config["default"].derpibooru_tag),
          id: 'tantabus-page',
          text: 'Tantabus',
          icon: 'fa-solid fa-paintbrush'
        });

        // Tiny Tips
        newItem.dbBase.information.push({
          href: "javascript:void(0)",
          id: 'information-menu',
          text: 'Museum',
          icon: 'fa-solid fa-building-columns',
          click: function click() {
            return openMDFile('pages/museum.md');
          }
        });
        newItem.dbBase.information.push({
          href: "javascript:void(0)",
          id: 'tiny-ai-writer-tips',
          text: 'AI Tips for human artists',
          icon: 'fa-solid fa-circle-info',
          click: function click() {
            return openMDFile('pages/artistTips.md');
          }
        });
        newItem.dbBase.information.push({
          href: "javascript:void(0)",
          id: 'ai-fic-template',
          text: 'Official AI Models',
          icon: 'fa-solid fa-toolbox',
          click: function click() {
            return openMDFile('pages/ai-templates/ai-models.md');
          }
        });

        // Patreon
        if (_config["default"].patreon) {
          newItem.dbBase.donations.push({
            href: "https://patreon.com/".concat(_config["default"].patreon),
            id: 'patreon-url',
            text: 'Patreon',
            icon: 'fa-brands fa-patreon'
          });
        }

        // Kofi
        if (_config["default"].kofi) {
          newItem.dbBase.donations.push({
            href: "https://ko-fi.com/".concat(_config["default"].kofi),
            id: 'kofi-url',
            text: 'Ko-Fi',
            icon: 'fa-solid fa-mug-hot'
          });
        }

        // Bitcoin
        if (_config["default"].bitcoin && _config["default"].bitcoin.address && _config["default"].bitcoin.explorer) {
          newItem.dbBase.donations.push({
            href: _config["default"].bitcoin.explorer + _config["default"].bitcoin.address,
            id: 'bitcoin-wallet',
            text: 'Bitcoin',
            icon: 'fa-brands fa-bitcoin',
            click: baseCryptoModal('bitcoin', 'Bitcoin')
          });
        }

        // Dogecoin
        if (_config["default"].dogecoin && _config["default"].dogecoin.address && _config["default"].dogecoin.explorer) {
          newItem.dbBase.donations.push({
            href: _config["default"].dogecoin.explorer + _config["default"].dogecoin.address,
            id: 'dogecoin-wallet',
            text: 'Dogecoin',
            icon: 'cf cf-doge',
            click: baseCryptoModal('dogecoin', 'Dogecoin')
          });
        }

        // Ethereum
        if (_config["default"].ethereum && _config["default"].ethereum.address && _config["default"].ethereum.explorer) {
          newItem.dbBase.donations.push({
            href: _config["default"].ethereum.explorer + _config["default"].ethereum.address,
            id: 'ethereum-wallet',
            text: 'Ethereum',
            icon: 'fa-brands fa-ethereum',
            web3Element: true,
            click: baseCryptoModal('ethereum', 'Ethereum')
          });
        }

        // Polygon
        if (_config["default"].polygon && _config["default"].polygon.address && _config["default"].polygon.explorer) {
          newItem.dbBase.donations.push({
            href: _config["default"].polygon.explorer + _config["default"].polygon.address,
            id: 'polygon-wallet',
            text: 'Polygon',
            icon: 'cf cf-matic',
            web3Element: true,
            click: baseCryptoModal('polygon', 'Polygon')
          });
        }

        // BNB
        if (_config["default"].bnb && _config["default"].bnb.address && _config["default"].bnb.explorer) {
          newItem.dbBase.donations.push({
            href: _config["default"].bnb.explorer + _config["default"].bnb.address,
            id: 'bnb-wallet',
            text: 'BNB',
            icon: 'cf cf-bnb',
            web3Element: true,
            click: baseCryptoModal('bnb', 'BNB')
          });
        }

        // Crypto Wallet
        if (_config["default"].nftDomain && _config["default"].nftDomain.url) {
          newItem.dbBase.donations.push({
            href: _config["default"].nftDomain.url.replace('{domain}', _config["default"].nftDomain.domainWallet),
            id: 'crypto-wallet',
            text: 'More crypto wallets',
            web3Element: true,
            icon: 'fas fa-wallet'
          });
        }

        // Characters
        newItem.dbBase.characters.push({
          file: '/data/characters/rayane/README.md',
          text: 'Rayane (Page WIP)'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/james/README.md',
          text: 'James (Character WIP)'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/rainbow-queen/README.md',
          text: 'Rainbow Queen'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/princess-ariella/README.md',
          text: 'Princess Ariella (Page WIP)'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/amy/README.md',
          text: 'Amy (Page WIP)'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/layla/README.md',
          text: 'Layla (Page WIP)'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/prisma/README.md',
          text: 'Prisma (Character WIP)'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/aniya/README.md',
          text: 'Aniya (Character WIP)'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/blue-screen/README.md',
          text: 'Blue Screen (Page WIP)'
        });
        newItem.dbBase.characters.push({
          file: '/data/characters/whistler/README.md',
          text: 'Whistler (Character WIP)'
        });

        // AI Login
        var aiLogin = {
          base: (0, _jquery["default"])('<li>', {
            "class": 'nav-item font-weight-bold'
          }),
          secondsUsed: 0,
          title: '',
          updateTitle: function updateTitle() {
            if (aiLogin.button) {
              var title = "".concat(aiLogin.title).concat(aiLogin.secondsUsed > 0 ? " - ".concat((0, _tinyEssentials.formatDayTimer)(aiLogin.secondsUsed)) : '');
              aiLogin.button.removeAttr('title');
              aiLogin.button.attr('data-bs-original-title', title);
            }
          }
        };
        tinyAiScript.setAiLogin(aiLogin);
        aiLogin.button = _tinyLib["default"].bs.button({
          id: 'ai-login',
          dsBtn: true,
          "class": 'nav-link'
        }).prepend(_tinyLib["default"].icon('fa-solid fa-robot me-2'));
        tinyAiScript.checkTitle();
        aiLogin.base.prepend(aiLogin.button);
        aiLogin.button.on('click', function () {
          tinyAiScript.login(this);
          return false;
        });

        // Nav Items
        newItem.dropdowns = {};
        newItem.dropdowns.information = (0, _jquery["default"])('<li>', {
          "class": 'nav-item dropdown',
          id: 'information-menu'
        }).prepend(_tinyLib["default"].bs.button({
          dsBtn: true,
          "class": 'nav-link dropdown-toggle'
        }).text('Information'));
        // Donations Button
        newItem.dropdowns.donations = (0, _jquery["default"])('<li>', {
          "class": 'nav-item dropdown',
          id: 'donations-menu'
        }).prepend(_tinyLib["default"].bs.button({
          dsBtn: true,
          "class": 'nav-link dropdown-toggle'
        }).text('Donations'));
        // Characters
        newItem.dropdowns.characters = (0, _jquery["default"])('<li>', {
          "class": 'nav-item dropdown',
          id: 'characters-menu'
        }).prepend(_tinyLib["default"].bs.button({
          dsBtn: true,
          "class": 'nav-link dropdown-toggle'
        }).text('Characters'));
        newItem.left = [
        // Homepage
        (0, _jquery["default"])('<li>', {
          "class": 'nav-item'
        }).prepend((0, _jquery["default"])('<a>', {
          "class": 'nav-link',
          href: '/',
          id: 'homepage'
        }).text('Home').prepend(_tinyLib["default"].icon('fas fa-home me-2')).on('click', function () {
          openMDFile('MAIN', true);
          if (offCanvasEl) offCanvasEl.hide();
          return false;
        })),
        // Discord Server
        (0, _jquery["default"])('<li>', {
          "class": 'nav-item'
        }).prepend((0, _jquery["default"])('<a>', {
          "class": 'nav-link',
          target: '_blank',
          href: "https://discord.gg/".concat(_config["default"].discordInvite),
          id: 'discord-server'
        }).text('Discord').prepend(_tinyLib["default"].icon('fab fa-discord me-2')).on('click', function () {
          if (offCanvasEl) offCanvasEl.hide();
        })),
        // Blog
        (0, _jquery["default"])('<li>', {
          "class": 'nav-item'
        }).prepend((0, _jquery["default"])('<a>', {
          "class": 'nav-link',
          target: '_blank',
          href: _config["default"].blog_url,
          id: 'blog-url'
        }).text('Blog').prepend(_tinyLib["default"].icon('fa-solid fa-rss me-2')).on('click', function () {
          if (offCanvasEl) offCanvasEl.hide();
        })),
        // AI
        (0, _jquery["default"])('<li>', {
          "class": 'nav-item nav-ai'
        }).prepend((0, _jquery["default"])('<a>', {
          "class": 'nav-link',
          href: '/?path=ai',
          id: 'ai-access-page'
        }).text('AI Page').prepend(_tinyLib["default"].icon('fa-solid fa-server me-2')).on('click', function () {
          tinyAiScript.open();
          if (offCanvasEl) offCanvasEl.hide();
          return false;
        })), newItem.dropdowns.information, newItem.dropdowns.donations, newItem.dropdowns.characters];
        newItem.right = [
        // Status Place
        (0, _jquery["default"])('<span>', {
          id: 'status'
        }),
        // Chapter Name
        (0, _jquery["default"])('<li>', {
          id: 'fic-chapter',
          "class": 'nav-item nav-link'
        }),
        // Login
        aiLogin.base,
        // Read Fic
        (0, _jquery["default"])('<li>', {
          "class": 'nav-item font-weight-bold'
        }).prepend((0, _jquery["default"])('<a>', {
          id: 'fic-start',
          "class": 'nav-link',
          href: '/?path=read-fic'
        }).text('Read Fic').append(isNewValue).prepend(_tinyLib["default"].icon('fab fa-readme me-2'))).on('click', function () {
          (0, _jquery["default"])('#top_page').addClass('d-none');
          (0, _index.openChapterMenu)();
          if (offCanvasEl) offCanvasEl.hide();
          return false;
        })];
        aiLogin.button.tooltip();
        return newItem;
      };

      // Navbar items
      var navbarData = navbarItems();
      var offCanvasBase = (0, _jquery["default"])('<ul>', {
        "class": 'list-group list-group-flush'
      });
      var navbarOffCanvas = _tinyLib["default"].bs.offcanvas('end d-lg-none', 'offcanvasNavbar', 'Pony Driland', offCanvasBase);
      var tinyCollapse1 = _tinyLib["default"].bs.navbar.collapse('left', 'small mdMenu', null);
      var tinyCollapse2 = _tinyLib["default"].bs.navbar.collapse('right', 'small mdMenu', 'fic-nav');

      // Insert Navbar
      (0, _jquery["default"])('body').prepend(
      // Navbar
      navbarOffCanvas, _tinyLib["default"].bs.navbar.root('md-navbar', 'dark', true).append(
      // Title
      _tinyLib["default"].bs.navbar.title(_config["default"].title, '/').on('click', function () {
        openMDFile('MAIN', true);
        return false;
      }),
      // Offcanvas button
      _tinyLib["default"].bs.button({
        dsBtn: true,
        "class": 'navbar-toggler',
        toggle: 'offcanvas',
        target: '#offcanvasNavbar'
      }).append((0, _jquery["default"])('<span>', {
        "class": 'navbar-toggler-icon'
      })),
      // Collapse
      tinyCollapse1, tinyCollapse2));
      _chapters.storyData.nc = {
        base: {},
        item: {}
      };
      _chapters.storyData.nc.item.left = tinyCollapse1.find('> ul');
      _chapters.storyData.nc.item.right = tinyCollapse2.find('> ul');
      var offCanvasNavCfg = new _bootstrap.Offcanvas(navbarOffCanvas.get(0));
      addDropdown(navbarData);
      navbarData.setOffCanvas(offCanvasNavCfg);
      var checkWindowSize = function checkWindowSize() {
        if (window.matchMedia('(min-width: 992px)').matches) {
          _chapters.storyData.nc.base.left = _chapters.storyData.nc.item.left;
          _chapters.storyData.nc.base.right = _chapters.storyData.nc.item.right;
          _chapters.storyData.nc.item.left.append(navbarData.left);
          _chapters.storyData.nc.item.right.append(navbarData.right);
        } else {
          _chapters.storyData.nc.base.left = offCanvasBase;
          _chapters.storyData.nc.base.right = offCanvasBase;
          offCanvasBase.append(navbarData.left, navbarData.right);
        }
      };
      window.addEventListener('resize', checkWindowSize);
      checkWindowSize();

      // Insert Readme
      (0, _jquery["default"])('#app').append(_tinyLib["default"].bs.container('markdown-read'));

      // Footer Base
      var tinyFooter = {
        1: [],
        2: []
      };

      // Footer 1

      // OpenSea
      if (_config["default"].opensea) {
        tinyFooter[1].push((0, _jquery["default"])('<li>').append((0, _jquery["default"])('<a>', {
          target: '_blank',
          href: "https://opensea.io/collection/".concat(_config["default"].opensea)
        }).text('OpenSea').prepend(_tinyLib["default"].icon('fab fa-ethereum me-2'))));
      }

      // CID32
      if (_chapters.storyData.cid32) {
        tinyFooter[1].push((0, _jquery["default"])('<li>').append((0, _jquery["default"])('<a>', {
          href: "https://".concat(_chapters.storyData.cid32, ".ipfs.dweb.link/")
        }).text('IPFS ' + _config["default"].nftDomain.name).prepend(_tinyLib["default"].icon('fas fa-wifi me-2'))));
      }

      // Mastodon
      if (_config["default"].mastodon) {
        tinyFooter[1].push((0, _jquery["default"])('<li>').prepend((0, _jquery["default"])('<a>', {
          rel: 'me',
          target: '_blank',
          href: "https://".concat(_config["default"].mastodon.domain, "/@").concat(_config["default"].mastodon.username)
        }).text('Mastodon').prepend(_tinyLib["default"].icon('fa-brands fa-mastodon me-2'))));
      }

      // Discord Invite
      if (_config["default"].discordInvite) {
        tinyFooter[1].push((0, _jquery["default"])('<li>').append((0, _jquery["default"])('<a>', {
          target: '_blank',
          href: "https://discord.gg/".concat(_config["default"].discordInvite)
        }).text('Discord Server').prepend(_tinyLib["default"].icon('fab fa-discord me-2'))));
      }

      // Mirror
      if (Array.isArray(_config["default"].mirror) && _config["default"].mirror.indexOf(location.host) > -1 || !Array.isArray(_config["default"].mirror) || _config["default"].mirror.length < 1) {
        tinyFooter[1].push((0, _jquery["default"])('<li>').append((0, _jquery["default"])('<a>', {
          target: '_blank',
          href: "https://".concat(_config["default"].domain)
        }).text('Website').prepend(_tinyLib["default"].icon('fa-solid fa-pager me-2'))));
      } else {
        var _ref2;
        tinyFooter[1].push((0, _jquery["default"])('<li>').append((0, _jquery["default"])('<a>', {
          target: '_blank',
          href: "https://".concat(_config["default"].mirror[Math.floor((_ref2 = Math.random() * (_config["default"] === null || _config["default"] === void 0 ? void 0 : _config["default"].mirror.length)) !== null && _ref2 !== void 0 ? _ref2 : 0)])
        }).text('Mirror').prepend(_tinyLib["default"].icon('fa-solid fa-pager me-2'))));
      }

      // Footer 2
      if (_config["default"].nftDomain) {
        tinyFooter[2].push((0, _jquery["default"])('<li>').append((0, _jquery["default"])('<a>', {
          target: '_blank',
          href: _config["default"].nftDomain.url.replace('{domain}', _config["default"].nftDomain.valueURL)
        }).text(_config["default"].nftDomain.name).prepend(_tinyLib["default"].icon('fas fa-marker me-2'))));
      }
      if (_config["default"].github) {
        tinyFooter[2].push((0, _jquery["default"])('<li>').append((0, _jquery["default"])('<a>', {
          target: '_blank',
          href: "https://github.com/".concat(_config["default"].github.account, "/").concat(_config["default"].github.repository)
        }).text('Github').prepend(_tinyLib["default"].icon('fab fa-github me-2'))));
      }
      tinyFooter[2].push((0, _jquery["default"])('<li>').append((0, _jquery["default"])('<a>', {
        target: '_blank',
        href: 'mailto:' + _config["default"].contact
      }).text('Contact').prepend(_tinyLib["default"].icon('fas fa-envelope me-2'))));
      tinyFooter[2].push((0, _jquery["default"])('<li>').prepend((0, _jquery["default"])('<a>', _defineProperty(_defineProperty({
        href: '/?path=%2FLICENSE.md&title=License'
      }, "href", '/?path=%2FLICENSE.md&title=License'), "id", 'license')).text('License').prepend(_tinyLib["default"].icon('fas fa-copyright me-2'))).on('click', function () {
        openMDFile('/LICENSE.md');
        return false;
      }));

      // Insert Footer
      (0, _jquery["default"])('body').append((0, _jquery["default"])('<footer>', {
        "class": 'page-footer font-small pt-4 clearfix'
      }).append(
      // Base
      (0, _jquery["default"])('<div>', {
        "class": 'container-fluid text-center text-md-left'
      }).append((0, _jquery["default"])('<div>', {
        "class": 'row'
      }).append(
      // Logo
      (0, _jquery["default"])('<div>', {
        "class": 'col-md-6 mt-md-0 mt-3'
      }).append((0, _jquery["default"])('<center>').append((0, _jquery["default"])('<img>', {
        "class": 'img-fluid',
        src: '/img/logo.png'
      }), (0, _jquery["default"])('<br/>'))),
      // Links 1
      (0, _jquery["default"])('<div>', {
        "class": 'col-md-3 mb-md-0 mb-3'
      }).append((0, _jquery["default"])('<h5>').text('Links'), (0, _jquery["default"])('<ul>', {
        "class": 'list-unstyled'
      }).append(tinyFooter[1])),
      // Links 2
      (0, _jquery["default"])('<div>', {
        "class": 'col-md-3 mb-md-0 mb-3'
      }).append((0, _jquery["default"])('<h5>').text('Links'), (0, _jquery["default"])('<ul>', {
        "class": 'list-unstyled'
      }).append(tinyFooter[2])))),
      // Copyright
      (0, _jquery["default"])('<div>', {
        id: 'footer2',
        "class": 'footer-copyright text-center py-3 bg-secondary text-white'
      }).text(copyrightText).append((0, _jquery["default"])('<a>', {
        target: '_blank',
        href: _config["default"].creator_url
      }).text(_config["default"].creator), '.')));

      // Carousel
      var indicators = (0, _jquery["default"])('body > #root #carouselHomepage .carousel-indicators');
      var inner = (0, _jquery["default"])('body > #root #carouselHomepage .carousel-inner');
      var slides = [{
        img: './img/homepage/banner/pony_driland.jpg',
        title: 'Pony Driland',
        text: 'Discover a science fiction story mixed with horror, mystery, and adventure. A mysterious dimension has just been discovered!'
      }, {
        img: './img/homepage/banner/discord.jpg',
        title: 'Discord Server',
        text: '<a href="https://discord.gg/sSkysVtj7y" target="_blank">Join the Discord official server to see real-time updates.</a>'
      }];

      // Insert slides
      slides.forEach(function (slide, index) {
        // Options
        (0, _jquery["default"])('<li>', {
          'data-bs-target': '#carouselHomepage',
          'data-bs-slide-to': index,
          "class": index === 0 ? 'active' : ''
        }).appendTo(indicators);
        var item = (0, _jquery["default"])('<div>', {
          "class": 'carousel-item' + (index === 0 ? ' active' : '')
        }).appendTo(inner);

        // Image
        (0, _jquery["default"])('<div>', {
          "class": 'img',
          css: {
            'background-image': 'url(' + slide.img + ')'
          }
        }).appendTo(item);

        // Text
        var caption = (0, _jquery["default"])('<div>', {
          "class": 'carousel-caption'
        }).appendTo(item);
        (0, _jquery["default"])('<h5>', {
          "class": 'px-5',
          text: slide.title
        }).appendTo(caption);
        (0, _jquery["default"])('<p>', {
          "class": 'px-5'
        }).html(slide.text).appendTo(caption);
      });

      // Start Readme
      var params = getParams();
      if (params.path === 'read-fic') (0, _index.openChapterMenu)(params);else if (params.path === 'ai') tinyAiScript.open();else openNewAddress(params, true, true);

      // Final part
      fn();

      // First Time
      if (!tinyLs.getItem('firstTime')) {
        tinyLs.setItem('firstTime', true);
        alert("If this is your first time visiting the website, remember that you can navigate using the navbar at the top of the page. " + "To read the fic, just click on the \"Read Fic\" link located in the top-right corner of the navbar. " + "The same navbar also gives you access to fic-related tools like bookmarks and story progress tracking." + "\n\nDue to restrictions from some countries, the website is required to track your country of origin to restrict some resources.", 'Welcome to Pony Driland!');
      }
    });
  };
  startApp();
});
rootApp.init();

},{"../build/bundle/bootstrap-paginator.mjs":3,"./ai/aiSoftware.mjs":208,"./chapter_manager/index.mjs":214,"./chapters/characters.mjs":218,"./chapters/config.mjs":219,"./chapters/counter.mjs":220,"./chapters/sound.mjs":221,"./files/chapters.mjs":222,"./files/tinyLib.mjs":223,"./gtag.mjs":224,"./pwa/installer.mjs":225,"bootstrap":65,"events":92,"file-saver":93,"jquery":97,"marked":103,"moment":104,"photoswipe":109,"qrcode":112,"tiny-essentials":181}]},{},[226]);
