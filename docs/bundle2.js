(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _socket = require("socket.io-client");
var _tippy = _interopRequireDefault(require("tippy.js"));
var _forPromise = _interopRequireDefault(require("for-promise"));
var _photoswipe = _interopRequireDefault(require("photoswipe"));
var _pizzicato = _interopRequireDefault(require("pizzicato"));
var JsStore = _interopRequireWildcard(require("jsstore"));
var _validateColor = _interopRequireDefault(require("validate-color"));
var _tinyAiApi = require("tiny-ai-api");
var _tinyEssentials = require("tiny-essentials");
var _tinyDices = _interopRequireDefault(require("tiny-dices"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// Socket.io

// Tippy JS

// For Promise

// Photoswipe

// Pizzicato

// jsstore

// Validate color

// Tiny AI

var startModules = new _tinyEssentials.TinyDomReadyManager();
startModules.onReady(function () {
  return (0, _tinyEssentials.installWindowHiddenScript)();
});
startModules.init();
global.window.tinyNotification = new _tinyEssentials.TinyNotifications({
  audio: '/audio/notification.ogg',
  defaultIcon: '/img/icon/192.png'
});

// Imports
(0, _tinyEssentials.addAiMarkerShortcut)();
global.window.TinyTextRangeEditor = _tinyEssentials.TinyTextRangeEditor;
global.window.TinyDomReadyManager = _tinyEssentials.TinyDomReadyManager;
global.window.TinyAfterScrollWatcher = _tinyEssentials.TinyAfterScrollWatcher;
global.window.TinyHtml = _tinyEssentials.TinyHtml;
global.window.readBase64Blob = _tinyEssentials.readBase64Blob;
global.window.readJsonBlob = _tinyEssentials.readJsonBlob;
global.window.fetchJson = _tinyEssentials.fetchJson;
global.window.TinyDices = _tinyDices["default"];
global.window.setTinyGoogleAi = _tinyAiApi.setTinyGoogleAi;
global.window.TinyAiInstance = _tinyAiApi.TinyAiInstance;
global.window.validateColor = _validateColor["default"];
global.window.JsStore = JsStore;
global.window.tippy = _tippy["default"];
global.window.io = _socket.io;
global.window.forPromise = _forPromise["default"];
global.window.ruleOfThree = _tinyEssentials.ruleOfThree;
global.window.toTitleCase = _tinyEssentials.toTitleCase;
global.window.formatDayTimer = _tinyEssentials.formatDayTimer;
global.window.objType = _tinyEssentials.objType;
global.window.countObj = _tinyEssentials.countObj;
global.window.shuffleArray = _tinyEssentials.shuffleArray;
global.window.Pizzicato = _pizzicato["default"];
global.window.PhotoSwipeLightbox = _photoswipe["default"];

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"for-promise":85,"jsstore":91,"photoswipe":95,"pizzicato":96,"socket.io-client":99,"tiny-ai-api":110,"tiny-dices":133,"tiny-essentials":160,"tippy.js":176,"validate-color":177}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPopper = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function get() {
    return _detectOverflow["default"];
  }
});
exports.popperGenerator = popperGenerator;
var _getCompositeRect = _interopRequireDefault(require("./dom-utils/getCompositeRect.js"));
var _getLayoutRect = _interopRequireDefault(require("./dom-utils/getLayoutRect.js"));
var _listScrollParents = _interopRequireDefault(require("./dom-utils/listScrollParents.js"));
var _getOffsetParent = _interopRequireDefault(require("./dom-utils/getOffsetParent.js"));
var _orderModifiers = _interopRequireDefault(require("./utils/orderModifiers.js"));
var _debounce = _interopRequireDefault(require("./utils/debounce.js"));
var _mergeByName = _interopRequireDefault(require("./utils/mergeByName.js"));
var _detectOverflow = _interopRequireDefault(require("./utils/detectOverflow.js"));
var _instanceOf = require("./dom-utils/instanceOf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
    _generatorOptions$def = _generatorOptions.defaultModifiers,
    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
    _generatorOptions$def2 = _generatorOptions.defaultOptions,
    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0, _instanceOf.isElement)(reference) ? (0, _listScrollParents["default"])(reference) : reference.contextElement ? (0, _listScrollParents["default"])(reference.contextElement) : [],
          popper: (0, _listScrollParents["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0, _orderModifiers["default"])((0, _mergeByName["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
          reference = _state$elements.reference,
          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers

        state.rects = {
          reference: (0, _getCompositeRect["default"])(reference, (0, _getOffsetParent["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0, _getLayoutRect["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
            fn = _state$orderedModifie.fn,
            _state$orderedModifie2 = _state$orderedModifie.options,
            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
            name = _state$orderedModifie.name;
          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0, _debounce["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      return instance;
    }
    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options,
          effect = _ref.effect;
        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
          var noopFn = function noopFn() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = exports.createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules

},{"./dom-utils/getCompositeRect.js":6,"./dom-utils/getLayoutRect.js":11,"./dom-utils/getOffsetParent.js":14,"./dom-utils/instanceOf.js":21,"./dom-utils/listScrollParents.js":25,"./utils/debounce.js":42,"./utils/detectOverflow.js":43,"./utils/mergeByName.js":53,"./utils/orderModifiers.js":55}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = contains;
var _instanceOf = require("./instanceOf.js");
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0, _instanceOf.isShadowRoot)(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...

      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false

  return false;
}

},{"./instanceOf.js":21}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getBoundingClientRect;
var _instanceOf = require("./instanceOf.js");
var _math = require("../utils/math.js");
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _isLayoutViewport = _interopRequireDefault(require("./isLayoutViewport.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && (0, _instanceOf.isHTMLElement)(element)) {
    scaleX = element.offsetWidth > 0 ? (0, _math.round)(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? (0, _math.round)(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = (0, _instanceOf.isElement)(element) ? (0, _getWindow["default"])(element) : window,
    visualViewport = _ref.visualViewport;
  var addVisualOffsets = !(0, _isLayoutViewport["default"])() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

},{"../utils/math.js":52,"./getWindow.js":18,"./instanceOf.js":21,"./isLayoutViewport.js":22}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getClippingRect;
var _enums = require("../enums.js");
var _getViewportRect = _interopRequireDefault(require("./getViewportRect.js"));
var _getDocumentRect = _interopRequireDefault(require("./getDocumentRect.js"));
var _listScrollParents = _interopRequireDefault(require("./listScrollParents.js"));
var _getOffsetParent = _interopRequireDefault(require("./getOffsetParent.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _instanceOf = require("./instanceOf.js");
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _contains = _interopRequireDefault(require("./contains.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _rectToClientRect = _interopRequireDefault(require("../utils/rectToClientRect.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getInnerBoundingClientRect(element, strategy) {
  var rect = (0, _getBoundingClientRect["default"])(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === _enums.viewport ? (0, _rectToClientRect["default"])((0, _getViewportRect["default"])(element, strategy)) : (0, _instanceOf.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0, _rectToClientRect["default"])((0, _getDocumentRect["default"])((0, _getDocumentElement["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`

function getClippingParents(element) {
  var clippingParents = (0, _listScrollParents["default"])((0, _getParentNode["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0, _getComputedStyle["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0, _instanceOf.isHTMLElement)(element) ? (0, _getOffsetParent["default"])(element) : element;
  if (!(0, _instanceOf.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

  return clippingParents.filter(function (clippingParent) {
    return (0, _instanceOf.isElement)(clippingParent) && (0, _contains["default"])(clippingParent, clipperElement) && (0, _getNodeName["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents

function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = (0, _math.max)(rect.top, accRect.top);
    accRect.right = (0, _math.min)(rect.right, accRect.right);
    accRect.bottom = (0, _math.min)(rect.bottom, accRect.bottom);
    accRect.left = (0, _math.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

},{"../enums.js":26,"../utils/math.js":52,"../utils/rectToClientRect.js":56,"./contains.js":3,"./getBoundingClientRect.js":4,"./getComputedStyle.js":7,"./getDocumentElement.js":8,"./getDocumentRect.js":9,"./getNodeName.js":12,"./getOffsetParent.js":14,"./getParentNode.js":15,"./getViewportRect.js":17,"./instanceOf.js":21,"./listScrollParents.js":25}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getCompositeRect;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getNodeScroll = _interopRequireDefault(require("./getNodeScroll.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _instanceOf = require("./instanceOf.js");
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0, _math.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0, _math.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = (0, _instanceOf.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0, _instanceOf.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0, _getDocumentElement["default"])(offsetParent);
  var rect = (0, _getBoundingClientRect["default"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0, _getNodeName["default"])(offsetParent) !== 'body' ||
    // https://github.com/popperjs/popper-core/issues/1078
    (0, _isScrollParent["default"])(documentElement)) {
      scroll = (0, _getNodeScroll["default"])(offsetParent);
    }
    if ((0, _instanceOf.isHTMLElement)(offsetParent)) {
      offsets = (0, _getBoundingClientRect["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0, _getWindowScrollBarX["default"])(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

},{"../utils/math.js":52,"./getBoundingClientRect.js":4,"./getDocumentElement.js":8,"./getNodeName.js":12,"./getNodeScroll.js":13,"./getWindowScrollBarX.js":20,"./instanceOf.js":21,"./isScrollParent.js":23}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getComputedStyle;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getComputedStyle(element) {
  return (0, _getWindow["default"])(element).getComputedStyle(element);
}

},{"./getWindow.js":18}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getDocumentElement;
var _instanceOf = require("./instanceOf.js");
function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0, _instanceOf.isElement)(element) ? element.ownerDocument :
  // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

},{"./instanceOf.js":21}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getDocumentRect;
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = (0, _getDocumentElement["default"])(element);
  var winScroll = (0, _getWindowScroll["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0, _math.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0, _math.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0, _getWindowScrollBarX["default"])(element);
  var y = -winScroll.scrollTop;
  if ((0, _getComputedStyle["default"])(body || html).direction === 'rtl') {
    x += (0, _math.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

},{"../utils/math.js":52,"./getComputedStyle.js":7,"./getDocumentElement.js":8,"./getWindowScroll.js":19,"./getWindowScrollBarX.js":20}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getHTMLElementScroll;
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getLayoutRect;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0, _getBoundingClientRect["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

},{"./getBoundingClientRect.js":4}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getNodeName;
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getNodeScroll;
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _instanceOf = require("./instanceOf.js");
var _getHTMLElementScroll = _interopRequireDefault(require("./getHTMLElementScroll.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getNodeScroll(node) {
  if (node === (0, _getWindow["default"])(node) || !(0, _instanceOf.isHTMLElement)(node)) {
    return (0, _getWindowScroll["default"])(node);
  } else {
    return (0, _getHTMLElementScroll["default"])(node);
  }
}

},{"./getHTMLElementScroll.js":10,"./getWindow.js":18,"./getWindowScroll.js":19,"./instanceOf.js":21}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getOffsetParent;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));
var _instanceOf = require("./instanceOf.js");
var _isTableElement = _interopRequireDefault(require("./isTableElement.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _userAgent = _interopRequireDefault(require("../utils/userAgent.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getTrueOffsetParent(element) {
  if (!(0, _instanceOf.isHTMLElement)(element) ||
  // https://github.com/popperjs/popper-core/issues/837
  (0, _getComputedStyle["default"])(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block

function getContainingBlock(element) {
  var isFirefox = /firefox/i.test((0, _userAgent["default"])());
  var isIE = /Trident/i.test((0, _userAgent["default"])());
  if (isIE && (0, _instanceOf.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0, _getComputedStyle["default"])(element);
    if (elementCss.position === 'fixed') {
      return null;
    }
  }
  var currentNode = (0, _getParentNode["default"])(element);
  if ((0, _instanceOf.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }
  while ((0, _instanceOf.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0, _getNodeName["default"])(currentNode)) < 0) {
    var css = (0, _getComputedStyle["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.

function getOffsetParent(element) {
  var window = (0, _getWindow["default"])(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && (0, _isTableElement["default"])(offsetParent) && (0, _getComputedStyle["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && ((0, _getNodeName["default"])(offsetParent) === 'html' || (0, _getNodeName["default"])(offsetParent) === 'body' && (0, _getComputedStyle["default"])(offsetParent).position === 'static')) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

},{"../utils/userAgent.js":57,"./getComputedStyle.js":7,"./getNodeName.js":12,"./getParentNode.js":15,"./getWindow.js":18,"./instanceOf.js":21,"./isTableElement.js":24}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getParentNode;
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _instanceOf = require("./instanceOf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getParentNode(element) {
  if ((0, _getNodeName["default"])(element) === 'html') {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot ||
    // step into the shadow DOM of the parent of a slotted node
    element.parentNode || (
    // DOM Element detected
    (0, _instanceOf.isShadowRoot)(element) ? element.host : null) ||
    // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0, _getDocumentElement["default"])(element) // fallback
  );
}

},{"./getDocumentElement.js":8,"./getNodeName.js":12,"./instanceOf.js":21}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getScrollParent;
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
var _instanceOf = require("./instanceOf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0, _getNodeName["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }
  if ((0, _instanceOf.isHTMLElement)(node) && (0, _isScrollParent["default"])(node)) {
    return node;
  }
  return getScrollParent((0, _getParentNode["default"])(node));
}

},{"./getNodeName.js":12,"./getParentNode.js":15,"./instanceOf.js":21,"./isScrollParent.js":23}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getViewportRect;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));
var _isLayoutViewport = _interopRequireDefault(require("./isLayoutViewport.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getViewportRect(element, strategy) {
  var win = (0, _getWindow["default"])(element);
  var html = (0, _getDocumentElement["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = (0, _isLayoutViewport["default"])();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width,
    height: height,
    x: x + (0, _getWindowScrollBarX["default"])(element),
    y: y
  };
}

},{"./getDocumentElement.js":8,"./getWindow.js":18,"./getWindowScrollBarX.js":20,"./isLayoutViewport.js":22}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getWindow;
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getWindowScroll;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getWindowScroll(node) {
  var win = (0, _getWindow["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

},{"./getWindow.js":18}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getWindowScrollBarX;
var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));
var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));
var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0, _getBoundingClientRect["default"])((0, _getDocumentElement["default"])(element)).left + (0, _getWindowScroll["default"])(element).scrollLeft;
}

},{"./getBoundingClientRect.js":4,"./getDocumentElement.js":8,"./getWindowScroll.js":19}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isElement = isElement;
exports.isHTMLElement = isHTMLElement;
exports.isShadowRoot = isShadowRoot;
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isElement(node) {
  var OwnElement = (0, _getWindow["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = (0, _getWindow["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  var OwnElement = (0, _getWindow["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

},{"./getWindow.js":18}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isLayoutViewport;
var _userAgent = _interopRequireDefault(require("../utils/userAgent.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test((0, _userAgent["default"])());
}

},{"../utils/userAgent.js":57}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isScrollParent;
var _getComputedStyle2 = _interopRequireDefault(require("./getComputedStyle.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0, _getComputedStyle2["default"])(element),
    overflow = _getComputedStyle.overflow,
    overflowX = _getComputedStyle.overflowX,
    overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

},{"./getComputedStyle.js":7}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isTableElement;
var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0, _getNodeName["default"])(element)) >= 0;
}

},{"./getNodeName.js":12}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = listScrollParents;
var _getScrollParent = _interopRequireDefault(require("./getScrollParent.js"));
var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));
var _getWindow = _interopRequireDefault(require("./getWindow.js"));
var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = (0, _getScrollParent["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0, _getWindow["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0, _isScrollParent["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList :
  // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0, _getParentNode["default"])(target)));
}

},{"./getParentNode.js":15,"./getScrollParent.js":16,"./getWindow.js":18,"./isScrollParent.js":23}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.write = exports.viewport = exports.variationPlacements = exports.top = exports.start = exports.right = exports.reference = exports.read = exports.popper = exports.placements = exports.modifierPhases = exports.main = exports.left = exports.end = exports.clippingParents = exports.bottom = exports.beforeWrite = exports.beforeRead = exports.beforeMain = exports.basePlacements = exports.auto = exports.afterWrite = exports.afterRead = exports.afterMain = void 0;
var top = exports.top = 'top';
var bottom = exports.bottom = 'bottom';
var right = exports.right = 'right';
var left = exports.left = 'left';
var auto = exports.auto = 'auto';
var basePlacements = exports.basePlacements = [top, bottom, right, left];
var start = exports.start = 'start';
var end = exports.end = 'end';
var clippingParents = exports.clippingParents = 'clippingParents';
var viewport = exports.viewport = 'viewport';
var popper = exports.popper = 'popper';
var reference = exports.reference = 'reference';
var variationPlacements = exports.variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = exports.placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = exports.beforeRead = 'beforeRead';
var read = exports.read = 'read';
var afterRead = exports.afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = exports.beforeMain = 'beforeMain';
var main = exports.main = 'main';
var afterMain = exports.afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = exports.beforeWrite = 'beforeWrite';
var write = exports.write = 'write';
var afterWrite = exports.afterWrite = 'afterWrite';
var modifierPhases = exports.modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  popperGenerator: true,
  detectOverflow: true,
  createPopperBase: true,
  createPopper: true,
  createPopperLite: true
};
Object.defineProperty(exports, "createPopper", {
  enumerable: true,
  get: function get() {
    return _popper.createPopper;
  }
});
Object.defineProperty(exports, "createPopperBase", {
  enumerable: true,
  get: function get() {
    return _createPopper.createPopper;
  }
});
Object.defineProperty(exports, "createPopperLite", {
  enumerable: true,
  get: function get() {
    return _popperLite.createPopper;
  }
});
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function get() {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function get() {
    return _createPopper.popperGenerator;
  }
});
var _enums = require("./enums.js");
Object.keys(_enums).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _enums[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _enums[key];
    }
  });
});
var _index = require("./modifiers/index.js");
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});
var _createPopper = require("./createPopper.js");
var _popper = require("./popper.js");
var _popperLite = require("./popper-lite.js");

},{"./createPopper.js":2,"./enums.js":26,"./modifiers/index.js":34,"./popper-lite.js":38,"./popper.js":39}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _getNodeName = _interopRequireDefault(require("../dom-utils/getNodeName.js"));
var _instanceOf = require("../dom-utils/instanceOf.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0, _instanceOf.isHTMLElement)(element) || !(0, _getNodeName["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]

    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0, _instanceOf.isHTMLElement)(element) || !(0, _getNodeName["default"])(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
};

},{"../dom-utils/getNodeName.js":12,"../dom-utils/instanceOf.js":21}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getLayoutRect = _interopRequireDefault(require("../dom-utils/getLayoutRect.js"));
var _contains = _interopRequireDefault(require("../dom-utils/contains.js"));
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("../utils/getMainAxisFromPlacement.js"));
var _within = require("../utils/within.js");
var _mergePaddingObject = _interopRequireDefault(require("../utils/mergePaddingObject.js"));
var _expandToHashMap = _interopRequireDefault(require("../utils/expandToHashMap.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0, _mergePaddingObject["default"])(typeof padding !== 'number' ? padding : (0, _expandToHashMap["default"])(padding, _enums.basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
    name = _ref.name,
    options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0, _getBasePlacement["default"])(state.placement);
  var axis = (0, _getMainAxisFromPlacement["default"])(basePlacement);
  var isVertical = [_enums.left, _enums.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0, _getLayoutRect["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums.top : _enums.left;
  var maxProp = axis === 'y' ? _enums.bottom : _enums.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0, _getOffsetParent["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0, _within.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
  var state = _ref2.state,
    options = _ref2.options;
  var _options$element = options.element,
    arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
  if (arrowElement == null) {
    return;
  } // CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!(0, _contains["default"])(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

},{"../dom-utils/contains.js":3,"../dom-utils/getLayoutRect.js":11,"../dom-utils/getOffsetParent.js":14,"../enums.js":26,"../utils/expandToHashMap.js":44,"../utils/getBasePlacement.js":46,"../utils/getMainAxisFromPlacement.js":48,"../utils/mergePaddingObject.js":54,"../utils/within.js":58}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.mapToStyles = mapToStyles;
var _enums = require("../enums.js");
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _getWindow = _interopRequireDefault(require("../dom-utils/getWindow.js"));
var _getDocumentElement = _interopRequireDefault(require("../dom-utils/getDocumentElement.js"));
var _getComputedStyle = _interopRequireDefault(require("../dom-utils/getComputedStyle.js"));
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
    y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0, _math.round)(x * dpr) / dpr || 0,
    y: (0, _math.round)(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper,
    popperRect = _ref2.popperRect,
    placement = _ref2.placement,
    variation = _ref2.variation,
    offsets = _ref2.offsets,
    position = _ref2.position,
    gpuAcceleration = _ref2.gpuAcceleration,
    adaptive = _ref2.adaptive,
    roundOffsets = _ref2.roundOffsets,
    isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
    x = _offsets$x === void 0 ? 0 : _offsets$x,
    _offsets$y = offsets.y,
    y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums.left;
  var sideY = _enums.top;
  var win = window;
  if (adaptive) {
    var offsetParent = (0, _getOffsetParent["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';
    if (offsetParent === (0, _getWindow["default"])(popper)) {
      offsetParent = (0, _getDocumentElement["default"])(popper);
      if ((0, _getComputedStyle["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    offsetParent = offsetParent;
    if (placement === _enums.top || (placement === _enums.left || placement === _enums.right) && variation === _enums.end) {
      sideY = _enums.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
      // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === _enums.left || (placement === _enums.top || placement === _enums.bottom) && variation === _enums.end) {
      sideX = _enums.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
      // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, (0, _getWindow["default"])(popper)) : {
    x: x,
    y: y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state,
    options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
    gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
    _options$adaptive = options.adaptive,
    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
    _options$roundOffsets = options.roundOffsets,
    roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: (0, _getBasePlacement["default"])(state.placement),
    variation: (0, _getVariation["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

},{"../dom-utils/getComputedStyle.js":7,"../dom-utils/getDocumentElement.js":8,"../dom-utils/getOffsetParent.js":14,"../dom-utils/getWindow.js":18,"../enums.js":26,"../utils/getBasePlacement.js":46,"../utils/getVariation.js":51,"../utils/math.js":52}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _getWindow = _interopRequireDefault(require("../dom-utils/getWindow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state,
    instance = _ref.instance,
    options = _ref.options;
  var _options$scroll = options.scroll,
    scroll = _options$scroll === void 0 ? true : _options$scroll,
    _options$resize = options.resize,
    resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0, _getWindow["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

},{"../dom-utils/getWindow.js":18}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _getOppositePlacement = _interopRequireDefault(require("../utils/getOppositePlacement.js"));
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getOppositeVariationPlacement = _interopRequireDefault(require("../utils/getOppositeVariationPlacement.js"));
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
var _computeAutoPlacement = _interopRequireDefault(require("../utils/computeAutoPlacement.js"));
var _enums = require("../enums.js");
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0, _getBasePlacement["default"])(placement) === _enums.auto) {
    return [];
  }
  var oppositePlacement = (0, _getOppositePlacement["default"])(placement);
  return [(0, _getOppositeVariationPlacement["default"])(placement), oppositePlacement, (0, _getOppositeVariationPlacement["default"])(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
    specifiedFallbackPlacements = options.fallbackPlacements,
    padding = options.padding,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    _options$flipVariatio = options.flipVariations,
    flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
    allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0, _getBasePlacement["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0, _getOppositePlacement["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0, _getBasePlacement["default"])(placement) === _enums.auto ? (0, _computeAutoPlacement["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];
  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = (0, _getBasePlacement["default"])(placement);
    var isStartVariation = (0, _getVariation["default"])(placement) === _enums.start;
    var isVertical = [_enums.top, _enums.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0, _detectOverflow["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums.right : _enums.left : isStartVariation ? _enums.bottom : _enums.top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0, _getOppositePlacement["default"])(mainVariationSide);
    }
    var altVariationSide = (0, _getOppositePlacement["default"])(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

},{"../enums.js":26,"../utils/computeAutoPlacement.js":40,"../utils/detectOverflow.js":43,"../utils/getBasePlacement.js":46,"../utils/getOppositePlacement.js":49,"../utils/getOppositeVariationPlacement.js":50,"../utils/getVariation.js":51}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _enums = require("../enums.js");
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [_enums.top, _enums.right, _enums.bottom, _enums.left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
    name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0, _detectOverflow["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0, _detectOverflow["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

},{"../enums.js":26,"../utils/detectOverflow.js":43}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "applyStyles", {
  enumerable: true,
  get: function get() {
    return _applyStyles["default"];
  }
});
Object.defineProperty(exports, "arrow", {
  enumerable: true,
  get: function get() {
    return _arrow["default"];
  }
});
Object.defineProperty(exports, "computeStyles", {
  enumerable: true,
  get: function get() {
    return _computeStyles["default"];
  }
});
Object.defineProperty(exports, "eventListeners", {
  enumerable: true,
  get: function get() {
    return _eventListeners["default"];
  }
});
Object.defineProperty(exports, "flip", {
  enumerable: true,
  get: function get() {
    return _flip["default"];
  }
});
Object.defineProperty(exports, "hide", {
  enumerable: true,
  get: function get() {
    return _hide["default"];
  }
});
Object.defineProperty(exports, "offset", {
  enumerable: true,
  get: function get() {
    return _offset["default"];
  }
});
Object.defineProperty(exports, "popperOffsets", {
  enumerable: true,
  get: function get() {
    return _popperOffsets["default"];
  }
});
Object.defineProperty(exports, "preventOverflow", {
  enumerable: true,
  get: function get() {
    return _preventOverflow["default"];
  }
});
var _applyStyles = _interopRequireDefault(require("./applyStyles.js"));
var _arrow = _interopRequireDefault(require("./arrow.js"));
var _computeStyles = _interopRequireDefault(require("./computeStyles.js"));
var _eventListeners = _interopRequireDefault(require("./eventListeners.js"));
var _flip = _interopRequireDefault(require("./flip.js"));
var _hide = _interopRequireDefault(require("./hide.js"));
var _offset = _interopRequireDefault(require("./offset.js"));
var _popperOffsets = _interopRequireDefault(require("./popperOffsets.js"));
var _preventOverflow = _interopRequireDefault(require("./preventOverflow.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"./applyStyles.js":28,"./arrow.js":29,"./computeStyles.js":30,"./eventListeners.js":31,"./flip.js":32,"./hide.js":33,"./offset.js":35,"./popperOffsets.js":36,"./preventOverflow.js":37}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.distanceAndSkiddingToXY = distanceAndSkiddingToXY;
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0, _getBasePlacement["default"])(placement);
  var invertDistance = [_enums.left, _enums.top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
    skidding = _ref[0],
    distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums.left, _enums.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state,
    options = _ref2.options,
    name = _ref2.name;
  var _options$offset = options.offset,
    offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
    x = _data$state$placement.x,
    y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

},{"../enums.js":26,"../utils/getBasePlacement.js":46}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _computeOffsets = _interopRequireDefault(require("../utils/computeOffsets.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function popperOffsets(_ref) {
  var state = _ref.state,
    name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0, _computeOffsets["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

},{"../utils/computeOffsets.js":41}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _enums = require("../enums.js");
var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("../utils/getMainAxisFromPlacement.js"));
var _getAltAxis = _interopRequireDefault(require("../utils/getAltAxis.js"));
var _within = require("../utils/within.js");
var _getLayoutRect = _interopRequireDefault(require("../dom-utils/getLayoutRect.js"));
var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));
var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));
var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));
var _getFreshSideObject = _interopRequireDefault(require("../utils/getFreshSideObject.js"));
var _math = require("../utils/math.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function preventOverflow(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    padding = options.padding,
    _options$tether = options.tether,
    tether = _options$tether === void 0 ? true : _options$tether,
    _options$tetherOffset = options.tetherOffset,
    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0, _detectOverflow["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0, _getBasePlacement["default"])(state.placement);
  var variation = (0, _getVariation["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0, _getMainAxisFromPlacement["default"])(basePlacement);
  var altAxis = (0, _getAltAxis["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === 'y' ? _enums.top : _enums.left;
    var altSide = mainAxis === 'y' ? _enums.bottom : _enums.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0, _getLayoutRect["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0, _getFreshSideObject["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0, _within.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0, _getOffsetParent["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0, _within.within)(tether ? (0, _math.min)(min, tetherMin) : min, offset, tether ? (0, _math.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === 'x' ? _enums.top : _enums.left;
    var _altSide = mainAxis === 'x' ? _enums.bottom : _enums.right;
    var _offset = popperOffsets[altAxis];
    var _len = altAxis === 'y' ? 'height' : 'width';
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [_enums.top, _enums.left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? (0, _within.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0, _within.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
var _default = exports["default"] = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

},{"../dom-utils/getLayoutRect.js":11,"../dom-utils/getOffsetParent.js":14,"../enums.js":26,"../utils/detectOverflow.js":43,"../utils/getAltAxis.js":45,"../utils/getBasePlacement.js":46,"../utils/getFreshSideObject.js":47,"../utils/getMainAxisFromPlacement.js":48,"../utils/getVariation.js":51,"../utils/math.js":52,"../utils/within.js":58}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultModifiers = exports.createPopper = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function get() {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function get() {
    return _createPopper.popperGenerator;
  }
});
var _createPopper = require("./createPopper.js");
var _eventListeners = _interopRequireDefault(require("./modifiers/eventListeners.js"));
var _popperOffsets = _interopRequireDefault(require("./modifiers/popperOffsets.js"));
var _computeStyles = _interopRequireDefault(require("./modifiers/computeStyles.js"));
var _applyStyles = _interopRequireDefault(require("./modifiers/applyStyles.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var defaultModifiers = exports.defaultModifiers = [_eventListeners["default"], _popperOffsets["default"], _computeStyles["default"], _applyStyles["default"]];
var createPopper = exports.createPopper = /*#__PURE__*/(0, _createPopper.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":2,"./modifiers/applyStyles.js":28,"./modifiers/computeStyles.js":30,"./modifiers/eventListeners.js":31,"./modifiers/popperOffsets.js":36}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createPopper: true,
  defaultModifiers: true,
  popperGenerator: true,
  detectOverflow: true,
  createPopperLite: true
};
exports.createPopper = void 0;
Object.defineProperty(exports, "createPopperLite", {
  enumerable: true,
  get: function get() {
    return _popperLite.createPopper;
  }
});
exports.defaultModifiers = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function get() {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function get() {
    return _createPopper.popperGenerator;
  }
});
var _createPopper = require("./createPopper.js");
var _eventListeners = _interopRequireDefault(require("./modifiers/eventListeners.js"));
var _popperOffsets = _interopRequireDefault(require("./modifiers/popperOffsets.js"));
var _computeStyles = _interopRequireDefault(require("./modifiers/computeStyles.js"));
var _applyStyles = _interopRequireDefault(require("./modifiers/applyStyles.js"));
var _offset = _interopRequireDefault(require("./modifiers/offset.js"));
var _flip = _interopRequireDefault(require("./modifiers/flip.js"));
var _preventOverflow = _interopRequireDefault(require("./modifiers/preventOverflow.js"));
var _arrow = _interopRequireDefault(require("./modifiers/arrow.js"));
var _hide = _interopRequireDefault(require("./modifiers/hide.js"));
var _popperLite = require("./popper-lite.js");
var _index = require("./modifiers/index.js");
Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var defaultModifiers = exports.defaultModifiers = [_eventListeners["default"], _popperOffsets["default"], _computeStyles["default"], _applyStyles["default"], _offset["default"], _flip["default"], _preventOverflow["default"], _arrow["default"], _hide["default"]];
var createPopper = exports.createPopper = /*#__PURE__*/(0, _createPopper.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

// eslint-disable-next-line import/no-unused-modules

// eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":2,"./modifiers/applyStyles.js":28,"./modifiers/arrow.js":29,"./modifiers/computeStyles.js":30,"./modifiers/eventListeners.js":31,"./modifiers/flip.js":32,"./modifiers/hide.js":33,"./modifiers/index.js":34,"./modifiers/offset.js":35,"./modifiers/popperOffsets.js":36,"./modifiers/preventOverflow.js":37,"./popper-lite.js":38}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = computeAutoPlacement;
var _getVariation = _interopRequireDefault(require("./getVariation.js"));
var _enums = require("../enums.js");
var _detectOverflow = _interopRequireDefault(require("./detectOverflow.js"));
var _getBasePlacement = _interopRequireDefault(require("./getBasePlacement.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    placement = _options.placement,
    boundary = _options.boundary,
    rootBoundary = _options.rootBoundary,
    padding = _options.padding,
    flipVariations = _options.flipVariations,
    _options$allowedAutoP = _options.allowedAutoPlacements,
    allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums.placements : _options$allowedAutoP;
  var variation = (0, _getVariation["default"])(placement);
  var placements = variation ? flipVariations ? _enums.variationPlacements : _enums.variationPlacements.filter(function (placement) {
    return (0, _getVariation["default"])(placement) === variation;
  }) : _enums.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0, _detectOverflow["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0, _getBasePlacement["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

},{"../enums.js":26,"./detectOverflow.js":43,"./getBasePlacement.js":46,"./getVariation.js":51}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = computeOffsets;
var _getBasePlacement = _interopRequireDefault(require("./getBasePlacement.js"));
var _getVariation = _interopRequireDefault(require("./getVariation.js"));
var _getMainAxisFromPlacement = _interopRequireDefault(require("./getMainAxisFromPlacement.js"));
var _enums = require("../enums.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function computeOffsets(_ref) {
  var reference = _ref.reference,
    element = _ref.element,
    placement = _ref.placement;
  var basePlacement = placement ? (0, _getBasePlacement["default"])(placement) : null;
  var variation = placement ? (0, _getVariation["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case _enums.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case _enums.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case _enums.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case _enums.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? (0, _getMainAxisFromPlacement["default"])(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case _enums.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case _enums.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

},{"../enums.js":26,"./getBasePlacement.js":46,"./getMainAxisFromPlacement.js":48,"./getVariation.js":51}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = debounce;
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

},{}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = detectOverflow;
var _getClippingRect = _interopRequireDefault(require("../dom-utils/getClippingRect.js"));
var _getDocumentElement = _interopRequireDefault(require("../dom-utils/getDocumentElement.js"));
var _getBoundingClientRect = _interopRequireDefault(require("../dom-utils/getBoundingClientRect.js"));
var _computeOffsets = _interopRequireDefault(require("./computeOffsets.js"));
var _rectToClientRect = _interopRequireDefault(require("./rectToClientRect.js"));
var _enums = require("../enums.js");
var _instanceOf = require("../dom-utils/instanceOf.js");
var _mergePaddingObject = _interopRequireDefault(require("./mergePaddingObject.js"));
var _expandToHashMap = _interopRequireDefault(require("./expandToHashMap.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$placement = _options.placement,
    placement = _options$placement === void 0 ? state.placement : _options$placement,
    _options$strategy = _options.strategy,
    strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
    _options$boundary = _options.boundary,
    boundary = _options$boundary === void 0 ? _enums.clippingParents : _options$boundary,
    _options$rootBoundary = _options.rootBoundary,
    rootBoundary = _options$rootBoundary === void 0 ? _enums.viewport : _options$rootBoundary,
    _options$elementConte = _options.elementContext,
    elementContext = _options$elementConte === void 0 ? _enums.popper : _options$elementConte,
    _options$altBoundary = _options.altBoundary,
    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
    _options$padding = _options.padding,
    padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0, _mergePaddingObject["default"])(typeof padding !== 'number' ? padding : (0, _expandToHashMap["default"])(padding, _enums.basePlacements));
  var altContext = elementContext === _enums.popper ? _enums.reference : _enums.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0, _getClippingRect["default"])((0, _instanceOf.isElement)(element) ? element : element.contextElement || (0, _getDocumentElement["default"])(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = (0, _getBoundingClientRect["default"])(state.elements.reference);
  var popperOffsets = (0, _computeOffsets["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0, _rectToClientRect["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums.right, _enums.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums.top, _enums.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}

},{"../dom-utils/getBoundingClientRect.js":4,"../dom-utils/getClippingRect.js":5,"../dom-utils/getDocumentElement.js":8,"../dom-utils/instanceOf.js":21,"../enums.js":26,"./computeOffsets.js":41,"./expandToHashMap.js":44,"./mergePaddingObject.js":54,"./rectToClientRect.js":56}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = expandToHashMap;
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getAltAxis;
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getBasePlacement;
var _enums = require("../enums.js");
function getBasePlacement(placement) {
  return placement.split('-')[0];
}

},{"../enums.js":26}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getFreshSideObject;
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

},{}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getMainAxisFromPlacement;
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getOppositePlacement;
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

},{}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getOppositeVariationPlacement;
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getVariation;
function getVariation(placement) {
  return placement.split('-')[1];
}

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.round = exports.min = exports.max = void 0;
var max = exports.max = Math.max;
var min = exports.min = Math.min;
var round = exports.round = Math.round;

},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = mergeByName;
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

},{}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = mergePaddingObject;
var _getFreshSideObject = _interopRequireDefault(require("./getFreshSideObject.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0, _getFreshSideObject["default"])(), paddingObject);
}

},{"./getFreshSideObject.js":47}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = orderModifiers;
var _enums = require("../enums.js");
// source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

},{"../enums.js":26}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = rectToClientRect;
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getUAString;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }
  return navigator.userAgent;
}

},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.within = within;
exports.withinMaxClamp = withinMaxClamp;
var _math = require("./math.js");
function within(min, value, max) {
  return (0, _math.max)(min, (0, _math.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

},{"./math.js":52}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emitter = Emitter;
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }
  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
    callbacks = this._callbacks['$' + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],60:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],61:[function(require,module,exports){

},{}],62:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":60,"buffer":62,"ieee754":87}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasCORS = void 0;
// imported from https://github.com/component/has-cors
let value = false;
try {
    value = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
}
catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
}
exports.hasCORS = value;

},{}],64:[function(require,module,exports){
"use strict";
// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = encode;
exports.decode = decode;
function encode(obj) {
    let str = '';
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (str.length)
                str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
    }
    return str;
}
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function decode(qs) {
    let qry = {};
    let pairs = qs.split('&');
    for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}

},{}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
function parse(str) {
  if (str.length > 8000) {
    throw "URI too long";
  }
  var src = str,
    b = str.indexOf('['),
    e = str.indexOf(']');
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }
  var m = re.exec(str || ''),
    uri = {},
    i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || '';
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri['path']);
  uri.queryKey = queryKey(uri, uri['query']);
  return uri;
}
function pathNames(obj, path) {
  var regx = /\/{2,9}/g,
    names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == '/' || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == '/') {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  var data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBinaryType = exports.globalThisShim = exports.nextTick = void 0;
exports.createCookieJar = createCookieJar;
exports.nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
exports.globalThisShim = (() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})();
exports.defaultBinaryType = "arraybuffer";
function createCookieJar() { }

},{}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.TransportError = exports.Transport = exports.protocol = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = exports.Socket = void 0;
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
var socket_js_2 = require("./socket.js");
Object.defineProperty(exports, "SocketWithoutUpgrade", { enumerable: true, get: function () { return socket_js_2.SocketWithoutUpgrade; } });
Object.defineProperty(exports, "SocketWithUpgrade", { enumerable: true, get: function () { return socket_js_2.SocketWithUpgrade; } });
exports.protocol = socket_js_1.Socket.protocol;
var transport_js_1 = require("./transport.js");
Object.defineProperty(exports, "Transport", { enumerable: true, get: function () { return transport_js_1.Transport; } });
Object.defineProperty(exports, "TransportError", { enumerable: true, get: function () { return transport_js_1.TransportError; } });
var index_js_1 = require("./transports/index.js");
Object.defineProperty(exports, "transports", { enumerable: true, get: function () { return index_js_1.transports; } });
var util_js_1 = require("./util.js");
Object.defineProperty(exports, "installTimerFunctions", { enumerable: true, get: function () { return util_js_1.installTimerFunctions; } });
var parseuri_js_1 = require("./contrib/parseuri.js");
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parseuri_js_1.parse; } });
var globals_node_js_1 = require("./globals.node.js");
Object.defineProperty(exports, "nextTick", { enumerable: true, get: function () { return globals_node_js_1.nextTick; } });
var polling_fetch_js_1 = require("./transports/polling-fetch.js");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return polling_fetch_js_1.Fetch; } });
var polling_xhr_node_js_1 = require("./transports/polling-xhr.node.js");
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return polling_xhr_node_js_1.XHR; } });
var polling_xhr_js_1 = require("./transports/polling-xhr.js");
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return polling_xhr_js_1.XHR; } });
var websocket_node_js_1 = require("./transports/websocket.node.js");
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return websocket_node_js_1.WS; } });
var websocket_js_1 = require("./transports/websocket.js");
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return websocket_js_1.WS; } });
var webtransport_js_1 = require("./transports/webtransport.js");
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return webtransport_js_1.WT; } });

},{"./contrib/parseuri.js":65,"./globals.node.js":66,"./socket.js":68,"./transport.js":69,"./transports/index.js":70,"./transports/polling-fetch.js":71,"./transports/polling-xhr.js":72,"./transports/polling-xhr.node.js":72,"./transports/websocket.js":74,"./transports/websocket.node.js":74,"./transports/webtransport.js":75,"./util.js":76}],68:[function(require,module,exports){
"use strict";

function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = exports.SocketWithUpgrade = exports.SocketWithoutUpgrade = void 0;
var index_js_1 = require("./transports/index.js");
var util_js_1 = require("./util.js");
var parseqs_js_1 = require("./contrib/parseqs.js");
var parseuri_js_1 = require("./contrib/parseuri.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var engine_io_parser_1 = require("engine.io-parser");
var globals_node_js_1 = require("./globals.node.js");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:socket"); // debug()
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
  // script, so we create one single event listener here which will forward the event to the socket instances
  addEventListener("offline", function () {
    debug("closing %d connection(s) because the network was lost", OFFLINE_EVENT_LISTENERS.length);
    OFFLINE_EVENT_LISTENERS.forEach(function (listener) {
      return listener();
    });
  }, false);
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
 * successfully establishes the connection.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithoutUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithUpgrade
 * @see Socket
 */
var SocketWithoutUpgrade = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  function SocketWithoutUpgrade(uri, opts) {
    var _this;
    _classCallCheck(this, SocketWithoutUpgrade);
    _this = _callSuper(this, SocketWithoutUpgrade);
    _this.binaryType = globals_node_js_1.defaultBinaryType;
    _this.writeBuffer = [];
    _this._prevBufferLen = 0;
    _this._pingInterval = -1;
    _this._pingTimeout = -1;
    _this._maxPayload = -1;
    /**
     * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
     * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
     */
    _this._pingTimeoutTime = Infinity;
    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      var parsedUri = (0, parseuri_js_1.parse)(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query) opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
    }
    (0, util_js_1.installTimerFunctions)(_this, opts);
    _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = _this.secure ? "443" : "80";
    }
    _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? "443" : "80");
    _this.transports = [];
    _this._transportsByName = {};
    opts.transports.forEach(function (t) {
      var transportName = t.prototype.name;
      _this.transports.push(transportName);
      _this._transportsByName[transportName] = t;
    });
    _this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    _this.opts.path = _this.opts.path.replace(/\/$/, "") + (_this.opts.addTrailingSlash ? "/" : "");
    if (typeof _this.opts.query === "string") {
      _this.opts.query = (0, parseqs_js_1.decode)(_this.opts.query);
    }
    if (withEventListeners) {
      if (_this.opts.closeOnBeforeunload) {
        // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
        // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
        // closed/reloaded)
        _this._beforeunloadEventListener = function () {
          if (_this.transport) {
            // silently close the transport
            _this.transport.removeAllListeners();
            _this.transport.close();
          }
        };
        addEventListener("beforeunload", _this._beforeunloadEventListener, false);
      }
      if (_this.hostname !== "localhost") {
        debug("adding listener for the 'offline' event");
        _this._offlineEventListener = function () {
          _this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(_this._offlineEventListener);
      }
    }
    if (_this.opts.withCredentials) {
      _this._cookieJar = (0, globals_node_js_1.createCookieJar)();
    }
    _this._open();
    return _this;
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  _inherits(SocketWithoutUpgrade, _component_emitter_1$);
  return _createClass(SocketWithoutUpgrade, [{
    key: "createTransport",
    value: function createTransport(name) {
      debug('creating transport "%s"', name);
      var query = Object.assign({}, this.opts.query);
      // append engine.io protocol identifier
      query.EIO = engine_io_parser_1.protocol;
      // transport name
      query.transport = name;
      // session id if we already have one
      if (this.id) query.sid = this.id;
      var opts = Object.assign({}, this.opts, {
        query: query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[name]);
      debug("options: %j", opts);
      return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
  }, {
    key: "_open",
    value: function _open() {
      var _this2 = this;
      if (this.transports.length === 0) {
        // Emit error on next tick so it can be listened to
        this.setTimeoutFn(function () {
          _this2.emitReserved("error", "No transports available");
        }, 0);
        return;
      }
      var transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
      this.readyState = "opening";
      var transport = this.createTransport(transportName);
      transport.open();
      this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var _this3 = this;
      debug("setting transport %s", transport.name);
      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      // set up transport
      this.transport = transport;
      // set up transport listeners
      transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", function (reason) {
        return _this3._onClose("transport close", reason);
      });
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
  }, {
    key: "onOpen",
    value: function onOpen() {
      debug("socket open");
      this.readyState = "open";
      SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emitReserved("open");
      this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */
  }, {
    key: "_onPacket",
    value: function _onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emitReserved("packet", packet);
        // Socket is live - any packet counts
        this.emitReserved("heartbeat");
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this._sendPacket("pong");
            this.emitReserved("ping");
            this.emitReserved("pong");
            this._resetPingTimeout();
            break;
          case "error":
            var err = new Error("server error");
            // @ts-ignore
            err.code = packet.data;
            this._onError(err);
            break;
          case "message":
            this.emitReserved("data", packet.data);
            this.emitReserved("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this.emitReserved("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this._pingInterval = data.pingInterval;
      this._pingTimeout = data.pingTimeout;
      this._maxPayload = data.maxPayload;
      this.onOpen();
      // In case open handler closes socket
      if ("closed" === this.readyState) return;
      this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
  }, {
    key: "_resetPingTimeout",
    value: function _resetPingTimeout() {
      var _this4 = this;
      this.clearTimeoutFn(this._pingTimeoutTimer);
      var delay = this._pingInterval + this._pingTimeout;
      this._pingTimeoutTime = Date.now() + delay;
      this._pingTimeoutTimer = this.setTimeoutFn(function () {
        _this4._onClose("ping timeout");
      }, delay);
      if (this.opts.autoUnref) {
        this._pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
  }, {
    key: "_onDrain",
    value: function _onDrain() {
      this.writeBuffer.splice(0, this._prevBufferLen);
      // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`
      this._prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emitReserved("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        var packets = this._getWritablePackets();
        debug("flushing %d packets in socket", packets.length);
        this.transport.send(packets);
        // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`
        this._prevBufferLen = packets.length;
        this.emitReserved("flush");
      }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
  }, {
    key: "_getWritablePackets",
    value: function _getWritablePackets() {
      var shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
      if (!shouldCheckPayloadSize) {
        return this.writeBuffer;
      }
      var payloadSize = 1; // first packet type
      for (var i = 0; i < this.writeBuffer.length; i++) {
        var data = this.writeBuffer[i].data;
        if (data) {
          payloadSize += (0, util_js_1.byteLength)(data);
        }
        if (i > 0 && payloadSize > this._maxPayload) {
          debug("only send %d out of %d packets", i, this.writeBuffer.length);
          return this.writeBuffer.slice(0, i);
        }
        payloadSize += 2; // separator + packet type
      }
      debug("payload size is %d (max: %d)", payloadSize, this._maxPayload);
      return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    /* private */
  }, {
    key: "_hasPingExpired",
    value: function _hasPingExpired() {
      var _this5 = this;
      if (!this._pingTimeoutTime) return true;
      var hasExpired = Date.now() > this._pingTimeoutTime;
      if (hasExpired) {
        debug("throttled timer detected, scheduling connection close");
        this._pingTimeoutTime = 0;
        (0, globals_node_js_1.nextTick)(function () {
          _this5._onClose("ping timeout");
        }, this.setTimeoutFn);
      }
      return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
  }, {
    key: "write",
    value: function write(msg, options, fn) {
      this._sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
  }, {
    key: "send",
    value: function send(msg, options, fn) {
      this._sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
  }, {
    key: "_sendPacket",
    value: function _sendPacket(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = undefined;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emitReserved("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn) this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     */
  }, {
    key: "close",
    value: function close() {
      var _this6 = this;
      var close = function close() {
        _this6._onClose("forced close");
        debug("socket closing - telling transport to close");
        _this6.transport.close();
      };
      var _cleanupAndClose = function cleanupAndClose() {
        _this6.off("upgrade", _cleanupAndClose);
        _this6.off("upgradeError", _cleanupAndClose);
        close();
      };
      var waitForUpgrade = function waitForUpgrade() {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        _this6.once("upgrade", _cleanupAndClose);
        _this6.once("upgradeError", _cleanupAndClose);
      };
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", function () {
            if (_this6.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
  }, {
    key: "_onError",
    value: function _onError(err) {
      debug("socket error %j", err);
      SocketWithoutUpgrade.priorWebsocketSuccess = false;
      if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
        debug("trying next transport");
        this.transports.shift();
        return this._open();
      }
      this.emitReserved("error", err);
      this._onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
  }, {
    key: "_onClose",
    value: function _onClose(reason, description) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket close with reason: "%s"', reason);
        // clear timers
        this.clearTimeoutFn(this._pingTimeoutTimer);
        // stop event from firing again for transport
        this.transport.removeAllListeners("close");
        // ensure transport won't stay open
        this.transport.close();
        // ignore further transport communication
        this.transport.removeAllListeners();
        if (withEventListeners) {
          if (this._beforeunloadEventListener) {
            removeEventListener("beforeunload", this._beforeunloadEventListener, false);
          }
          if (this._offlineEventListener) {
            var i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
            if (i !== -1) {
              debug("removing listener for the 'offline' event");
              OFFLINE_EVENT_LISTENERS.splice(i, 1);
            }
          }
        }
        // set ready state
        this.readyState = "closed";
        // clear session id
        this.id = null;
        // emit close event
        this.emitReserved("close", reason, description);
        // clean buffers after, so users can still
        // grab the buffers on `close` event
        this.writeBuffer = [];
        this._prevBufferLen = 0;
      }
    }
  }]);
}(component_emitter_1.Emitter);
exports.SocketWithoutUpgrade = SocketWithoutUpgrade;
SocketWithoutUpgrade.protocol = engine_io_parser_1.protocol;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see Socket
 */
var SocketWithUpgrade = /*#__PURE__*/function (_SocketWithoutUpgrade) {
  function SocketWithUpgrade() {
    var _this7;
    _classCallCheck(this, SocketWithUpgrade);
    _this7 = _callSuper(this, SocketWithUpgrade, arguments);
    _this7._upgrades = [];
    return _this7;
  }
  _inherits(SocketWithUpgrade, _SocketWithoutUpgrade);
  return _createClass(SocketWithUpgrade, [{
    key: "onOpen",
    value: function onOpen() {
      _superPropGet(SocketWithUpgrade, "onOpen", this, 3)([]);
      if ("open" === this.readyState && this.opts.upgrade) {
        debug("starting upgrade probes");
        for (var i = 0; i < this._upgrades.length; i++) {
          this._probe(this._upgrades[i]);
        }
      }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
  }, {
    key: "_probe",
    value: function _probe(name) {
      var _this8 = this;
      debug('probing transport "%s"', name);
      var transport = this.createTransport(name);
      var failed = false;
      SocketWithoutUpgrade.priorWebsocketSuccess = false;
      var onTransportOpen = function onTransportOpen() {
        if (failed) return;
        debug('probe transport "%s" opened', name);
        transport.send([{
          type: "ping",
          data: "probe"
        }]);
        transport.once("packet", function (msg) {
          if (failed) return;
          if ("pong" === msg.type && "probe" === msg.data) {
            debug('probe transport "%s" pong', name);
            _this8.upgrading = true;
            _this8.emitReserved("upgrading", transport);
            if (!transport) return;
            SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
            debug('pausing current transport "%s"', _this8.transport.name);
            _this8.transport.pause(function () {
              if (failed) return;
              if ("closed" === _this8.readyState) return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              _this8.setTransport(transport);
              transport.send([{
                type: "upgrade"
              }]);
              _this8.emitReserved("upgrade", transport);
              transport = null;
              _this8.upgrading = false;
              _this8.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            var err = new Error("probe error");
            // @ts-ignore
            err.transport = transport.name;
            _this8.emitReserved("upgradeError", err);
          }
        });
      };
      function freezeTransport() {
        if (failed) return;
        // Any callback called by transport should be ignored since now
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      // Handle any error that happens while probing
      var onerror = function onerror(err) {
        var error = new Error("probe error: " + err);
        // @ts-ignore
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        _this8.emitReserved("upgradeError", error);
      };
      function onTransportClose() {
        onerror("transport closed");
      }
      // When the socket is closed while we're probing
      function onclose() {
        onerror("socket closed");
      }
      // When the socket is upgraded while we're probing
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }
      // Remove all listeners on the transport and on self
      var cleanup = function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        _this8.off("close", onclose);
        _this8.off("upgrading", onupgrade);
      };
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
        // favor WebTransport
        this.setTimeoutFn(function () {
          if (!failed) {
            transport.open();
          }
        }, 200);
      } else {
        transport.open();
      }
    }
  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this._upgrades = this._filterUpgrades(data.upgrades);
      _superPropGet(SocketWithUpgrade, "onHandshake", this, 3)([data]);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
  }, {
    key: "_filterUpgrades",
    value: function _filterUpgrades(upgrades) {
      var filteredUpgrades = [];
      for (var i = 0; i < upgrades.length; i++) {
        if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    }
  }]);
}(SocketWithoutUpgrade);
exports.SocketWithUpgrade = SocketWithUpgrade;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * @example
 * import { Socket } from "engine.io-client";
 *
 * const socket = new Socket();
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see SocketWithUpgrade
 */
var Socket = /*#__PURE__*/function (_SocketWithUpgrade) {
  function Socket(uri) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Socket);
    var o = _typeof(uri) === "object" ? uri : opts;
    if (!o.transports || o.transports && typeof o.transports[0] === "string") {
      o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map(function (transportName) {
        return index_js_1.transports[transportName];
      }).filter(function (t) {
        return !!t;
      });
    }
    return _callSuper(this, Socket, [uri, o]);
  }
  _inherits(Socket, _SocketWithUpgrade);
  return _createClass(Socket);
}(SocketWithUpgrade);
exports.Socket = Socket;

},{"./contrib/parseqs.js":64,"./contrib/parseuri.js":65,"./globals.node.js":66,"./transports/index.js":70,"./util.js":76,"@socket.io/component-emitter":59,"debug":77,"engine.io-parser":83}],69:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = exports.TransportError = void 0;
const engine_io_parser_1 = require("engine.io-parser");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("./util.js");
const parseqs_js_1 = require("./contrib/parseqs.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:transport"); // debug()
class TransportError extends Error {
    constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
exports.TransportError = TransportError;
class Transport extends component_emitter_1.Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
        super();
        this.writable = false;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
        this.supportsBinary = !opts.forceBase64;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */
    open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */
    close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
        if (this.readyState === "open") {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
            debug("transport is not open, discarding packets");
        }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) { }
    createUri(schema, query = {}) {
        return (schema +
            "://" +
            this._hostname() +
            this._port() +
            this.opts.path +
            this._query(query));
    }
    _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
        if (this.opts.port &&
            ((this.opts.secure && Number(this.opts.port !== 443)) ||
                (!this.opts.secure && Number(this.opts.port) !== 80))) {
            return ":" + this.opts.port;
        }
        else {
            return "";
        }
    }
    _query(query) {
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
    }
}
exports.Transport = Transport;

},{"./contrib/parseqs.js":64,"./util.js":76,"@socket.io/component-emitter":59,"debug":77,"engine.io-parser":83}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transports = void 0;
const polling_xhr_node_js_1 = require("./polling-xhr.node.js");
const websocket_node_js_1 = require("./websocket.node.js");
const webtransport_js_1 = require("./webtransport.js");
exports.transports = {
    websocket: websocket_node_js_1.WS,
    webtransport: webtransport_js_1.WT,
    polling: polling_xhr_node_js_1.XHR,
};

},{"./polling-xhr.node.js":72,"./websocket.node.js":74,"./webtransport.js":75}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fetch = void 0;
const polling_js_1 = require("./polling.js");
/**
 * HTTP long-polling based on the built-in `fetch()` method.
 *
 * Usage: browser, Node.js (since v18), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch
 * @see https://caniuse.com/fetch
 * @see https://nodejs.org/api/globals.html#fetch
 */
class Fetch extends polling_js_1.Polling {
    doPoll() {
        this._fetch()
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch read error", res.status, res);
            }
            res.text().then((data) => this.onData(data));
        })
            .catch((err) => {
            this.onError("fetch read error", err);
        });
    }
    doWrite(data, callback) {
        this._fetch(data)
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch write error", res.status, res);
            }
            callback();
        })
            .catch((err) => {
            this.onError("fetch write error", err);
        });
    }
    _fetch(data) {
        var _a;
        const isPost = data !== undefined;
        const headers = new Headers(this.opts.extraHeaders);
        if (isPost) {
            headers.set("content-type", "text/plain;charset=UTF-8");
        }
        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
        return fetch(this.uri(), {
            method: isPost ? "POST" : "GET",
            body: isPost ? data : null,
            headers,
            credentials: this.opts.withCredentials ? "include" : "omit",
        }).then((res) => {
            var _a;
            // @ts-ignore getSetCookie() was added in Node.js v19.7.0
            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());
            return res;
        });
    }
}
exports.Fetch = Fetch;

},{"./polling.js":73}],72:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XHR = exports.Request = exports.BaseXHR = void 0;
const polling_js_1 = require("./polling.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("../util.js");
const globals_node_js_1 = require("../globals.node.js");
const has_cors_js_1 = require("../contrib/has-cors.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
function empty() { }
class BaseXHR extends polling_js_1.Polling {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
        }
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data,
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
        debug("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
exports.BaseXHR = BaseXHR;
class Request extends component_emitter_1.Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(createRequest, uri, opts) {
        super();
        this.createRequest = createRequest;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this._opts = opts;
        this._method = opts.method || "GET";
        this._uri = uri;
        this._data = undefined !== opts.data ? opts.data : null;
        this._create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    _create() {
        var _a;
        const opts = (0, util_js_1.pick)(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this._opts.xd;
        const xhr = (this._xhr = this.createRequest(opts));
        try {
            debug("xhr open %s: %s", this._method, this._uri);
            xhr.open(this._method, this._uri, true);
            try {
                if (this._opts.extraHeaders) {
                    // @ts-ignore
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this._opts.extraHeaders) {
                        if (this._opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this._method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this._opts.withCredentials;
            }
            if (this._opts.requestTimeout) {
                xhr.timeout = this._opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                var _a;
                if (xhr.readyState === 3) {
                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(
                    // @ts-ignore
                    xhr.getResponseHeader("set-cookie"));
                }
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this._onLoad();
                }
                else {
                    // make sure the `error` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this._onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            debug("xhr data %s", this._data);
            xhr.send(this._data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this._onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this._index = Request.requestsCount++;
            Request.requests[this._index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    _onError(err) {
        this.emitReserved("error", err, this._xhr);
        this._cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    _cleanup(fromError) {
        if ("undefined" === typeof this._xhr || null === this._xhr) {
            return;
        }
        this._xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this._xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this._index];
        }
        this._xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    _onLoad() {
        const data = this._xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this._cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
        this._cleanup();
    }
}
exports.Request = Request;
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globals_node_js_1.globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}
const hasXHR2 = (function () {
    const xhr = newRequest({
        xdomain: false,
    });
    return xhr && xhr.responseType !== null;
})();
/**
 * HTTP long-polling based on the built-in `XMLHttpRequest` object.
 *
 * Usage: browser
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 */
class XHR extends BaseXHR {
    constructor(opts) {
        super(opts);
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd }, this.opts);
        return new Request(newRequest, this.uri(), opts);
    }
}
exports.XHR = XHR;
function newRequest(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new globals_node_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
}

},{"../contrib/has-cors.js":63,"../globals.node.js":66,"../util.js":76,"./polling.js":73,"@socket.io/component-emitter":59,"debug":77}],73:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Polling = void 0;
const transport_js_1 = require("../transport.js");
const util_js_1 = require("../util.js");
const engine_io_parser_1 = require("engine.io-parser");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
class Polling extends transport_js_1.Transport {
    constructor() {
        super(...arguments);
        this._polling = false;
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
        this._poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            debug("paused");
            this.readyState = "paused";
            onPause();
        };
        if (this._polling || !this.writable) {
            let total = 0;
            if (this._polling) {
                debug("we are currently polling - waiting to pause");
                total++;
                this.once("pollComplete", function () {
                    debug("pre-pause polling complete");
                    --total || pause();
                });
            }
            if (!this.writable) {
                debug("we are currently writing - waiting to pause");
                total++;
                this.once("drain", function () {
                    debug("pre-pause writing complete");
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    _poll() {
        debug("polling");
        this._polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
        debug("polling got data %s", data);
        const callback = (packet) => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({ description: "transport closed by the server" });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this._polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
                this._poll();
            }
            else {
                debug('ignoring poll - transport state "%s"', this.readyState);
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
        const close = () => {
            debug("writing close packet");
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            debug("transport open - closing");
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            debug("transport not open - deferring close");
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
        this.writable = false;
        (0, engine_io_parser_1.encodePayload)(packets, (data) => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, util_js_1.randomString)();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
exports.Polling = Polling;

},{"../transport.js":69,"../util.js":76,"debug":77,"engine.io-parser":83}],74:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WS = exports.BaseWS = void 0;
const transport_js_1 = require("../transport.js");
const util_js_1 = require("../util.js");
const engine_io_parser_1 = require("engine.io-parser");
const globals_node_js_1 = require("../globals.node.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:websocket"); // debug()
// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class BaseWS extends transport_js_1.Transport {
    get name() {
        return "websocket";
    }
    doOpen() {
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws = this.createSocket(uri, protocols, opts);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
            description: "websocket connection closed",
            context: closeEvent,
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    this.doWrite(packet, data);
                }
                catch (e) {
                    debug("websocket closed before onclose event");
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    (0, globals_node_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.onerror = () => { };
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, util_js_1.randomString)();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
exports.BaseWS = BaseWS;
const WebSocketCtor = globals_node_js_1.globalThisShim.WebSocket || globals_node_js_1.globalThisShim.MozWebSocket;
/**
 * WebSocket transport based on the built-in `WebSocket` object.
 *
 * Usage: browser, Node.js (since v21), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
 * @see https://caniuse.com/mdn-api_websocket
 * @see https://nodejs.org/api/globals.html#websocket
 */
class WS extends BaseWS {
    createSocket(uri, protocols, opts) {
        return !isReactNative
            ? protocols
                ? new WebSocketCtor(uri, protocols)
                : new WebSocketCtor(uri)
            : new WebSocketCtor(uri, protocols, opts);
    }
    doWrite(_packet, data) {
        this.ws.send(data);
    }
}
exports.WS = WS;

},{"../globals.node.js":66,"../transport.js":69,"../util.js":76,"debug":77,"engine.io-parser":83}],75:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WT = void 0;
const transport_js_1 = require("../transport.js");
const globals_node_js_1 = require("../globals.node.js");
const engine_io_parser_1 = require("engine.io-parser");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:webtransport"); // debug()
/**
 * WebTransport transport based on the built-in `WebTransport` object.
 *
 * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
 * @see https://caniuse.com/webtransport
 */
class WT extends transport_js_1.Transport {
    get name() {
        return "webtransport";
    }
    doOpen() {
        try {
            // @ts-ignore
            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this._transport.closed
            .then(() => {
            debug("transport closed gracefully");
            this.onClose();
        })
            .catch((err) => {
            debug("transport closed due to %s", err);
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
        this._transport.ready.then(() => {
            this._transport.createBidirectionalStream().then((stream) => {
                const decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();
                encoderStream.readable.pipeTo(stream.writable);
                this._writer = encoderStream.writable.getWriter();
                const read = () => {
                    reader
                        .read()
                        .then(({ done, value }) => {
                        if (done) {
                            debug("session is closed");
                            return;
                        }
                        debug("received chunk: %o", value);
                        this.onPacket(value);
                        read();
                    })
                        .catch((err) => {
                        debug("an error occurred while reading: %s", err);
                    });
                };
                read();
                const packet = { type: "open" };
                if (this.query.sid) {
                    packet.data = `{"sid":"${this.query.sid}"}`;
                }
                this._writer.write(packet).then(() => this.onOpen());
            });
        });
    }
    write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            this._writer.write(packet).then(() => {
                if (lastPacket) {
                    (0, globals_node_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        var _a;
        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
    }
}
exports.WT = WT;

},{"../globals.node.js":66,"../transport.js":69,"debug":77,"engine.io-parser":83}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = pick;
exports.installTimerFunctions = installTimerFunctions;
exports.byteLength = byteLength;
exports.randomString = randomString;
const globals_node_js_1 = require("./globals.node.js");
function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = globals_node_js_1.globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globals_node_js_1.globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globals_node_js_1.globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globals_node_js_1.globalThisShim);
    }
    else {
        obj.setTimeoutFn = globals_node_js_1.globalThisShim.setTimeout.bind(globals_node_js_1.globalThisShim);
        obj.clearTimeoutFn = globals_node_js_1.globalThisShim.clearTimeout.bind(globals_node_js_1.globalThisShim);
    }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
    if (typeof obj === "string") {
        return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
    let c = 0, length = 0;
    for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 0x80) {
            length += 1;
        }
        else if (c < 0x800) {
            length += 2;
        }
        else if (c < 0xd800 || c >= 0xe000) {
            length += 3;
        }
        else {
            i++;
            length += 4;
        }
    }
    return length;
}
/**
 * Generates a random 8-characters string.
 */
function randomString() {
    return (Date.now().toString(36).substring(3) +
        Math.random().toString(36).substring(2, 5));
}

},{"./globals.node.js":66}],77:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))
},{"./common":78,"_process":97}],78:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":92}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
exports.ERROR_PACKET = ERROR_PACKET;

},{}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
// imported from https://github.com/socketio/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
const encode = (arraybuffer) => {
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
exports.encode = encode;
const decode = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};
exports.decode = decode;

},{}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePacket = void 0;
const commons_js_1 = require("./commons.js");
const base64_arraybuffer_js_1 = require("./contrib/base64-arraybuffer.js");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType),
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),
        };
    }
    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
    if (!packetType) {
        return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
        }
        : {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
        };
};
exports.decodePacket = decodePacket;
const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
        const decoded = (0, base64_arraybuffer_js_1.decode)(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            if (data instanceof Blob) {
                // from WebSocket + binaryType "blob"
                return data;
            }
            else {
                // from HTTP long-polling or WebTransport
                return new Blob([data]);
            }
        case "arraybuffer":
        default:
            if (data instanceof ArrayBuffer) {
                // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
                return data;
            }
            else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
    }
};

},{"./commons.js":79,"./contrib/base64-arraybuffer.js":80}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePacket = void 0;
exports.encodePacketToBinary = encodePacketToBinary;
const commons_js_1 = require("./commons.js");
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};
exports.encodePacket = encodePacket;
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
};
function toArray(data) {
    if (data instanceof Uint8Array) {
        return data;
    }
    else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    else {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (withNativeBlob && packet.data instanceof Blob) {
        return packet.data.arrayBuffer().then(toArray).then(callback);
    }
    else if (withNativeArrayBuffer &&
        (packet.data instanceof ArrayBuffer || isView(packet.data))) {
        return callback(toArray(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
        if (!TEXT_ENCODER) {
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}

},{"./commons.js":79}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;
exports.createPacketEncoderStream = createPacketEncoderStream;
exports.createPacketDecoderStream = createPacketDecoderStream;
const encodePacket_js_1 = require("./encodePacket.js");
Object.defineProperty(exports, "encodePacket", { enumerable: true, get: function () { return encodePacket_js_1.encodePacket; } });
const decodePacket_js_1 = require("./decodePacket.js");
Object.defineProperty(exports, "decodePacket", { enumerable: true, get: function () { return decodePacket_js_1.decodePacket; } });
const commons_js_1 = require("./commons.js");
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
exports.encodePayload = encodePayload;
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
exports.decodePayload = decodePayload;
function createPacketEncoderStream() {
    return new TransformStream({
        transform(packet, controller) {
            (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                }
                else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                }
                else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        },
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* State.READ_HEADER */;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            while (true) {
                if (state === 0 /* State.READ_HEADER */) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* State.READ_PAYLOAD */;
                    }
                    else if (expectedLength === 126) {
                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
                    }
                    else {
                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
                    }
                }
                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(commons_js_1.ERROR_PACKET);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* State.READ_HEADER */;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(commons_js_1.ERROR_PACKET);
                    break;
                }
            }
        },
    });
}
exports.protocol = 4;

},{"./commons.js":79,"./decodePacket.js":81,"./encodePacket.js":82}],84:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = forPromise;
var _essentials = require("./utils/essentials.mjs");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } //  Libs
/**
 * @typedef {Object} forPromiseIteration
 * @property {Record<string, any>|any[]|number} data - The main data source. Can be an array-like object, number (as count), or object for keys.
 * @property {string} [type] - Optional type of iteration. Currently supports "while" for while-like looping.
 * @property {*} [while] - While validator
 * @property {Function} [checker] - Used only with type: "while" to determine loop continuation.
 */
/**
 * Extra control object.
 *
 * @typedef {Object} forPromiseExtra
 * @property {boolean} complete - Whether the extra item has completed processing.
 * @property {boolean} forceBreak - Whether the extra item has triggered a forced break.
 * @property {number} count - Number of processed items.
 * @property {number|null} total - Total expected items, or null if not set.
 * @property {Array<any>} items - List of items processed.
 * @property {string} [type] - Optional type of processing (e.g., 'while').
 * @property {boolean} [error] - Is error.
 */
/**
 * @typedef {{
 *  error: boolean;
 *  forceBreak: boolean;
 *  type?: string;
 *  extra?: Array<forPromiseExtra>;
 *  count: number;
 *  total: number|null;
 *  items: Array<any>
 * }} ForPromiseStatus
 */
/**
 * Runs an asynchronous iterative operation with advanced control over flow, breaks, and nested (extra) iterations.
 * The function accepts a data object and a callback, and returns a Promise that resolves with iteration results.
 *
 * @param {forPromiseIteration} obj - The data object used to control the iteration process. It must follow a specific structure.
 * @param {Function} callback - A function that will be called on each iteration step.
 *
 * @returns {Promise<ForPromiseStatus>}
 */
function forPromise(obj, callback) {
  return new Promise(function (resolve, reject) {
    try {
      if (_typeof(obj) !== 'object' || obj === null) throw new Error('Invalid object provided.');
      if (typeof callback !== 'function') throw new Error('Callback must be a function.');
    } catch (err) {
      return reject(err);
    }
    // Validate Obj
    var objValidated = (0, _essentials.superValidator)(obj);
    // Validator
    if (objValidated.confirmed) {
      /** @type {ForPromiseStatus} */
      var items = {
        error: false,
        forceBreak: false,
        count: 0,
        total: null,
        items: []
      };
      // Error Result
      /** @param {Error} err */
      var error_result = function error_result(err) {
        // Send Error Reject
        items.error = true;
        reject(err);
      };
      /**
       * Prepare Result
       *
       * @param {boolean} isExtra
       * @param {number} extraIndex
       * @param {*} item
       * @param {boolean|{ break: boolean; dontSendResult: boolean; forceResult: boolean;}} [forceBreak=false]
       */
      var result = function result(isExtra, extraIndex, item) {
        var forceBreak = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        // Prepare Edit
        var item_to_edit = null;
        // Not Extra
        if (!isExtra) {
          item_to_edit = items;
        } else {
          item_to_edit = extra.list[extraIndex];
        }
        if (typeof item_to_edit.total !== 'number') return reject(new Error('Invalid "item_to_edit.total" value: null or undefined.'));
        // Force Break
        /**
         * @typedef {Object} ForceBreakResult
         * @property {boolean} isObject
         * @property {boolean} [allowed]
         * @property {boolean} [dontSendResult]
         * @property {boolean} [forceResult]
         */
        /** @type {ForceBreakResult} */
        var forceBreakResult = {
          isObject: (/** @type {boolean} */(0, _essentials.objType)(forceBreak, 'object'))
        };
        // Is Boolean
        if (!forceBreakResult.isObject) {
          if (!item_to_edit.forceBreak) {
            forceBreakResult.allowed = typeof forceBreak === 'boolean' && forceBreak;
          } else {
            forceBreakResult.allowed = false;
          }
          forceBreakResult.dontSendResult = false;
          forceBreakResult.forceResult = false;
        }
        // Object
        else if (_typeof(forceBreak) === 'object') {
          if (!item_to_edit.forceBreak) forceBreakResult.allowed = typeof forceBreak["break"] === 'boolean' && forceBreak["break"];else forceBreakResult.allowed = false;
          forceBreakResult.dontSendResult = typeof forceBreak.dontSendResult === 'boolean' && forceBreak.dontSendResult;
          forceBreakResult.forceResult = typeof forceBreak.forceResult === 'boolean' && forceBreak.forceResult;
        }
        // No Error
        if (!item_to_edit.error && !item_to_edit.forceBreak || forceBreakResult.forceResult) {
          // Count
          item_to_edit.count++;
          // Normal
          if (item !== null) {
            // Add Item
            item_to_edit.items.push(item);
          }
          // Set Force Break
          if (!item_to_edit.forceBreak && forceBreakResult.allowed) {
            item_to_edit.forceBreak = true;
            item_to_edit.count = item_to_edit.total + 1;
          }
          // Complete
          if (
          // Can Send Results
          !forceBreakResult.dontSendResult && (
          // Count is Bigger
          item_to_edit.count >= item_to_edit.total ||
          // Type
          typeof item_to_edit.type === 'string' &&
          // While
          item_to_edit.type === 'while' && item_to_edit.count > 0)) {
            // Normal Result
            if (!isExtra) {
              if (!extra.enabled) resolve(items);
            }
            // Extra Result
            else {
              // Check Extra Exist
              if (extra.list[extraIndex]) {
                // Complete Check
                extra.list[extraIndex].complete = true;
                // Check List
                var confirmation_checked = true;
                // Detect Progress
                for (var _item in extra.list) {
                  if (!extra.list[_item].complete) {
                    confirmation_checked = false;
                    break;
                  }
                }
                // Complete
                if (confirmation_checked) {
                  // Add Extra Info
                  items.extra = extra.list;
                  // Resolve
                  resolve(items);
                }
              }
              // Nope
              else {
                items.error = true;
                reject(new Error("forAwait Extra Index ".concat(extraIndex, " not found.")));
              }
            }
          }
        }
      };
      /**
       * @param {Function} callback
       * @param {boolean} [isExtra=false]
       * @param {number} [index=-1]
       * @param {{data: any, type?: string, checker?: Function}|null} [new_extra=null]
       * @returns {void}
       */
      var runFor = function runFor(callback) {
        var isExtra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        var new_extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var the_item = null;
        // Normal
        if (!isExtra) the_item = obj;else if (_typeof(new_extra) === 'object') the_item = new_extra;
        /**
         * @param {number|string|null} [item=null]
         * @returns {boolean}
         */
        var runFor_script = function runFor_script() {
          var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          // No Error
          if (!items.error && !items.forceBreak) {
            // Try
            try {
              // Result Function
              var result_data = /**  @param {boolean} forceBreak */function result_data(forceBreak) {
                return result(isExtra, index, item, forceBreak);
              };
              // Exist Item
              if (item !== null) callback(item, result_data, error_result, extra.extra_function);
              // Nope
              else callback(result_data, error_result, extra.extra_function);
            } catch (err) {
              // Error
              items.error = true;
              reject(err);
              return false;
            }
            // Normal Return
            return true;
          }
          // Error
          else return false;
        };
        if (the_item === null) throw new Error('Invalid "the_item" value: null or undefined.');
        // Start the For
        if (typeof the_item.data !== 'number') {
          // For Object
          if (!the_item.type) {
            // Start For
            var for_used = false;
            for (var item in the_item.data) {
              for_used = true;
              if (!runFor_script(item)) {
                break;
              }
            }
            // Not Used? Confirmed
            if (!for_used) return result(isExtra, index, null);
          }
          // Type
          else {
            // Start a While
            if (the_item.type === 'while') {
              /** @returns {object|void} */
              var _custom_do = function custom_do() {
                if (typeof the_item.checker !== 'function') throw new Error('Invalid "checker" function in "the_item".');
                // Validate
                if (the_item.checker()) {
                  // Prepare Edit
                  var item_to_edit = null;
                  // Not Extra
                  if (!isExtra) {
                    item_to_edit = items;
                  } else item_to_edit = extra.list[index];
                  if (typeof item_to_edit.total !== 'number') throw new Error('Invalid "item_to_edit.total" value: null or undefined.');
                  // Add Total
                  item_to_edit.total++;
                  // Callback and Continue
                  callback(
                  /**
                   * Increments the item count and returns the result handler.
                   *
                   * @param {boolean} forceBreak - Whether to forcefully break the loop.
                   * @returns {*} The result of the handler execution.
                   */
                  function (forceBreak) {
                    item_to_edit.count++;
                    return result(isExtra, index, null, forceBreak);
                  }, error_result, extra.extra_function);
                  return _custom_do();
                }
                // Nope
                else return result(isExtra, index, null);
              };
              // Start
              _custom_do();
            }
            // Nothing
            else {
              items.error = true;
              reject(new Error('Invalid Function Type!'));
            }
          }
        }
        // Number Type
        else {
          // Exist Number
          if (the_item.data > 0) {
            for (var _item2 = 0; _item2 < the_item.data; _item2++) {
              if (!runFor_script(_item2)) {
                break;
              }
            }
          }
          // Nope
          else return result(isExtra, index, null);
        }
      };
      // Detect Object Module
      items.total = (0, _essentials.validateTotal)(obj.data);
      // Type
      if (objValidated.type) items.type = objValidated.type;
      /**
       * Represents the extra handling structure.
       *
       * @typedef {Object} Extra
       * @property {boolean} enabled - Whether extra processing is enabled.
       * @property {Array<forPromiseExtra>} list - List of extra items.
       * @property {function(forPromiseIteration): {run: function(Function): void}|null} extra_function - Function to add a new extra item.
       */
      /** @type {Extra} */
      var extra = {
        // Enabled
        enabled: false,
        // Extra List
        list: [],
        /**
         * @param {forPromiseIteration} new_extra
         * @returns {{run: function(Function): void}|null}
         */
        extra_function: function extra_function(new_extra) {
          // Validate Obj
          var objValidated = (0, _essentials.superValidator)(new_extra);
          // Validator
          if (objValidated.confirmed) {
            // Prepare Extra
            extra.enabled = true;
            extra.list.push({
              complete: false,
              forceBreak: false,
              count: 0,
              total: null,
              items: []
            });
            // Index
            var index = extra.list.length - 1;
            // Get Total
            extra.list[index].total = (0, _essentials.validateTotal)(new_extra.data);
            // Type
            if (objValidated.type) extra.list[index].type = objValidated.type;
            // Callback
            return {
              // Run Extra
              run: function run(callback) {
                // Run For
                if (!items.error && !items.forceBreak) runFor(callback, true, index, new_extra);
              }
            };
          }
          // Nope
          else {
            var err = new Error('Invalid Object Extra Type to start the Script.');
            items.error = true;
            reject(err);
            return null;
          }
        }
      };
      // Run For
      runFor(callback);
    }
    // Nope
    else reject(new Error('Invalid Object Type to start the Script.'));
  });
}

},{"./utils/essentials.mjs":86}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.countObj = countObj;
exports.objType = objType;
exports.superValidator = superValidator;
exports.validateTotal = validateTotal;
/**
 * Validates the total value based on the type of the input.
 *
 * - If the input is a number, subtracts 1 and returns it.
 * - If it's an object or array, returns its size using `countObj`.
 * - Otherwise, returns 0.
 *
 * @param {*} obj - The input to validate and process.
 * @returns {number} - The resulting total based on the input type.
 *
 * @example
 * validateTotal(5); // 4
 * validateTotal([1, 2, 3]); // 3
 * validateTotal({ a: 1, b: 2 }); // 2
 * validateTotal('invalid'); // 0
 */
function validateTotal(obj) {
  // Get Total
  var newTotal = 0;
  if (typeof obj !== 'number') {
    if (objType(obj, 'object') || Array.isArray(obj)) newTotal = countObj(obj);
  } else newTotal = obj - 1;
  // Insert New Total
  return newTotal;
}
/**
 * Performs a structured validation on a given object and returns a confirmation result.
 *
 * - Confirms validity if `obj.data` is an object, array, or number.
 * - Also confirms if `obj.type` is `'while'`, and `obj.while` is defined, and `obj.checker` is a function.
 *
 * @param {import("../index.mjs").forPromiseIteration} obj - The input object to validate.
 * @returns {{ confirmed: boolean, type?: string }} - Returns an object with a `confirmed` boolean.
 *   If a "while" validation is detected, includes `type: 'while'`.
 *
 * @example
 * superValidator({ data: [1, 2, 3] }); // { confirmed: true }
 * superValidator({ type: 'while', while: true, checker: () => true }); // { confirmed: true, type: 'while' }
 * superValidator({}); // { confirmed: false }
 */
function superValidator(obj) {
  // Start Module
  /**  @type {{ confirmed: boolean, type?: string }} */
  var result = {
    confirmed: false
  };
  // Normal
  if (
  // Main Type
  objType(obj, 'object') && (
  // Object
  objType(obj.data, 'object') ||
  // Array
  Array.isArray(obj.data) ||
  // Number
  typeof obj.data === 'number')) result.confirmed = true;
  // Type
  else if (typeof obj.type === 'string') {
    // While
    if (
    // Confirm Type
    obj.type === 'while' &&
    // Not Empty
    typeof obj["while"] !== 'undefined' &&
    // Detect Function
    typeof obj.checker === 'function') {
      result.confirmed = true;
      result.type = 'while';
    }
  }
  // Complete
  return result;
}
/**
 * Checks the type of a given object or returns its type as a string.
 *
 * @param {*} obj - The object to check or identify.
 * @param {string} [type] - Optional. If provided, checks whether the object matches this type (e.g., "object", "array", "string").
 * @returns {boolean|string|null} - Returns `true` if the type matches, `false` if not,
 *                                   the type string if no type is provided, or `null` if the object is `undefined`.
 *
 * @example
 * objType([], 'array'); // true
 * objType({}, 'object'); // true
 * objType('hello'); // "string"
 * objType(undefined); // null
 */
function objType(obj, type) {
  // Is Defined
  if (typeof obj !== 'undefined') {
    // Get Obj Type
    var result = Object.prototype.toString.call(obj).toLowerCase();
    // Check Obj Type
    if (typeof type === 'string') {
      if (result === "[object ".concat(type, "]")) return true;
      return false;
    }
    // Send Result
    return result.substring(8, result.length - 1);
  }
  // Nope
  return null;
}
/**
 * Counts the number of elements in an array or the number of properties in an object.
 *
 * @param {*} obj - The array or object to count.
 * @returns {number} - The count of items (array elements or object keys), or `0` if the input is neither an array nor an object.
 *
 * @example
 * countObj([1, 2, 3]); // 3
 * countObj({ a: 1, b: 2 }); // 2
 * countObj('not an object'); // 0
 */
function countObj(obj) {
  // Is Array
  if (Array.isArray(obj)) return obj.length;
  // Object
  if (objType(obj, 'object')) return Object.keys(obj).length;
  // Nothing
  return 0;
}

},{}],87:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],88:[function(require,module,exports){
((t,n)=>{"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).JSONRepair={})})(this,function(t){class y extends Error{constructor(t,n){super("".concat(t," at position ").concat(n)),this.position=n}}let e=32,r=10,i=9,f=13,a=160,h=8192,$=8202,O=8239,N=8287,J=12288;function S(t){return"0"<=t&&t<="9"}function j(t){return",:[]/{}()\n+".includes(t)}function k(t){return"a"<=t&&t<="z"||"A"<=t&&t<="Z"||"_"===t||"$"===t}function C(t){return"a"<=t&&t<="z"||"A"<=t&&t<="Z"||"_"===t||"$"===t||"0"<=t&&t<="9"}let m=/^(http|https|ftp|mailto|file|data|irc):\/\/$/,z=/^[A-Za-z0-9-._~:/?#@!$&'()*+;=]$/;function E(t){return",[]/{}\n+".includes(t)}function I(t){return _(t)||n.test(t)}let n=/^[[{\w-]$/;function T(t,n){t=t.charCodeAt(n);return t===e||t===r||t===i||t===f}function Z(t,n){t=t.charCodeAt(n);return t===e||t===i||t===f}function _(t){return F(t)||U(t)}function F(t){return'"'===t||"“"===t||"”"===t}function R(t){return'"'===t}function U(t){return"'"===t||"‘"===t||"’"===t||"`"===t||"´"===t}function q(t){return"'"===t}function B(t,n,e){e=2<arguments.length&&void 0!==e&&e,n=t.lastIndexOf(n);return-1!==n?t.substring(0,n)+(e?"":t.substring(n+1)):t}function D(t,n){let e=t.length;if(!T(t,e-1))return t+n;for(;T(t,e-1);)e--;return t.substring(0,e)+n+t.substring(e)}let G={"\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},H={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};t.JSONRepairError=y,t.jsonrepair=function(g){let d=0,b="";if(n(),!f())throw new y("Unexpected end of json string",g.length);n();var t=u(",");if(t&&v(),I(g[d])&&/[,\n][ \t\r]*$/.test(b)){t||(b=D(b,","));{let t=!0,n=!0;for(;n;)t?t=!1:u(",")||(b=D(b,",")),n=f();n||(b=B(b,",")),b="[\n".concat(b,"\n]")}}else t&&(b=B(b,","));for(;"}"===g[d]||"]"===g[d];)d++,v();if(d>=g.length)return b;throw new y("Unexpected character ".concat(JSON.stringify(g[d])),d);function f(){v();var t=(()=>{if("{"!==g[d])return!1;{b+="{",d++,v(),p(",")&&v();let n=!0;for(;d<g.length&&"}"!==g[d];){let t;if(n?(t=!0,n=!1):((t=u(","))||(b=D(b,",")),v()),o(),!(w()||l(!0))){"}"===g[d]||"{"===g[d]||"]"===g[d]||"["===g[d]||void 0===g[d]?b=B(b,","):(()=>{throw new y("Object key expected",d)})();break}v();var e=u(":"),r=d>=g.length,i=(e||(I(g[d])||r?b=D(b,":"):s()),f());i||(e||r?b+="null":s())}return"}"===g[d]?(b+="}",d++):b=D(b,"}"),!0}})()||(()=>{if("["!==g[d])return!1;{b+="[",d++,v(),p(",")&&v();let t=!0;for(;d<g.length&&"]"!==g[d];){t?t=!1:u(",")||(b=D(b,",")),o();var n=f();if(!n){b=B(b,",");break}}return"]"===g[d]?(b+="]",d++):b=D(b,"]"),!0}})()||w()||(()=>{var t,n,e=d;if("-"===g[d]){if(d++,i())return c(e),!0;if(!S(g[d]))return d=e,!1}for(;S(g[d]);)d++;if("."===g[d]){if(d++,i())return c(e),!0;if(!S(g[d]))return d=e,!1;for(;S(g[d]);)d++}if("e"===g[d]||"E"===g[d]){if(d++,"-"!==g[d]&&"+"!==g[d]||d++,i())return c(e),!0;if(!S(g[d]))return d=e,!1;for(;S(g[d]);)d++}if(i()){if(d>e)return t=g.slice(e,d),n=/^0\d/.test(t),b+=n?'"'.concat(t,'"'):t,!0}else d=e;return!1})()||e("true","true")||e("false","false")||e("null","null")||e("True","true")||e("False","false")||e("None","null")||l(!1)||(()=>{if("/"===g[d]){var t=d;for(d++;d<g.length&&("/"!==g[d]||"\\"===g[d-1]);)d++;return d++,b+='"'.concat(g.substring(t,d),'"'),!0}})();return v(),t}function v(t){var n=!(0<arguments.length&&void 0!==t)||t;d;let e=r(n);for(;e=(e=(()=>{if("/"===g[d]&&"*"===g[d+1]){for(;d<g.length&&!((t,n)=>"*"===t[n]&&"/"===t[n+1])(g,d);)d++;d+=2}else{if("/"!==g[d]||"/"!==g[d+1])return!1;for(;d<g.length&&"\n"!==g[d];)d++}return!0})())&&r(n););d}function r(t){var n,e,r=t?T:Z;let i="";for(;;){if(r(g,d))i+=g[d];else{if(n=g,e=d,!((n=n.charCodeAt(e))===a||n>=h&&n<=$||n===O||n===N||n===J))break;i+=" "}d++}return 0<i.length&&(b+=i,!0)}function n(){if("```"===g.slice(d,d+3)){if(d+=3,k(g[d]))for(;d<g.length&&C(g[d]);)d++;v()}}function u(t){return g[d]===t&&(b+=g[d],d++,!0)}function p(t){return g[d]===t&&(d++,!0)}function o(){v(),"."===g[d]&&"."===g[d+1]&&"."===g[d+2]&&(d+=3,v(),p(","))}function w(t,n){var e=0<arguments.length&&void 0!==t&&t,r=1<arguments.length&&void 0!==n?n:-1;let i="\\"===g[d];if(i&&(d++,i=!0),_(g[d])){var f=R(g[d])?R:q(g[d])?q:U(g[d])?U:F,u=d,o=b.length;let n='"';for(d++;;){if(d>=g.length)return l=x(d-1),!e&&j(g.charAt(l))?(d=u,b=b.substring(0,o),w(!0)):(n=D(n,'"'),b+=n,!0);if(d===r)return n=D(n,'"'),b+=n,!0;if(f(g[d])){var l=d,c=n.length;if(n+='"',d++,b+=n,v(!1),e||d>=g.length||j(g[d])||_(g[d])||S(g[d]))return A(),!0;var s=x(l-1),a=g.charAt(s);if(","===a)return d=u,b=b.substring(0,o),w(!1,s);if(j(a))return d=u,b=b.substring(0,o),w(!0);b=b.substring(0,o),d=l+1,n="".concat(n.substring(0,c),"\\").concat(n.substring(c))}else{if(e&&E(g[d])){if(":"===g[d-1]&&m.test(g.substring(u+1,d+2)))for(;d<g.length&&z.test(g[d]);)n+=g[d],d++;return n=D(n,'"'),b+=n,A(),!0}if("\\"===g[d]){s=g.charAt(d+1);if(void 0!==H[s])n+=g.slice(d,d+2),d+=2;else if("u"===s){let t=2;for(;t<6&&/^[0-9A-Fa-f]$/.test(g[d+t]);)t++;if(6===t)n+=g.slice(d,d+6),d+=6;else{if(!(d+t>=g.length))throw a=void 0,a=g.slice(d,d+6),new y('Invalid unicode character "'.concat(a,'"'),d);d=g.length}}else n+=s,d+=2}else{var h,c=g.charAt(d);if('"'===c&&"\\"!==g[d-1])n+="\\".concat(c);else if("\n"===(h=c)||"\r"===h||"\t"===h||"\b"===h||"\f"===h)n+=G[c];else{if(!(" "<=c))throw h=void 0,h=c,new y("Invalid character ".concat(JSON.stringify(h)),d);n+=c}d++}}i&&p("\\")}}return!1}function A(){let t=!1;for(v();"+"===g[d];){t=!0,d++,v();var n=(b=B(b,'"',!0)).length,e=w();b=e?(e=b,n=n,r=1,e.substring(0,n)+e.substring(n+r)):D(b,'"')}var r;t}function e(t,n){return g.slice(d,d+t.length)===t&&(b+=n,d+=t.length,!0)}function l(t){var n=d;if(k(g[d])){for(;d<g.length&&C(g[d]);)d++;let t=d;for(;T(g,t);)t++;if("("===g[t])return d=t+1,f(),")"===g[d]&&(d++,";"===g[d])&&d++,!0}for(;d<g.length&&!E(g[d])&&!_(g[d])&&(!t||":"!==g[d]);)d++;if(":"===g[d-1]&&m.test(g.substring(n,d+2)))for(;d<g.length&&z.test(g[d]);)d++;if(d>n){for(;T(g,d-1)&&0<d;)d--;n=g.slice(n,d);return b+="undefined"===n?"null":JSON.stringify(n),'"'===g[d]&&d++,!0}}function x(t){let n=t;for(;0<n&&T(g,n);)n--;return n}function i(){return d>=g.length||j(g[d])||T(g,d)}function c(t){b+="".concat(g.slice(t,d),"0")}function s(){throw new y("Colon expected",d)}}});
},{}],89:[function(require,module,exports){
"use strict";

/*!
 * @license :jsstore - V4.9.0 - 16/12/2024
 * https://github.com/ujjwalguptaofficial/JsStore
 * Copyright (c) 2024 @Ujjwal Gupta; Licensed MIT
 */
/******/
(function () {
  // webpackBootstrap
  /******/
  "use strict";

  /******/ // The require scope
  /******/
  var __webpack_require__ = {};
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/define property getters */
  /******/
  (function () {
    /******/ // define getter functions for harmony exports
    /******/__webpack_require__.d = function (exports, definition) {
      /******/for (var key in definition) {
        /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          /******/Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/
  (function () {
    /******/__webpack_require__.o = function (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/
  (function () {
    /******/ // define __esModule on exports
    /******/__webpack_require__.r = function (exports) {
      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};
  // ESM COMPAT FLAG
  __webpack_require__.r(__webpack_exports__);

  // EXPORTS
  __webpack_require__.d(__webpack_exports__, {
    API: function API() {
      return /* reexport */_API;
    },
    CONNECTION_STATUS: function CONNECTION_STATUS() {
      return /* reexport */_CONNECTION_STATUS;
    },
    Connection: function Connection() {
      return /* reexport */_Connection;
    },
    DATA_TYPE: function DATA_TYPE() {
      return /* reexport */_DATA_TYPE;
    },
    ERROR_TYPE: function ERROR_TYPE() {
      return /* reexport */_ERROR_TYPE;
    },
    EVENT: function EVENT() {
      return /* reexport */_EVENT;
    },
    IDB_MODE: function IDB_MODE() {
      return /* reexport */_IDB_MODE;
    },
    OCCURENCE: function OCCURENCE() {
      return /* reexport */_OCCURENCE;
    },
    QUERY_OPTION: function QUERY_OPTION() {
      return /* reexport */_QUERY_OPTION;
    },
    WORKER_STATUS: function WORKER_STATUS() {
      return /* reexport */_WORKER_STATUS;
    },
    forObj: function forObj() {
      return /* reexport */_forObj;
    },
    promise: function promise() {
      return /* reexport */_promise;
    },
    promiseAll: function promiseAll() {
      return /* reexport */_promiseAll;
    },
    promiseResolve: function promiseResolve() {
      return /* reexport */_promiseResolve;
    }
  });
  ; // ./src/main/log_helper.ts
  var LogHelper = /** @class */function () {
    function LogHelper(type, info) {
      this.type = type;
      this._info = info;
      this.message = this.getMsg();
    }
    LogHelper.prototype["throw"] = function () {
      throw this;
    };
    LogHelper.prototype.log = function (msg) {
      if (this.status) {
        console.log(msg);
      }
    };
    LogHelper.prototype.logError = function () {
      console.error(this.get());
    };
    LogHelper.prototype.logWarning = function () {
      console.warn(this.get());
    };
    LogHelper.prototype.get = function () {
      return {
        message: this.message,
        type: this.type
      };
    };
    LogHelper.prototype.getMsg = function () {
      var errMsg;
      switch (this.type) {
        default:
          errMsg = this.message;
          break;
      }
      return errMsg;
    };
    return LogHelper;
  }();
  ; // ./src/common/enums.ts
  var _ERROR_TYPE = {
    InvalidUpdateColumn: "invalid_update_column",
    UndefinedColumn: "undefined_column",
    UndefinedValue: "undefined_value",
    UndefinedColumnName: "undefined_column_name",
    UndefinedDbName: "undefined_database_name",
    UndefinedColumnValue: "undefined_column_value",
    NotArray: "not_array",
    NoValueSupplied: "no_value_supplied",
    ColumnNotExist: "column_not_exist",
    NoIndexFound: "no_index_found",
    InvalidOp: "invalid_operator",
    NullValue: "null_value",
    WrongDataType: "wrong_data_type",
    TableNotExist: "table_not_exist",
    DbNotExist: "db_not_exist",
    ConnectionAborted: "connection_aborted",
    ConnectionClosed: "connection_closed",
    NotObject: "not_object",
    InvalidConfig: "invalid_config",
    DbBlocked: "Db_blocked",
    IndexedDbNotSupported: "indexeddb_not_supported",
    NullValueInWhere: "null_value_in_where",
    InvalidJoinQuery: 'invalid_join_query',
    InvalidQuery: 'invalid_query',
    ImportScriptsFailed: 'import_scripts_failed',
    MethodNotExist: 'method_not_exist',
    Unknown: "unknown",
    InvalidMiddleware: "invalid_middleware",
    InvalidOrderQuery: 'invalid_order_query',
    InvalidGroupQuery: 'invalid_group_query',
    NoPrimaryKey: 'no_primary_key'
  };
  var _WORKER_STATUS;
  (function (WORKER_STATUS) {
    WORKER_STATUS["Registered"] = "registerd";
    WORKER_STATUS["Failed"] = "failed";
    WORKER_STATUS["NotStarted"] = "not_started";
  })(_WORKER_STATUS || (_WORKER_STATUS = {}));
  var _DATA_TYPE;
  (function (DATA_TYPE) {
    DATA_TYPE["String"] = "string";
    DATA_TYPE["Object"] = "object";
    DATA_TYPE["Array"] = "array";
    DATA_TYPE["Number"] = "number";
    DATA_TYPE["Boolean"] = "boolean";
    DATA_TYPE["Null"] = "null";
    DATA_TYPE["DateTime"] = "date_time";
  })(_DATA_TYPE || (_DATA_TYPE = {}));
  var _API;
  (function (API) {
    API["InitDb"] = "init_db";
    API["MapGet"] = "map_get";
    API["MapSet"] = "map_set";
    API["MapHas"] = "map_has";
    API["MapDelete"] = "map_delete";
    API["Select"] = "select";
    API["Insert"] = "insert";
    API["Update"] = "update";
    API["Remove"] = "remove";
    API["OpenDb"] = "open_db";
    API["Clear"] = "clear";
    API["DropDb"] = "drop_db";
    API["Count"] = "count";
    API["ChangeLogStatus"] = "change_log_status";
    API["Terminate"] = "terminate";
    API["Transaction"] = "transaction";
    API["CloseDb"] = "close_db";
    API["Union"] = "union";
    API["Intersect"] = "intersect";
    API["ImportScripts"] = "import_scripts";
    API["Middleware"] = "middleware";
  })(_API || (_API = {}));
  var _EVENT;
  (function (EVENT) {
    EVENT["RequestQueueEmpty"] = "requestQueueEmpty";
    EVENT["RequestQueueFilled"] = "requestQueueFilled";
    EVENT["Upgrade"] = "upgrade";
    EVENT["Create"] = "create";
    EVENT["Open"] = "open";
  })(_EVENT || (_EVENT = {}));
  var _QUERY_OPTION;
  (function (QUERY_OPTION) {
    QUERY_OPTION["Where"] = "where";
    QUERY_OPTION["Like"] = "like";
    QUERY_OPTION["Regex"] = "regex";
    QUERY_OPTION["In"] = "in";
    QUERY_OPTION["Equal"] = "=";
    QUERY_OPTION["Between"] = "-";
    QUERY_OPTION["GreaterThan"] = ">";
    QUERY_OPTION["LessThan"] = "<";
    QUERY_OPTION["GreaterThanEqualTo"] = ">=";
    QUERY_OPTION["LessThanEqualTo"] = "<=";
    QUERY_OPTION["NotEqualTo"] = "!=";
    QUERY_OPTION["Aggregate"] = "aggregate";
    QUERY_OPTION["Max"] = "max";
    QUERY_OPTION["Min"] = "min";
    QUERY_OPTION["Avg"] = "avg";
    QUERY_OPTION["Count"] = "count";
    QUERY_OPTION["Sum"] = "sum";
    QUERY_OPTION["List"] = "list";
    QUERY_OPTION["Or"] = "or";
    QUERY_OPTION["Skip"] = "skip";
    QUERY_OPTION["Limit"] = "limit";
    QUERY_OPTION["And"] = "and";
    QUERY_OPTION["IgnoreCase"] = "ignoreCase";
    QUERY_OPTION["Then"] = "then";
  })(_QUERY_OPTION || (_QUERY_OPTION = {}));
  var _IDB_MODE;
  (function (IDB_MODE) {
    IDB_MODE["ReadOnly"] = "readonly";
    IDB_MODE["ReadWrite"] = "readwrite";
  })(_IDB_MODE || (_IDB_MODE = {}));
  var _OCCURENCE;
  (function (OCCURENCE) {
    OCCURENCE["First"] = "f";
    OCCURENCE["Last"] = "l";
    OCCURENCE["Any"] = "a";
  })(_OCCURENCE || (_OCCURENCE = {}));
  var _CONNECTION_STATUS;
  (function (CONNECTION_STATUS) {
    CONNECTION_STATUS["Connected"] = "connected";
    CONNECTION_STATUS["Closed"] = "closed";
    CONNECTION_STATUS["NotStarted"] = "not_started";
    CONNECTION_STATUS["UnableToStart"] = "unable_to_start";
    CONNECTION_STATUS["ClosedByJsStore"] = "closed_by_jsstore";
  })(_CONNECTION_STATUS || (_CONNECTION_STATUS = {}));
  ; // ./src/common/utils/promise.ts
  var _promise = function _promise(cb) {
    return new Promise(cb);
  };
  ; // ./src/common/utils/promise_resolve.ts
  var _promiseResolve = function _promiseResolve(value) {
    return Promise.resolve(value);
  };
  ; // ./src/main/event_bus.ts
  var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var EventBus = /** @class */function () {
    function EventBus(ctx) {
      this._events = {};
      this._ctx = ctx;
    }
    EventBus.prototype.on = function (event, cb) {
      if (this._events[event] == null) {
        this._events[event] = [];
      }
      this._events[event].push(cb);
      return this;
    };
    EventBus.prototype.off = function (event, cb) {
      if (this._events[event]) {
        if (cb) {
          var index = this._events[event].indexOf(cb);
          this._events[event].splice(index, 1);
        } else {
          this._events[event] = [];
        }
      }
    };
    EventBus.prototype.emit = function (event) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[event] || [];
      var index = 0;
      var length = events.length;
      var results = [];
      var callMethod = function callMethod() {
        var eventCb = events[index++];
        if (eventCb) {
          var result = eventCb.call.apply(eventCb, __spreadArray([_this._ctx], args, false));
          return result && result.then ? result : Promise.resolve(result);
        }
      };
      return new Promise(function (res) {
        var _checkAndCall = function checkAndCall() {
          if (index < length) {
            callMethod().then(function (result) {
              results.push(result);
              _checkAndCall();
            });
          } else {
            res(results);
          }
        };
        _checkAndCall();
      });
    };
    EventBus.prototype.destroy = function () {
      this._events = null;
      this._ctx = null;
    };
    return EventBus;
  }();
  ; // ./src/main/connection_helper.ts

  var ConnectionHelper = /** @class */function () {
    function ConnectionHelper(worker) {
      this.isConOpened_ = false;
      this.isDbIdle_ = true;
      this.requestQueue_ = [];
      this.isCodeExecuting_ = false;
      this.inactivityTimer_ = -1000;
      this.middlewares = [];
      this.eventBus_ = new EventBus(this);
      // these apis have special permissions. These apis dont wait for database open.
      this.whiteListApi_ = [_API.InitDb, _API.OpenDb, _API.MapGet, _API.MapSet, _API.MapHas, _API.MapDelete, _API.ChangeLogStatus, _API.Terminate, _API.DropDb];
      this.isWorker = true;
      this.logger = new LogHelper(null);
      if (worker) {
        this.worker_ = worker;
        this.worker_.onmessage = this.onMessageFromWorker_.bind(this);
      } else {
        this.isWorker = false;
        this.initQueryManager_();
      }
    }
    Object.defineProperty(ConnectionHelper.prototype, "jsstoreWorker", {
      get: function get() {
        return this.$worker || self['JsStoreWorker'];
      },
      enumerable: false,
      configurable: true
    });
    ConnectionHelper.prototype.initQueryManager_ = function () {
      var workerRef = this.jsstoreWorker;
      if (workerRef) {
        this.queryManager = new workerRef.QueryManager(this.processFinishedQuery_.bind(this));
      }
    };
    ConnectionHelper.prototype.onMessageFromWorker_ = function (msg) {
      this.processFinishedQuery_(msg.data);
    };
    ConnectionHelper.prototype.processFinishedQuery_ = function (message) {
      var finishedRequest = this.requestQueue_.shift();
      if (finishedRequest) {
        this.logger.log("request ".concat(finishedRequest.name, " finished"));
        if (message.error) {
          finishedRequest.onError(message.error);
        } else {
          switch (finishedRequest.name) {
            case _API.OpenDb:
            case _API.InitDb:
              this.isConOpened_ = true;
              break;
            case _API.Terminate:
              this.isConOpened_ = false;
              if (this.isWorker === true) {
                this.worker_.terminate();
              }
            case _API.DropDb:
              this.isConOpened_ = false;
              this.requestQueue_ = [];
              this.isDbIdle_ = true;
              break;
            case _API.CloseDb:
              this.isDbIdle_ = true;
              this.eventBus_.emit(_EVENT.RequestQueueEmpty, []);
              if (this.requestQueue_.length > 0) {
                this.openDb_(false);
              }
              break;
          }
          finishedRequest.onSuccess(message.result);
        }
        this.isCodeExecuting_ = false;
        this.executeQry_();
      }
    };
    ConnectionHelper.prototype.openDb_ = function (execute) {
      if (execute === void 0) {
        execute = true;
      }
      var request = {
        name: _API.OpenDb,
        query: {
          name: this.database.name,
          version: this.database.version
        },
        onSuccess: function onSuccess() {},
        onError: function onError(err) {
          console.error(err);
        }
      };
      if (execute) {
        this.prcoessExecutionOfQry_(request, 0);
      } else {
        this.requestQueue_.splice(0, 0, request);
      }
    };
    ConnectionHelper.prototype.executeMiddleware_ = function (input) {
      var _this = this;
      return _promise(function (res) {
        var index = 0;
        var lastIndex = _this.middlewares.length - 1;
        var _callNextMiddleware = function callNextMiddleware() {
          if (index <= lastIndex) {
            var promiseResult = _this.middlewares[index++](input);
            if (!promiseResult || !promiseResult.then) {
              promiseResult = _promiseResolve(promiseResult);
            }
            promiseResult.then(function (_) {
              _callNextMiddleware();
            });
          } else {
            res();
          }
        };
        _callNextMiddleware();
      });
    };
    ConnectionHelper.prototype.callResultMiddleware = function (middlewares, result) {
      return _promise(function (res) {
        var index = 0;
        var lastIndex = middlewares.length - 1;
        var _callNextMiddleware2 = function callNextMiddleware() {
          if (index <= lastIndex) {
            var promiseResult = middlewares[index++](result);
            if (!promiseResult.then) {
              promiseResult = _promiseResolve(promiseResult);
            }
            promiseResult.then(function (modifiedResult) {
              result = modifiedResult;
              _callNextMiddleware2();
            });
          } else {
            res(result);
          }
        };
        _callNextMiddleware2();
      });
    };
    ConnectionHelper.prototype.pushApi = function (request) {
      var _this = this;
      if (true && !this.jsstoreWorker && !this.worker_) {
        throw new Error("JsStoreWorker not found. Either pass web worker or inject JsStore Worker.");
      }
      return new Promise(function (resolve, reject) {
        var middlewares = [];
        request.onResult = function (cb) {
          middlewares.push(function (result) {
            return cb(result);
          });
        };
        _this.executeMiddleware_(request).then(function () {
          request.onSuccess = function (result) {
            _this.callResultMiddleware(middlewares, result).then(function (modifiedResult) {
              resolve(modifiedResult);
            })["catch"](function (err) {
              request.onError(err);
            });
          };
          request.onError = function (err) {
            middlewares = [];
            reject(err);
          };
          if (_this.requestQueue_.length === 0) {
            _this.eventBus_.emit(_EVENT.RequestQueueFilled, []);
            if (_this.isDbIdle_ && _this.isConOpened_) {
              var isConnectionApi = [_API.InitDb, _API.CloseDb, _API.DropDb, _API.OpenDb, _API.Terminate].indexOf(request.name) >= 0;
              if (!isConnectionApi) {
                _this.openDb_();
              }
            }
            clearTimeout(_this.inactivityTimer_);
          }
          _this.prcoessExecutionOfQry_(request);
        })["catch"](reject);
      });
    };
    ConnectionHelper.prototype.prcoessExecutionOfQry_ = function (request, index) {
      this.isDbIdle_ = false;
      if (index != null) {
        this.requestQueue_.splice(index, 0, request);
      } else {
        this.requestQueue_.push(request);
      }
      this.logger.log("request pushed: " + request.name);
      this.executeQry_();
    };
    ConnectionHelper.prototype.executeQry_ = function () {
      var _this = this;
      var requestQueueLength = this.requestQueue_.length;
      if (!this.isCodeExecuting_ && requestQueueLength > 0) {
        if (this.isConOpened_ === true) {
          this.sendRequestToWorker_(this.requestQueue_[0]);
          return;
        }
        var allowedQueryIndex = this.requestQueue_.findIndex(function (item) {
          return _this.whiteListApi_.indexOf(item.name) >= 0;
        });
        // shift allowed query to zeroth index
        if (allowedQueryIndex >= 0) {
          this.requestQueue_.splice(0, 0, this.requestQueue_.splice(allowedQueryIndex, 1)[0]);
          this.sendRequestToWorker_(this.requestQueue_[0]);
        }
      } else if (requestQueueLength === 0 && this.isDbIdle_ === false && this.isConOpened_) {
        this.inactivityTimer_ = setTimeout(function () {
          _this.prcoessExecutionOfQry_({
            name: _API.CloseDb,
            onSuccess: function onSuccess() {},
            onError: function onError(err) {
              console.error(err);
            }
          });
        }, 100);
      }
    };
    ConnectionHelper.prototype.sendRequestToWorker_ = function (request) {
      this.isCodeExecuting_ = true;
      this.logger.log("request executing: " + request.name);
      var requestForWorker = {
        name: request.name,
        query: request.query
      };
      if (this.isWorker === true) {
        this.worker_.postMessage(requestForWorker);
      } else {
        this.queryManager.run(requestForWorker);
      }
    };
    return ConnectionHelper;
  }();
  ; // ./src/main/map.ts

  var JsStoreMap = /** @class */function () {
    function JsStoreMap(con) {
      this.con = con;
    }
    /**
     * Returns the value associated to the passed key, or undefined if there is none.
     *
     * @template T
     * @param {string} key
     * @return {*}
     * @memberof JsStoreMap
     */
    JsStoreMap.prototype.get = function (key) {
      return this.con['pushApi']({
        name: _API.MapGet,
        query: key
      });
    };
    /**
     * Returns a boolean indicating whether a value has been associated with the passed key in the MapStore or not.
     *
     * @param {string} key
     * @return {*}
     * @memberof JsStoreMap
     */
    JsStoreMap.prototype.has = function (key) {
      return this.con['pushApi']({
        name: _API.MapHas,
        query: key
      });
    };
    /**
     * Sets the value for the passed key in the map store
     *
     * @param {string} key
     * @param {*} value
     * @return {*}
     * @memberof JsStoreMap
     */
    JsStoreMap.prototype.set = function (key, value) {
      return this.con['pushApi']({
        name: _API.MapSet,
        query: {
          key: key,
          value: value
        }
      });
    };
    /**
     * delete the value by key in the map store
     *
     * @param {string} key
     * @return {*}
     * @memberof JsStoreMap
     */
    JsStoreMap.prototype["delete"] = function (key) {
      return this.con['pushApi']({
        name: _API.MapDelete,
        query: key
      });
    };
    return JsStoreMap;
  }();
  ; // ./src/main/connection.ts
  var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };
      return _extendStatics(d, b);
    };
    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      _extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var _Connection = /** @class */function (_super) {
    __extends(Connection, _super);
    function Connection(worker) {
      var _this = _super.call(this, worker) || this;
      /**
       * stores data in the key value format
       *
       * @memberof Connection
       */
      // tslint:disable-next-line
      _this.Map = new JsStoreMap(_this);
      return _this;
    }
    /**
     * initiate DataBase
     *
     * @param {IDataBase} dataBase
     * @returns
     * @memberof Connection
     */
    Connection.prototype.initDb = function (dataBase) {
      var _this = this;
      this.database = dataBase;
      return this.pushApi({
        name: _API.InitDb,
        query: dataBase
      }).then(function (result) {
        var promiseObj;
        var db = result.database;
        // db.tables = db.tables.filter(table => table.name !== 'JsStore_Meta');
        if (result.isCreated) {
          if (result.oldVersion) {
            promiseObj = _this.eventBus_.emit(_EVENT.Upgrade, db, result.oldVersion, result.newVersion);
          } else {
            promiseObj = _this.eventBus_.emit(_EVENT.Create, db);
          }
        }
        return (promiseObj || _promiseResolve()).then(function (_) {
          return _this.eventBus_.emit(_EVENT.Open, db);
        }).then(function (_) {
          return result.isCreated;
        });
      });
    };
    /**
     * drop dataBase
     *
     * @returns
     * @memberof Connection
     */
    Connection.prototype.dropDb = function () {
      return this.pushApi({
        name: _API.DropDb
      });
    };
    /**
     * select data from table
     *
     * @template T
     * @param {ISelectQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.select = function (query) {
      return this.pushApi({
        name: _API.Select,
        query: query
      });
    };
    /**
     * get no of record from table
     *
     * @param {ICountQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.count = function (query) {
      return this.pushApi({
        name: _API.Count,
        query: query
      });
    };
    /**
     * insert data into table
     *
     * @template T
     * @param {IInsertQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.insert = function (query) {
      return this.pushApi({
        name: _API.Insert,
        query: query
      });
    };
    /**
     * update data into table
     *
     * @param {IUpdateQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.update = function (query) {
      return this.pushApi({
        name: _API.Update,
        query: query
      });
    };
    /**
     * remove data from table
     *
     * @param {IRemoveQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.remove = function (query) {
      return this.pushApi({
        name: _API.Remove,
        query: query
      });
    };
    /**
     * delete all data from table
     *
     * @param {string} tableName
     * @returns
     * @memberof Connection
     */
    Connection.prototype.clear = function (tableName) {
      return this.pushApi({
        name: _API.Clear,
        query: tableName
      });
    };
    Object.defineProperty(Connection.prototype, "logStatus", {
      /**
       * set log status
       *
       * @param {boolean} status
       * @memberof Connection
       */
      set: function set(status) {
        this.logger.status = status;
        this.pushApi({
          name: _API.ChangeLogStatus,
          query: status
        });
      },
      enumerable: false,
      configurable: true
    });
    /**
     * open database
     *
     * @param {string} dbName
     * @returns
     * @memberof Connection
     */
    Connection.prototype.openDb = function (dbName, version) {
      var _this = this;
      return this.pushApi({
        name: _API.OpenDb,
        query: {
          version: version,
          name: dbName
        }
      }).then(function (dataBase) {
        _this.database = dataBase;
        return dataBase;
      });
    };
    /**
     * returns list of database created
     *
     * @returns
     * @memberof Connection
     */
    Connection.prototype.getDbList = function () {
      console.warn("Api getDbList is recommended to use for debugging only. Do not use in code.");
      return indexedDB.databases();
    };
    /**
     * get the value from keystore table
     *
     * @template T
     * @param {string} key
     * @returns
     * @memberof Connection
     */
    Connection.prototype.get = function (key) {
      console.warn("This API is obsolete, please use Map");
      return this.Map.get(key);
    };
    /**
     * set the value in keystore table
     *
     * @param {string} key
     * @param {*} value
     * @returns
     * @memberof Connection
     */
    Connection.prototype.set = function (key, value) {
      console.warn("This API is obsolete, please use Map");
      return this.Map.set(key, value);
    };
    /**
     * terminate the connection
     *
     * @returns
     * @memberof Connection
     */
    Connection.prototype.terminate = function () {
      return this.pushApi({
        name: _API.Terminate
      });
    };
    /**
     * execute transaction
     *
     * @template T
     * @param {ITransactionQuery} query
     * @returns
     * @memberof Connection
     */
    Connection.prototype.transaction = function (query) {
      return this.pushApi({
        name: _API.Transaction,
        query: query
      });
    };
    Connection.prototype.on = function (event, eventCallBack) {
      this.eventBus_.on(event, eventCallBack);
    };
    Connection.prototype.off = function (event, eventCallBack) {
      this.eventBus_.off(event, eventCallBack);
    };
    Connection.prototype.union = function (query) {
      return this.pushApi({
        name: _API.Union,
        query: query
      });
    };
    Connection.prototype.intersect = function (query) {
      return this.pushApi({
        name: _API.Intersect,
        query: query
      });
    };
    Connection.prototype.addPlugin = function (plugin, params) {
      return plugin.setup(this, params);
    };
    Connection.prototype.addMiddleware = function (middleware, forWorker) {
      if (forWorker) {
        return this.pushApi({
          name: _API.Middleware,
          query: middleware
        });
      }
      this.middlewares.push(middleware);
      return Promise.resolve();
    };
    /**
     * import scripts in jsstore web worker.
     * Scripts method can be called using transaction api.
     *
     * @param {...string[]} urls
     * @returns
     * @memberof Connection
     */
    Connection.prototype.importScripts = function () {
      var urls = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        urls[_i] = arguments[_i];
      }
      return this.pushApi({
        name: _API.ImportScripts,
        query: urls
      });
    };
    return Connection;
  }(ConnectionHelper);
  ; // ./src/common/utils/promise_all.ts
  var _promiseAll = function _promiseAll(promises) {
    return Promise.all(promises);
  };
  ; // ./src/common/utils/for_obj.ts
  var _forObj = function _forObj(obj, cb) {
    for (var key in obj) {
      cb(key, obj[key]);
    }
  };
  ; // ./src/common/utils/index.ts

  ; // ./src/common/index.ts

  ; // ./src/main/index.ts

  module.exports = __webpack_exports__;
  /******/
})();

},{}],90:[function(require,module,exports){
/*! For license information please see jsstore.commonjs2.min.js.LICENSE.txt */
(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{API:()=>o,CONNECTION_STATUS:()=>p,Connection:()=>b,DATA_TYPE:()=>r,ERROR_TYPE:()=>l,EVENT:()=>i,IDB_MODE:()=>u,OCCURENCE:()=>a,QUERY_OPTION:()=>s,WORKER_STATUS:()=>n,forObj:()=>q,promise:()=>d,promiseAll:()=>v,promiseResolve:()=>f});var n,r,o,i,s,u,a,p,c=function(){function e(e,t){this.type=e,this._info=t,this.message=this.getMsg()}return e.prototype.throw=function(){throw this},e.prototype.log=function(e){this.status&&console.log(e)},e.prototype.logError=function(){console.error(this.get())},e.prototype.logWarning=function(){console.warn(this.get())},e.prototype.get=function(){return{message:this.message,type:this.type}},e.prototype.getMsg=function(){return this.type,this.message},e}(),l={InvalidUpdateColumn:"invalid_update_column",UndefinedColumn:"undefined_column",UndefinedValue:"undefined_value",UndefinedColumnName:"undefined_column_name",UndefinedDbName:"undefined_database_name",UndefinedColumnValue:"undefined_column_value",NotArray:"not_array",NoValueSupplied:"no_value_supplied",ColumnNotExist:"column_not_exist",NoIndexFound:"no_index_found",InvalidOp:"invalid_operator",NullValue:"null_value",WrongDataType:"wrong_data_type",TableNotExist:"table_not_exist",DbNotExist:"db_not_exist",ConnectionAborted:"connection_aborted",ConnectionClosed:"connection_closed",NotObject:"not_object",InvalidConfig:"invalid_config",DbBlocked:"Db_blocked",IndexedDbNotSupported:"indexeddb_not_supported",NullValueInWhere:"null_value_in_where",InvalidJoinQuery:"invalid_join_query",InvalidQuery:"invalid_query",ImportScriptsFailed:"import_scripts_failed",MethodNotExist:"method_not_exist",Unknown:"unknown",InvalidMiddleware:"invalid_middleware",InvalidOrderQuery:"invalid_order_query",InvalidGroupQuery:"invalid_group_query",NoPrimaryKey:"no_primary_key"};!function(e){e.Registered="registerd",e.Failed="failed",e.NotStarted="not_started"}(n||(n={})),function(e){e.String="string",e.Object="object",e.Array="array",e.Number="number",e.Boolean="boolean",e.Null="null",e.DateTime="date_time"}(r||(r={})),function(e){e.InitDb="init_db",e.MapGet="map_get",e.MapSet="map_set",e.MapHas="map_has",e.MapDelete="map_delete",e.Select="select",e.Insert="insert",e.Update="update",e.Remove="remove",e.OpenDb="open_db",e.Clear="clear",e.DropDb="drop_db",e.Count="count",e.ChangeLogStatus="change_log_status",e.Terminate="terminate",e.Transaction="transaction",e.CloseDb="close_db",e.Union="union",e.Intersect="intersect",e.ImportScripts="import_scripts",e.Middleware="middleware"}(o||(o={})),function(e){e.RequestQueueEmpty="requestQueueEmpty",e.RequestQueueFilled="requestQueueFilled",e.Upgrade="upgrade",e.Create="create",e.Open="open"}(i||(i={})),function(e){e.Where="where",e.Like="like",e.Regex="regex",e.In="in",e.Equal="=",e.Between="-",e.GreaterThan=">",e.LessThan="<",e.GreaterThanEqualTo=">=",e.LessThanEqualTo="<=",e.NotEqualTo="!=",e.Aggregate="aggregate",e.Max="max",e.Min="min",e.Avg="avg",e.Count="count",e.Sum="sum",e.List="list",e.Or="or",e.Skip="skip",e.Limit="limit",e.And="and",e.IgnoreCase="ignoreCase",e.Then="then"}(s||(s={})),function(e){e.ReadOnly="readonly",e.ReadWrite="readwrite"}(u||(u={})),function(e){e.First="f",e.Last="l",e.Any="a"}(a||(a={})),function(e){e.Connected="connected",e.Closed="closed",e.NotStarted="not_started",e.UnableToStart="unable_to_start",e.ClosedByJsStore="closed_by_jsstore"}(p||(p={}));var h,d=function(e){return new Promise(e)},f=function(e){return Promise.resolve(e)},_=function(){function e(e){this._events={},this._ctx=e}return e.prototype.on=function(e,t){return null==this._events[e]&&(this._events[e]=[]),this._events[e].push(t),this},e.prototype.off=function(e,t){if(this._events[e])if(t){var n=this._events[e].indexOf(t);this._events[e].splice(n,1)}else this._events[e]=[]},e.prototype.emit=function(e){for(var t=this,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];var o=this._events[e]||[],i=0,s=o.length,u=[];return new Promise((function(e){var r=function(){i<s?function(){var e=o[i++];if(e){var r=e.call.apply(e,function(e,t,n){if(n||2===arguments.length)for(var r,o=0,i=t.length;o<i;o++)!r&&o in t||(r||(r=Array.prototype.slice.call(t,0,o)),r[o]=t[o]);return e.concat(r||Array.prototype.slice.call(t))}([t._ctx],n,!1));return r&&r.then?r:Promise.resolve(r)}}().then((function(e){u.push(e),r()})):e(u)};r()}))},e.prototype.destroy=function(){this._events=null,this._ctx=null},e}(),y=function(){function e(e){this.isConOpened_=!1,this.isDbIdle_=!0,this.requestQueue_=[],this.isCodeExecuting_=!1,this.inactivityTimer_=-1e3,this.middlewares=[],this.eventBus_=new _(this),this.whiteListApi_=[o.InitDb,o.OpenDb,o.MapGet,o.MapSet,o.MapHas,o.MapDelete,o.ChangeLogStatus,o.Terminate,o.DropDb],this.isWorker=!0,this.logger=new c(null),e?(this.worker_=e,this.worker_.onmessage=this.onMessageFromWorker_.bind(this)):(this.isWorker=!1,this.initQueryManager_())}return Object.defineProperty(e.prototype,"jsstoreWorker",{get:function(){return this.$worker||self.JsStoreWorker},enumerable:!1,configurable:!0}),e.prototype.initQueryManager_=function(){var e=this.jsstoreWorker;e&&(this.queryManager=new e.QueryManager(this.processFinishedQuery_.bind(this)))},e.prototype.onMessageFromWorker_=function(e){this.processFinishedQuery_(e.data)},e.prototype.processFinishedQuery_=function(e){var t=this.requestQueue_.shift();if(t){if(this.logger.log("request ".concat(t.name," finished")),e.error)t.onError(e.error);else{switch(t.name){case o.OpenDb:case o.InitDb:this.isConOpened_=!0;break;case o.Terminate:this.isConOpened_=!1,!0===this.isWorker&&this.worker_.terminate();case o.DropDb:this.isConOpened_=!1,this.requestQueue_=[],this.isDbIdle_=!0;break;case o.CloseDb:this.isDbIdle_=!0,this.eventBus_.emit(i.RequestQueueEmpty,[]),this.requestQueue_.length>0&&this.openDb_(!1)}t.onSuccess(e.result)}this.isCodeExecuting_=!1,this.executeQry_()}},e.prototype.openDb_=function(e){void 0===e&&(e=!0);var t={name:o.OpenDb,query:{name:this.database.name,version:this.database.version},onSuccess:function(){},onError:function(e){console.error(e)}};e?this.prcoessExecutionOfQry_(t,0):this.requestQueue_.splice(0,0,t)},e.prototype.executeMiddleware_=function(e){var t=this;return d((function(n){var r=0,o=t.middlewares.length-1,i=function(){if(r<=o){var s=t.middlewares[r++](e);s&&s.then||(s=f(s)),s.then((function(e){i()}))}else n()};i()}))},e.prototype.callResultMiddleware=function(e,t){return d((function(n){var r=0,o=e.length-1,i=function(){if(r<=o){var s=e[r++](t);s.then||(s=f(s)),s.then((function(e){t=e,i()}))}else n(t)};i()}))},e.prototype.pushApi=function(e){var t=this;return new Promise((function(n,r){var s=[];e.onResult=function(e){s.push((function(t){return e(t)}))},t.executeMiddleware_(e).then((function(){e.onSuccess=function(r){t.callResultMiddleware(s,r).then((function(e){n(e)})).catch((function(t){e.onError(t)}))},e.onError=function(e){s=[],r(e)},0===t.requestQueue_.length&&(t.eventBus_.emit(i.RequestQueueFilled,[]),t.isDbIdle_&&t.isConOpened_&&([o.InitDb,o.CloseDb,o.DropDb,o.OpenDb,o.Terminate].indexOf(e.name)>=0||t.openDb_()),clearTimeout(t.inactivityTimer_)),t.prcoessExecutionOfQry_(e)})).catch(r)}))},e.prototype.prcoessExecutionOfQry_=function(e,t){this.isDbIdle_=!1,null!=t?this.requestQueue_.splice(t,0,e):this.requestQueue_.push(e),this.logger.log("request pushed: "+e.name),this.executeQry_()},e.prototype.executeQry_=function(){var e=this,t=this.requestQueue_.length;if(!this.isCodeExecuting_&&t>0){if(!0===this.isConOpened_)return void this.sendRequestToWorker_(this.requestQueue_[0]);var n=this.requestQueue_.findIndex((function(t){return e.whiteListApi_.indexOf(t.name)>=0}));n>=0&&(this.requestQueue_.splice(0,0,this.requestQueue_.splice(n,1)[0]),this.sendRequestToWorker_(this.requestQueue_[0]))}else 0===t&&!1===this.isDbIdle_&&this.isConOpened_&&(this.inactivityTimer_=setTimeout((function(){e.prcoessExecutionOfQry_({name:o.CloseDb,onSuccess:function(){},onError:function(e){console.error(e)}})}),100))},e.prototype.sendRequestToWorker_=function(e){this.isCodeExecuting_=!0,this.logger.log("request executing: "+e.name);var t={name:e.name,query:e.query};!0===this.isWorker?this.worker_.postMessage(t):this.queryManager.run(t)},e}(),m=function(){function e(e){this.con=e}return e.prototype.get=function(e){return this.con.pushApi({name:o.MapGet,query:e})},e.prototype.has=function(e){return this.con.pushApi({name:o.MapHas,query:e})},e.prototype.set=function(e,t){return this.con.pushApi({name:o.MapSet,query:{key:e,value:t}})},e.prototype.delete=function(e){return this.con.pushApi({name:o.MapDelete,query:e})},e}(),g=(h=function(e,t){return h=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},h(e,t)},function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}h(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}),b=function(e){function t(t){var n=e.call(this,t)||this;return n.Map=new m(n),n}return g(t,e),t.prototype.initDb=function(e){var t=this;return this.database=e,this.pushApi({name:o.InitDb,query:e}).then((function(e){var n,r=e.database;return e.isCreated&&(n=e.oldVersion?t.eventBus_.emit(i.Upgrade,r,e.oldVersion,e.newVersion):t.eventBus_.emit(i.Create,r)),(n||f()).then((function(e){return t.eventBus_.emit(i.Open,r)})).then((function(t){return e.isCreated}))}))},t.prototype.dropDb=function(){return this.pushApi({name:o.DropDb})},t.prototype.select=function(e){return this.pushApi({name:o.Select,query:e})},t.prototype.count=function(e){return this.pushApi({name:o.Count,query:e})},t.prototype.insert=function(e){return this.pushApi({name:o.Insert,query:e})},t.prototype.update=function(e){return this.pushApi({name:o.Update,query:e})},t.prototype.remove=function(e){return this.pushApi({name:o.Remove,query:e})},t.prototype.clear=function(e){return this.pushApi({name:o.Clear,query:e})},Object.defineProperty(t.prototype,"logStatus",{set:function(e){this.logger.status=e,this.pushApi({name:o.ChangeLogStatus,query:e})},enumerable:!1,configurable:!0}),t.prototype.openDb=function(e,t){var n=this;return this.pushApi({name:o.OpenDb,query:{version:t,name:e}}).then((function(e){return n.database=e,e}))},t.prototype.getDbList=function(){return console.warn("Api getDbList is recommended to use for debugging only. Do not use in code."),indexedDB.databases()},t.prototype.get=function(e){return console.warn("This API is obsolete, please use Map"),this.Map.get(e)},t.prototype.set=function(e,t){return console.warn("This API is obsolete, please use Map"),this.Map.set(e,t)},t.prototype.terminate=function(){return this.pushApi({name:o.Terminate})},t.prototype.transaction=function(e){return this.pushApi({name:o.Transaction,query:e})},t.prototype.on=function(e,t){this.eventBus_.on(e,t)},t.prototype.off=function(e,t){this.eventBus_.off(e,t)},t.prototype.union=function(e){return this.pushApi({name:o.Union,query:e})},t.prototype.intersect=function(e){return this.pushApi({name:o.Intersect,query:e})},t.prototype.addPlugin=function(e,t){return e.setup(this,t)},t.prototype.addMiddleware=function(e,t){return t?this.pushApi({name:o.Middleware,query:e}):(this.middlewares.push(e),Promise.resolve())},t.prototype.importScripts=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return this.pushApi({name:o.ImportScripts,query:e})},t}(y),v=function(e){return Promise.all(e)},q=function(e,t){for(var n in e)t(n,e[n])};module.exports=t})();

},{}],91:[function(require,module,exports){
(function (process){(function (){
"production"===process.env.NODE_ENV?module.exports=require("./jsstore.commonjs2.min.js"):module.exports=require("./jsstore.commonjs2.js");
}).call(this)}).call(this,require('_process'))
},{"./jsstore.commonjs2.js":89,"./jsstore.commonjs2.min.js":90,"_process":97}],92:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],93:[function(require,module,exports){
(function (global){(function (){
!function(e){var t;"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):("undefined"!=typeof window?t=window:"undefined"!=typeof global?t=global:"undefined"!=typeof self&&(t=self),t.objectHash=e())}(function(){return function r(o,i,u){function s(n,e){if(!i[n]){if(!o[n]){var t="function"==typeof require&&require;if(!e&&t)return t(n,!0);if(a)return a(n,!0);throw new Error("Cannot find module '"+n+"'")}e=i[n]={exports:{}};o[n][0].call(e.exports,function(e){var t=o[n][1][e];return s(t||e)},e,e.exports,r,o,i,u)}return i[n].exports}for(var a="function"==typeof require&&require,e=0;e<u.length;e++)s(u[e]);return s}({1:[function(w,b,m){!function(e,n,s,c,d,h,p,g,y){"use strict";var r=w("crypto");function t(e,t){t=u(e,t);var n;return void 0===(n="passthrough"!==t.algorithm?r.createHash(t.algorithm):new l).write&&(n.write=n.update,n.end=n.update),f(t,n).dispatch(e),n.update||n.end(""),n.digest?n.digest("buffer"===t.encoding?void 0:t.encoding):(e=n.read(),"buffer"!==t.encoding?e.toString(t.encoding):e)}(m=b.exports=t).sha1=function(e){return t(e)},m.keys=function(e){return t(e,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},m.MD5=function(e){return t(e,{algorithm:"md5",encoding:"hex"})},m.keysMD5=function(e){return t(e,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var o=r.getHashes?r.getHashes().slice():["sha1","md5"],i=(o.push("passthrough"),["buffer","hex","binary","base64"]);function u(e,t){var n={};if(n.algorithm=(t=t||{}).algorithm||"sha1",n.encoding=t.encoding||"hex",n.excludeValues=!!t.excludeValues,n.algorithm=n.algorithm.toLowerCase(),n.encoding=n.encoding.toLowerCase(),n.ignoreUnknown=!0===t.ignoreUnknown,n.respectType=!1!==t.respectType,n.respectFunctionNames=!1!==t.respectFunctionNames,n.respectFunctionProperties=!1!==t.respectFunctionProperties,n.unorderedArrays=!0===t.unorderedArrays,n.unorderedSets=!1!==t.unorderedSets,n.unorderedObjects=!1!==t.unorderedObjects,n.replacer=t.replacer||void 0,n.excludeKeys=t.excludeKeys||void 0,void 0===e)throw new Error("Object argument required.");for(var r=0;r<o.length;++r)o[r].toLowerCase()===n.algorithm.toLowerCase()&&(n.algorithm=o[r]);if(-1===o.indexOf(n.algorithm))throw new Error('Algorithm "'+n.algorithm+'"  not supported. supported values: '+o.join(", "));if(-1===i.indexOf(n.encoding)&&"passthrough"!==n.algorithm)throw new Error('Encoding "'+n.encoding+'"  not supported. supported values: '+i.join(", "));return n}function a(e){if("function"==typeof e)return null!=/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e))}function f(o,t,i){i=i||[];function u(e){return t.update?t.update(e,"utf8"):t.write(e,"utf8")}return{dispatch:function(e){return this["_"+(null===(e=o.replacer?o.replacer(e):e)?"null":typeof e)](e)},_object:function(t){var n,e=Object.prototype.toString.call(t),r=/\[object (.*)\]/i.exec(e);r=(r=r?r[1]:"unknown:["+e+"]").toLowerCase();if(0<=(e=i.indexOf(t)))return this.dispatch("[CIRCULAR:"+e+"]");if(i.push(t),void 0!==s&&s.isBuffer&&s.isBuffer(t))return u("buffer:"),u(t);if("object"===r||"function"===r||"asyncfunction"===r)return e=Object.keys(t),o.unorderedObjects&&(e=e.sort()),!1===o.respectType||a(t)||e.splice(0,0,"prototype","__proto__","constructor"),o.excludeKeys&&(e=e.filter(function(e){return!o.excludeKeys(e)})),u("object:"+e.length+":"),n=this,e.forEach(function(e){n.dispatch(e),u(":"),o.excludeValues||n.dispatch(t[e]),u(",")});if(!this["_"+r]){if(o.ignoreUnknown)return u("["+r+"]");throw new Error('Unknown object type "'+r+'"')}this["_"+r](t)},_array:function(e,t){t=void 0!==t?t:!1!==o.unorderedArrays;var n=this;if(u("array:"+e.length+":"),!t||e.length<=1)return e.forEach(function(e){return n.dispatch(e)});var r=[],t=e.map(function(e){var t=new l,n=i.slice();return f(o,t,n).dispatch(e),r=r.concat(n.slice(i.length)),t.read().toString()});return i=i.concat(r),t.sort(),this._array(t,!1)},_date:function(e){return u("date:"+e.toJSON())},_symbol:function(e){return u("symbol:"+e.toString())},_error:function(e){return u("error:"+e.toString())},_boolean:function(e){return u("bool:"+e.toString())},_string:function(e){u("string:"+e.length+":"),u(e.toString())},_function:function(e){u("fn:"),a(e)?this.dispatch("[native]"):this.dispatch(e.toString()),!1!==o.respectFunctionNames&&this.dispatch("function-name:"+String(e.name)),o.respectFunctionProperties&&this._object(e)},_number:function(e){return u("number:"+e.toString())},_xml:function(e){return u("xml:"+e.toString())},_null:function(){return u("Null")},_undefined:function(){return u("Undefined")},_regexp:function(e){return u("regex:"+e.toString())},_uint8array:function(e){return u("uint8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint8clampedarray:function(e){return u("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(e))},_int8array:function(e){return u("int8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint16array:function(e){return u("uint16array:"),this.dispatch(Array.prototype.slice.call(e))},_int16array:function(e){return u("int16array:"),this.dispatch(Array.prototype.slice.call(e))},_uint32array:function(e){return u("uint32array:"),this.dispatch(Array.prototype.slice.call(e))},_int32array:function(e){return u("int32array:"),this.dispatch(Array.prototype.slice.call(e))},_float32array:function(e){return u("float32array:"),this.dispatch(Array.prototype.slice.call(e))},_float64array:function(e){return u("float64array:"),this.dispatch(Array.prototype.slice.call(e))},_arraybuffer:function(e){return u("arraybuffer:"),this.dispatch(new Uint8Array(e))},_url:function(e){return u("url:"+e.toString())},_map:function(e){u("map:");e=Array.from(e);return this._array(e,!1!==o.unorderedSets)},_set:function(e){u("set:");e=Array.from(e);return this._array(e,!1!==o.unorderedSets)},_file:function(e){return u("file:"),this.dispatch([e.name,e.size,e.type,e.lastModfied])},_blob:function(){if(o.ignoreUnknown)return u("[blob]");throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')},_domwindow:function(){return u("domwindow")},_bigint:function(e){return u("bigint:"+e.toString())},_process:function(){return u("process")},_timer:function(){return u("timer")},_pipe:function(){return u("pipe")},_tcp:function(){return u("tcp")},_udp:function(){return u("udp")},_tty:function(){return u("tty")},_statwatcher:function(){return u("statwatcher")},_securecontext:function(){return u("securecontext")},_connection:function(){return u("connection")},_zlib:function(){return u("zlib")},_context:function(){return u("context")},_nodescript:function(){return u("nodescript")},_httpparser:function(){return u("httpparser")},_dataview:function(){return u("dataview")},_signal:function(){return u("signal")},_fsevent:function(){return u("fsevent")},_tlswrap:function(){return u("tlswrap")}}}function l(){return{buf:"",write:function(e){this.buf+=e},end:function(e){this.buf+=e},read:function(){return this.buf}}}m.writeToStream=function(e,t,n){return void 0===n&&(n=t,t={}),f(t=u(e,t),n).dispatch(e)}}.call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_9a5aa49d.js","/")},{buffer:3,crypto:5,lYpoI2:11}],2:[function(e,t,f){!function(e,t,n,r,o,i,u,s,a){!function(e){"use strict";var a="undefined"!=typeof Uint8Array?Uint8Array:Array,t="+".charCodeAt(0),n="/".charCodeAt(0),r="0".charCodeAt(0),o="a".charCodeAt(0),i="A".charCodeAt(0),u="-".charCodeAt(0),s="_".charCodeAt(0);function f(e){e=e.charCodeAt(0);return e===t||e===u?62:e===n||e===s?63:e<r?-1:e<r+10?e-r+26+26:e<i+26?e-i:e<o+26?e-o+26:void 0}e.toByteArray=function(e){var t,n;if(0<e.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.length,r="="===e.charAt(r-2)?2:"="===e.charAt(r-1)?1:0,o=new a(3*e.length/4-r),i=0<r?e.length-4:e.length,u=0;function s(e){o[u++]=e}for(t=0;t<i;t+=4,0)s((16711680&(n=f(e.charAt(t))<<18|f(e.charAt(t+1))<<12|f(e.charAt(t+2))<<6|f(e.charAt(t+3))))>>16),s((65280&n)>>8),s(255&n);return 2==r?s(255&(n=f(e.charAt(t))<<2|f(e.charAt(t+1))>>4)):1==r&&(s((n=f(e.charAt(t))<<10|f(e.charAt(t+1))<<4|f(e.charAt(t+2))>>2)>>8&255),s(255&n)),o},e.fromByteArray=function(e){var t,n,r,o,i=e.length%3,u="";function s(e){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e)}for(t=0,r=e.length-i;t<r;t+=3)n=(e[t]<<16)+(e[t+1]<<8)+e[t+2],u+=s((o=n)>>18&63)+s(o>>12&63)+s(o>>6&63)+s(63&o);switch(i){case 1:u=(u+=s((n=e[e.length-1])>>2))+s(n<<4&63)+"==";break;case 2:u=(u=(u+=s((n=(e[e.length-2]<<8)+e[e.length-1])>>10))+s(n>>4&63))+s(n<<2&63)+"="}return u}}(void 0===f?this.base64js={}:f)}.call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/base64-js/lib")},{buffer:3,lYpoI2:11}],3:[function(O,e,H){!function(e,n,f,r,h,p,g,y,w){var a=O("base64-js"),i=O("ieee754");function f(e,t,n){if(!(this instanceof f))return new f(e,t,n);var r,o,i,u,s=typeof e;if("base64"===t&&"string"==s)for(e=(u=e).trim?u.trim():u.replace(/^\s+|\s+$/g,"");e.length%4!=0;)e+="=";if("number"==s)r=j(e);else if("string"==s)r=f.byteLength(e,t);else{if("object"!=s)throw new Error("First argument needs to be a number, array or string.");r=j(e.length)}if(f._useTypedArrays?o=f._augment(new Uint8Array(r)):((o=this).length=r,o._isBuffer=!0),f._useTypedArrays&&"number"==typeof e.byteLength)o._set(e);else if(C(u=e)||f.isBuffer(u)||u&&"object"==typeof u&&"number"==typeof u.length)for(i=0;i<r;i++)f.isBuffer(e)?o[i]=e.readUInt8(i):o[i]=e[i];else if("string"==s)o.write(e,0,t);else if("number"==s&&!f._useTypedArrays&&!n)for(i=0;i<r;i++)o[i]=0;return o}function b(e,t,n,r){return f._charsWritten=c(function(e){for(var t=[],n=0;n<e.length;n++)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function m(e,t,n,r){return f._charsWritten=c(function(e){for(var t,n,r=[],o=0;o<e.length;o++)n=e.charCodeAt(o),t=n>>8,n=n%256,r.push(n),r.push(t);return r}(t),e,n,r)}function v(e,t,n){var r="";n=Math.min(e.length,n);for(var o=t;o<n;o++)r+=String.fromCharCode(e[o]);return r}function o(e,t,n,r){r||(d("boolean"==typeof n,"missing or invalid endian"),d(null!=t,"missing offset"),d(t+1<e.length,"Trying to read beyond buffer length"));var o,r=e.length;if(!(r<=t))return n?(o=e[t],t+1<r&&(o|=e[t+1]<<8)):(o=e[t]<<8,t+1<r&&(o|=e[t+1])),o}function u(e,t,n,r){r||(d("boolean"==typeof n,"missing or invalid endian"),d(null!=t,"missing offset"),d(t+3<e.length,"Trying to read beyond buffer length"));var o,r=e.length;if(!(r<=t))return n?(t+2<r&&(o=e[t+2]<<16),t+1<r&&(o|=e[t+1]<<8),o|=e[t],t+3<r&&(o+=e[t+3]<<24>>>0)):(t+1<r&&(o=e[t+1]<<16),t+2<r&&(o|=e[t+2]<<8),t+3<r&&(o|=e[t+3]),o+=e[t]<<24>>>0),o}function _(e,t,n,r){if(r||(d("boolean"==typeof n,"missing or invalid endian"),d(null!=t,"missing offset"),d(t+1<e.length,"Trying to read beyond buffer length")),!(e.length<=t))return r=o(e,t,n,!0),32768&r?-1*(65535-r+1):r}function E(e,t,n,r){if(r||(d("boolean"==typeof n,"missing or invalid endian"),d(null!=t,"missing offset"),d(t+3<e.length,"Trying to read beyond buffer length")),!(e.length<=t))return r=u(e,t,n,!0),2147483648&r?-1*(4294967295-r+1):r}function I(e,t,n,r){return r||(d("boolean"==typeof n,"missing or invalid endian"),d(t+3<e.length,"Trying to read beyond buffer length")),i.read(e,t,n,23,4)}function A(e,t,n,r){return r||(d("boolean"==typeof n,"missing or invalid endian"),d(t+7<e.length,"Trying to read beyond buffer length")),i.read(e,t,n,52,8)}function s(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+1<e.length,"trying to write beyond buffer length"),Y(t,65535));o=e.length;if(!(o<=n))for(var i=0,u=Math.min(o-n,2);i<u;i++)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function l(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+3<e.length,"trying to write beyond buffer length"),Y(t,4294967295));o=e.length;if(!(o<=n))for(var i=0,u=Math.min(o-n,4);i<u;i++)e[n+i]=t>>>8*(r?i:3-i)&255}function B(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+1<e.length,"Trying to write beyond buffer length"),F(t,32767,-32768)),e.length<=n||s(e,0<=t?t:65535+t+1,n,r,o)}function L(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+3<e.length,"Trying to write beyond buffer length"),F(t,2147483647,-2147483648)),e.length<=n||l(e,0<=t?t:4294967295+t+1,n,r,o)}function U(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+3<e.length,"Trying to write beyond buffer length"),D(t,34028234663852886e22,-34028234663852886e22)),e.length<=n||i.write(e,t,n,r,23,4)}function x(e,t,n,r,o){o||(d(null!=t,"missing value"),d("boolean"==typeof r,"missing or invalid endian"),d(null!=n,"missing offset"),d(n+7<e.length,"Trying to write beyond buffer length"),D(t,17976931348623157e292,-17976931348623157e292)),e.length<=n||i.write(e,t,n,r,52,8)}H.Buffer=f,H.SlowBuffer=f,H.INSPECT_MAX_BYTES=50,f.poolSize=8192,f._useTypedArrays=function(){try{var e=new ArrayBuffer(0),t=new Uint8Array(e);return t.foo=function(){return 42},42===t.foo()&&"function"==typeof t.subarray}catch(e){return!1}}(),f.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},f.isBuffer=function(e){return!(null==e||!e._isBuffer)},f.byteLength=function(e,t){var n;switch(e+="",t||"utf8"){case"hex":n=e.length/2;break;case"utf8":case"utf-8":n=T(e).length;break;case"ascii":case"binary":case"raw":n=e.length;break;case"base64":n=M(e).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":n=2*e.length;break;default:throw new Error("Unknown encoding")}return n},f.concat=function(e,t){if(d(C(e),"Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."),0===e.length)return new f(0);if(1===e.length)return e[0];if("number"!=typeof t)for(o=t=0;o<e.length;o++)t+=e[o].length;for(var n=new f(t),r=0,o=0;o<e.length;o++){var i=e[o];i.copy(n,r),r+=i.length}return n},f.prototype.write=function(e,t,n,r){isFinite(t)?isFinite(n)||(r=n,n=void 0):(a=r,r=t,t=n,n=a),t=Number(t)||0;var o,i,u,s,a=this.length-t;switch((!n||a<(n=Number(n)))&&(n=a),r=String(r||"utf8").toLowerCase()){case"hex":o=function(e,t,n,r){n=Number(n)||0;var o=e.length-n;(!r||o<(r=Number(r)))&&(r=o),d((o=t.length)%2==0,"Invalid hex string"),o/2<r&&(r=o/2);for(var i=0;i<r;i++){var u=parseInt(t.substr(2*i,2),16);d(!isNaN(u),"Invalid hex string"),e[n+i]=u}return f._charsWritten=2*i,i}(this,e,t,n);break;case"utf8":case"utf-8":i=this,u=t,s=n,o=f._charsWritten=c(T(e),i,u,s);break;case"ascii":case"binary":o=b(this,e,t,n);break;case"base64":i=this,u=t,s=n,o=f._charsWritten=c(M(e),i,u,s);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":o=m(this,e,t,n);break;default:throw new Error("Unknown encoding")}return o},f.prototype.toString=function(e,t,n){var r,o,i,u,s=this;if(e=String(e||"utf8").toLowerCase(),t=Number(t)||0,(n=void 0!==n?Number(n):s.length)===t)return"";switch(e){case"hex":r=function(e,t,n){var r=e.length;(!t||t<0)&&(t=0);(!n||n<0||r<n)&&(n=r);for(var o="",i=t;i<n;i++)o+=k(e[i]);return o}(s,t,n);break;case"utf8":case"utf-8":r=function(e,t,n){var r="",o="";n=Math.min(e.length,n);for(var i=t;i<n;i++)e[i]<=127?(r+=N(o)+String.fromCharCode(e[i]),o=""):o+="%"+e[i].toString(16);return r+N(o)}(s,t,n);break;case"ascii":case"binary":r=v(s,t,n);break;case"base64":o=s,u=n,r=0===(i=t)&&u===o.length?a.fromByteArray(o):a.fromByteArray(o.slice(i,u));break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":r=function(e,t,n){for(var r=e.slice(t,n),o="",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}(s,t,n);break;default:throw new Error("Unknown encoding")}return r},f.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},f.prototype.copy=function(e,t,n,r){if(t=t||0,(r=r||0===r?r:this.length)!==(n=n||0)&&0!==e.length&&0!==this.length){d(n<=r,"sourceEnd < sourceStart"),d(0<=t&&t<e.length,"targetStart out of bounds"),d(0<=n&&n<this.length,"sourceStart out of bounds"),d(0<=r&&r<=this.length,"sourceEnd out of bounds"),r>this.length&&(r=this.length);var o=(r=e.length-t<r-n?e.length-t+n:r)-n;if(o<100||!f._useTypedArrays)for(var i=0;i<o;i++)e[i+t]=this[i+n];else e._set(this.subarray(n,n+o),t)}},f.prototype.slice=function(e,t){var n=this.length;if(e=S(e,n,0),t=S(t,n,n),f._useTypedArrays)return f._augment(this.subarray(e,t));for(var r=t-e,o=new f(r,void 0,!0),i=0;i<r;i++)o[i]=this[i+e];return o},f.prototype.get=function(e){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(e)},f.prototype.set=function(e,t){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(e,t)},f.prototype.readUInt8=function(e,t){if(t||(d(null!=e,"missing offset"),d(e<this.length,"Trying to read beyond buffer length")),!(e>=this.length))return this[e]},f.prototype.readUInt16LE=function(e,t){return o(this,e,!0,t)},f.prototype.readUInt16BE=function(e,t){return o(this,e,!1,t)},f.prototype.readUInt32LE=function(e,t){return u(this,e,!0,t)},f.prototype.readUInt32BE=function(e,t){return u(this,e,!1,t)},f.prototype.readInt8=function(e,t){if(t||(d(null!=e,"missing offset"),d(e<this.length,"Trying to read beyond buffer length")),!(e>=this.length))return 128&this[e]?-1*(255-this[e]+1):this[e]},f.prototype.readInt16LE=function(e,t){return _(this,e,!0,t)},f.prototype.readInt16BE=function(e,t){return _(this,e,!1,t)},f.prototype.readInt32LE=function(e,t){return E(this,e,!0,t)},f.prototype.readInt32BE=function(e,t){return E(this,e,!1,t)},f.prototype.readFloatLE=function(e,t){return I(this,e,!0,t)},f.prototype.readFloatBE=function(e,t){return I(this,e,!1,t)},f.prototype.readDoubleLE=function(e,t){return A(this,e,!0,t)},f.prototype.readDoubleBE=function(e,t){return A(this,e,!1,t)},f.prototype.writeUInt8=function(e,t,n){n||(d(null!=e,"missing value"),d(null!=t,"missing offset"),d(t<this.length,"trying to write beyond buffer length"),Y(e,255)),t>=this.length||(this[t]=e)},f.prototype.writeUInt16LE=function(e,t,n){s(this,e,t,!0,n)},f.prototype.writeUInt16BE=function(e,t,n){s(this,e,t,!1,n)},f.prototype.writeUInt32LE=function(e,t,n){l(this,e,t,!0,n)},f.prototype.writeUInt32BE=function(e,t,n){l(this,e,t,!1,n)},f.prototype.writeInt8=function(e,t,n){n||(d(null!=e,"missing value"),d(null!=t,"missing offset"),d(t<this.length,"Trying to write beyond buffer length"),F(e,127,-128)),t>=this.length||(0<=e?this.writeUInt8(e,t,n):this.writeUInt8(255+e+1,t,n))},f.prototype.writeInt16LE=function(e,t,n){B(this,e,t,!0,n)},f.prototype.writeInt16BE=function(e,t,n){B(this,e,t,!1,n)},f.prototype.writeInt32LE=function(e,t,n){L(this,e,t,!0,n)},f.prototype.writeInt32BE=function(e,t,n){L(this,e,t,!1,n)},f.prototype.writeFloatLE=function(e,t,n){U(this,e,t,!0,n)},f.prototype.writeFloatBE=function(e,t,n){U(this,e,t,!1,n)},f.prototype.writeDoubleLE=function(e,t,n){x(this,e,t,!0,n)},f.prototype.writeDoubleBE=function(e,t,n){x(this,e,t,!1,n)},f.prototype.fill=function(e,t,n){if(t=t||0,n=n||this.length,d("number"==typeof(e="string"==typeof(e=e||0)?e.charCodeAt(0):e)&&!isNaN(e),"value is not a number"),d(t<=n,"end < start"),n!==t&&0!==this.length){d(0<=t&&t<this.length,"start out of bounds"),d(0<=n&&n<=this.length,"end out of bounds");for(var r=t;r<n;r++)this[r]=e}},f.prototype.inspect=function(){for(var e=[],t=this.length,n=0;n<t;n++)if(e[n]=k(this[n]),n===H.INSPECT_MAX_BYTES){e[n+1]="...";break}return"<Buffer "+e.join(" ")+">"},f.prototype.toArrayBuffer=function(){if("undefined"==typeof Uint8Array)throw new Error("Buffer.toArrayBuffer not supported in this browser");if(f._useTypedArrays)return new f(this).buffer;for(var e=new Uint8Array(this.length),t=0,n=e.length;t<n;t+=1)e[t]=this[t];return e.buffer};var t=f.prototype;function S(e,t,n){return"number"!=typeof e?n:t<=(e=~~e)?t:0<=e||0<=(e+=t)?e:0}function j(e){return(e=~~Math.ceil(+e))<0?0:e}function C(e){return(Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)})(e)}function k(e){return e<16?"0"+e.toString(16):e.toString(16)}function T(e){for(var t=[],n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<=127)t.push(e.charCodeAt(n));else for(var o=n,i=(55296<=r&&r<=57343&&n++,encodeURIComponent(e.slice(o,n+1)).substr(1).split("%")),u=0;u<i.length;u++)t.push(parseInt(i[u],16))}return t}function M(e){return a.toByteArray(e)}function c(e,t,n,r){for(var o=0;o<r&&!(o+n>=t.length||o>=e.length);o++)t[o+n]=e[o];return o}function N(e){try{return decodeURIComponent(e)}catch(e){return String.fromCharCode(65533)}}function Y(e,t){d("number"==typeof e,"cannot write a non-number as a number"),d(0<=e,"specified a negative value for writing an unsigned value"),d(e<=t,"value is larger than maximum value for type"),d(Math.floor(e)===e,"value has a fractional component")}function F(e,t,n){d("number"==typeof e,"cannot write a non-number as a number"),d(e<=t,"value larger than maximum allowed value"),d(n<=e,"value smaller than minimum allowed value"),d(Math.floor(e)===e,"value has a fractional component")}function D(e,t,n){d("number"==typeof e,"cannot write a non-number as a number"),d(e<=t,"value larger than maximum allowed value"),d(n<=e,"value smaller than minimum allowed value")}function d(e,t){if(!e)throw new Error(t||"Failed assertion")}f._augment=function(e){return e._isBuffer=!0,e._get=e.get,e._set=e.set,e.get=t.get,e.set=t.set,e.write=t.write,e.toString=t.toString,e.toLocaleString=t.toString,e.toJSON=t.toJSON,e.copy=t.copy,e.slice=t.slice,e.readUInt8=t.readUInt8,e.readUInt16LE=t.readUInt16LE,e.readUInt16BE=t.readUInt16BE,e.readUInt32LE=t.readUInt32LE,e.readUInt32BE=t.readUInt32BE,e.readInt8=t.readInt8,e.readInt16LE=t.readInt16LE,e.readInt16BE=t.readInt16BE,e.readInt32LE=t.readInt32LE,e.readInt32BE=t.readInt32BE,e.readFloatLE=t.readFloatLE,e.readFloatBE=t.readFloatBE,e.readDoubleLE=t.readDoubleLE,e.readDoubleBE=t.readDoubleBE,e.writeUInt8=t.writeUInt8,e.writeUInt16LE=t.writeUInt16LE,e.writeUInt16BE=t.writeUInt16BE,e.writeUInt32LE=t.writeUInt32LE,e.writeUInt32BE=t.writeUInt32BE,e.writeInt8=t.writeInt8,e.writeInt16LE=t.writeInt16LE,e.writeInt16BE=t.writeInt16BE,e.writeInt32LE=t.writeInt32LE,e.writeInt32BE=t.writeInt32BE,e.writeFloatLE=t.writeFloatLE,e.writeFloatBE=t.writeFloatBE,e.writeDoubleLE=t.writeDoubleLE,e.writeDoubleBE=t.writeDoubleBE,e.fill=t.fill,e.inspect=t.inspect,e.toArrayBuffer=t.toArrayBuffer,e}}.call(this,O("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},O("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/buffer")},{"base64-js":2,buffer:3,ieee754:10,lYpoI2:11}],4:[function(c,d,e){!function(e,t,a,n,r,o,i,u,s){var a=c("buffer").Buffer,f=4,l=new a(f);l.fill(0);d.exports={hash:function(e,t,n,r){for(var o=t(function(e,t){e.length%f!=0&&(n=e.length+(f-e.length%f),e=a.concat([e,l],n));for(var n,r=[],o=t?e.readInt32BE:e.readInt32LE,i=0;i<e.length;i+=f)r.push(o.call(e,i));return r}(e=a.isBuffer(e)?e:new a(e),r),8*e.length),t=r,i=new a(n),u=t?i.writeInt32BE:i.writeInt32LE,s=0;s<o.length;s++)u.call(i,o[s],4*s,!0);return i}}}.call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],5:[function(v,e,_){!function(l,c,u,d,h,p,g,y,w){var u=v("buffer").Buffer,e=v("./sha"),t=v("./sha256"),n=v("./rng"),b={sha1:e,sha256:t,md5:v("./md5")},s=64,a=new u(s);function r(e,n){var r=b[e=e||"sha1"],o=[];return r||i("algorithm:",e,"is not yet supported"),{update:function(e){return u.isBuffer(e)||(e=new u(e)),o.push(e),e.length,this},digest:function(e){var t=u.concat(o),t=n?function(e,t,n){u.isBuffer(t)||(t=new u(t)),u.isBuffer(n)||(n=new u(n)),t.length>s?t=e(t):t.length<s&&(t=u.concat([t,a],s));for(var r=new u(s),o=new u(s),i=0;i<s;i++)r[i]=54^t[i],o[i]=92^t[i];return n=e(u.concat([r,n])),e(u.concat([o,n]))}(r,n,t):r(t);return o=null,e?t.toString(e):t}}}function i(){var e=[].slice.call(arguments).join(" ");throw new Error([e,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join("\n"))}a.fill(0),_.createHash=function(e){return r(e)},_.createHmac=r,_.randomBytes=function(e,t){if(!t||!t.call)return new u(n(e));try{t.call(this,void 0,new u(n(e)))}catch(e){t(e)}};var o,f=["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],m=function(e){_[e]=function(){i("sorry,",e,"is not implemented yet")}};for(o in f)m(f[o],o)}.call(this,v("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},v("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,buffer:3,lYpoI2:11}],6:[function(w,b,e){!function(e,r,o,i,u,a,f,l,y){var t=w("./helpers");function n(e,t){e[t>>5]|=128<<t%32,e[14+(t+64>>>9<<4)]=t;for(var n=1732584193,r=-271733879,o=-1732584194,i=271733878,u=0;u<e.length;u+=16){var s=n,a=r,f=o,l=i,n=c(n,r,o,i,e[u+0],7,-680876936),i=c(i,n,r,o,e[u+1],12,-389564586),o=c(o,i,n,r,e[u+2],17,606105819),r=c(r,o,i,n,e[u+3],22,-1044525330);n=c(n,r,o,i,e[u+4],7,-176418897),i=c(i,n,r,o,e[u+5],12,1200080426),o=c(o,i,n,r,e[u+6],17,-1473231341),r=c(r,o,i,n,e[u+7],22,-45705983),n=c(n,r,o,i,e[u+8],7,1770035416),i=c(i,n,r,o,e[u+9],12,-1958414417),o=c(o,i,n,r,e[u+10],17,-42063),r=c(r,o,i,n,e[u+11],22,-1990404162),n=c(n,r,o,i,e[u+12],7,1804603682),i=c(i,n,r,o,e[u+13],12,-40341101),o=c(o,i,n,r,e[u+14],17,-1502002290),n=d(n,r=c(r,o,i,n,e[u+15],22,1236535329),o,i,e[u+1],5,-165796510),i=d(i,n,r,o,e[u+6],9,-1069501632),o=d(o,i,n,r,e[u+11],14,643717713),r=d(r,o,i,n,e[u+0],20,-373897302),n=d(n,r,o,i,e[u+5],5,-701558691),i=d(i,n,r,o,e[u+10],9,38016083),o=d(o,i,n,r,e[u+15],14,-660478335),r=d(r,o,i,n,e[u+4],20,-405537848),n=d(n,r,o,i,e[u+9],5,568446438),i=d(i,n,r,o,e[u+14],9,-1019803690),o=d(o,i,n,r,e[u+3],14,-187363961),r=d(r,o,i,n,e[u+8],20,1163531501),n=d(n,r,o,i,e[u+13],5,-1444681467),i=d(i,n,r,o,e[u+2],9,-51403784),o=d(o,i,n,r,e[u+7],14,1735328473),n=h(n,r=d(r,o,i,n,e[u+12],20,-1926607734),o,i,e[u+5],4,-378558),i=h(i,n,r,o,e[u+8],11,-2022574463),o=h(o,i,n,r,e[u+11],16,1839030562),r=h(r,o,i,n,e[u+14],23,-35309556),n=h(n,r,o,i,e[u+1],4,-1530992060),i=h(i,n,r,o,e[u+4],11,1272893353),o=h(o,i,n,r,e[u+7],16,-155497632),r=h(r,o,i,n,e[u+10],23,-1094730640),n=h(n,r,o,i,e[u+13],4,681279174),i=h(i,n,r,o,e[u+0],11,-358537222),o=h(o,i,n,r,e[u+3],16,-722521979),r=h(r,o,i,n,e[u+6],23,76029189),n=h(n,r,o,i,e[u+9],4,-640364487),i=h(i,n,r,o,e[u+12],11,-421815835),o=h(o,i,n,r,e[u+15],16,530742520),n=p(n,r=h(r,o,i,n,e[u+2],23,-995338651),o,i,e[u+0],6,-198630844),i=p(i,n,r,o,e[u+7],10,1126891415),o=p(o,i,n,r,e[u+14],15,-1416354905),r=p(r,o,i,n,e[u+5],21,-57434055),n=p(n,r,o,i,e[u+12],6,1700485571),i=p(i,n,r,o,e[u+3],10,-1894986606),o=p(o,i,n,r,e[u+10],15,-1051523),r=p(r,o,i,n,e[u+1],21,-2054922799),n=p(n,r,o,i,e[u+8],6,1873313359),i=p(i,n,r,o,e[u+15],10,-30611744),o=p(o,i,n,r,e[u+6],15,-1560198380),r=p(r,o,i,n,e[u+13],21,1309151649),n=p(n,r,o,i,e[u+4],6,-145523070),i=p(i,n,r,o,e[u+11],10,-1120210379),o=p(o,i,n,r,e[u+2],15,718787259),r=p(r,o,i,n,e[u+9],21,-343485551),n=g(n,s),r=g(r,a),o=g(o,f),i=g(i,l)}return Array(n,r,o,i)}function s(e,t,n,r,o,i){return g((t=g(g(t,e),g(r,i)))<<o|t>>>32-o,n)}function c(e,t,n,r,o,i,u){return s(t&n|~t&r,e,t,o,i,u)}function d(e,t,n,r,o,i,u){return s(t&r|n&~r,e,t,o,i,u)}function h(e,t,n,r,o,i,u){return s(t^n^r,e,t,o,i,u)}function p(e,t,n,r,o,i,u){return s(n^(t|~r),e,t,o,i,u)}function g(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}b.exports=function(e){return t.hash(e,n,16)}}.call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],7:[function(e,l,t){!function(e,t,n,r,o,i,u,s,f){var a;l.exports=a||function(e){for(var t,n=new Array(e),r=0;r<e;r++)0==(3&r)&&(t=4294967296*Math.random()),n[r]=t>>>((3&r)<<3)&255;return n}}.call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],8:[function(c,d,e){!function(e,t,n,r,o,s,a,f,l){var i=c("./helpers");function u(l,c){l[c>>5]|=128<<24-c%32,l[15+(c+64>>9<<4)]=c;for(var e,t,n,r=Array(80),o=1732584193,i=-271733879,u=-1732584194,s=271733878,d=-1009589776,h=0;h<l.length;h+=16){for(var p=o,g=i,y=u,w=s,b=d,a=0;a<80;a++){r[a]=a<16?l[h+a]:v(r[a-3]^r[a-8]^r[a-14]^r[a-16],1);var f=m(m(v(o,5),(f=i,t=u,n=s,(e=a)<20?f&t|~f&n:!(e<40)&&e<60?f&t|f&n|t&n:f^t^n)),m(m(d,r[a]),(e=a)<20?1518500249:e<40?1859775393:e<60?-1894007588:-899497514)),d=s,s=u,u=v(i,30),i=o,o=f}o=m(o,p),i=m(i,g),u=m(u,y),s=m(s,w),d=m(d,b)}return Array(o,i,u,s,d)}function m(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function v(e,t){return e<<t|e>>>32-t}d.exports=function(e){return i.hash(e,u,20,!0)}}.call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],9:[function(c,d,e){!function(e,t,n,r,u,s,a,f,l){function b(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function o(e,l){var c,d=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),t=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),n=new Array(64);e[l>>5]|=128<<24-l%32,e[15+(l+64>>9<<4)]=l;for(var r,o,h=0;h<e.length;h+=16){for(var i=t[0],u=t[1],s=t[2],p=t[3],a=t[4],g=t[5],y=t[6],w=t[7],f=0;f<64;f++)n[f]=f<16?e[f+h]:b(b(b((o=n[f-2],m(o,17)^m(o,19)^v(o,10)),n[f-7]),(o=n[f-15],m(o,7)^m(o,18)^v(o,3))),n[f-16]),c=b(b(b(b(w,m(o=a,6)^m(o,11)^m(o,25)),a&g^~a&y),d[f]),n[f]),r=b(m(r=i,2)^m(r,13)^m(r,22),i&u^i&s^u&s),w=y,y=g,g=a,a=b(p,c),p=s,s=u,u=i,i=b(c,r);t[0]=b(i,t[0]),t[1]=b(u,t[1]),t[2]=b(s,t[2]),t[3]=b(p,t[3]),t[4]=b(a,t[4]),t[5]=b(g,t[5]),t[6]=b(y,t[6]),t[7]=b(w,t[7])}return t}var i=c("./helpers"),m=function(e,t){return e>>>t|e<<32-t},v=function(e,t){return e>>>t};d.exports=function(e){return i.hash(e,o,32,!0)}}.call(this,c("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},c("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],10:[function(e,t,f){!function(e,t,n,r,o,i,u,s,a){f.read=function(e,t,n,r,o){var i,u,l=8*o-r-1,c=(1<<l)-1,d=c>>1,s=-7,a=n?o-1:0,f=n?-1:1,o=e[t+a];for(a+=f,i=o&(1<<-s)-1,o>>=-s,s+=l;0<s;i=256*i+e[t+a],a+=f,s-=8);for(u=i&(1<<-s)-1,i>>=-s,s+=r;0<s;u=256*u+e[t+a],a+=f,s-=8);if(0===i)i=1-d;else{if(i===c)return u?NaN:1/0*(o?-1:1);u+=Math.pow(2,r),i-=d}return(o?-1:1)*u*Math.pow(2,i-r)},f.write=function(e,t,l,n,r,c){var o,i,u=8*c-r-1,s=(1<<u)-1,a=s>>1,d=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:c-1,h=n?1:-1,c=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(i=isNaN(t)?1:0,o=s):(o=Math.floor(Math.log(t)/Math.LN2),t*(n=Math.pow(2,-o))<1&&(o--,n*=2),2<=(t+=1<=o+a?d/n:d*Math.pow(2,1-a))*n&&(o++,n/=2),s<=o+a?(i=0,o=s):1<=o+a?(i=(t*n-1)*Math.pow(2,r),o+=a):(i=t*Math.pow(2,a-1)*Math.pow(2,r),o=0));8<=r;e[l+f]=255&i,f+=h,i/=256,r-=8);for(o=o<<r|i,u+=r;0<u;e[l+f]=255&o,f+=h,o/=256,u-=8);e[l+f-h]|=128*c}}.call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/ieee754/index.js","/node_modules/gulp-browserify/node_modules/ieee754")},{buffer:3,lYpoI2:11}],11:[function(e,h,t){!function(e,t,n,r,o,f,l,c,d){var i,u,s;function a(){}(e=h.exports={}).nextTick=(u="undefined"!=typeof window&&window.setImmediate,s="undefined"!=typeof window&&window.postMessage&&window.addEventListener,u?function(e){return window.setImmediate(e)}:s?(i=[],window.addEventListener("message",function(e){var t=e.source;t!==window&&null!==t||"process-tick"!==e.data||(e.stopPropagation(),0<i.length&&i.shift()())},!0),function(e){i.push(e),window.postMessage("process-tick","*")}):function(e){setTimeout(e,0)}),e.title="browser",e.browser=!0,e.env={},e.argv=[],e.on=a,e.addListener=a,e.once=a,e.off=a,e.removeListener=a,e.removeAllListeners=a,e.emit=a,e.binding=function(e){throw new Error("process.binding is not supported")},e.cwd=function(){return"/"},e.chdir=function(e){throw new Error("process.chdir is not supported")}}.call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/process")},{buffer:3,lYpoI2:11}]},{},[1])(1)});
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],94:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":97}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*!
  * PhotoSwipe 5.4.4 - https://photoswipe.com
  * (c) 2024 Dmytro Semenov
  */
/** @typedef {import('../photoswipe.js').Point} Point */

/**
 * @template {keyof HTMLElementTagNameMap} T
 * @param {string} className
 * @param {T} tagName
 * @param {Node} [appendToEl]
 * @returns {HTMLElementTagNameMap[T]}
 */
function createElement(className, tagName, appendToEl) {
  var el = document.createElement(tagName);
  if (className) {
    el.className = className;
  }
  if (appendToEl) {
    appendToEl.appendChild(el);
  }
  return el;
}
/**
 * @param {Point} p1
 * @param {Point} p2
 * @returns {Point}
 */

function equalizePoints(p1, p2) {
  p1.x = p2.x;
  p1.y = p2.y;
  if (p2.id !== undefined) {
    p1.id = p2.id;
  }
  return p1;
}
/**
 * @param {Point} p
 */

function roundPoint(p) {
  p.x = Math.round(p.x);
  p.y = Math.round(p.y);
}
/**
 * Returns distance between two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 * @returns {number}
 */

function getDistanceBetween(p1, p2) {
  var x = Math.abs(p1.x - p2.x);
  var y = Math.abs(p1.y - p2.y);
  return Math.sqrt(x * x + y * y);
}
/**
 * Whether X and Y positions of points are equal
 *
 * @param {Point} p1
 * @param {Point} p2
 * @returns {boolean}
 */

function pointsEqual(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
/**
 * The float result between the min and max values.
 *
 * @param {number} val
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */

function clamp(val, min, max) {
  return Math.min(Math.max(val, min), max);
}
/**
 * Get transform string
 *
 * @param {number} x
 * @param {number} [y]
 * @param {number} [scale]
 * @returns {string}
 */

function toTransformString(x, y, scale) {
  var propValue = "translate3d(".concat(x, "px,").concat(y || 0, "px,0)");
  if (scale !== undefined) {
    propValue += " scale3d(".concat(scale, ",").concat(scale, ",1)");
  }
  return propValue;
}
/**
 * Apply transform:translate(x, y) scale(scale) to element
 *
 * @param {HTMLElement} el
 * @param {number} x
 * @param {number} [y]
 * @param {number} [scale]
 */

function setTransform(el, x, y, scale) {
  el.style.transform = toTransformString(x, y, scale);
}
var defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';
/**
 * Apply CSS transition to element
 *
 * @param {HTMLElement} el
 * @param {string} [prop] CSS property to animate
 * @param {number} [duration] in ms
 * @param {string} [ease] CSS easing function
 */

function setTransitionStyle(el, prop, duration, ease) {
  // inOut: 'cubic-bezier(.4, 0, .22, 1)', // for "toggle state" transitions
  // out: 'cubic-bezier(0, 0, .22, 1)', // for "show" transitions
  // in: 'cubic-bezier(.4, 0, 1, 1)'// for "hide" transitions
  el.style.transition = prop ? "".concat(prop, " ").concat(duration, "ms ").concat(ease || defaultCSSEasing) : 'none';
}
/**
 * Apply width and height CSS properties to element
 *
 * @param {HTMLElement} el
 * @param {string | number} w
 * @param {string | number} h
 */

function setWidthHeight(el, w, h) {
  el.style.width = typeof w === 'number' ? "".concat(w, "px") : w;
  el.style.height = typeof h === 'number' ? "".concat(h, "px") : h;
}
/**
 * @param {HTMLElement} el
 */

function removeTransitionStyle(el) {
  setTransitionStyle(el);
}
/**
 * @param {HTMLImageElement} img
 * @returns {Promise<HTMLImageElement | void>}
 */

function decodeImage(img) {
  if ('decode' in img) {
    return img.decode()["catch"](function () {});
  }
  if (img.complete) {
    return Promise.resolve(img);
  }
  return new Promise(function (resolve, reject) {
    img.onload = function () {
      return resolve(img);
    };
    img.onerror = reject;
  });
}
/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */

/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */

var LOAD_STATE = {
  IDLE: 'idle',
  LOADING: 'loading',
  LOADED: 'loaded',
  ERROR: 'error'
};
/**
 * Check if click or keydown event was dispatched
 * with a special key or via mouse wheel.
 *
 * @param {MouseEvent | KeyboardEvent} e
 * @returns {boolean}
 */

function specialKeyUsed(e) {
  return 'button' in e && e.button === 1 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;
}
/**
 * Parse `gallery` or `children` options.
 *
 * @param {import('../photoswipe.js').ElementProvider} [option]
 * @param {string} [legacySelector]
 * @param {HTMLElement | Document} [parent]
 * @returns HTMLElement[]
 */

function getElementsFromOption(option, legacySelector) {
  var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
  /** @type {HTMLElement[]} */
  var elements = [];
  if (option instanceof Element) {
    elements = [option];
  } else if (option instanceof NodeList || Array.isArray(option)) {
    elements = Array.from(option);
  } else {
    var selector = typeof option === 'string' ? option : legacySelector;
    if (selector) {
      elements = Array.from(parent.querySelectorAll(selector));
    }
  }
  return elements;
}
/**
 * Check if browser is Safari
 *
 * @returns {boolean}
 */

function isSafari() {
  return !!(navigator.vendor && navigator.vendor.match(/apple/i));
}

// Detect passive event listener support
var supportsPassive = false;
/* eslint-disable */

try {
  /* @ts-ignore */
  window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
    get: function get() {
      supportsPassive = true;
    }
  }));
} catch (e) {}
/* eslint-enable */

/**
 * @typedef {Object} PoolItem
 * @prop {HTMLElement | Window | Document | undefined | null} target
 * @prop {string} type
 * @prop {EventListenerOrEventListenerObject} listener
 * @prop {boolean} [passive]
 */
var DOMEvents = /*#__PURE__*/function () {
  function DOMEvents() {
    _classCallCheck(this, DOMEvents);
    /**
     * @type {PoolItem[]}
     * @private
     */
    this._pool = [];
  }
  /**
   * Adds event listeners
   *
   * @param {PoolItem['target']} target
   * @param {PoolItem['type']} type Can be multiple, separated by space.
   * @param {PoolItem['listener']} listener
   * @param {PoolItem['passive']} [passive]
   */
  return _createClass(DOMEvents, [{
    key: "add",
    value: function add(target, type, listener, passive) {
      this._toggleListener(target, type, listener, passive);
    }
    /**
     * Removes event listeners
     *
     * @param {PoolItem['target']} target
     * @param {PoolItem['type']} type
     * @param {PoolItem['listener']} listener
     * @param {PoolItem['passive']} [passive]
     */
  }, {
    key: "remove",
    value: function remove(target, type, listener, passive) {
      this._toggleListener(target, type, listener, passive, true);
    }
    /**
     * Removes all bound events
     */
  }, {
    key: "removeAll",
    value: function removeAll() {
      var _this = this;
      this._pool.forEach(function (poolItem) {
        _this._toggleListener(poolItem.target, poolItem.type, poolItem.listener, poolItem.passive, true, true);
      });
      this._pool = [];
    }
    /**
     * Adds or removes event
     *
     * @private
     * @param {PoolItem['target']} target
     * @param {PoolItem['type']} type
     * @param {PoolItem['listener']} listener
     * @param {PoolItem['passive']} [passive]
     * @param {boolean} [unbind] Whether the event should be added or removed
     * @param {boolean} [skipPool] Whether events pool should be skipped
     */
  }, {
    key: "_toggleListener",
    value: function _toggleListener(target, type, listener, passive, unbind, skipPool) {
      var _this2 = this;
      if (!target) {
        return;
      }
      var methodName = unbind ? 'removeEventListener' : 'addEventListener';
      var types = type.split(' ');
      types.forEach(function (eType) {
        if (eType) {
          // Events pool is used to easily unbind all events when PhotoSwipe is closed,
          // so developer doesn't need to do this manually
          if (!skipPool) {
            if (unbind) {
              // Remove from the events pool
              _this2._pool = _this2._pool.filter(function (poolItem) {
                return poolItem.type !== eType || poolItem.listener !== listener || poolItem.target !== target;
              });
            } else {
              // Add to the events pool
              _this2._pool.push({
                target: target,
                type: eType,
                listener: listener,
                passive: passive
              });
            }
          } // most PhotoSwipe events call preventDefault,
          // and we do not need browser to scroll the page

          var eventOptions = supportsPassive ? {
            passive: passive || false
          } : false;
          target[methodName](eType, listener, eventOptions);
        }
      });
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('../slide/slide.js').SlideData} SlideData */
/**
 * @param {PhotoSwipeOptions} options
 * @param {PhotoSwipeBase} pswp
 * @returns {Point}
 */
function getViewportSize(options, pswp) {
  if (options.getViewportSizeFn) {
    var newViewportSize = options.getViewportSizeFn(options, pswp);
    if (newViewportSize) {
      return newViewportSize;
    }
  }
  return {
    x: document.documentElement.clientWidth,
    // TODO: height on mobile is very incosistent due to toolbar
    // find a way to improve this
    //
    // document.documentElement.clientHeight - doesn't seem to work well
    y: window.innerHeight
  };
}
/**
 * Parses padding option.
 * Supported formats:
 *
 * // Object
 * padding: {
 *  top: 0,
 *  bottom: 0,
 *  left: 0,
 *  right: 0
 * }
 *
 * // A function that returns the object
 * paddingFn: (viewportSize, itemData, index) => {
 *  return {
 *    top: 0,
 *    bottom: 0,
 *    left: 0,
 *    right: 0
 *  };
 * }
 *
 * // Legacy variant
 * paddingLeft: 0,
 * paddingRight: 0,
 * paddingTop: 0,
 * paddingBottom: 0,
 *
 * @param {'left' | 'top' | 'bottom' | 'right'} prop
 * @param {PhotoSwipeOptions} options PhotoSwipe options
 * @param {Point} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }
 * @param {SlideData} itemData Data about the slide
 * @param {number} index Slide index
 * @returns {number}
 */

function parsePaddingOption(prop, options, viewportSize, itemData, index) {
  var paddingValue = 0;
  if (options.paddingFn) {
    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];
  } else if (options.padding) {
    paddingValue = options.padding[prop];
  } else {
    var legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1); // @ts-expect-error

    if (options[legacyPropName]) {
      // @ts-expect-error
      paddingValue = options[legacyPropName];
    }
  }
  return Number(paddingValue) || 0;
}
/**
 * @param {PhotoSwipeOptions} options
 * @param {Point} viewportSize
 * @param {SlideData} itemData
 * @param {number} index
 * @returns {Point}
 */

function getPanAreaSize(options, viewportSize, itemData, index) {
  return {
    x: viewportSize.x - parsePaddingOption('left', options, viewportSize, itemData, index) - parsePaddingOption('right', options, viewportSize, itemData, index),
    y: viewportSize.y - parsePaddingOption('top', options, viewportSize, itemData, index) - parsePaddingOption('bottom', options, viewportSize, itemData, index)
  };
}

/** @typedef {import('./slide.js').default} Slide */

/** @typedef {Record<Axis, number>} Point */

/** @typedef {'x' | 'y'} Axis */

/**
 * Calculates minimum, maximum and initial (center) bounds of a slide
 */
var PanBounds = /*#__PURE__*/function () {
  /**
   * @param {Slide} slide
   */
  function PanBounds(slide) {
    _classCallCheck(this, PanBounds);
    this.slide = slide;
    this.currZoomLevel = 1;
    this.center = /** @type {Point} */
    {
      x: 0,
      y: 0
    };
    this.max = /** @type {Point} */
    {
      x: 0,
      y: 0
    };
    this.min = /** @type {Point} */
    {
      x: 0,
      y: 0
    };
  }
  /**
   * _getItemBounds
   *
   * @param {number} currZoomLevel
   */
  return _createClass(PanBounds, [{
    key: "update",
    value: function update(currZoomLevel) {
      this.currZoomLevel = currZoomLevel;
      if (!this.slide.width) {
        this.reset();
      } else {
        this._updateAxis('x');
        this._updateAxis('y');
        this.slide.pswp.dispatch('calcBounds', {
          slide: this.slide
        });
      }
    }
    /**
     * _calculateItemBoundsForAxis
     *
     * @param {Axis} axis
     */
  }, {
    key: "_updateAxis",
    value: function _updateAxis(axis) {
      var pswp = this.slide.pswp;
      var elSize = this.slide[axis === 'x' ? 'width' : 'height'] * this.currZoomLevel;
      var paddingProp = axis === 'x' ? 'left' : 'top';
      var padding = parsePaddingOption(paddingProp, pswp.options, pswp.viewportSize, this.slide.data, this.slide.index);
      var panAreaSize = this.slide.panAreaSize[axis]; // Default position of element.
      // By default, it is center of viewport:

      this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding; // maximum pan position

      this.max[axis] = elSize > panAreaSize ? Math.round(panAreaSize - elSize) + padding : this.center[axis]; // minimum pan position

      this.min[axis] = elSize > panAreaSize ? padding : this.center[axis];
    } // _getZeroBounds
  }, {
    key: "reset",
    value: function reset() {
      this.center.x = 0;
      this.center.y = 0;
      this.max.x = 0;
      this.max.y = 0;
      this.min.x = 0;
      this.min.y = 0;
    }
    /**
     * Correct pan position if it's beyond the bounds
     *
     * @param {Axis} axis x or y
     * @param {number} panOffset
     * @returns {number}
     */
  }, {
    key: "correctPan",
    value: function correctPan(axis, panOffset) {
      // checkPanBounds
      return clamp(panOffset, this.max[axis], this.min[axis]);
    }
  }]);
}();
var MAX_IMAGE_WIDTH = 4000;
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */

/** @typedef {import('../photoswipe.js').Point} Point */

/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */

/**
 * Calculates zoom levels for specific slide.
 * Depends on viewport size and image size.
 */
var ZoomLevel = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipeOptions} options PhotoSwipe options
   * @param {SlideData} itemData Slide data
   * @param {number} index Slide index
   * @param {PhotoSwipe} [pswp] PhotoSwipe instance, can be undefined if not initialized yet
   */
  function ZoomLevel(options, itemData, index, pswp) {
    _classCallCheck(this, ZoomLevel);
    this.pswp = pswp;
    this.options = options;
    this.itemData = itemData;
    this.index = index;
    /** @type { Point | null } */

    this.panAreaSize = null;
    /** @type { Point | null } */

    this.elementSize = null;
    this.fit = 1;
    this.fill = 1;
    this.vFill = 1;
    this.initial = 1;
    this.secondary = 1;
    this.max = 1;
    this.min = 1;
  }
  /**
   * Calculate initial, secondary and maximum zoom level for the specified slide.
   *
   * It should be called when either image or viewport size changes.
   *
   * @param {number} maxWidth
   * @param {number} maxHeight
   * @param {Point} panAreaSize
   */
  return _createClass(ZoomLevel, [{
    key: "update",
    value: function update(maxWidth, maxHeight, panAreaSize) {
      /** @type {Point} */
      var elementSize = {
        x: maxWidth,
        y: maxHeight
      };
      this.elementSize = elementSize;
      this.panAreaSize = panAreaSize;
      var hRatio = panAreaSize.x / elementSize.x;
      var vRatio = panAreaSize.y / elementSize.y;
      this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);
      this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio); // zoom.vFill defines zoom level of the image
      // when it has 100% of viewport vertical space (height)

      this.vFill = Math.min(1, vRatio);
      this.initial = this._getInitial();
      this.secondary = this._getSecondary();
      this.max = Math.max(this.initial, this.secondary, this._getMax());
      this.min = Math.min(this.fit, this.initial, this.secondary);
      if (this.pswp) {
        this.pswp.dispatch('zoomLevelsUpdate', {
          zoomLevels: this,
          slideData: this.itemData
        });
      }
    }
    /**
     * Parses user-defined zoom option.
     *
     * @private
     * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)
     * @returns { number | undefined }
     */
  }, {
    key: "_parseZoomLevelOption",
    value: function _parseZoomLevelOption(optionPrefix) {
      var optionName = /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */
      optionPrefix + 'ZoomLevel';
      var optionValue = this.options[optionName];
      if (!optionValue) {
        return;
      }
      if (typeof optionValue === 'function') {
        return optionValue(this);
      }
      if (optionValue === 'fill') {
        return this.fill;
      }
      if (optionValue === 'fit') {
        return this.fit;
      }
      return Number(optionValue);
    }
    /**
     * Get zoom level to which image will be zoomed after double-tap gesture,
     * or when user clicks on zoom icon,
     * or mouse-click on image itself.
     * If you return 1 image will be zoomed to its original size.
     *
     * @private
     * @return {number}
     */
  }, {
    key: "_getSecondary",
    value: function _getSecondary() {
      var currZoomLevel = this._parseZoomLevelOption('secondary');
      if (currZoomLevel) {
        return currZoomLevel;
      } // 3x of "fit" state, but not larger than original

      currZoomLevel = Math.min(1, this.fit * 3);
      if (this.elementSize && currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {
        currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;
      }
      return currZoomLevel;
    }
    /**
     * Get initial image zoom level.
     *
     * @private
     * @return {number}
     */
  }, {
    key: "_getInitial",
    value: function _getInitial() {
      return this._parseZoomLevelOption('initial') || this.fit;
    }
    /**
     * Maximum zoom level when user zooms
     * via zoom/pinch gesture,
     * via cmd/ctrl-wheel or via trackpad.
     *
     * @private
     * @return {number}
     */
  }, {
    key: "_getMax",
    value: function _getMax() {
      // max zoom level is x4 from "fit state",
      // used for zoom gesture and ctrl/trackpad zoom
      return this._parseZoomLevelOption('max') || Math.max(1, this.fit * 4);
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/**
 * Renders and allows to control a single slide
 */
var Slide = /*#__PURE__*/function () {
  /**
   * @param {SlideData} data
   * @param {number} index
   * @param {PhotoSwipe} pswp
   */
  function Slide(data, index, pswp) {
    _classCallCheck(this, Slide);
    this.data = data;
    this.index = index;
    this.pswp = pswp;
    this.isActive = index === pswp.currIndex;
    this.currentResolution = 0;
    /** @type {Point} */

    this.panAreaSize = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.pan = {
      x: 0,
      y: 0
    };
    this.isFirstSlide = this.isActive && !pswp.opener.isOpen;
    this.zoomLevels = new ZoomLevel(pswp.options, data, index, pswp);
    this.pswp.dispatch('gettingData', {
      slide: this,
      data: this.data,
      index: index
    });
    this.content = this.pswp.contentLoader.getContentBySlide(this);
    this.container = createElement('pswp__zoom-wrap', 'div');
    /** @type {HTMLElement | null} */

    this.holderElement = null;
    this.currZoomLevel = 1;
    /** @type {number} */

    this.width = this.content.width;
    /** @type {number} */

    this.height = this.content.height;
    this.heavyAppended = false;
    this.bounds = new PanBounds(this);
    this.prevDisplayedWidth = -1;
    this.prevDisplayedHeight = -1;
    this.pswp.dispatch('slideInit', {
      slide: this
    });
  }
  /**
   * If this slide is active/current/visible
   *
   * @param {boolean} isActive
   */
  return _createClass(Slide, [{
    key: "setIsActive",
    value: function setIsActive(isActive) {
      if (isActive && !this.isActive) {
        // slide just became active
        this.activate();
      } else if (!isActive && this.isActive) {
        // slide just became non-active
        this.deactivate();
      }
    }
    /**
     * Appends slide content to DOM
     *
     * @param {HTMLElement} holderElement
     */
  }, {
    key: "append",
    value: function append(holderElement) {
      this.holderElement = holderElement;
      this.container.style.transformOrigin = '0 0'; // Slide appended to DOM

      if (!this.data) {
        return;
      }
      this.calculateSize();
      this.load();
      this.updateContentSize();
      this.appendHeavy();
      this.holderElement.appendChild(this.container);
      this.zoomAndPanToInitial();
      this.pswp.dispatch('firstZoomPan', {
        slide: this
      });
      this.applyCurrentZoomPan();
      this.pswp.dispatch('afterSetContent', {
        slide: this
      });
      if (this.isActive) {
        this.activate();
      }
    }
  }, {
    key: "load",
    value: function load() {
      this.content.load(false);
      this.pswp.dispatch('slideLoad', {
        slide: this
      });
    }
    /**
     * Append "heavy" DOM elements
     *
     * This may depend on a type of slide,
     * but generally these are large images.
     */
  }, {
    key: "appendHeavy",
    value: function appendHeavy() {
      var pswp = this.pswp;
      var appendHeavyNearby = true; // todo
      // Avoid appending heavy elements during animations

      if (this.heavyAppended || !pswp.opener.isOpen || pswp.mainScroll.isShifted() || !this.isActive && !appendHeavyNearby) {
        return;
      }
      if (this.pswp.dispatch('appendHeavy', {
        slide: this
      }).defaultPrevented) {
        return;
      }
      this.heavyAppended = true;
      this.content.append();
      this.pswp.dispatch('appendHeavyContent', {
        slide: this
      });
    }
    /**
     * Triggered when this slide is active (selected).
     *
     * If it's part of opening/closing transition -
     * activate() will trigger after the transition is ended.
     */
  }, {
    key: "activate",
    value: function activate() {
      this.isActive = true;
      this.appendHeavy();
      this.content.activate();
      this.pswp.dispatch('slideActivate', {
        slide: this
      });
    }
    /**
     * Triggered when this slide becomes inactive.
     *
     * Slide can become inactive only after it was active.
     */
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.isActive = false;
      this.content.deactivate();
      if (this.currZoomLevel !== this.zoomLevels.initial) {
        // allow filtering
        this.calculateSize();
      } // reset zoom level

      this.currentResolution = 0;
      this.zoomAndPanToInitial();
      this.applyCurrentZoomPan();
      this.updateContentSize();
      this.pswp.dispatch('slideDeactivate', {
        slide: this
      });
    }
    /**
     * The slide should destroy itself, it will never be used again.
     * (unbind all events and destroy internal components)
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.content.hasSlide = false;
      this.content.remove();
      this.container.remove();
      this.pswp.dispatch('slideDestroy', {
        slide: this
      });
    }
  }, {
    key: "resize",
    value: function resize() {
      if (this.currZoomLevel === this.zoomLevels.initial || !this.isActive) {
        // Keep initial zoom level if it was before the resize,
        // as well as when this slide is not active
        // Reset position and scale to original state
        this.calculateSize();
        this.currentResolution = 0;
        this.zoomAndPanToInitial();
        this.applyCurrentZoomPan();
        this.updateContentSize();
      } else {
        // readjust pan position if it's beyond the bounds
        this.calculateSize();
        this.bounds.update(this.currZoomLevel);
        this.panTo(this.pan.x, this.pan.y);
      }
    }
    /**
     * Apply size to current slide content,
     * based on the current resolution and scale.
     *
     * @param {boolean} [force] if size should be updated even if dimensions weren't changed
     */
  }, {
    key: "updateContentSize",
    value: function updateContentSize(force) {
      // Use initial zoom level
      // if resolution is not defined (user didn't zoom yet)
      var scaleMultiplier = this.currentResolution || this.zoomLevels.initial;
      if (!scaleMultiplier) {
        return;
      }
      var width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x;
      var height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;
      if (!this.sizeChanged(width, height) && !force) {
        return;
      }
      this.content.setDisplayedSize(width, height);
    }
    /**
     * @param {number} width
     * @param {number} height
     */
  }, {
    key: "sizeChanged",
    value: function sizeChanged(width, height) {
      if (width !== this.prevDisplayedWidth || height !== this.prevDisplayedHeight) {
        this.prevDisplayedWidth = width;
        this.prevDisplayedHeight = height;
        return true;
      }
      return false;
    }
    /** @returns {HTMLImageElement | HTMLDivElement | null | undefined} */
  }, {
    key: "getPlaceholderElement",
    value: function getPlaceholderElement() {
      var _this$content$placeho;
      return (_this$content$placeho = this.content.placeholder) === null || _this$content$placeho === void 0 ? void 0 : _this$content$placeho.element;
    }
    /**
     * Zoom current slide image to...
     *
     * @param {number} destZoomLevel Destination zoom level.
     * @param {Point} [centerPoint]
     * Transform origin center point, or false if viewport center should be used.
     * @param {number | false} [transitionDuration] Transition duration, may be set to 0.
     * @param {boolean} [ignoreBounds] Minimum and maximum zoom levels will be ignored.
     */
  }, {
    key: "zoomTo",
    value: function zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {
      var _this3 = this;
      var pswp = this.pswp;
      if (!this.isZoomable() || pswp.mainScroll.isShifted()) {
        return;
      }
      pswp.dispatch('beforeZoomTo', {
        destZoomLevel: destZoomLevel,
        centerPoint: centerPoint,
        transitionDuration: transitionDuration
      }); // stop all pan and zoom transitions

      pswp.animations.stopAllPan(); // if (!centerPoint) {
      //   centerPoint = pswp.getViewportCenterPoint();
      // }

      var prevZoomLevel = this.currZoomLevel;
      if (!ignoreBounds) {
        destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max);
      } // if (transitionDuration === undefined) {
      //   transitionDuration = this.pswp.options.zoomAnimationDuration;
      // }

      this.setZoomLevel(destZoomLevel);
      this.pan.x = this.calculateZoomToPanOffset('x', centerPoint, prevZoomLevel);
      this.pan.y = this.calculateZoomToPanOffset('y', centerPoint, prevZoomLevel);
      roundPoint(this.pan);
      var finishTransition = function finishTransition() {
        _this3._setResolution(destZoomLevel);
        _this3.applyCurrentZoomPan();
      };
      if (!transitionDuration) {
        finishTransition();
      } else {
        pswp.animations.startTransition({
          isPan: true,
          name: 'zoomTo',
          target: this.container,
          transform: this.getCurrentTransform(),
          onComplete: finishTransition,
          duration: transitionDuration,
          easing: pswp.options.easing
        });
      }
    }
    /**
     * @param {Point} [centerPoint]
     */
  }, {
    key: "toggleZoom",
    value: function toggleZoom(centerPoint) {
      this.zoomTo(this.currZoomLevel === this.zoomLevels.initial ? this.zoomLevels.secondary : this.zoomLevels.initial, centerPoint, this.pswp.options.zoomAnimationDuration);
    }
    /**
     * Updates zoom level property and recalculates new pan bounds,
     * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)
     *
     * @param {number} currZoomLevel
     */
  }, {
    key: "setZoomLevel",
    value: function setZoomLevel(currZoomLevel) {
      this.currZoomLevel = currZoomLevel;
      this.bounds.update(this.currZoomLevel);
    }
    /**
     * Get pan position after zoom at a given `point`.
     *
     * Always call setZoomLevel(newZoomLevel) beforehand to recalculate
     * pan bounds according to the new zoom level.
     *
     * @param {'x' | 'y'} axis
     * @param {Point} [point]
     * point based on which zoom is performed, usually refers to the current mouse position,
     * if false - viewport center will be used.
     * @param {number} [prevZoomLevel] Zoom level before new zoom was applied.
     * @returns {number}
     */
  }, {
    key: "calculateZoomToPanOffset",
    value: function calculateZoomToPanOffset(axis, point, prevZoomLevel) {
      var totalPanDistance = this.bounds.max[axis] - this.bounds.min[axis];
      if (totalPanDistance === 0) {
        return this.bounds.center[axis];
      }
      if (!point) {
        point = this.pswp.getViewportCenterPoint();
      }
      if (!prevZoomLevel) {
        prevZoomLevel = this.zoomLevels.initial;
      }
      var zoomFactor = this.currZoomLevel / prevZoomLevel;
      return this.bounds.correctPan(axis, (this.pan[axis] - point[axis]) * zoomFactor + point[axis]);
    }
    /**
     * Apply pan and keep it within bounds.
     *
     * @param {number} panX
     * @param {number} panY
     */
  }, {
    key: "panTo",
    value: function panTo(panX, panY) {
      this.pan.x = this.bounds.correctPan('x', panX);
      this.pan.y = this.bounds.correctPan('y', panY);
      this.applyCurrentZoomPan();
    }
    /**
     * If the slide in the current state can be panned by the user
     * @returns {boolean}
     */
  }, {
    key: "isPannable",
    value: function isPannable() {
      return Boolean(this.width) && this.currZoomLevel > this.zoomLevels.fit;
    }
    /**
     * If the slide can be zoomed
     * @returns {boolean}
     */
  }, {
    key: "isZoomable",
    value: function isZoomable() {
      return Boolean(this.width) && this.content.isZoomable();
    }
    /**
     * Apply transform and scale based on
     * the current pan position (this.pan) and zoom level (this.currZoomLevel)
     */
  }, {
    key: "applyCurrentZoomPan",
    value: function applyCurrentZoomPan() {
      this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel);
      if (this === this.pswp.currSlide) {
        this.pswp.dispatch('zoomPanUpdate', {
          slide: this
        });
      }
    }
  }, {
    key: "zoomAndPanToInitial",
    value: function zoomAndPanToInitial() {
      this.currZoomLevel = this.zoomLevels.initial; // pan according to the zoom level

      this.bounds.update(this.currZoomLevel);
      equalizePoints(this.pan, this.bounds.center);
      this.pswp.dispatch('initialZoomPan', {
        slide: this
      });
    }
    /**
     * Set translate and scale based on current resolution
     *
     * @param {number} x
     * @param {number} y
     * @param {number} zoom
     * @private
     */
  }, {
    key: "_applyZoomTransform",
    value: function _applyZoomTransform(x, y, zoom) {
      zoom /= this.currentResolution || this.zoomLevels.initial;
      setTransform(this.container, x, y, zoom);
    }
  }, {
    key: "calculateSize",
    value: function calculateSize() {
      var pswp = this.pswp;
      equalizePoints(this.panAreaSize, getPanAreaSize(pswp.options, pswp.viewportSize, this.data, this.index));
      this.zoomLevels.update(this.width, this.height, this.panAreaSize);
      pswp.dispatch('calcSlideSize', {
        slide: this
      });
    }
    /** @returns {string} */
  }, {
    key: "getCurrentTransform",
    value: function getCurrentTransform() {
      var scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);
      return toTransformString(this.pan.x, this.pan.y, scale);
    }
    /**
     * Set resolution and re-render the image.
     *
     * For example, if the real image size is 2000x1500,
     * and resolution is 0.5 - it will be rendered as 1000x750.
     *
     * Image with zoom level 2 and resolution 0.5 is
     * the same as image with zoom level 1 and resolution 1.
     *
     * Used to optimize animations and make
     * sure that browser renders image in the highest quality.
     * Also used by responsive images to load the correct one.
     *
     * @param {number} newResolution
     */
  }, {
    key: "_setResolution",
    value: function _setResolution(newResolution) {
      if (newResolution === this.currentResolution) {
        return;
      }
      this.currentResolution = newResolution;
      this.updateContentSize();
      this.pswp.dispatch('resolutionChanged');
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('./gestures.js').default} Gestures */
var PAN_END_FRICTION = 0.35;
var VERTICAL_DRAG_FRICTION = 0.6; // 1 corresponds to the third of viewport height

var MIN_RATIO_TO_CLOSE = 0.4; // Minimum speed required to navigate
// to next or previous slide

var MIN_NEXT_SLIDE_SPEED = 0.5;
/**
 * @param {number} initialVelocity
 * @param {number} decelerationRate
 * @returns {number}
 */

function project(initialVelocity, decelerationRate) {
  return initialVelocity * decelerationRate / (1 - decelerationRate);
}
/**
 * Handles single pointer dragging
 */
var DragHandler = /*#__PURE__*/function () {
  /**
   * @param {Gestures} gestures
   */
  function DragHandler(gestures) {
    _classCallCheck(this, DragHandler);
    this.gestures = gestures;
    this.pswp = gestures.pswp;
    /** @type {Point} */

    this.startPan = {
      x: 0,
      y: 0
    };
  }
  return _createClass(DragHandler, [{
    key: "start",
    value: function start() {
      if (this.pswp.currSlide) {
        equalizePoints(this.startPan, this.pswp.currSlide.pan);
      }
      this.pswp.animations.stopAll();
    }
  }, {
    key: "change",
    value: function change() {
      var _this$gestures = this.gestures,
        p1 = _this$gestures.p1,
        prevP1 = _this$gestures.prevP1,
        dragAxis = _this$gestures.dragAxis;
      var currSlide = this.pswp.currSlide;
      if (dragAxis === 'y' && this.pswp.options.closeOnVerticalDrag && currSlide && currSlide.currZoomLevel <= currSlide.zoomLevels.fit && !this.gestures.isMultitouch) {
        // Handle vertical drag to close
        var panY = currSlide.pan.y + (p1.y - prevP1.y);
        if (!this.pswp.dispatch('verticalDrag', {
          panY: panY
        }).defaultPrevented) {
          this._setPanWithFriction('y', panY, VERTICAL_DRAG_FRICTION);
          var bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));
          this.pswp.applyBgOpacity(bgOpacity);
          currSlide.applyCurrentZoomPan();
        }
      } else {
        var mainScrollChanged = this._panOrMoveMainScroll('x');
        if (!mainScrollChanged) {
          this._panOrMoveMainScroll('y');
          if (currSlide) {
            roundPoint(currSlide.pan);
            currSlide.applyCurrentZoomPan();
          }
        }
      }
    }
  }, {
    key: "end",
    value: function end() {
      var velocity = this.gestures.velocity;
      var _this$pswp4 = this.pswp,
        mainScroll = _this$pswp4.mainScroll,
        currSlide = _this$pswp4.currSlide;
      var indexDiff = 0;
      this.pswp.animations.stopAll(); // Handle main scroll if it's shifted

      if (mainScroll.isShifted()) {
        // Position of the main scroll relative to the viewport
        var mainScrollShiftDiff = mainScroll.x - mainScroll.getCurrSlideX(); // Ratio between 0 and 1:
        // 0 - slide is not visible at all,
        // 0.5 - half of the slide is visible
        // 1 - slide is fully visible

        var currentSlideVisibilityRatio = mainScrollShiftDiff / this.pswp.viewportSize.x; // Go next slide.
        //
        // - if velocity and its direction is matched,
        //   and we see at least tiny part of the next slide
        //
        // - or if we see less than 50% of the current slide
        //   and velocity is close to 0
        //

        if (velocity.x < -MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio < 0 || velocity.x < 0.1 && currentSlideVisibilityRatio < -0.5) {
          // Go to next slide
          indexDiff = 1;
          velocity.x = Math.min(velocity.x, 0);
        } else if (velocity.x > MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio > 0 || velocity.x > -0.1 && currentSlideVisibilityRatio > 0.5) {
          // Go to prev slide
          indexDiff = -1;
          velocity.x = Math.max(velocity.x, 0);
        }
        mainScroll.moveIndexBy(indexDiff, true, velocity.x);
      } // Restore zoom level

      if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.max || this.gestures.isMultitouch) {
        this.gestures.zoomLevels.correctZoomPan(true);
      } else {
        // we run two animations instead of one,
        // as each axis has own pan boundaries and thus different spring function
        // (correctZoomPan does not have this functionality,
        //  it animates all properties with single timing function)
        this._finishPanGestureForAxis('x');
        this._finishPanGestureForAxis('y');
      }
    }
    /**
     * @private
     * @param {'x' | 'y'} axis
     */
  }, {
    key: "_finishPanGestureForAxis",
    value: function _finishPanGestureForAxis(axis) {
      var _this4 = this;
      var velocity = this.gestures.velocity;
      var currSlide = this.pswp.currSlide;
      if (!currSlide) {
        return;
      }
      var pan = currSlide.pan,
        bounds = currSlide.bounds;
      var panPos = pan[axis];
      var restoreBgOpacity = this.pswp.bgOpacity < 1 && axis === 'y'; // 0.995 means - scroll view loses 0.5% of its velocity per millisecond
      // Increasing this number will reduce travel distance

      var decelerationRate = 0.995; // 0.99
      // Pan position if there is no bounds

      var projectedPosition = panPos + project(velocity[axis], decelerationRate);
      if (restoreBgOpacity) {
        var vDragRatio = this._getVerticalDragRatio(panPos);
        var projectedVDragRatio = this._getVerticalDragRatio(projectedPosition); // If we are above and moving upwards,
        // or if we are below and moving downwards

        if (vDragRatio < 0 && projectedVDragRatio < -MIN_RATIO_TO_CLOSE || vDragRatio > 0 && projectedVDragRatio > MIN_RATIO_TO_CLOSE) {
          this.pswp.close();
          return;
        }
      } // Pan position with corrected bounds

      var correctedPanPosition = bounds.correctPan(axis, projectedPosition); // Exit if pan position should not be changed
      // or if speed it too low

      if (panPos === correctedPanPosition) {
        return;
      } // Overshoot if the final position is out of pan bounds

      var dampingRatio = correctedPanPosition === projectedPosition ? 1 : 0.82;
      var initialBgOpacity = this.pswp.bgOpacity;
      var totalPanDist = correctedPanPosition - panPos;
      this.pswp.animations.startSpring({
        name: 'panGesture' + axis,
        isPan: true,
        start: panPos,
        end: correctedPanPosition,
        velocity: velocity[axis],
        dampingRatio: dampingRatio,
        onUpdate: function onUpdate(pos) {
          // Animate opacity of background relative to Y pan position of an image
          if (restoreBgOpacity && _this4.pswp.bgOpacity < 1) {
            // 0 - start of animation, 1 - end of animation
            var animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist; // We clamp opacity to keep it between 0 and 1.
            // As progress ratio can be larger than 1 due to overshoot,
            // and we do not want to bounce opacity.

            _this4.pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio, 0, 1));
          }
          pan[axis] = Math.floor(pos);
          currSlide.applyCurrentZoomPan();
        }
      });
    }
    /**
     * Update position of the main scroll,
     * or/and update pan position of the current slide.
     *
     * Should return true if it changes (or can change) main scroll.
     *
     * @private
     * @param {'x' | 'y'} axis
     * @returns {boolean}
     */
  }, {
    key: "_panOrMoveMainScroll",
    value: function _panOrMoveMainScroll(axis) {
      var _this$gestures2 = this.gestures,
        p1 = _this$gestures2.p1,
        dragAxis = _this$gestures2.dragAxis,
        prevP1 = _this$gestures2.prevP1,
        isMultitouch = _this$gestures2.isMultitouch;
      var _this$pswp5 = this.pswp,
        currSlide = _this$pswp5.currSlide,
        mainScroll = _this$pswp5.mainScroll;
      var delta = p1[axis] - prevP1[axis];
      var newMainScrollX = mainScroll.x + delta;
      if (!delta || !currSlide) {
        return false;
      } // Always move main scroll if image can not be panned

      if (axis === 'x' && !currSlide.isPannable() && !isMultitouch) {
        mainScroll.moveTo(newMainScrollX, true);
        return true; // changed main scroll
      }
      var bounds = currSlide.bounds;
      var newPan = currSlide.pan[axis] + delta;
      if (this.pswp.options.allowPanToNext && dragAxis === 'x' && axis === 'x' && !isMultitouch) {
        var currSlideMainScrollX = mainScroll.getCurrSlideX(); // Position of the main scroll relative to the viewport

        var mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX;
        var isLeftToRight = delta > 0;
        var isRightToLeft = !isLeftToRight;
        if (newPan > bounds.min[axis] && isLeftToRight) {
          // Panning from left to right, beyond the left edge
          // Wether the image was at minimum pan position (or less)
          // when this drag gesture started.
          // Minimum pan position refers to the left edge of the image.
          var wasAtMinPanPosition = bounds.min[axis] <= this.startPan[axis];
          if (wasAtMinPanPosition) {
            mainScroll.moveTo(newMainScrollX, true);
            return true;
          } else {
            this._setPanWithFriction(axis, newPan); //currSlide.pan[axis] = newPan;
          }
        } else if (newPan < bounds.max[axis] && isRightToLeft) {
          // Paning from right to left, beyond the right edge
          // Maximum pan position refers to the right edge of the image.
          var wasAtMaxPanPosition = this.startPan[axis] <= bounds.max[axis];
          if (wasAtMaxPanPosition) {
            mainScroll.moveTo(newMainScrollX, true);
            return true;
          } else {
            this._setPanWithFriction(axis, newPan); //currSlide.pan[axis] = newPan;
          }
        } else {
          // If main scroll is shifted
          if (mainScrollShiftDiff !== 0) {
            // If main scroll is shifted right
            if (mainScrollShiftDiff > 0
            /*&& isRightToLeft*/) {
              mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), true);
              return true;
            } else if (mainScrollShiftDiff < 0
            /*&& isLeftToRight*/) {
              // Main scroll is shifted left (Position is less than 0 comparing to the viewport 0)
              mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), true);
              return true;
            }
          } else {
            // We are within pan bounds, so just pan
            this._setPanWithFriction(axis, newPan);
          }
        }
      } else {
        if (axis === 'y') {
          // Do not pan vertically if main scroll is shifted o
          if (!mainScroll.isShifted() && bounds.min.y !== bounds.max.y) {
            this._setPanWithFriction(axis, newPan);
          }
        } else {
          this._setPanWithFriction(axis, newPan);
        }
      }
      return false;
    } // If we move above - the ratio is negative
    // If we move below the ratio is positive

    /**
     * Relation between pan Y position and third of viewport height.
     *
     * When we are at initial position (center bounds) - the ratio is 0,
     * if position is shifted upwards - the ratio is negative,
     * if position is shifted downwards - the ratio is positive.
     *
     * @private
     * @param {number} panY The current pan Y position.
     * @returns {number}
     */
  }, {
    key: "_getVerticalDragRatio",
    value: function _getVerticalDragRatio(panY) {
      var _this$pswp$currSlide$, _this$pswp$currSlide;
      return (panY - ((_this$pswp$currSlide$ = (_this$pswp$currSlide = this.pswp.currSlide) === null || _this$pswp$currSlide === void 0 ? void 0 : _this$pswp$currSlide.bounds.center.y) !== null && _this$pswp$currSlide$ !== void 0 ? _this$pswp$currSlide$ : 0)) / (this.pswp.viewportSize.y / 3);
    }
    /**
     * Set pan position of the current slide.
     * Apply friction if the position is beyond the pan bounds,
     * or if custom friction is defined.
     *
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} potentialPan
     * @param {number} [customFriction] (0.1 - 1)
     */
  }, {
    key: "_setPanWithFriction",
    value: function _setPanWithFriction(axis, potentialPan, customFriction) {
      var currSlide = this.pswp.currSlide;
      if (!currSlide) {
        return;
      }
      var pan = currSlide.pan,
        bounds = currSlide.bounds;
      var correctedPan = bounds.correctPan(axis, potentialPan); // If we are out of pan bounds

      if (correctedPan !== potentialPan || customFriction) {
        var delta = Math.round(potentialPan - pan[axis]);
        pan[axis] += delta * (customFriction || PAN_END_FRICTION);
      } else {
        pan[axis] = potentialPan;
      }
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {import('./gestures.js').default} Gestures */
var UPPER_ZOOM_FRICTION = 0.05;
var LOWER_ZOOM_FRICTION = 0.15;
/**
 * Get center point between two points
 *
 * @param {Point} p
 * @param {Point} p1
 * @param {Point} p2
 * @returns {Point}
 */

function getZoomPointsCenter(p, p1, p2) {
  p.x = (p1.x + p2.x) / 2;
  p.y = (p1.y + p2.y) / 2;
  return p;
}
var ZoomHandler = /*#__PURE__*/function () {
  /**
   * @param {Gestures} gestures
   */
  function ZoomHandler(gestures) {
    _classCallCheck(this, ZoomHandler);
    this.gestures = gestures;
    /**
     * @private
     * @type {Point}
     */

    this._startPan = {
      x: 0,
      y: 0
    };
    /**
     * @private
     * @type {Point}
     */

    this._startZoomPoint = {
      x: 0,
      y: 0
    };
    /**
     * @private
     * @type {Point}
     */

    this._zoomPoint = {
      x: 0,
      y: 0
    };
    /** @private */

    this._wasOverFitZoomLevel = false;
    /** @private */

    this._startZoomLevel = 1;
  }
  return _createClass(ZoomHandler, [{
    key: "start",
    value: function start() {
      var currSlide = this.gestures.pswp.currSlide;
      if (currSlide) {
        this._startZoomLevel = currSlide.currZoomLevel;
        equalizePoints(this._startPan, currSlide.pan);
      }
      this.gestures.pswp.animations.stopAllPan();
      this._wasOverFitZoomLevel = false;
    }
  }, {
    key: "change",
    value: function change() {
      var _this$gestures3 = this.gestures,
        p1 = _this$gestures3.p1,
        startP1 = _this$gestures3.startP1,
        p2 = _this$gestures3.p2,
        startP2 = _this$gestures3.startP2,
        pswp = _this$gestures3.pswp;
      var currSlide = pswp.currSlide;
      if (!currSlide) {
        return;
      }
      var minZoomLevel = currSlide.zoomLevels.min;
      var maxZoomLevel = currSlide.zoomLevels.max;
      if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) {
        return;
      }
      getZoomPointsCenter(this._startZoomPoint, startP1, startP2);
      getZoomPointsCenter(this._zoomPoint, p1, p2);
      var currZoomLevel = 1 / getDistanceBetween(startP1, startP2) * getDistanceBetween(p1, p2) * this._startZoomLevel; // slightly over the zoom.fit

      if (currZoomLevel > currSlide.zoomLevels.initial + currSlide.zoomLevels.initial / 15) {
        this._wasOverFitZoomLevel = true;
      }
      if (currZoomLevel < minZoomLevel) {
        if (pswp.options.pinchToClose && !this._wasOverFitZoomLevel && this._startZoomLevel <= currSlide.zoomLevels.initial) {
          // fade out background if zooming out
          var bgOpacity = 1 - (minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2);
          if (!pswp.dispatch('pinchClose', {
            bgOpacity: bgOpacity
          }).defaultPrevented) {
            pswp.applyBgOpacity(bgOpacity);
          }
        } else {
          // Apply the friction if zoom level is below the min
          currZoomLevel = minZoomLevel - (minZoomLevel - currZoomLevel) * LOWER_ZOOM_FRICTION;
        }
      } else if (currZoomLevel > maxZoomLevel) {
        // Apply the friction if zoom level is above the max
        currZoomLevel = maxZoomLevel + (currZoomLevel - maxZoomLevel) * UPPER_ZOOM_FRICTION;
      }
      currSlide.pan.x = this._calculatePanForZoomLevel('x', currZoomLevel);
      currSlide.pan.y = this._calculatePanForZoomLevel('y', currZoomLevel);
      currSlide.setZoomLevel(currZoomLevel);
      currSlide.applyCurrentZoomPan();
    }
  }, {
    key: "end",
    value: function end() {
      var pswp = this.gestures.pswp;
      var currSlide = pswp.currSlide;
      if ((!currSlide || currSlide.currZoomLevel < currSlide.zoomLevels.initial) && !this._wasOverFitZoomLevel && pswp.options.pinchToClose) {
        pswp.close();
      } else {
        this.correctZoomPan();
      }
    }
    /**
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} currZoomLevel
     * @returns {number}
     */
  }, {
    key: "_calculatePanForZoomLevel",
    value: function _calculatePanForZoomLevel(axis, currZoomLevel) {
      var zoomFactor = currZoomLevel / this._startZoomLevel;
      return this._zoomPoint[axis] - (this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor;
    }
    /**
     * Correct currZoomLevel and pan if they are
     * beyond minimum or maximum values.
     * With animation.
     *
     * @param {boolean} [ignoreGesture]
     * Wether gesture coordinates should be ignored when calculating destination pan position.
     */
  }, {
    key: "correctZoomPan",
    value: function correctZoomPan(ignoreGesture) {
      var pswp = this.gestures.pswp;
      var currSlide = pswp.currSlide;
      if (!(currSlide !== null && currSlide !== void 0 && currSlide.isZoomable())) {
        return;
      }
      if (this._zoomPoint.x === 0) {
        ignoreGesture = true;
      }
      var prevZoomLevel = currSlide.currZoomLevel;
      /** @type {number} */

      var destinationZoomLevel;
      var currZoomLevelNeedsChange = true;
      if (prevZoomLevel < currSlide.zoomLevels.initial) {
        destinationZoomLevel = currSlide.zoomLevels.initial; // zoom to min
      } else if (prevZoomLevel > currSlide.zoomLevels.max) {
        destinationZoomLevel = currSlide.zoomLevels.max; // zoom to max
      } else {
        currZoomLevelNeedsChange = false;
        destinationZoomLevel = prevZoomLevel;
      }
      var initialBgOpacity = pswp.bgOpacity;
      var restoreBgOpacity = pswp.bgOpacity < 1;
      var initialPan = equalizePoints({
        x: 0,
        y: 0
      }, currSlide.pan);
      var destinationPan = equalizePoints({
        x: 0,
        y: 0
      }, initialPan);
      if (ignoreGesture) {
        this._zoomPoint.x = 0;
        this._zoomPoint.y = 0;
        this._startZoomPoint.x = 0;
        this._startZoomPoint.y = 0;
        this._startZoomLevel = prevZoomLevel;
        equalizePoints(this._startPan, initialPan);
      }
      if (currZoomLevelNeedsChange) {
        destinationPan = {
          x: this._calculatePanForZoomLevel('x', destinationZoomLevel),
          y: this._calculatePanForZoomLevel('y', destinationZoomLevel)
        };
      } // set zoom level, so pan bounds are updated according to it

      currSlide.setZoomLevel(destinationZoomLevel);
      destinationPan = {
        x: currSlide.bounds.correctPan('x', destinationPan.x),
        y: currSlide.bounds.correctPan('y', destinationPan.y)
      }; // return zoom level and its bounds to initial

      currSlide.setZoomLevel(prevZoomLevel);
      var panNeedsChange = !pointsEqual(destinationPan, initialPan);
      if (!panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) {
        // update resolution after gesture
        currSlide._setResolution(destinationZoomLevel);
        currSlide.applyCurrentZoomPan(); // nothing to animate

        return;
      }
      pswp.animations.stopAllPan();
      pswp.animations.startSpring({
        isPan: true,
        start: 0,
        end: 1000,
        velocity: 0,
        dampingRatio: 1,
        naturalFrequency: 40,
        onUpdate: function onUpdate(now) {
          now /= 1000; // 0 - start, 1 - end

          if (panNeedsChange || currZoomLevelNeedsChange) {
            if (panNeedsChange) {
              currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now;
              currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now;
            }
            if (currZoomLevelNeedsChange) {
              var newZoomLevel = prevZoomLevel + (destinationZoomLevel - prevZoomLevel) * now;
              currSlide.setZoomLevel(newZoomLevel);
            }
            currSlide.applyCurrentZoomPan();
          } // Restore background opacity

          if (restoreBgOpacity && pswp.bgOpacity < 1) {
            // We clamp opacity to keep it between 0 and 1.
            // As progress ratio can be larger than 1 due to overshoot,
            // and we do not want to bounce opacity.
            pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1));
          }
        },
        onComplete: function onComplete() {
          // update resolution after transition ends
          currSlide._setResolution(destinationZoomLevel);
          currSlide.applyCurrentZoomPan();
        }
      });
    }
  }]);
}();
/**
 * @template {string} T
 * @template {string} P
 * @typedef {import('../types.js').AddPostfix<T, P>} AddPostfix<T, P>
 */
/** @typedef {import('./gestures.js').default} Gestures */
/** @typedef {import('../photoswipe.js').Point} Point */
/** @typedef {'imageClick' | 'bgClick' | 'tap' | 'doubleTap'} Actions */
/**
 * Whether the tap was performed on the main slide
 * (rather than controls or caption).
 *
 * @param {PointerEvent} event
 * @returns {boolean}
 */
function didTapOnMainContent(event) {
  return !! /** @type {HTMLElement} */
  event.target.closest('.pswp__container');
}
/**
 * Tap, double-tap handler.
 */
var TapHandler = /*#__PURE__*/function () {
  /**
   * @param {Gestures} gestures
   */
  function TapHandler(gestures) {
    _classCallCheck(this, TapHandler);
    this.gestures = gestures;
  }
  /**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */
  return _createClass(TapHandler, [{
    key: "click",
    value: function click(point, originalEvent) {
      var targetClassList = /** @type {HTMLElement} */
      originalEvent.target.classList;
      var isImageClick = targetClassList.contains('pswp__img');
      var isBackgroundClick = targetClassList.contains('pswp__item') || targetClassList.contains('pswp__zoom-wrap');
      if (isImageClick) {
        this._doClickOrTapAction('imageClick', point, originalEvent);
      } else if (isBackgroundClick) {
        this._doClickOrTapAction('bgClick', point, originalEvent);
      }
    }
    /**
     * @param {Point} point
     * @param {PointerEvent} originalEvent
     */
  }, {
    key: "tap",
    value: function tap(point, originalEvent) {
      if (didTapOnMainContent(originalEvent)) {
        this._doClickOrTapAction('tap', point, originalEvent);
      }
    }
    /**
     * @param {Point} point
     * @param {PointerEvent} originalEvent
     */
  }, {
    key: "doubleTap",
    value: function doubleTap(point, originalEvent) {
      if (didTapOnMainContent(originalEvent)) {
        this._doClickOrTapAction('doubleTap', point, originalEvent);
      }
    }
    /**
     * @private
     * @param {Actions} actionName
     * @param {Point} point
     * @param {PointerEvent} originalEvent
     */
  }, {
    key: "_doClickOrTapAction",
    value: function _doClickOrTapAction(actionName, point, originalEvent) {
      var _this$gestures$pswp$e;
      var pswp = this.gestures.pswp;
      var currSlide = pswp.currSlide;
      var actionFullName = /** @type {AddPostfix<Actions, 'Action'>} */
      actionName + 'Action';
      var optionValue = pswp.options[actionFullName];
      if (pswp.dispatch(actionFullName, {
        point: point,
        originalEvent: originalEvent
      }).defaultPrevented) {
        return;
      }
      if (typeof optionValue === 'function') {
        optionValue.call(pswp, point, originalEvent);
        return;
      }
      switch (optionValue) {
        case 'close':
        case 'next':
          pswp[optionValue]();
          break;
        case 'zoom':
          currSlide === null || currSlide === void 0 || currSlide.toggleZoom(point);
          break;
        case 'zoom-or-close':
          // by default click zooms current image,
          // if it can not be zoomed - gallery will be closed
          if (currSlide !== null && currSlide !== void 0 && currSlide.isZoomable() && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial) {
            currSlide.toggleZoom(point);
          } else if (pswp.options.clickToCloseNonZoomable) {
            pswp.close();
          }
          break;
        case 'toggle-controls':
          (_this$gestures$pswp$e = this.gestures.pswp.element) === null || _this$gestures$pswp$e === void 0 || _this$gestures$pswp$e.classList.toggle('pswp--ui-visible'); // if (_controlsVisible) {
          //   _ui.hideControls();
          // } else {
          //   _ui.showControls();
          // }

          break;
      }
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {import('../photoswipe.js').Point} Point */
// How far should user should drag
// until we can determine that the gesture is swipe and its direction
var AXIS_SWIPE_HYSTERISIS = 10; //const PAN_END_FRICTION = 0.35;

var DOUBLE_TAP_DELAY = 300; // ms

var MIN_TAP_DISTANCE = 25; // px

/**
 * Gestures class bind touch, pointer or mouse events
 * and emits drag to drag-handler and zoom events zoom-handler.
 *
 * Drag and zoom events are emited in requestAnimationFrame,
 * and only when one of pointers was actually changed.
 */
var Gestures = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function Gestures(pswp) {
    var _this5 = this;
    _classCallCheck(this, Gestures);
    this.pswp = pswp;
    /** @type {'x' | 'y' | null} */

    this.dragAxis = null; // point objects are defined once and reused
    // PhotoSwipe keeps track only of two pointers, others are ignored

    /** @type {Point} */

    this.p1 = {
      x: 0,
      y: 0
    }; // the first pressed pointer

    /** @type {Point} */

    this.p2 = {
      x: 0,
      y: 0
    }; // the second pressed pointer

    /** @type {Point} */

    this.prevP1 = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.prevP2 = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.startP1 = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.startP2 = {
      x: 0,
      y: 0
    };
    /** @type {Point} */

    this.velocity = {
      x: 0,
      y: 0
    };
    /** @type {Point}
     * @private
     */

    this._lastStartP1 = {
      x: 0,
      y: 0
    };
    /** @type {Point}
     * @private
     */

    this._intervalP1 = {
      x: 0,
      y: 0
    };
    /** @private */

    this._numActivePoints = 0;
    /** @type {Point[]}
     * @private
     */

    this._ongoingPointers = [];
    /** @private */

    this._touchEventEnabled = 'ontouchstart' in window;
    /** @private */

    this._pointerEventEnabled = !!window.PointerEvent;
    this.supportsTouch = this._touchEventEnabled || this._pointerEventEnabled && navigator.maxTouchPoints > 1;
    /** @private */

    this._numActivePoints = 0;
    /** @private */

    this._intervalTime = 0;
    /** @private */

    this._velocityCalculated = false;
    this.isMultitouch = false;
    this.isDragging = false;
    this.isZooming = false;
    /** @type {number | null} */

    this.raf = null;
    /** @type {NodeJS.Timeout | null}
     * @private
     */

    this._tapTimer = null;
    if (!this.supportsTouch) {
      // disable pan to next slide for non-touch devices
      pswp.options.allowPanToNext = false;
    }
    this.drag = new DragHandler(this);
    this.zoomLevels = new ZoomHandler(this);
    this.tapHandler = new TapHandler(this);
    pswp.on('bindEvents', function () {
      pswp.events.add(pswp.scrollWrap, 'click', /** @type EventListener */
      _this5._onClick.bind(_this5));
      if (_this5._pointerEventEnabled) {
        _this5._bindEvents('pointer', 'down', 'up', 'cancel');
      } else if (_this5._touchEventEnabled) {
        _this5._bindEvents('touch', 'start', 'end', 'cancel'); // In previous versions we also bound mouse event here,
        // in case device supports both touch and mouse events,
        // but newer versions of browsers now support PointerEvent.
        // on iOS10 if you bind touchmove/end after touchstart,
        // and you don't preventDefault touchstart (which PhotoSwipe does),
        // preventDefault will have no effect on touchmove and touchend.
        // Unless you bind it previously.

        if (pswp.scrollWrap) {
          pswp.scrollWrap.ontouchmove = function () {};
          pswp.scrollWrap.ontouchend = function () {};
        }
      } else {
        _this5._bindEvents('mouse', 'down', 'up');
      }
    });
  }
  /**
   * @private
   * @param {'mouse' | 'touch' | 'pointer'} pref
   * @param {'down' | 'start'} down
   * @param {'up' | 'end'} up
   * @param {'cancel'} [cancel]
   */
  return _createClass(Gestures, [{
    key: "_bindEvents",
    value: function _bindEvents(pref, down, up, cancel) {
      var pswp = this.pswp;
      var events = pswp.events;
      var cancelEvent = cancel ? pref + cancel : '';
      events.add(pswp.scrollWrap, pref + down, /** @type EventListener */
      this.onPointerDown.bind(this));
      events.add(window, pref + 'move', /** @type EventListener */
      this.onPointerMove.bind(this));
      events.add(window, pref + up, /** @type EventListener */
      this.onPointerUp.bind(this));
      if (cancelEvent) {
        events.add(pswp.scrollWrap, cancelEvent, /** @type EventListener */
        this.onPointerUp.bind(this));
      }
    }
    /**
     * @param {PointerEvent} e
     */
  }, {
    key: "onPointerDown",
    value: function onPointerDown(e) {
      // We do not call preventDefault for touch events
      // to allow browser to show native dialog on longpress
      // (the one that allows to save image or open it in new tab).
      //
      // Desktop Safari allows to drag images when preventDefault isn't called on mousedown,
      // even though preventDefault IS called on mousemove. That's why we preventDefault mousedown.
      var isMousePointer = e.type === 'mousedown' || e.pointerType === 'mouse'; // Allow dragging only via left mouse button.
      // http://www.quirksmode.org/js/events_properties.html
      // https://developer.mozilla.org/en-US/docs/Web/API/event.button

      if (isMousePointer && e.button > 0) {
        return;
      }
      var pswp = this.pswp; // if PhotoSwipe is opening or closing

      if (!pswp.opener.isOpen) {
        e.preventDefault();
        return;
      }
      if (pswp.dispatch('pointerDown', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (isMousePointer) {
        pswp.mouseDetected(); // preventDefault mouse event to prevent
        // browser image drag feature

        this._preventPointerEventBehaviour(e, 'down');
      }
      pswp.animations.stopAll();
      this._updatePoints(e, 'down');
      if (this._numActivePoints === 1) {
        this.dragAxis = null; // we need to store initial point to determine the main axis,
        // drag is activated only after the axis is determined

        equalizePoints(this.startP1, this.p1);
      }
      if (this._numActivePoints > 1) {
        // Tap or double tap should not trigger if more than one pointer
        this._clearTapTimer();
        this.isMultitouch = true;
      } else {
        this.isMultitouch = false;
      }
    }
    /**
     * @param {PointerEvent} e
     */
  }, {
    key: "onPointerMove",
    value: function onPointerMove(e) {
      this._preventPointerEventBehaviour(e, 'move');
      if (!this._numActivePoints) {
        return;
      }
      this._updatePoints(e, 'move');
      if (this.pswp.dispatch('pointerMove', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (this._numActivePoints === 1 && !this.isDragging) {
        if (!this.dragAxis) {
          this._calculateDragDirection();
        } // Drag axis was detected, emit drag.start

        if (this.dragAxis && !this.isDragging) {
          if (this.isZooming) {
            this.isZooming = false;
            this.zoomLevels.end();
          }
          this.isDragging = true;
          this._clearTapTimer(); // Tap can not trigger after drag
          // Adjust starting point

          this._updateStartPoints();
          this._intervalTime = Date.now(); //this._startTime = this._intervalTime;

          this._velocityCalculated = false;
          equalizePoints(this._intervalP1, this.p1);
          this.velocity.x = 0;
          this.velocity.y = 0;
          this.drag.start();
          this._rafStopLoop();
          this._rafRenderLoop();
        }
      } else if (this._numActivePoints > 1 && !this.isZooming) {
        this._finishDrag();
        this.isZooming = true; // Adjust starting points

        this._updateStartPoints();
        this.zoomLevels.start();
        this._rafStopLoop();
        this._rafRenderLoop();
      }
    }
    /**
     * @private
     */
  }, {
    key: "_finishDrag",
    value: function _finishDrag() {
      if (this.isDragging) {
        this.isDragging = false; // Try to calculate velocity,
        // if it wasn't calculated yet in drag.change

        if (!this._velocityCalculated) {
          this._updateVelocity(true);
        }
        this.drag.end();
        this.dragAxis = null;
      }
    }
    /**
     * @param {PointerEvent} e
     */
  }, {
    key: "onPointerUp",
    value: function onPointerUp(e) {
      if (!this._numActivePoints) {
        return;
      }
      this._updatePoints(e, 'up');
      if (this.pswp.dispatch('pointerUp', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (this._numActivePoints === 0) {
        this._rafStopLoop();
        if (this.isDragging) {
          this._finishDrag();
        } else if (!this.isZooming && !this.isMultitouch) {
          //this.zoomLevels.correctZoomPan();
          this._finishTap(e);
        }
      }
      if (this._numActivePoints < 2 && this.isZooming) {
        this.isZooming = false;
        this.zoomLevels.end();
        if (this._numActivePoints === 1) {
          // Since we have 1 point left, we need to reinitiate drag
          this.dragAxis = null;
          this._updateStartPoints();
        }
      }
    }
    /**
     * @private
     */
  }, {
    key: "_rafRenderLoop",
    value: function _rafRenderLoop() {
      if (this.isDragging || this.isZooming) {
        this._updateVelocity();
        if (this.isDragging) {
          // make sure that pointer moved since the last update
          if (!pointsEqual(this.p1, this.prevP1)) {
            this.drag.change();
          }
        } else /* if (this.isZooming) */
          {
            if (!pointsEqual(this.p1, this.prevP1) || !pointsEqual(this.p2, this.prevP2)) {
              this.zoomLevels.change();
            }
          }
        this._updatePrevPoints();
        this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this));
      }
    }
    /**
     * Update velocity at 50ms interval
     *
     * @private
     * @param {boolean} [force]
     */
  }, {
    key: "_updateVelocity",
    value: function _updateVelocity(force) {
      var time = Date.now();
      var duration = time - this._intervalTime;
      if (duration < 50 && !force) {
        return;
      }
      this.velocity.x = this._getVelocity('x', duration);
      this.velocity.y = this._getVelocity('y', duration);
      this._intervalTime = time;
      equalizePoints(this._intervalP1, this.p1);
      this._velocityCalculated = true;
    }
    /**
     * @private
     * @param {PointerEvent} e
     */
  }, {
    key: "_finishTap",
    value: function _finishTap(e) {
      var _this6 = this;
      var mainScroll = this.pswp.mainScroll; // Do not trigger tap events if main scroll is shifted

      if (mainScroll.isShifted()) {
        // restore main scroll position
        // (usually happens if stopped in the middle of animation)
        mainScroll.moveIndexBy(0, true);
        return;
      } // Do not trigger tap for touchcancel or pointercancel

      if (e.type.indexOf('cancel') > 0) {
        return;
      } // Trigger click instead of tap for mouse events

      if (e.type === 'mouseup' || e.pointerType === 'mouse') {
        this.tapHandler.click(this.startP1, e);
        return;
      } // Disable delay if there is no doubleTapAction

      var tapDelay = this.pswp.options.doubleTapAction ? DOUBLE_TAP_DELAY : 0; // If tapTimer is defined - we tapped recently,
      // check if the current tap is close to the previous one,
      // if yes - trigger double tap

      if (this._tapTimer) {
        this._clearTapTimer(); // Check if two taps were more or less on the same place

        if (getDistanceBetween(this._lastStartP1, this.startP1) < MIN_TAP_DISTANCE) {
          this.tapHandler.doubleTap(this.startP1, e);
        }
      } else {
        equalizePoints(this._lastStartP1, this.startP1);
        this._tapTimer = setTimeout(function () {
          _this6.tapHandler.tap(_this6.startP1, e);
          _this6._clearTapTimer();
        }, tapDelay);
      }
    }
    /**
     * @private
     */
  }, {
    key: "_clearTapTimer",
    value: function _clearTapTimer() {
      if (this._tapTimer) {
        clearTimeout(this._tapTimer);
        this._tapTimer = null;
      }
    }
    /**
     * Get velocity for axis
     *
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} duration
     * @returns {number}
     */
  }, {
    key: "_getVelocity",
    value: function _getVelocity(axis, duration) {
      // displacement is like distance, but can be negative.
      var displacement = this.p1[axis] - this._intervalP1[axis];
      if (Math.abs(displacement) > 1 && duration > 5) {
        return displacement / duration;
      }
      return 0;
    }
    /**
     * @private
     */
  }, {
    key: "_rafStopLoop",
    value: function _rafStopLoop() {
      if (this.raf) {
        cancelAnimationFrame(this.raf);
        this.raf = null;
      }
    }
    /**
     * @private
     * @param {PointerEvent} e
     * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
     */
  }, {
    key: "_preventPointerEventBehaviour",
    value: function _preventPointerEventBehaviour(e, pointerType) {
      var preventPointerEvent = this.pswp.applyFilters('preventPointerEvent', true, e, pointerType);
      if (preventPointerEvent) {
        e.preventDefault();
      }
    }
    /**
     * Parses and normalizes points from the touch, mouse or pointer event.
     * Updates p1 and p2.
     *
     * @private
     * @param {PointerEvent | TouchEvent} e
     * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
     */
  }, {
    key: "_updatePoints",
    value: function _updatePoints(e, pointerType) {
      if (this._pointerEventEnabled) {
        var pointerEvent = /** @type {PointerEvent} */
        e; // Try to find the current pointer in ongoing pointers by its ID

        var pointerIndex = this._ongoingPointers.findIndex(function (ongoingPointer) {
          return ongoingPointer.id === pointerEvent.pointerId;
        });
        if (pointerType === 'up' && pointerIndex > -1) {
          // release the pointer - remove it from ongoing
          this._ongoingPointers.splice(pointerIndex, 1);
        } else if (pointerType === 'down' && pointerIndex === -1) {
          // add new pointer
          this._ongoingPointers.push(this._convertEventPosToPoint(pointerEvent, {
            x: 0,
            y: 0
          }));
        } else if (pointerIndex > -1) {
          // update existing pointer
          this._convertEventPosToPoint(pointerEvent, this._ongoingPointers[pointerIndex]);
        }
        this._numActivePoints = this._ongoingPointers.length; // update points that PhotoSwipe uses
        // to calculate position and scale

        if (this._numActivePoints > 0) {
          equalizePoints(this.p1, this._ongoingPointers[0]);
        }
        if (this._numActivePoints > 1) {
          equalizePoints(this.p2, this._ongoingPointers[1]);
        }
      } else {
        var touchEvent = /** @type {TouchEvent} */
        e;
        this._numActivePoints = 0;
        if (touchEvent.type.indexOf('touch') > -1) {
          // Touch Event
          // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
          if (touchEvent.touches && touchEvent.touches.length > 0) {
            this._convertEventPosToPoint(touchEvent.touches[0], this.p1);
            this._numActivePoints++;
            if (touchEvent.touches.length > 1) {
              this._convertEventPosToPoint(touchEvent.touches[1], this.p2);
              this._numActivePoints++;
            }
          }
        } else {
          // Mouse Event
          this._convertEventPosToPoint(/** @type {PointerEvent} */
          e, this.p1);
          if (pointerType === 'up') {
            // clear all points on mouseup
            this._numActivePoints = 0;
          } else {
            this._numActivePoints++;
          }
        }
      }
    }
    /** update points that were used during previous rAF tick
     * @private
     */
  }, {
    key: "_updatePrevPoints",
    value: function _updatePrevPoints() {
      equalizePoints(this.prevP1, this.p1);
      equalizePoints(this.prevP2, this.p2);
    }
    /** update points at the start of gesture
     * @private
     */
  }, {
    key: "_updateStartPoints",
    value: function _updateStartPoints() {
      equalizePoints(this.startP1, this.p1);
      equalizePoints(this.startP2, this.p2);
      this._updatePrevPoints();
    }
    /** @private */
  }, {
    key: "_calculateDragDirection",
    value: function _calculateDragDirection() {
      if (this.pswp.mainScroll.isShifted()) {
        // if main scroll position is shifted – direction is always horizontal
        this.dragAxis = 'x';
      } else {
        // calculate delta of the last touchmove tick
        var diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);
        if (diff !== 0) {
          // check if pointer was shifted horizontally or vertically
          var axisToCheck = diff > 0 ? 'x' : 'y';
          if (Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= AXIS_SWIPE_HYSTERISIS) {
            this.dragAxis = axisToCheck;
          }
        }
      }
    }
    /**
     * Converts touch, pointer or mouse event
     * to PhotoSwipe point.
     *
     * @private
     * @param {Touch | PointerEvent} e
     * @param {Point} p
     * @returns {Point}
     */
  }, {
    key: "_convertEventPosToPoint",
    value: function _convertEventPosToPoint(e, p) {
      p.x = e.pageX - this.pswp.offset.x;
      p.y = e.pageY - this.pswp.offset.y;
      if ('pointerId' in e) {
        p.id = e.pointerId;
      } else if (e.identifier !== undefined) {
        p.id = e.identifier;
      }
      return p;
    }
    /**
     * @private
     * @param {PointerEvent} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      // Do not allow click event to pass through after drag
      if (this.pswp.mainScroll.isShifted()) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }]);
}();
/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./slide/slide.js').default} Slide */
/** @typedef {{ el: HTMLDivElement; slide?: Slide }} ItemHolder */
var MAIN_SCROLL_END_FRICTION = 0.35; // const MIN_SWIPE_TRANSITION_DURATION = 250;
// const MAX_SWIPE_TRABSITION_DURATION = 500;
// const DEFAULT_SWIPE_TRANSITION_DURATION = 333;

/**
 * Handles movement of the main scrolling container
 * (for example, it repositions when user swipes left or right).
 *
 * Also stores its state.
 */
var MainScroll = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function MainScroll(pswp) {
    _classCallCheck(this, MainScroll);
    this.pswp = pswp;
    this.x = 0;
    this.slideWidth = 0;
    /** @private */

    this._currPositionIndex = 0;
    /** @private */

    this._prevPositionIndex = 0;
    /** @private */

    this._containerShiftIndex = -1;
    /** @type {ItemHolder[]} */

    this.itemHolders = [];
  }
  /**
   * Position the scroller and slide containers
   * according to viewport size.
   *
   * @param {boolean} [resizeSlides] Whether slides content should resized
   */
  return _createClass(MainScroll, [{
    key: "resize",
    value: function resize(resizeSlides) {
      var _this7 = this;
      var pswp = this.pswp;
      var newSlideWidth = Math.round(pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing); // Mobile browsers might trigger a resize event during a gesture.
      // (due to toolbar appearing or hiding).
      // Avoid re-adjusting main scroll position if width wasn't changed

      var slideWidthChanged = newSlideWidth !== this.slideWidth;
      if (slideWidthChanged) {
        this.slideWidth = newSlideWidth;
        this.moveTo(this.getCurrSlideX());
      }
      this.itemHolders.forEach(function (itemHolder, index) {
        if (slideWidthChanged) {
          setTransform(itemHolder.el, (index + _this7._containerShiftIndex) * _this7.slideWidth);
        }
        if (resizeSlides && itemHolder.slide) {
          itemHolder.slide.resize();
        }
      });
    }
    /**
     * Reset X position of the main scroller to zero
     */
  }, {
    key: "resetPosition",
    value: function resetPosition() {
      // Position on the main scroller (offset)
      // it is independent from slide index
      this._currPositionIndex = 0;
      this._prevPositionIndex = 0; // This will force recalculation of size on next resize()

      this.slideWidth = 0; // _containerShiftIndex*viewportSize will give you amount of transform of the current slide

      this._containerShiftIndex = -1;
    }
    /**
     * Create and append array of three items
     * that hold data about slides in DOM
     */
  }, {
    key: "appendHolders",
    value: function appendHolders() {
      this.itemHolders = []; // append our three slide holders -
      // previous, current, and next

      for (var i = 0; i < 3; i++) {
        var el = createElement('pswp__item', 'div', this.pswp.container);
        el.setAttribute('role', 'group');
        el.setAttribute('aria-roledescription', 'slide');
        el.setAttribute('aria-hidden', 'true'); // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)

        el.style.display = i === 1 ? 'block' : 'none';
        this.itemHolders.push({
          el: el //index: -1
        });
      }
    }
    /**
     * Whether the main scroll can be horizontally swiped to the next or previous slide.
     * @returns {boolean}
     */
  }, {
    key: "canBeSwiped",
    value: function canBeSwiped() {
      return this.pswp.getNumItems() > 1;
    }
    /**
     * Move main scroll by X amount of slides.
     * For example:
     *   `-1` will move to the previous slide,
     *    `0` will reset the scroll position of the current slide,
     *    `3` will move three slides forward
     *
     * If loop option is enabled - index will be automatically looped too,
     * (for example `-1` will move to the last slide of the gallery).
     *
     * @param {number} diff
     * @param {boolean} [animate]
     * @param {number} [velocityX]
     * @returns {boolean} whether index was changed or not
     */
  }, {
    key: "moveIndexBy",
    value: function moveIndexBy(diff, animate, velocityX) {
      var _this8 = this;
      var pswp = this.pswp;
      var newIndex = pswp.potentialIndex + diff;
      var numSlides = pswp.getNumItems();
      if (pswp.canLoop()) {
        newIndex = pswp.getLoopedIndex(newIndex);
        var distance = (diff + numSlides) % numSlides;
        if (distance <= numSlides / 2) {
          // go forward
          diff = distance;
        } else {
          // go backwards
          diff = distance - numSlides;
        }
      } else {
        if (newIndex < 0) {
          newIndex = 0;
        } else if (newIndex >= numSlides) {
          newIndex = numSlides - 1;
        }
        diff = newIndex - pswp.potentialIndex;
      }
      pswp.potentialIndex = newIndex;
      this._currPositionIndex -= diff;
      pswp.animations.stopMainScroll();
      var destinationX = this.getCurrSlideX();
      if (!animate) {
        this.moveTo(destinationX);
        this.updateCurrItem();
      } else {
        pswp.animations.startSpring({
          isMainScroll: true,
          start: this.x,
          end: destinationX,
          velocity: velocityX || 0,
          naturalFrequency: 30,
          dampingRatio: 1,
          //0.7,
          onUpdate: function onUpdate(x) {
            _this8.moveTo(x);
          },
          onComplete: function onComplete() {
            _this8.updateCurrItem();
            pswp.appendHeavy();
          }
        });
        var currDiff = pswp.potentialIndex - pswp.currIndex;
        if (pswp.canLoop()) {
          var currDistance = (currDiff + numSlides) % numSlides;
          if (currDistance <= numSlides / 2) {
            // go forward
            currDiff = currDistance;
          } else {
            // go backwards
            currDiff = currDistance - numSlides;
          }
        } // Force-append new slides during transition
        // if difference between slides is more than 1

        if (Math.abs(currDiff) > 1) {
          this.updateCurrItem();
        }
      }
      return Boolean(diff);
    }
    /**
     * X position of the main scroll for the current slide
     * (ignores position during dragging)
     * @returns {number}
     */
  }, {
    key: "getCurrSlideX",
    value: function getCurrSlideX() {
      return this.slideWidth * this._currPositionIndex;
    }
    /**
     * Whether scroll position is shifted.
     * For example, it will return true if the scroll is being dragged or animated.
     * @returns {boolean}
     */
  }, {
    key: "isShifted",
    value: function isShifted() {
      return this.x !== this.getCurrSlideX();
    }
    /**
     * Update slides X positions and set their content
     */
  }, {
    key: "updateCurrItem",
    value: function updateCurrItem() {
      var _this$itemHolders$;
      var pswp = this.pswp;
      var positionDifference = this._prevPositionIndex - this._currPositionIndex;
      if (!positionDifference) {
        return;
      }
      this._prevPositionIndex = this._currPositionIndex;
      pswp.currIndex = pswp.potentialIndex;
      var diffAbs = Math.abs(positionDifference);
      /** @type {ItemHolder | undefined} */

      var tempHolder;
      if (diffAbs >= 3) {
        this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3);
        diffAbs = 3; // If slides are changed by 3 screens or more - clean up previous slides

        this.itemHolders.forEach(function (itemHolder) {
          var _itemHolder$slide;
          (_itemHolder$slide = itemHolder.slide) === null || _itemHolder$slide === void 0 || _itemHolder$slide.destroy();
          itemHolder.slide = undefined;
        });
      }
      for (var i = 0; i < diffAbs; i++) {
        if (positionDifference > 0) {
          tempHolder = this.itemHolders.shift();
          if (tempHolder) {
            this.itemHolders[2] = tempHolder; // move first to last

            this._containerShiftIndex++;
            setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth);
            pswp.setContent(tempHolder, pswp.currIndex - diffAbs + i + 2);
          }
        } else {
          tempHolder = this.itemHolders.pop();
          if (tempHolder) {
            this.itemHolders.unshift(tempHolder); // move last to first

            this._containerShiftIndex--;
            setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth);
            pswp.setContent(tempHolder, pswp.currIndex + diffAbs - i - 2);
          }
        }
      } // Reset transfrom every 50ish navigations in one direction.
      //
      // Otherwise transform will keep growing indefinitely,
      // which might cause issues as browsers have a maximum transform limit.
      // I wasn't able to reach it, but just to be safe.
      // This should not cause noticable lag.

      if (Math.abs(this._containerShiftIndex) > 50 && !this.isShifted()) {
        this.resetPosition();
        this.resize();
      } // Pan transition might be running (and consntantly updating pan position)

      pswp.animations.stopAllPan();
      this.itemHolders.forEach(function (itemHolder, i) {
        if (itemHolder.slide) {
          // Slide in the 2nd holder is always active
          itemHolder.slide.setIsActive(i === 1);
        }
      });
      pswp.currSlide = (_this$itemHolders$ = this.itemHolders[1]) === null || _this$itemHolders$ === void 0 ? void 0 : _this$itemHolders$.slide;
      pswp.contentLoader.updateLazy(positionDifference);
      if (pswp.currSlide) {
        pswp.currSlide.applyCurrentZoomPan();
      }
      pswp.dispatch('change');
    }
    /**
     * Move the X position of the main scroll container
     *
     * @param {number} x
     * @param {boolean} [dragging]
     */
  }, {
    key: "moveTo",
    value: function moveTo(x, dragging) {
      if (!this.pswp.canLoop() && dragging) {
        // Apply friction
        var newSlideIndexOffset = (this.slideWidth * this._currPositionIndex - x) / this.slideWidth;
        newSlideIndexOffset += this.pswp.currIndex;
        var delta = Math.round(x - this.x);
        if (newSlideIndexOffset < 0 && delta > 0 || newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0) {
          x = this.x + delta * MAIN_SCROLL_END_FRICTION;
        }
      }
      this.x = x;
      if (this.pswp.container) {
        setTransform(this.pswp.container, x);
      }
      this.pswp.dispatch('moveMainScroll', {
        x: x,
        dragging: dragging !== null && dragging !== void 0 ? dragging : false
      });
    }
  }]);
}();
/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/**
 * @template T
 * @typedef {import('./types.js').Methods<T>} Methods<T>
 */
var KeyboardKeyCodesMap = {
  Escape: 27,
  z: 90,
  ArrowLeft: 37,
  ArrowUp: 38,
  ArrowRight: 39,
  ArrowDown: 40,
  Tab: 9
};
/**
 * @template {keyof KeyboardKeyCodesMap} T
 * @param {T} key
 * @param {boolean} isKeySupported
 * @returns {T | number | undefined}
 */

var getKeyboardEventKey = function getKeyboardEventKey(key, isKeySupported) {
  return isKeySupported ? key : KeyboardKeyCodesMap[key];
};
/**
 * - Manages keyboard shortcuts.
 * - Helps trap focus within photoswipe.
 */
var Keyboard = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function Keyboard(pswp) {
    var _this9 = this;
    _classCallCheck(this, Keyboard);
    this.pswp = pswp;
    /** @private */

    this._wasFocused = false;
    pswp.on('bindEvents', function () {
      if (pswp.options.trapFocus) {
        // Dialog was likely opened by keyboard if initial point is not defined
        if (!pswp.options.initialPointerPos) {
          // focus causes layout,
          // which causes lag during the animation,
          // that's why we delay it until the opener transition ends
          _this9._focusRoot();
        }
        pswp.events.add(document, 'focusin', /** @type EventListener */
        _this9._onFocusIn.bind(_this9));
      }
      pswp.events.add(document, 'keydown', /** @type EventListener */
      _this9._onKeyDown.bind(_this9));
    });
    var lastActiveElement = /** @type {HTMLElement} */
    document.activeElement;
    pswp.on('destroy', function () {
      if (pswp.options.returnFocus && lastActiveElement && _this9._wasFocused) {
        lastActiveElement.focus();
      }
    });
  }
  /** @private */
  return _createClass(Keyboard, [{
    key: "_focusRoot",
    value: function _focusRoot() {
      if (!this._wasFocused && this.pswp.element) {
        this.pswp.element.focus();
        this._wasFocused = true;
      }
    }
    /**
     * @private
     * @param {KeyboardEvent} e
     */
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(e) {
      var pswp = this.pswp;
      if (pswp.dispatch('keydown', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (specialKeyUsed(e)) {
        // don't do anything if special key pressed
        // to prevent from overriding default browser actions
        // for example, in Chrome on Mac cmd+arrow-left returns to previous page
        return;
      }
      /** @type {Methods<PhotoSwipe> | undefined} */

      var keydownAction;
      /** @type {'x' | 'y' | undefined} */

      var axis;
      var isForward = false;
      var isKeySupported = 'key' in e;
      switch (isKeySupported ? e.key : e.keyCode) {
        case getKeyboardEventKey('Escape', isKeySupported):
          if (pswp.options.escKey) {
            keydownAction = 'close';
          }
          break;
        case getKeyboardEventKey('z', isKeySupported):
          keydownAction = 'toggleZoom';
          break;
        case getKeyboardEventKey('ArrowLeft', isKeySupported):
          axis = 'x';
          break;
        case getKeyboardEventKey('ArrowUp', isKeySupported):
          axis = 'y';
          break;
        case getKeyboardEventKey('ArrowRight', isKeySupported):
          axis = 'x';
          isForward = true;
          break;
        case getKeyboardEventKey('ArrowDown', isKeySupported):
          isForward = true;
          axis = 'y';
          break;
        case getKeyboardEventKey('Tab', isKeySupported):
          this._focusRoot();
          break;
      } // if left/right/top/bottom key

      if (axis) {
        // prevent page scroll
        e.preventDefault();
        var currSlide = pswp.currSlide;
        if (pswp.options.arrowKeys && axis === 'x' && pswp.getNumItems() > 1) {
          keydownAction = isForward ? 'next' : 'prev';
        } else if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit) {
          // up/down arrow keys pan the image vertically
          // left/right arrow keys pan horizontally.
          // Unless there is only one image,
          // or arrowKeys option is disabled
          currSlide.pan[axis] += isForward ? -80 : 80;
          currSlide.panTo(currSlide.pan.x, currSlide.pan.y);
        }
      }
      if (keydownAction) {
        e.preventDefault(); // @ts-ignore

        pswp[keydownAction]();
      }
    }
    /**
     * Trap focus inside photoswipe
     *
     * @private
     * @param {FocusEvent} e
     */
  }, {
    key: "_onFocusIn",
    value: function _onFocusIn(e) {
      var template = this.pswp.template;
      if (template && document !== e.target && template !== e.target && !template.contains(/** @type {Node} */
      e.target)) {
        // focus root element
        template.focus();
      }
    }
  }]);
}();
var DEFAULT_EASING = 'cubic-bezier(.4,0,.22,1)';
/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */

/** @typedef {Object} DefaultCssAnimationProps
 *
 * @prop {HTMLElement} target
 * @prop {number} [duration]
 * @prop {string} [easing]
 * @prop {string} [transform]
 * @prop {string} [opacity]
 * */

/** @typedef {SharedAnimationProps & DefaultCssAnimationProps} CssAnimationProps */

/**
 * Runs CSS transition.
 */
var CSSAnimation = /*#__PURE__*/function () {
  /**
   * onComplete can be unpredictable, be careful about current state
   *
   * @param {CssAnimationProps} props
   */
  function CSSAnimation(props) {
    var _this0 = this;
    _classCallCheck(this, CSSAnimation);
    var _props$prop;
    this.props = props;
    var target = props.target,
      onComplete = props.onComplete,
      transform = props.transform,
      _props$onFinish = props.onFinish,
      onFinish = _props$onFinish === void 0 ? function () {} : _props$onFinish,
      _props$duration = props.duration,
      duration = _props$duration === void 0 ? 333 : _props$duration,
      _props$easing = props.easing,
      easing = _props$easing === void 0 ? DEFAULT_EASING : _props$easing;
    this.onFinish = onFinish; // support only transform and opacity

    var prop = transform ? 'transform' : 'opacity';
    var propValue = (_props$prop = props[prop]) !== null && _props$prop !== void 0 ? _props$prop : '';
    /** @private */

    this._target = target;
    /** @private */

    this._onComplete = onComplete;
    /** @private */

    this._finished = false;
    /** @private */

    this._onTransitionEnd = this._onTransitionEnd.bind(this); // Using timeout hack to make sure that animation
    // starts even if the animated property was changed recently,
    // otherwise transitionend might not fire or transition won't start.
    // https://drafts.csswg.org/css-transitions/#starting
    //
    // ¯\_(ツ)_/¯

    /** @private */

    this._helperTimeout = setTimeout(function () {
      setTransitionStyle(target, prop, duration, easing);
      _this0._helperTimeout = setTimeout(function () {
        target.addEventListener('transitionend', _this0._onTransitionEnd, false);
        target.addEventListener('transitioncancel', _this0._onTransitionEnd, false); // Safari occasionally does not emit transitionend event
        // if element property was modified during the transition,
        // which may be caused by resize or third party component,
        // using timeout as a safety fallback

        _this0._helperTimeout = setTimeout(function () {
          _this0._finalizeAnimation();
        }, duration + 500);
        target.style[prop] = propValue;
      }, 30); // Do not reduce this number
    }, 0);
  }
  /**
   * @private
   * @param {TransitionEvent} e
   */
  return _createClass(CSSAnimation, [{
    key: "_onTransitionEnd",
    value: function _onTransitionEnd(e) {
      if (e.target === this._target) {
        this._finalizeAnimation();
      }
    }
    /**
     * @private
     */
  }, {
    key: "_finalizeAnimation",
    value: function _finalizeAnimation() {
      if (!this._finished) {
        this._finished = true;
        this.onFinish();
        if (this._onComplete) {
          this._onComplete();
        }
      }
    } // Destroy is called automatically onFinish
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._helperTimeout) {
        clearTimeout(this._helperTimeout);
      }
      removeTransitionStyle(this._target);
      this._target.removeEventListener('transitionend', this._onTransitionEnd, false);
      this._target.removeEventListener('transitioncancel', this._onTransitionEnd, false);
      if (!this._finished) {
        this._finalizeAnimation();
      }
    }
  }]);
}();
var DEFAULT_NATURAL_FREQUENCY = 12;
var DEFAULT_DAMPING_RATIO = 0.75;
/**
 * Spring easing helper
 */
var SpringEaser = /*#__PURE__*/function () {
  /**
   * @param {number} initialVelocity Initial velocity, px per ms.
   *
   * @param {number} [dampingRatio]
   * Determines how bouncy animation will be.
   * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.
   * "overshoot" refers to part of animation that
   * goes beyond the final value.
   *
   * @param {number} [naturalFrequency]
   * Determines how fast animation will slow down.
   * The higher value - the stiffer the transition will be,
   * and the faster it will slow down.
   * Recommended value from 10 to 50
   */
  function SpringEaser(initialVelocity, dampingRatio, naturalFrequency) {
    _classCallCheck(this, SpringEaser);
    this.velocity = initialVelocity * 1000; // convert to "pixels per second"
    // https://en.wikipedia.org/wiki/Damping_ratio

    this._dampingRatio = dampingRatio || DEFAULT_DAMPING_RATIO; // https://en.wikipedia.org/wiki/Natural_frequency

    this._naturalFrequency = naturalFrequency || DEFAULT_NATURAL_FREQUENCY;
    this._dampedFrequency = this._naturalFrequency;
    if (this._dampingRatio < 1) {
      this._dampedFrequency *= Math.sqrt(1 - this._dampingRatio * this._dampingRatio);
    }
  }
  /**
   * @param {number} deltaPosition Difference between current and end position of the animation
   * @param {number} deltaTime Frame duration in milliseconds
   *
   * @returns {number} Displacement, relative to the end position.
   */
  return _createClass(SpringEaser, [{
    key: "easeFrame",
    value: function easeFrame(deltaPosition, deltaTime) {
      // Inspired by Apple Webkit and Android spring function implementation
      // https://en.wikipedia.org/wiki/Oscillation
      // https://en.wikipedia.org/wiki/Damping_ratio
      // we ignore mass (assume that it's 1kg)
      var displacement = 0;
      var coeff;
      deltaTime /= 1000;
      var naturalDumpingPow = Math.pow(Math.E, -this._dampingRatio * this._naturalFrequency * deltaTime);
      if (this._dampingRatio === 1) {
        coeff = this.velocity + this._naturalFrequency * deltaPosition;
        displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow;
        this.velocity = displacement * -this._naturalFrequency + coeff * naturalDumpingPow;
      } else if (this._dampingRatio < 1) {
        coeff = 1 / this._dampedFrequency * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);
        var dumpedFCos = Math.cos(this._dampedFrequency * deltaTime);
        var dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);
        displacement = naturalDumpingPow * (deltaPosition * dumpedFCos + coeff * dumpedFSin);
        this.velocity = displacement * -this._naturalFrequency * this._dampingRatio + naturalDumpingPow * (-this._dampedFrequency * deltaPosition * dumpedFSin + this._dampedFrequency * coeff * dumpedFCos);
      } // Overdamped (>1) damping ratio is not supported

      return displacement;
    }
  }]);
}();
/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */
/**
 * @typedef {Object} DefaultSpringAnimationProps
 *
 * @prop {number} start
 * @prop {number} end
 * @prop {number} velocity
 * @prop {number} [dampingRatio]
 * @prop {number} [naturalFrequency]
 * @prop {(end: number) => void} onUpdate
 */
/** @typedef {SharedAnimationProps & DefaultSpringAnimationProps} SpringAnimationProps */
var SpringAnimation = /*#__PURE__*/function () {
  /**
   * @param {SpringAnimationProps} props
   */
  function SpringAnimation(props) {
    var _this1 = this;
    _classCallCheck(this, SpringAnimation);
    this.props = props;
    this._raf = 0;
    var start = props.start,
      end = props.end,
      velocity = props.velocity,
      onUpdate = props.onUpdate,
      onComplete = props.onComplete,
      _props$onFinish2 = props.onFinish,
      onFinish = _props$onFinish2 === void 0 ? function () {} : _props$onFinish2,
      dampingRatio = props.dampingRatio,
      naturalFrequency = props.naturalFrequency;
    this.onFinish = onFinish;
    var easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);
    var prevTime = Date.now();
    var deltaPosition = start - end;
    var _animationLoop = function animationLoop() {
      if (_this1._raf) {
        deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime); // Stop the animation if velocity is low and position is close to end

        if (Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50) {
          // Finalize the animation
          onUpdate(end);
          if (onComplete) {
            onComplete();
          }
          _this1.onFinish();
        } else {
          prevTime = Date.now();
          onUpdate(deltaPosition + end);
          _this1._raf = requestAnimationFrame(_animationLoop);
        }
      }
    };
    this._raf = requestAnimationFrame(_animationLoop);
  } // Destroy is called automatically onFinish
  return _createClass(SpringAnimation, [{
    key: "destroy",
    value: function destroy() {
      if (this._raf >= 0) {
        cancelAnimationFrame(this._raf);
      }
      this._raf = 0;
    }
  }]);
}();
/** @typedef {import('./css-animation.js').CssAnimationProps} CssAnimationProps */
/** @typedef {import('./spring-animation.js').SpringAnimationProps} SpringAnimationProps */
/** @typedef {Object} SharedAnimationProps
 * @prop {string} [name]
 * @prop {boolean} [isPan]
 * @prop {boolean} [isMainScroll]
 * @prop {VoidFunction} [onComplete]
 * @prop {VoidFunction} [onFinish]
 */
/** @typedef {SpringAnimation | CSSAnimation} Animation */
/** @typedef {SpringAnimationProps | CssAnimationProps} AnimationProps */
/**
 * Manages animations
 */
var Animations = /*#__PURE__*/function () {
  function Animations() {
    _classCallCheck(this, Animations);
    /** @type {Animation[]} */
    this.activeAnimations = [];
  }
  /**
   * @param {SpringAnimationProps} props
   */
  return _createClass(Animations, [{
    key: "startSpring",
    value: function startSpring(props) {
      this._start(props, true);
    }
    /**
     * @param {CssAnimationProps} props
     */
  }, {
    key: "startTransition",
    value: function startTransition(props) {
      this._start(props);
    }
    /**
     * @private
     * @param {AnimationProps} props
     * @param {boolean} [isSpring]
     * @returns {Animation}
     */
  }, {
    key: "_start",
    value: function _start(props, isSpring) {
      var _this10 = this;
      var animation = isSpring ? new SpringAnimation(/** @type SpringAnimationProps */
      props) : new CSSAnimation(/** @type CssAnimationProps */
      props);
      this.activeAnimations.push(animation);
      animation.onFinish = function () {
        return _this10.stop(animation);
      };
      return animation;
    }
    /**
     * @param {Animation} animation
     */
  }, {
    key: "stop",
    value: function stop(animation) {
      animation.destroy();
      var index = this.activeAnimations.indexOf(animation);
      if (index > -1) {
        this.activeAnimations.splice(index, 1);
      }
    }
  }, {
    key: "stopAll",
    value: function stopAll() {
      // _stopAllAnimations
      this.activeAnimations.forEach(function (animation) {
        animation.destroy();
      });
      this.activeAnimations = [];
    }
    /**
     * Stop all pan or zoom transitions
     */
  }, {
    key: "stopAllPan",
    value: function stopAllPan() {
      this.activeAnimations = this.activeAnimations.filter(function (animation) {
        if (animation.props.isPan) {
          animation.destroy();
          return false;
        }
        return true;
      });
    }
  }, {
    key: "stopMainScroll",
    value: function stopMainScroll() {
      this.activeAnimations = this.activeAnimations.filter(function (animation) {
        if (animation.props.isMainScroll) {
          animation.destroy();
          return false;
        }
        return true;
      });
    }
    /**
     * Returns true if main scroll transition is running
     */
    // isMainScrollRunning() {
    //   return this.activeAnimations.some((animation) => {
    //     return animation.props.isMainScroll;
    //   });
    // }

    /**
     * Returns true if any pan or zoom transition is running
     */
  }, {
    key: "isPanRunning",
    value: function isPanRunning() {
      return this.activeAnimations.some(function (animation) {
        return animation.props.isPan;
      });
    }
  }]);
}();
/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/**
 * Handles scroll wheel.
 * Can pan and zoom current slide image.
 */
var ScrollWheel = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function ScrollWheel(pswp) {
    _classCallCheck(this, ScrollWheel);
    this.pswp = pswp;
    pswp.events.add(pswp.element, 'wheel', /** @type EventListener */
    this._onWheel.bind(this));
  }
  /**
   * @private
   * @param {WheelEvent} e
   */
  return _createClass(ScrollWheel, [{
    key: "_onWheel",
    value: function _onWheel(e) {
      e.preventDefault();
      var currSlide = this.pswp.currSlide;
      var deltaX = e.deltaX,
        deltaY = e.deltaY;
      if (!currSlide) {
        return;
      }
      if (this.pswp.dispatch('wheel', {
        originalEvent: e
      }).defaultPrevented) {
        return;
      }
      if (e.ctrlKey || this.pswp.options.wheelToZoom) {
        // zoom
        if (currSlide.isZoomable()) {
          var zoomFactor = -deltaY;
          if (e.deltaMode === 1
          /* DOM_DELTA_LINE */) {
            zoomFactor *= 0.05;
          } else {
            zoomFactor *= e.deltaMode ? 1 : 0.002;
          }
          zoomFactor = Math.pow(2, zoomFactor);
          var destZoomLevel = currSlide.currZoomLevel * zoomFactor;
          currSlide.zoomTo(destZoomLevel, {
            x: e.clientX,
            y: e.clientY
          });
        }
      } else {
        // pan
        if (currSlide.isPannable()) {
          if (e.deltaMode === 1
          /* DOM_DELTA_LINE */) {
            // 18 - average line height
            deltaX *= 18;
            deltaY *= 18;
          }
          currSlide.panTo(currSlide.pan.x - deltaX, currSlide.pan.y - deltaY);
        }
      }
    }
  }]);
}();
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/**
 * @template T
 * @typedef {import('../types.js').Methods<T>} Methods<T>
 */
/**
 * @typedef {Object} UIElementMarkupProps
 * @prop {boolean} [isCustomSVG]
 * @prop {string} inner
 * @prop {string} [outlineID]
 * @prop {number | string} [size]
 */
/**
 * @typedef {Object} UIElementData
 * @prop {DefaultUIElements | string} [name]
 * @prop {string} [className]
 * @prop {UIElementMarkup} [html]
 * @prop {boolean} [isButton]
 * @prop {keyof HTMLElementTagNameMap} [tagName]
 * @prop {string} [title]
 * @prop {string} [ariaLabel]
 * @prop {(element: HTMLElement, pswp: PhotoSwipe) => void} [onInit]
 * @prop {Methods<PhotoSwipe> | ((e: MouseEvent, element: HTMLElement, pswp: PhotoSwipe) => void)} [onClick]
 * @prop {'bar' | 'wrapper' | 'root'} [appendTo]
 * @prop {number} [order]
 */
/** @typedef {'arrowPrev' | 'arrowNext' | 'close' | 'zoom' | 'counter'} DefaultUIElements */
/** @typedef {string | UIElementMarkupProps} UIElementMarkup */
/**
 * @param {UIElementMarkup} [htmlData]
 * @returns {string}
 */
function addElementHTML(htmlData) {
  if (typeof htmlData === 'string') {
    // Allow developers to provide full svg,
    // For example:
    // <svg viewBox="0 0 32 32" width="32" height="32" aria-hidden="true" class="pswp__icn">
    //   <path d="..." />
    //   <circle ... />
    // </svg>
    // Can also be any HTML string.
    return htmlData;
  }
  if (!htmlData || !htmlData.isCustomSVG) {
    return '';
  }
  var svgData = htmlData;
  var out = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">'; // replace all %d with size

  out = out.split('%d').join(/** @type {string} */
  svgData.size || 32); // Icons may contain outline/shadow,
  // to make it we "clone" base icon shape and add border to it.
  // Icon itself and border are styled via CSS.
  //
  // Property shadowID defines ID of element that should be cloned.

  if (svgData.outlineID) {
    out += '<use class="pswp__icn-shadow" xlink:href="#' + svgData.outlineID + '"/>';
  }
  out += svgData.inner;
  out += '</svg>';
  return out;
}
var UIElement = /*#__PURE__*/_createClass(
/**
 * @param {PhotoSwipe} pswp
 * @param {UIElementData} data
 */
function UIElement(pswp, data) {
  _classCallCheck(this, UIElement);
  var _container;
  var name = data.name || data.className;
  var elementHTML = data.html; // @ts-expect-error lookup only by `data.name` maybe?

  if (pswp.options[name] === false) {
    // exit if element is disabled from options
    return;
  } // Allow to override SVG icons from options
  // @ts-expect-error lookup only by `data.name` maybe?

  if (typeof pswp.options[name + 'SVG'] === 'string') {
    // arrowPrevSVG
    // arrowNextSVG
    // closeSVG
    // zoomSVG
    // @ts-expect-error lookup only by `data.name` maybe?
    elementHTML = pswp.options[name + 'SVG'];
  }
  pswp.dispatch('uiElementCreate', {
    data: data
  });
  var className = '';
  if (data.isButton) {
    className += 'pswp__button ';
    className += data.className || "pswp__button--".concat(data.name);
  } else {
    className += data.className || "pswp__".concat(data.name);
  }
  var tagName = data.isButton ? data.tagName || 'button' : data.tagName || 'div';
  tagName = /** @type {keyof HTMLElementTagNameMap} */
  tagName.toLowerCase();
  /** @type {HTMLElement} */

  var element = createElement(className, tagName);
  if (data.isButton) {
    if (tagName === 'button') {
      /** @type {HTMLButtonElement} */
      element.type = 'button';
    }
    var title = data.title;
    var ariaLabel = data.ariaLabel; // @ts-expect-error lookup only by `data.name` maybe?

    if (typeof pswp.options[name + 'Title'] === 'string') {
      // @ts-expect-error lookup only by `data.name` maybe?
      title = pswp.options[name + 'Title'];
    }
    if (title) {
      element.title = title;
    }
    var ariaText = ariaLabel || title;
    if (ariaText) {
      element.setAttribute('aria-label', ariaText);
    }
  }
  element.innerHTML = addElementHTML(elementHTML);
  if (data.onInit) {
    data.onInit(element, pswp);
  }
  if (data.onClick) {
    element.onclick = function (e) {
      if (typeof data.onClick === 'string') {
        // @ts-ignore
        pswp[data.onClick]();
      } else if (typeof data.onClick === 'function') {
        data.onClick(e, element, pswp);
      }
    };
  } // Top bar is default position

  var appendTo = data.appendTo || 'bar';
  /** @type {HTMLElement | undefined} root element by default */

  var container = pswp.element;
  if (appendTo === 'bar') {
    if (!pswp.topBar) {
      pswp.topBar = createElement('pswp__top-bar pswp__hide-on-close', 'div', pswp.scrollWrap);
    }
    container = pswp.topBar;
  } else {
    // element outside of top bar gets a secondary class
    // that makes element fade out on close
    element.classList.add('pswp__hide-on-close');
    if (appendTo === 'wrapper') {
      container = pswp.scrollWrap;
    }
  }
  (_container = container) === null || _container === void 0 || _container.appendChild(pswp.applyFilters('uiElement', element, data));
});
/*
  Backward and forward arrow buttons
 */
/** @typedef {import('./ui-element.js').UIElementData} UIElementData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/**
 *
 * @param {HTMLElement} element
 * @param {PhotoSwipe} pswp
 * @param {boolean} [isNextButton]
 */
function initArrowButton(element, pswp, isNextButton) {
  element.classList.add('pswp__button--arrow'); // TODO: this should point to a unique id for this instance

  element.setAttribute('aria-controls', 'pswp__items');
  pswp.on('change', function () {
    if (!pswp.options.loop) {
      if (isNextButton) {
        /** @type {HTMLButtonElement} */
        element.disabled = !(pswp.currIndex < pswp.getNumItems() - 1);
      } else {
        /** @type {HTMLButtonElement} */
        element.disabled = !(pswp.currIndex > 0);
      }
    }
  });
}
/** @type {UIElementData} */

var arrowPrev = {
  name: 'arrowPrev',
  className: 'pswp__button--arrow--prev',
  title: 'Previous',
  order: 10,
  isButton: true,
  appendTo: 'wrapper',
  html: {
    isCustomSVG: true,
    size: 60,
    inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
    outlineID: 'pswp__icn-arrow'
  },
  onClick: 'prev',
  onInit: initArrowButton
};
/** @type {UIElementData} */

var arrowNext = {
  name: 'arrowNext',
  className: 'pswp__button--arrow--next',
  title: 'Next',
  order: 11,
  isButton: true,
  appendTo: 'wrapper',
  html: {
    isCustomSVG: true,
    size: 60,
    inner: '<use xlink:href="#pswp__icn-arrow"/>',
    outlineID: 'pswp__icn-arrow'
  },
  onClick: 'next',
  onInit: function onInit(el, pswp) {
    initArrowButton(el, pswp, true);
  }
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
var closeButton = {
  name: 'close',
  title: 'Close',
  order: 20,
  isButton: true,
  html: {
    isCustomSVG: true,
    inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
    outlineID: 'pswp__icn-close'
  },
  onClick: 'close'
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
var zoomButton = {
  name: 'zoom',
  title: 'Zoom',
  order: 10,
  isButton: true,
  html: {
    isCustomSVG: true,
    // eslint-disable-next-line max-len
    inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/>' + '<path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/>' + '<path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
    outlineID: 'pswp__icn-zoom'
  },
  onClick: 'toggleZoom'
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
var loadingIndicator = {
  name: 'preloader',
  appendTo: 'bar',
  order: 7,
  html: {
    isCustomSVG: true,
    // eslint-disable-next-line max-len
    inner: '<path fill-rule="evenodd" clip-rule="evenodd" d="M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z" id="pswp__icn-loading"/>',
    outlineID: 'pswp__icn-loading'
  },
  onInit: function onInit(indicatorElement, pswp) {
    /** @type {boolean | undefined} */
    var isVisible;
    /** @type {NodeJS.Timeout | null} */

    var delayTimeout = null;
    /**
     * @param {string} className
     * @param {boolean} add
     */

    var toggleIndicatorClass = function toggleIndicatorClass(className, add) {
      indicatorElement.classList.toggle('pswp__preloader--' + className, add);
    };
    /**
     * @param {boolean} visible
     */

    var setIndicatorVisibility = function setIndicatorVisibility(visible) {
      if (isVisible !== visible) {
        isVisible = visible;
        toggleIndicatorClass('active', visible);
      }
    };
    var updatePreloaderVisibility = function updatePreloaderVisibility() {
      var _pswp$currSlide;
      if (!((_pswp$currSlide = pswp.currSlide) !== null && _pswp$currSlide !== void 0 && _pswp$currSlide.content.isLoading())) {
        setIndicatorVisibility(false);
        if (delayTimeout) {
          clearTimeout(delayTimeout);
          delayTimeout = null;
        }
        return;
      }
      if (!delayTimeout) {
        // display loading indicator with delay
        delayTimeout = setTimeout(function () {
          var _pswp$currSlide2;
          setIndicatorVisibility(Boolean((_pswp$currSlide2 = pswp.currSlide) === null || _pswp$currSlide2 === void 0 ? void 0 : _pswp$currSlide2.content.isLoading()));
          delayTimeout = null;
        }, pswp.options.preloaderDelay);
      }
    };
    pswp.on('change', updatePreloaderVisibility);
    pswp.on('loadComplete', function (e) {
      if (pswp.currSlide === e.slide) {
        updatePreloaderVisibility();
      }
    }); // expose the method

    if (pswp.ui) {
      pswp.ui.updatePreloaderVisibility = updatePreloaderVisibility;
    }
  }
};

/** @type {import('./ui-element.js').UIElementData} UIElementData */
var counterIndicator = {
  name: 'counter',
  order: 5,
  onInit: function onInit(counterElement, pswp) {
    pswp.on('change', function () {
      counterElement.innerText = pswp.currIndex + 1 + pswp.options.indexIndicatorSep + pswp.getNumItems();
    });
  }
};

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {import('./ui-element.js').UIElementData} UIElementData */

/**
 * Set special class on element when image is zoomed.
 *
 * By default, it is used to adjust
 * zoom icon and zoom cursor via CSS.
 *
 * @param {HTMLElement} el
 * @param {boolean} isZoomedIn
 */

function setZoomedIn(el, isZoomedIn) {
  el.classList.toggle('pswp--zoomed-in', isZoomedIn);
}
var UI = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function UI(pswp) {
    _classCallCheck(this, UI);
    this.pswp = pswp;
    this.isRegistered = false;
    /** @type {UIElementData[]} */

    this.uiElementsData = [];
    /** @type {(UIElement | UIElementData)[]} */

    this.items = [];
    /** @type {() => void} */

    this.updatePreloaderVisibility = function () {};
    /**
     * @private
     * @type {number | undefined}
     */

    this._lastUpdatedZoomLevel = undefined;
  }
  return _createClass(UI, [{
    key: "init",
    value: function init() {
      var _this11 = this;
      var pswp = this.pswp;
      this.isRegistered = false;
      this.uiElementsData = [closeButton, arrowPrev, arrowNext, zoomButton, loadingIndicator, counterIndicator];
      pswp.dispatch('uiRegister'); // sort by order

      this.uiElementsData.sort(function (a, b) {
        // default order is 0
        return (a.order || 0) - (b.order || 0);
      });
      this.items = [];
      this.isRegistered = true;
      this.uiElementsData.forEach(function (uiElementData) {
        _this11.registerElement(uiElementData);
      });
      pswp.on('change', function () {
        var _pswp$element;
        (_pswp$element = pswp.element) === null || _pswp$element === void 0 || _pswp$element.classList.toggle('pswp--one-slide', pswp.getNumItems() === 1);
      });
      pswp.on('zoomPanUpdate', function () {
        return _this11._onZoomPanUpdate();
      });
    }
    /**
     * @param {UIElementData} elementData
     */
  }, {
    key: "registerElement",
    value: function registerElement(elementData) {
      if (this.isRegistered) {
        this.items.push(new UIElement(this.pswp, elementData));
      } else {
        this.uiElementsData.push(elementData);
      }
    }
    /**
     * Fired each time zoom or pan position is changed.
     * Update classes that control visibility of zoom button and cursor icon.
     *
     * @private
     */
  }, {
    key: "_onZoomPanUpdate",
    value: function _onZoomPanUpdate() {
      var _this$pswp6 = this.pswp,
        template = _this$pswp6.template,
        currSlide = _this$pswp6.currSlide,
        options = _this$pswp6.options;
      if (this.pswp.opener.isClosing || !template || !currSlide) {
        return;
      }
      var currZoomLevel = currSlide.currZoomLevel; // if not open yet - check against initial zoom level

      if (!this.pswp.opener.isOpen) {
        currZoomLevel = currSlide.zoomLevels.initial;
      }
      if (currZoomLevel === this._lastUpdatedZoomLevel) {
        return;
      }
      this._lastUpdatedZoomLevel = currZoomLevel;
      var currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary; // Initial and secondary zoom levels are almost equal

      if (Math.abs(currZoomLevelDiff) < 0.01 || !currSlide.isZoomable()) {
        // disable zoom
        setZoomedIn(template, false);
        template.classList.remove('pswp--zoom-allowed');
        return;
      }
      template.classList.add('pswp--zoom-allowed');
      var potentialZoomLevel = currZoomLevel === currSlide.zoomLevels.initial ? currSlide.zoomLevels.secondary : currSlide.zoomLevels.initial;
      setZoomedIn(template, potentialZoomLevel <= currZoomLevel);
      if (options.imageClickAction === 'zoom' || options.imageClickAction === 'zoom-or-close') {
        template.classList.add('pswp--click-to-zoom');
      }
    }
  }]);
}();
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
/** @typedef {{ x: number; y: number; w: number; innerRect?: { w: number; h: number; x: number; y: number } }} Bounds */
/**
 * @param {HTMLElement} el
 * @returns Bounds
 */
function getBoundsByElement(el) {
  var thumbAreaRect = el.getBoundingClientRect();
  return {
    x: thumbAreaRect.left,
    y: thumbAreaRect.top,
    w: thumbAreaRect.width
  };
}
/**
 * @param {HTMLElement} el
 * @param {number} imageWidth
 * @param {number} imageHeight
 * @returns Bounds
 */

function getCroppedBoundsByElement(el, imageWidth, imageHeight) {
  var thumbAreaRect = el.getBoundingClientRect(); // fill image into the area
  // (do they same as object-fit:cover does to retrieve coordinates)

  var hRatio = thumbAreaRect.width / imageWidth;
  var vRatio = thumbAreaRect.height / imageHeight;
  var fillZoomLevel = hRatio > vRatio ? hRatio : vRatio;
  var offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2;
  var offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2;
  /**
   * Coordinates of the image,
   * as if it was not cropped,
   * height is calculated automatically
   *
   * @type {Bounds}
   */

  var bounds = {
    x: thumbAreaRect.left + offsetX,
    y: thumbAreaRect.top + offsetY,
    w: imageWidth * fillZoomLevel
  }; // Coordinates of inner crop area
  // relative to the image

  bounds.innerRect = {
    w: thumbAreaRect.width,
    h: thumbAreaRect.height,
    x: offsetX,
    y: offsetY
  };
  return bounds;
}
/**
 * Get dimensions of thumbnail image
 * (click on which opens photoswipe or closes photoswipe to)
 *
 * @param {number} index
 * @param {SlideData} itemData
 * @param {PhotoSwipe} instance PhotoSwipe instance
 * @returns {Bounds | undefined}
 */

function _getThumbBounds(index, itemData, instance) {
  // legacy event, before filters were introduced
  var event = instance.dispatch('thumbBounds', {
    index: index,
    itemData: itemData,
    instance: instance
  }); // @ts-expect-error

  if (event.thumbBounds) {
    // @ts-expect-error
    return event.thumbBounds;
  }
  var element = itemData.element;
  /** @type {Bounds | undefined} */

  var thumbBounds;
  /** @type {HTMLElement | null | undefined} */

  var thumbnail;
  if (element && instance.options.thumbSelector !== false) {
    var thumbSelector = instance.options.thumbSelector || 'img';
    thumbnail = element.matches(thumbSelector) ? element : /** @type {HTMLElement | null} */
    element.querySelector(thumbSelector);
  }
  thumbnail = instance.applyFilters('thumbEl', thumbnail, itemData, index);
  if (thumbnail) {
    if (!itemData.thumbCropped) {
      thumbBounds = getBoundsByElement(thumbnail);
    } else {
      thumbBounds = getCroppedBoundsByElement(thumbnail, itemData.width || itemData.w || 0, itemData.height || itemData.h || 0);
    }
  }
  return instance.applyFilters('thumbBounds', thumbBounds, itemData, index);
}

/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */

/** @typedef {import('../photoswipe.js').DataSource} DataSource */

/** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */

/** @typedef {import('../slide/content.js').default} ContentDefault */

/** @typedef {import('../slide/slide.js').default} Slide */

/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */

/** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */

/**
 * Allow adding an arbitrary props to the Content
 * https://photoswipe.com/custom-content/#using-webp-image-format
 * @typedef {ContentDefault & Record<string, any>} Content
 */

/** @typedef {{ x?: number; y?: number }} Point */

/**
 * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/
 *
 *
 * https://photoswipe.com/adding-ui-elements/
 *
 * @prop {undefined} uiRegister
 * @prop {{ data: UIElementData }} uiElementCreate
 *
 *
 * https://photoswipe.com/events/#initialization-events
 *
 * @prop {undefined} beforeOpen
 * @prop {undefined} firstUpdate
 * @prop {undefined} initialLayout
 * @prop {undefined} change
 * @prop {undefined} afterInit
 * @prop {undefined} bindEvents
 *
 *
 * https://photoswipe.com/events/#opening-or-closing-transition-events
 *
 * @prop {undefined} openingAnimationStart
 * @prop {undefined} openingAnimationEnd
 * @prop {undefined} closingAnimationStart
 * @prop {undefined} closingAnimationEnd
 *
 *
 * https://photoswipe.com/events/#closing-events
 *
 * @prop {undefined} close
 * @prop {undefined} destroy
 *
 *
 * https://photoswipe.com/events/#pointer-and-gesture-events
 *
 * @prop {{ originalEvent: PointerEvent }} pointerDown
 * @prop {{ originalEvent: PointerEvent }} pointerMove
 * @prop {{ originalEvent: PointerEvent }} pointerUp
 * @prop {{ bgOpacity: number }} pinchClose can be default prevented
 * @prop {{ panY: number }} verticalDrag can be default prevented
 *
 *
 * https://photoswipe.com/events/#slide-content-events
 *
 * @prop {{ content: Content }} contentInit
 * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented
 * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented
 * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete
 * @prop {{ content: Content; slide: Slide }} loadError
 * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented
 * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange
 * @prop {{ content: Content }} contentLazyLoad can be default prevented
 * @prop {{ content: Content }} contentAppend can be default prevented
 * @prop {{ content: Content }} contentActivate can be default prevented
 * @prop {{ content: Content }} contentDeactivate can be default prevented
 * @prop {{ content: Content }} contentRemove can be default prevented
 * @prop {{ content: Content }} contentDestroy can be default prevented
 *
 *
 * undocumented
 *
 * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented
 *
 * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented
 * @prop {{ x: number; dragging: boolean }} moveMainScroll
 * @prop {{ slide: Slide }} firstZoomPan
 * @prop {{ slide: Slide | undefined, data: SlideData, index: number }} gettingData
 * @prop {undefined} beforeResize
 * @prop {undefined} resize
 * @prop {undefined} viewportSize
 * @prop {undefined} updateScrollOffset
 * @prop {{ slide: Slide }} slideInit
 * @prop {{ slide: Slide }} afterSetContent
 * @prop {{ slide: Slide }} slideLoad
 * @prop {{ slide: Slide }} appendHeavy can be default prevented
 * @prop {{ slide: Slide }} appendHeavyContent
 * @prop {{ slide: Slide }} slideActivate
 * @prop {{ slide: Slide }} slideDeactivate
 * @prop {{ slide: Slide }} slideDestroy
 * @prop {{ destZoomLevel: number, centerPoint: Point | undefined, transitionDuration: number | false | undefined }} beforeZoomTo
 * @prop {{ slide: Slide }} zoomPanUpdate
 * @prop {{ slide: Slide }} initialZoomPan
 * @prop {{ slide: Slide }} calcSlideSize
 * @prop {undefined} resolutionChanged
 * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented
 * @prop {{ content: Content }} contentAppendImage can be default prevented
 * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented
 * @prop {undefined} lazyLoad
 * @prop {{ slide: Slide }} calcBounds
 * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate
 *
 *
 * legacy
 *
 * @prop {undefined} init
 * @prop {undefined} initialZoomIn
 * @prop {undefined} initialZoomOut
 * @prop {undefined} initialZoomInEnd
 * @prop {undefined} initialZoomOutEnd
 * @prop {{ dataSource: DataSource | undefined, numItems: number }} numItems
 * @prop {{ itemData: SlideData; index: number }} itemData
 * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds
 */

/**
 * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/
 *
 * @prop {(numItems: number, dataSource: DataSource | undefined) => number} numItems
 * Modify the total amount of slides. Example on Data sources page.
 * https://photoswipe.com/filters/#numitems
 *
 * @prop {(itemData: SlideData, index: number) => SlideData} itemData
 * Modify slide item data. Example on Data sources page.
 * https://photoswipe.com/filters/#itemdata
 *
 * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData
 * Modify item data when it's parsed from DOM element. Example on Data sources page.
 * https://photoswipe.com/filters/#domitemdata
 *
 * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex
 * Modify clicked gallery item index.
 * https://photoswipe.com/filters/#clickedindex
 *
 * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc
 * Modify placeholder image source.
 * https://photoswipe.com/filters/#placeholdersrc
 *
 * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading
 * Modify if the content is currently loading.
 * https://photoswipe.com/filters/#iscontentloading
 *
 * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable
 * Modify if the content can be zoomed.
 * https://photoswipe.com/filters/#iscontentzoomable
 *
 * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder
 * Modify if the placeholder should be used for the content.
 * https://photoswipe.com/filters/#usecontentplaceholder
 *
 * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder
 * Modify if the placeholder should be kept after the content is loaded.
 * https://photoswipe.com/filters/#iskeepingplaceholder
 *
 *
 * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement
 * Modify an element when the content has error state (for example, if image cannot be loaded).
 * https://photoswipe.com/filters/#contenterrorelement
 *
 * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement
 * Modify a UI element that's being created.
 * https://photoswipe.com/filters/#uielement
 *
 * @prop {(thumbnail: HTMLElement | null | undefined, itemData: SlideData, index: number) => HTMLElement} thumbEl
 * Modify the thumbnail element from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbel
 *
 * @prop {(thumbBounds: Bounds | undefined, itemData: SlideData, index: number) => Bounds} thumbBounds
 * Modify the thumbnail bounds from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbbounds
 *
 * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth
 *
 * @prop {(preventPointerEvent: boolean, event: PointerEvent, pointerType: string) => boolean} preventPointerEvent
 *
 */

/**
 * @template {keyof PhotoSwipeFiltersMap} T
 * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {(event: AugmentedEvent<T>) => void} EventCallback
 */

/**
 * Base PhotoSwipe event object
 *
 * @template {keyof PhotoSwipeEventsMap} T
 */
var PhotoSwipeEvent = /*#__PURE__*/function () {
  /**
   * @param {T} type
   * @param {PhotoSwipeEventsMap[T]} [details]
   */
  function PhotoSwipeEvent(type, details) {
    _classCallCheck(this, PhotoSwipeEvent);
    this.type = type;
    this.defaultPrevented = false;
    if (details) {
      Object.assign(this, details);
    }
  }
  return _createClass(PhotoSwipeEvent, [{
    key: "preventDefault",
    value: function preventDefault() {
      this.defaultPrevented = true;
    }
  }]);
}();
/**
 * PhotoSwipe base class that can listen and dispatch for events.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js
 */
var Eventable = /*#__PURE__*/function () {
  function Eventable() {
    _classCallCheck(this, Eventable);
    /**
     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}
     */
    this._listeners = {};
    /**
     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}
     */

    this._filters = {};
    /** @type {PhotoSwipe | undefined} */

    this.pswp = undefined;
    /** @type {PhotoSwipeOptions | undefined} */

    this.options = undefined;
  }
  /**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {PhotoSwipeFiltersMap[T]} fn
   * @param {number} priority
   */
  return _createClass(Eventable, [{
    key: "addFilter",
    value: function addFilter(name, fn) {
      var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
      var _this$_filters$name, _this$_filters$name2, _this$pswp;
      if (!this._filters[name]) {
        this._filters[name] = [];
      }
      (_this$_filters$name = this._filters[name]) === null || _this$_filters$name === void 0 || _this$_filters$name.push({
        fn: fn,
        priority: priority
      });
      (_this$_filters$name2 = this._filters[name]) === null || _this$_filters$name2 === void 0 || _this$_filters$name2.sort(function (f1, f2) {
        return f1.priority - f2.priority;
      });
      (_this$pswp = this.pswp) === null || _this$pswp === void 0 || _this$pswp.addFilter(name, fn, priority);
    }
    /**
     * @template {keyof PhotoSwipeFiltersMap} T
     * @param {T} name
     * @param {PhotoSwipeFiltersMap[T]} fn
     */
  }, {
    key: "removeFilter",
    value: function removeFilter(name, fn) {
      if (this._filters[name]) {
        // @ts-expect-error
        this._filters[name] = this._filters[name].filter(function (filter) {
          return filter.fn !== fn;
        });
      }
      if (this.pswp) {
        this.pswp.removeFilter(name, fn);
      }
    }
    /**
     * @template {keyof PhotoSwipeFiltersMap} T
     * @param {T} name
     * @param {Parameters<PhotoSwipeFiltersMap[T]>} args
     * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}
     */
  }, {
    key: "applyFilters",
    value: function applyFilters(name) {
      var _this12 = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var _this$_filters$name3;
      (_this$_filters$name3 = this._filters[name]) === null || _this$_filters$name3 === void 0 || _this$_filters$name3.forEach(function (filter) {
        // @ts-expect-error
        args[0] = filter.fn.apply(_this12, args);
      });
      return args[0];
    }
    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @param {T} name
     * @param {EventCallback<T>} fn
     */
  }, {
    key: "on",
    value: function on(name, fn) {
      var _this$_listeners$name, _this$pswp2;
      if (!this._listeners[name]) {
        this._listeners[name] = [];
      }
      (_this$_listeners$name = this._listeners[name]) === null || _this$_listeners$name === void 0 || _this$_listeners$name.push(fn); // When binding events to lightbox,
      // also bind events to PhotoSwipe Core,
      // if it's open.

      (_this$pswp2 = this.pswp) === null || _this$pswp2 === void 0 || _this$pswp2.on(name, fn);
    }
    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @param {T} name
     * @param {EventCallback<T>} fn
     */
  }, {
    key: "off",
    value: function off(name, fn) {
      var _this$pswp3;
      if (this._listeners[name]) {
        // @ts-expect-error
        this._listeners[name] = this._listeners[name].filter(function (listener) {
          return fn !== listener;
        });
      }
      (_this$pswp3 = this.pswp) === null || _this$pswp3 === void 0 || _this$pswp3.off(name, fn);
    }
    /**
     * @template {keyof PhotoSwipeEventsMap} T
     * @param {T} name
     * @param {PhotoSwipeEventsMap[T]} [details]
     * @returns {AugmentedEvent<T>}
     */
  }, {
    key: "dispatch",
    value: function dispatch(name, details) {
      var _this13 = this;
      var _this$_listeners$name2;
      if (this.pswp) {
        return this.pswp.dispatch(name, details);
      }
      var event = /** @type {AugmentedEvent<T>} */
      new PhotoSwipeEvent(name, details);
      (_this$_listeners$name2 = this._listeners[name]) === null || _this$_listeners$name2 === void 0 || _this$_listeners$name2.forEach(function (listener) {
        listener.call(_this13, event);
      });
      return event;
    }
  }]);
}();
var Placeholder = /*#__PURE__*/function () {
  /**
   * @param {string | false} imageSrc
   * @param {HTMLElement} container
   */
  function Placeholder(imageSrc, container) {
    _classCallCheck(this, Placeholder);
    // Create placeholder
    // (stretched thumbnail or simple div behind the main image)

    /** @type {HTMLImageElement | HTMLDivElement | null} */
    this.element = createElement('pswp__img pswp__img--placeholder', imageSrc ? 'img' : 'div', container);
    if (imageSrc) {
      var imgEl = /** @type {HTMLImageElement} */
      this.element;
      imgEl.decoding = 'async';
      imgEl.alt = '';
      imgEl.src = imageSrc;
      imgEl.setAttribute('role', 'presentation');
    }
    this.element.setAttribute('aria-hidden', 'true');
  }
  /**
   * @param {number} width
   * @param {number} height
   */
  return _createClass(Placeholder, [{
    key: "setDisplayedSize",
    value: function setDisplayedSize(width, height) {
      if (!this.element) {
        return;
      }
      if (this.element.tagName === 'IMG') {
        // Use transform scale() to modify img placeholder size
        // (instead of changing width/height directly).
        // This helps with performance, specifically in iOS15 Safari.
        setWidthHeight(this.element, 250, 'auto');
        this.element.style.transformOrigin = '0 0';
        this.element.style.transform = toTransformString(0, 0, width / 250);
      } else {
        setWidthHeight(this.element, width, height);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$element;
      if ((_this$element = this.element) !== null && _this$element !== void 0 && _this$element.parentNode) {
        this.element.remove();
      }
      this.element = null;
    }
  }]);
}();
/** @typedef {import('./slide.js').default} Slide */
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../util/util.js').LoadState} LoadState */
var Content = /*#__PURE__*/function () {
  /**
   * @param {SlideData} itemData Slide data
   * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance
   * @param {number} index
   */
  function Content(itemData, instance, index) {
    _classCallCheck(this, Content);
    this.instance = instance;
    this.data = itemData;
    this.index = index;
    /** @type {HTMLImageElement | HTMLDivElement | undefined} */

    this.element = undefined;
    /** @type {Placeholder | undefined} */

    this.placeholder = undefined;
    /** @type {Slide | undefined} */

    this.slide = undefined;
    this.displayedImageWidth = 0;
    this.displayedImageHeight = 0;
    this.width = Number(this.data.w) || Number(this.data.width) || 0;
    this.height = Number(this.data.h) || Number(this.data.height) || 0;
    this.isAttached = false;
    this.hasSlide = false;
    this.isDecoding = false;
    /** @type {LoadState} */

    this.state = LOAD_STATE.IDLE;
    if (this.data.type) {
      this.type = this.data.type;
    } else if (this.data.src) {
      this.type = 'image';
    } else {
      this.type = 'html';
    }
    this.instance.dispatch('contentInit', {
      content: this
    });
  }
  return _createClass(Content, [{
    key: "removePlaceholder",
    value: function removePlaceholder() {
      var _this14 = this;
      if (this.placeholder && !this.keepPlaceholder()) {
        // With delay, as image might be loaded, but not rendered
        setTimeout(function () {
          if (_this14.placeholder) {
            _this14.placeholder.destroy();
            _this14.placeholder = undefined;
          }
        }, 1000);
      }
    }
    /**
     * Preload content
     *
     * @param {boolean} isLazy
     * @param {boolean} [reload]
     */
  }, {
    key: "load",
    value: function load(isLazy, reload) {
      if (this.slide && this.usePlaceholder()) {
        if (!this.placeholder) {
          var placeholderSrc = this.instance.applyFilters('placeholderSrc',
          // use  image-based placeholder only for the first slide,
          // as rendering (even small stretched thumbnail) is an expensive operation
          this.data.msrc && this.slide.isFirstSlide ? this.data.msrc : false, this);
          this.placeholder = new Placeholder(placeholderSrc, this.slide.container);
        } else {
          var placeholderEl = this.placeholder.element; // Add placeholder to DOM if it was already created

          if (placeholderEl && !placeholderEl.parentElement) {
            this.slide.container.prepend(placeholderEl);
          }
        }
      }
      if (this.element && !reload) {
        return;
      }
      if (this.instance.dispatch('contentLoad', {
        content: this,
        isLazy: isLazy
      }).defaultPrevented) {
        return;
      }
      if (this.isImageContent()) {
        this.element = createElement('pswp__img', 'img'); // Start loading only after width is defined, as sizes might depend on it.
        // Due to Safari feature, we must define sizes before srcset.

        if (this.displayedImageWidth) {
          this.loadImage(isLazy);
        }
      } else {
        this.element = createElement('pswp__content', 'div');
        this.element.innerHTML = this.data.html || '';
      }
      if (reload && this.slide) {
        this.slide.updateContentSize(true);
      }
    }
    /**
     * Preload image
     *
     * @param {boolean} isLazy
     */
  }, {
    key: "loadImage",
    value: function loadImage(isLazy) {
      var _this15 = this;
      var _this$data$src, _this$data$alt;
      if (!this.isImageContent() || !this.element || this.instance.dispatch('contentLoadImage', {
        content: this,
        isLazy: isLazy
      }).defaultPrevented) {
        return;
      }
      var imageElement = /** @type HTMLImageElement */
      this.element;
      this.updateSrcsetSizes();
      if (this.data.srcset) {
        imageElement.srcset = this.data.srcset;
      }
      imageElement.src = (_this$data$src = this.data.src) !== null && _this$data$src !== void 0 ? _this$data$src : '';
      imageElement.alt = (_this$data$alt = this.data.alt) !== null && _this$data$alt !== void 0 ? _this$data$alt : '';
      this.state = LOAD_STATE.LOADING;
      if (imageElement.complete) {
        this.onLoaded();
      } else {
        imageElement.onload = function () {
          _this15.onLoaded();
        };
        imageElement.onerror = function () {
          _this15.onError();
        };
      }
    }
    /**
     * Assign slide to content
     *
     * @param {Slide} slide
     */
  }, {
    key: "setSlide",
    value: function setSlide(slide) {
      this.slide = slide;
      this.hasSlide = true;
      this.instance = slide.pswp; // todo: do we need to unset slide?
    }
    /**
     * Content load success handler
     */
  }, {
    key: "onLoaded",
    value: function onLoaded() {
      this.state = LOAD_STATE.LOADED;
      if (this.slide && this.element) {
        this.instance.dispatch('loadComplete', {
          slide: this.slide,
          content: this
        }); // if content is reloaded

        if (this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode) {
          this.append();
          this.slide.updateContentSize(true);
        }
        if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
          this.removePlaceholder();
        }
      }
    }
    /**
     * Content load error handler
     */
  }, {
    key: "onError",
    value: function onError() {
      this.state = LOAD_STATE.ERROR;
      if (this.slide) {
        this.displayError();
        this.instance.dispatch('loadComplete', {
          slide: this.slide,
          isError: true,
          content: this
        });
        this.instance.dispatch('loadError', {
          slide: this.slide,
          content: this
        });
      }
    }
    /**
     * @returns {Boolean} If the content is currently loading
     */
  }, {
    key: "isLoading",
    value: function isLoading() {
      return this.instance.applyFilters('isContentLoading', this.state === LOAD_STATE.LOADING, this);
    }
    /**
     * @returns {Boolean} If the content is in error state
     */
  }, {
    key: "isError",
    value: function isError() {
      return this.state === LOAD_STATE.ERROR;
    }
    /**
     * @returns {boolean} If the content is image
     */
  }, {
    key: "isImageContent",
    value: function isImageContent() {
      return this.type === 'image';
    }
    /**
     * Update content size
     *
     * @param {Number} width
     * @param {Number} height
     */
  }, {
    key: "setDisplayedSize",
    value: function setDisplayedSize(width, height) {
      if (!this.element) {
        return;
      }
      if (this.placeholder) {
        this.placeholder.setDisplayedSize(width, height);
      }
      if (this.instance.dispatch('contentResize', {
        content: this,
        width: width,
        height: height
      }).defaultPrevented) {
        return;
      }
      setWidthHeight(this.element, width, height);
      if (this.isImageContent() && !this.isError()) {
        var isInitialSizeUpdate = !this.displayedImageWidth && width;
        this.displayedImageWidth = width;
        this.displayedImageHeight = height;
        if (isInitialSizeUpdate) {
          this.loadImage(false);
        } else {
          this.updateSrcsetSizes();
        }
        if (this.slide) {
          this.instance.dispatch('imageSizeChange', {
            slide: this.slide,
            width: width,
            height: height,
            content: this
          });
        }
      }
    }
    /**
     * @returns {boolean} If the content can be zoomed
     */
  }, {
    key: "isZoomable",
    value: function isZoomable() {
      return this.instance.applyFilters('isContentZoomable', this.isImageContent() && this.state !== LOAD_STATE.ERROR, this);
    }
    /**
     * Update image srcset sizes attribute based on width and height
     */
  }, {
    key: "updateSrcsetSizes",
    value: function updateSrcsetSizes() {
      // Handle srcset sizes attribute.
      //
      // Never lower quality, if it was increased previously.
      // Chrome does this automatically, Firefox and Safari do not,
      // so we store largest used size in dataset.
      if (!this.isImageContent() || !this.element || !this.data.srcset) {
        return;
      }
      var image = /** @type HTMLImageElement */
      this.element;
      var sizesWidth = this.instance.applyFilters('srcsetSizesWidth', this.displayedImageWidth, this);
      if (!image.dataset.largestUsedSize || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)) {
        image.sizes = sizesWidth + 'px';
        image.dataset.largestUsedSize = String(sizesWidth);
      }
    }
    /**
     * @returns {boolean} If content should use a placeholder (from msrc by default)
     */
  }, {
    key: "usePlaceholder",
    value: function usePlaceholder() {
      return this.instance.applyFilters('useContentPlaceholder', this.isImageContent(), this);
    }
    /**
     * Preload content with lazy-loading param
     */
  }, {
    key: "lazyLoad",
    value: function lazyLoad() {
      if (this.instance.dispatch('contentLazyLoad', {
        content: this
      }).defaultPrevented) {
        return;
      }
      this.load(true);
    }
    /**
     * @returns {boolean} If placeholder should be kept after content is loaded
     */
  }, {
    key: "keepPlaceholder",
    value: function keepPlaceholder() {
      return this.instance.applyFilters('isKeepingPlaceholder', this.isLoading(), this);
    }
    /**
     * Destroy the content
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.hasSlide = false;
      this.slide = undefined;
      if (this.instance.dispatch('contentDestroy', {
        content: this
      }).defaultPrevented) {
        return;
      }
      this.remove();
      if (this.placeholder) {
        this.placeholder.destroy();
        this.placeholder = undefined;
      }
      if (this.isImageContent() && this.element) {
        this.element.onload = null;
        this.element.onerror = null;
        this.element = undefined;
      }
    }
    /**
     * Display error message
     */
  }, {
    key: "displayError",
    value: function displayError() {
      if (this.slide) {
        var _this$instance$option, _this$instance$option2;
        var errorMsgEl = createElement('pswp__error-msg', 'div');
        errorMsgEl.innerText = (_this$instance$option = (_this$instance$option2 = this.instance.options) === null || _this$instance$option2 === void 0 ? void 0 : _this$instance$option2.errorMsg) !== null && _this$instance$option !== void 0 ? _this$instance$option : '';
        errorMsgEl = /** @type {HTMLDivElement} */
        this.instance.applyFilters('contentErrorElement', errorMsgEl, this);
        this.element = createElement('pswp__content pswp__error-msg-container', 'div');
        this.element.appendChild(errorMsgEl);
        this.slide.container.innerText = '';
        this.slide.container.appendChild(this.element);
        this.slide.updateContentSize(true);
        this.removePlaceholder();
      }
    }
    /**
     * Append the content
     */
  }, {
    key: "append",
    value: function append() {
      var _this16 = this;
      if (this.isAttached || !this.element) {
        return;
      }
      this.isAttached = true;
      if (this.state === LOAD_STATE.ERROR) {
        this.displayError();
        return;
      }
      if (this.instance.dispatch('contentAppend', {
        content: this
      }).defaultPrevented) {
        return;
      }
      var supportsDecode = 'decode' in this.element;
      if (this.isImageContent()) {
        // Use decode() on nearby slides
        //
        // Nearby slide images are in DOM and not hidden via display:none.
        // However, they are placed offscreen (to the left and right side).
        //
        // Some browsers do not composite the image until it's actually visible,
        // using decode() helps.
        //
        // You might ask "why dont you just decode() and then append all images",
        // that's because I want to show image before it's fully loaded,
        // as browser can render parts of image while it is loading.
        // We do not do this in Safari due to partial loading bug.
        if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {
          this.isDecoding = true; // purposefully using finally instead of then,
          // as if srcset sizes changes dynamically - it may cause decode error

          /** @type {HTMLImageElement} */

          this.element.decode()["catch"](function () {})["finally"](function () {
            _this16.isDecoding = false;
            _this16.appendImage();
          });
        } else {
          this.appendImage();
        }
      } else if (this.slide && !this.element.parentNode) {
        this.slide.container.appendChild(this.element);
      }
    }
    /**
     * Activate the slide,
     * active slide is generally the current one,
     * meaning the user can see it.
     */
  }, {
    key: "activate",
    value: function activate() {
      if (this.instance.dispatch('contentActivate', {
        content: this
      }).defaultPrevented || !this.slide) {
        return;
      }
      if (this.isImageContent() && this.isDecoding && !isSafari()) {
        // add image to slide when it becomes active,
        // even if it's not finished decoding
        this.appendImage();
      } else if (this.isError()) {
        this.load(false, true); // try to reload
      }
      if (this.slide.holderElement) {
        this.slide.holderElement.setAttribute('aria-hidden', 'false');
      }
    }
    /**
     * Deactivate the content
     */
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.instance.dispatch('contentDeactivate', {
        content: this
      });
      if (this.slide && this.slide.holderElement) {
        this.slide.holderElement.setAttribute('aria-hidden', 'true');
      }
    }
    /**
     * Remove the content from DOM
     */
  }, {
    key: "remove",
    value: function remove() {
      this.isAttached = false;
      if (this.instance.dispatch('contentRemove', {
        content: this
      }).defaultPrevented) {
        return;
      }
      if (this.element && this.element.parentNode) {
        this.element.remove();
      }
      if (this.placeholder && this.placeholder.element) {
        this.placeholder.element.remove();
      }
    }
    /**
     * Append the image content to slide container
     */
  }, {
    key: "appendImage",
    value: function appendImage() {
      if (!this.isAttached) {
        return;
      }
      if (this.instance.dispatch('contentAppendImage', {
        content: this
      }).defaultPrevented) {
        return;
      } // ensure that element exists and is not already appended

      if (this.slide && this.element && !this.element.parentNode) {
        this.slide.container.appendChild(this.element);
      }
      if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
        this.removePlaceholder();
      }
    }
  }]);
}();
/** @typedef {import('./content.js').default} Content */
/** @typedef {import('./slide.js').default} Slide */
/** @typedef {import('./slide.js').SlideData} SlideData */
/** @typedef {import('../core/base.js').default} PhotoSwipeBase */
/** @typedef {import('../photoswipe.js').default} PhotoSwipe */
var MIN_SLIDES_TO_CACHE = 5;
/**
 * Lazy-load an image
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * @param {SlideData} itemData Data about the slide
 * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance
 * @param {number} index
 * @returns {Content} Image that is being decoded or false.
 */

function _lazyLoadData(itemData, instance, index) {
  var content = instance.createContentFromData(itemData, index);
  /** @type {ZoomLevel | undefined} */

  var zoomLevel;
  var options = instance.options; // We need to know dimensions of the image to preload it,
  // as it might use srcset, and we need to define sizes

  if (options) {
    zoomLevel = new ZoomLevel(options, itemData, -1);
    var viewportSize;
    if (instance.pswp) {
      viewportSize = instance.pswp.viewportSize;
    } else {
      viewportSize = getViewportSize(options, instance);
    }
    var panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);
    zoomLevel.update(content.width, content.height, panAreaSize);
  }
  content.lazyLoad();
  if (zoomLevel) {
    content.setDisplayedSize(Math.ceil(content.width * zoomLevel.initial), Math.ceil(content.height * zoomLevel.initial));
  }
  return content;
}
/**
 * Lazy-loads specific slide.
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * By default, it loads image based on viewport size and initial zoom level.
 *
 * @param {number} index Slide index
 * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox eventable instance
 * @returns {Content | undefined}
 */

function lazyLoadSlide(index, instance) {
  var itemData = instance.getItemData(index);
  if (instance.dispatch('lazyLoadSlide', {
    index: index,
    itemData: itemData
  }).defaultPrevented) {
    return;
  }
  return _lazyLoadData(itemData, instance, index);
}
var ContentLoader = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function ContentLoader(pswp) {
    _classCallCheck(this, ContentLoader);
    this.pswp = pswp; // Total amount of cached images

    this.limit = Math.max(pswp.options.preload[0] + pswp.options.preload[1] + 1, MIN_SLIDES_TO_CACHE);
    /** @type {Content[]} */

    this._cachedItems = [];
  }
  /**
   * Lazy load nearby slides based on `preload` option.
   *
   * @param {number} [diff] Difference between slide indexes that was changed recently, or 0.
   */
  return _createClass(ContentLoader, [{
    key: "updateLazy",
    value: function updateLazy(diff) {
      var pswp = this.pswp;
      if (pswp.dispatch('lazyLoad').defaultPrevented) {
        return;
      }
      var preload = pswp.options.preload;
      var isForward = diff === undefined ? true : diff >= 0;
      var i; // preload[1] - num items to preload in forward direction

      for (i = 0; i <= preload[1]; i++) {
        this.loadSlideByIndex(pswp.currIndex + (isForward ? i : -i));
      } // preload[0] - num items to preload in backward direction

      for (i = 1; i <= preload[0]; i++) {
        this.loadSlideByIndex(pswp.currIndex + (isForward ? -i : i));
      }
    }
    /**
     * @param {number} initialIndex
     */
  }, {
    key: "loadSlideByIndex",
    value: function loadSlideByIndex(initialIndex) {
      var index = this.pswp.getLoopedIndex(initialIndex); // try to get cached content

      var content = this.getContentByIndex(index);
      if (!content) {
        // no cached content, so try to load from scratch:
        content = lazyLoadSlide(index, this.pswp); // if content can be loaded, add it to cache:

        if (content) {
          this.addToCache(content);
        }
      }
    }
    /**
     * @param {Slide} slide
     * @returns {Content}
     */
  }, {
    key: "getContentBySlide",
    value: function getContentBySlide(slide) {
      var content = this.getContentByIndex(slide.index);
      if (!content) {
        // create content if not found in cache
        content = this.pswp.createContentFromData(slide.data, slide.index);
        this.addToCache(content);
      } // assign slide to content

      content.setSlide(slide);
      return content;
    }
    /**
     * @param {Content} content
     */
  }, {
    key: "addToCache",
    value: function addToCache(content) {
      // move to the end of array
      this.removeByIndex(content.index);
      this._cachedItems.push(content);
      if (this._cachedItems.length > this.limit) {
        // Destroy the first content that's not attached
        var indexToRemove = this._cachedItems.findIndex(function (item) {
          return !item.isAttached && !item.hasSlide;
        });
        if (indexToRemove !== -1) {
          var removedItem = this._cachedItems.splice(indexToRemove, 1)[0];
          removedItem.destroy();
        }
      }
    }
    /**
     * Removes an image from cache, does not destroy() it, just removes.
     *
     * @param {number} index
     */
  }, {
    key: "removeByIndex",
    value: function removeByIndex(index) {
      var indexToRemove = this._cachedItems.findIndex(function (item) {
        return item.index === index;
      });
      if (indexToRemove !== -1) {
        this._cachedItems.splice(indexToRemove, 1);
      }
    }
    /**
     * @param {number} index
     * @returns {Content | undefined}
     */
  }, {
    key: "getContentByIndex",
    value: function getContentByIndex(index) {
      return this._cachedItems.find(function (content) {
        return content.index === index;
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._cachedItems.forEach(function (content) {
        return content.destroy();
      });
      this._cachedItems = [];
    }
  }]);
}();
/** @typedef {import("../photoswipe.js").default} PhotoSwipe */
/** @typedef {import("../slide/slide.js").SlideData} SlideData */
/**
 * PhotoSwipe base class that can retrieve data about every slide.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox
 */
var PhotoSwipeBase = /*#__PURE__*/function (_Eventable) {
  function PhotoSwipeBase() {
    _classCallCheck(this, PhotoSwipeBase);
    return _callSuper(this, PhotoSwipeBase, arguments);
  }
  _inherits(PhotoSwipeBase, _Eventable);
  return _createClass(PhotoSwipeBase, [{
    key: "getNumItems",
    value:
    /**
     * Get total number of slides
     *
     * @returns {number}
     */
    function getNumItems() {
      var _this$options;
      var numItems = 0;
      var dataSource = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.dataSource;
      if (dataSource && 'length' in dataSource) {
        // may be an array or just object with length property
        numItems = dataSource.length;
      } else if (dataSource && 'gallery' in dataSource) {
        // query DOM elements
        if (!dataSource.items) {
          dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
        }
        if (dataSource.items) {
          numItems = dataSource.items.length;
        }
      } // legacy event, before filters were introduced

      var event = this.dispatch('numItems', {
        dataSource: dataSource,
        numItems: numItems
      });
      return this.applyFilters('numItems', event.numItems, dataSource);
    }
    /**
     * @param {SlideData} slideData
     * @param {number} index
     * @returns {Content}
     */
  }, {
    key: "createContentFromData",
    value: function createContentFromData(slideData, index) {
      return new Content(slideData, this, index);
    }
    /**
     * Get item data by index.
     *
     * "item data" should contain normalized information that PhotoSwipe needs to generate a slide.
     * For example, it may contain properties like
     * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.
     *
     * @param {number} index
     * @returns {SlideData}
     */
  }, {
    key: "getItemData",
    value: function getItemData(index) {
      var _this$options2;
      var dataSource = (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.dataSource;
      /** @type {SlideData | HTMLElement} */

      var dataSourceItem = {};
      if (Array.isArray(dataSource)) {
        // Datasource is an array of elements
        dataSourceItem = dataSource[index];
      } else if (dataSource && 'gallery' in dataSource) {
        // dataSource has gallery property,
        // thus it was created by Lightbox, based on
        // gallery and children options
        // query DOM elements
        if (!dataSource.items) {
          dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
        }
        dataSourceItem = dataSource.items[index];
      }
      var itemData = dataSourceItem;
      if (itemData instanceof Element) {
        itemData = this._domElementToItemData(itemData);
      } // Dispatching the itemData event,
      // it's a legacy verion before filters were introduced

      var event = this.dispatch('itemData', {
        itemData: itemData || {},
        index: index
      });
      return this.applyFilters('itemData', event.itemData, index);
    }
    /**
     * Get array of gallery DOM elements,
     * based on childSelector and gallery element.
     *
     * @param {HTMLElement} galleryElement
     * @returns {HTMLElement[]}
     */
  }, {
    key: "_getGalleryDOMElements",
    value: function _getGalleryDOMElements(galleryElement) {
      var _this$options3, _this$options4;
      if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.children || (_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.childSelector) {
        return getElementsFromOption(this.options.children, this.options.childSelector, galleryElement) || [];
      }
      return [galleryElement];
    }
    /**
     * Converts DOM element to item data object.
     *
     * @param {HTMLElement} element DOM element
     * @returns {SlideData}
     */
  }, {
    key: "_domElementToItemData",
    value: function _domElementToItemData(element) {
      /** @type {SlideData} */
      var itemData = {
        element: element
      };
      var linkEl = /** @type {HTMLAnchorElement} */
      element.tagName === 'A' ? element : element.querySelector('a');
      if (linkEl) {
        // src comes from data-pswp-src attribute,
        // if it's empty link href is used
        itemData.src = linkEl.dataset.pswpSrc || linkEl.href;
        if (linkEl.dataset.pswpSrcset) {
          itemData.srcset = linkEl.dataset.pswpSrcset;
        }
        itemData.width = linkEl.dataset.pswpWidth ? parseInt(linkEl.dataset.pswpWidth, 10) : 0;
        itemData.height = linkEl.dataset.pswpHeight ? parseInt(linkEl.dataset.pswpHeight, 10) : 0; // support legacy w & h properties

        itemData.w = itemData.width;
        itemData.h = itemData.height;
        if (linkEl.dataset.pswpType) {
          itemData.type = linkEl.dataset.pswpType;
        }
        var thumbnailEl = element.querySelector('img');
        if (thumbnailEl) {
          var _thumbnailEl$getAttri;

          // msrc is URL to placeholder image that's displayed before large image is loaded
          // by default it's displayed only for the first slide
          itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;
          itemData.alt = (_thumbnailEl$getAttri = thumbnailEl.getAttribute('alt')) !== null && _thumbnailEl$getAttri !== void 0 ? _thumbnailEl$getAttri : '';
        }
        if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {
          itemData.thumbCropped = true;
        }
      }
      return this.applyFilters('domItemData', itemData, element, linkEl);
    }
    /**
     * Lazy-load by slide data
     *
     * @param {SlideData} itemData Data about the slide
     * @param {number} index
     * @returns {Content} Image that is being decoded or false.
     */
  }, {
    key: "lazyLoadData",
    value: function lazyLoadData(itemData, index) {
      return _lazyLoadData(itemData, this, index);
    }
  }]);
}(Eventable);
/** @typedef {import('./photoswipe.js').default} PhotoSwipe */
/** @typedef {import('./slide/get-thumb-bounds.js').Bounds} Bounds */
/** @typedef {import('./util/animations.js').AnimationProps} AnimationProps */
// some browsers do not paint
// elements which opacity is set to 0,
// since we need to pre-render elements for the animation -
// we set it to the minimum amount
var MIN_OPACITY = 0.003;
/**
 * Manages opening and closing transitions of the PhotoSwipe.
 *
 * It can perform zoom, fade or no transition.
 */
var Opener = /*#__PURE__*/function () {
  /**
   * @param {PhotoSwipe} pswp
   */
  function Opener(pswp) {
    _classCallCheck(this, Opener);
    this.pswp = pswp;
    this.isClosed = true;
    this.isOpen = false;
    this.isClosing = false;
    this.isOpening = false;
    /**
     * @private
     * @type {number | false | undefined}
     */

    this._duration = undefined;
    /** @private */

    this._useAnimation = false;
    /** @private */

    this._croppedZoom = false;
    /** @private */

    this._animateRootOpacity = false;
    /** @private */

    this._animateBgOpacity = false;
    /**
     * @private
     * @type { HTMLDivElement | HTMLImageElement | null | undefined }
     */

    this._placeholder = undefined;
    /**
     * @private
     * @type { HTMLDivElement | undefined }
     */

    this._opacityElement = undefined;
    /**
     * @private
     * @type { HTMLDivElement | undefined }
     */

    this._cropContainer1 = undefined;
    /**
     * @private
     * @type { HTMLElement | null | undefined }
     */

    this._cropContainer2 = undefined;
    /**
     * @private
     * @type {Bounds | undefined}
     */

    this._thumbBounds = undefined;
    this._prepareOpen = this._prepareOpen.bind(this); // Override initial zoom and pan position

    pswp.on('firstZoomPan', this._prepareOpen);
  }
  return _createClass(Opener, [{
    key: "open",
    value: function open() {
      this._prepareOpen();
      this._start();
    }
  }, {
    key: "close",
    value: function close() {
      var _this17 = this;
      if (this.isClosed || this.isClosing || this.isOpening) {
        // if we close during opening animation
        // for now do nothing,
        // browsers aren't good at changing the direction of the CSS transition
        return;
      }
      var slide = this.pswp.currSlide;
      this.isOpen = false;
      this.isOpening = false;
      this.isClosing = true;
      this._duration = this.pswp.options.hideAnimationDuration;
      if (slide && slide.currZoomLevel * slide.width >= this.pswp.options.maxWidthToAnimate) {
        this._duration = 0;
      }
      this._applyStartProps();
      setTimeout(function () {
        _this17._start();
      }, this._croppedZoom ? 30 : 0);
    }
    /** @private */
  }, {
    key: "_prepareOpen",
    value: function _prepareOpen() {
      this.pswp.off('firstZoomPan', this._prepareOpen);
      if (!this.isOpening) {
        var slide = this.pswp.currSlide;
        this.isOpening = true;
        this.isClosing = false;
        this._duration = this.pswp.options.showAnimationDuration;
        if (slide && slide.zoomLevels.initial * slide.width >= this.pswp.options.maxWidthToAnimate) {
          this._duration = 0;
        }
        this._applyStartProps();
      }
    }
    /** @private */
  }, {
    key: "_applyStartProps",
    value: function _applyStartProps() {
      var pswp = this.pswp;
      var slide = this.pswp.currSlide;
      var options = pswp.options;
      if (options.showHideAnimationType === 'fade') {
        options.showHideOpacity = true;
        this._thumbBounds = undefined;
      } else if (options.showHideAnimationType === 'none') {
        options.showHideOpacity = false;
        this._duration = 0;
        this._thumbBounds = undefined;
      } else if (this.isOpening && pswp._initialThumbBounds) {
        // Use initial bounds if defined
        this._thumbBounds = pswp._initialThumbBounds;
      } else {
        this._thumbBounds = this.pswp.getThumbBounds();
      }
      this._placeholder = slide === null || slide === void 0 ? void 0 : slide.getPlaceholderElement();
      pswp.animations.stopAll(); // Discard animations when duration is less than 50ms

      this._useAnimation = Boolean(this._duration && this._duration > 50);
      this._animateZoom = Boolean(this._thumbBounds) && (slide === null || slide === void 0 ? void 0 : slide.content.usePlaceholder()) && (!this.isClosing || !pswp.mainScroll.isShifted());
      if (!this._animateZoom) {
        this._animateRootOpacity = true;
        if (this.isOpening && slide) {
          slide.zoomAndPanToInitial();
          slide.applyCurrentZoomPan();
        }
      } else {
        var _options$showHideOpac;
        this._animateRootOpacity = (_options$showHideOpac = options.showHideOpacity) !== null && _options$showHideOpac !== void 0 ? _options$showHideOpac : false;
      }
      this._animateBgOpacity = !this._animateRootOpacity && this.pswp.options.bgOpacity > MIN_OPACITY;
      this._opacityElement = this._animateRootOpacity ? pswp.element : pswp.bg;
      if (!this._useAnimation) {
        this._duration = 0;
        this._animateZoom = false;
        this._animateBgOpacity = false;
        this._animateRootOpacity = true;
        if (this.isOpening) {
          if (pswp.element) {
            pswp.element.style.opacity = String(MIN_OPACITY);
          }
          pswp.applyBgOpacity(1);
        }
        return;
      }
      if (this._animateZoom && this._thumbBounds && this._thumbBounds.innerRect) {
        var _this$pswp$currSlide;

        // Properties are used when animation from cropped thumbnail
        this._croppedZoom = true;
        this._cropContainer1 = this.pswp.container;
        this._cropContainer2 = (_this$pswp$currSlide = this.pswp.currSlide) === null || _this$pswp$currSlide === void 0 ? void 0 : _this$pswp$currSlide.holderElement;
        if (pswp.container) {
          pswp.container.style.overflow = 'hidden';
          pswp.container.style.width = pswp.viewportSize.x + 'px';
        }
      } else {
        this._croppedZoom = false;
      }
      if (this.isOpening) {
        // Apply styles before opening transition
        if (this._animateRootOpacity) {
          if (pswp.element) {
            pswp.element.style.opacity = String(MIN_OPACITY);
          }
          pswp.applyBgOpacity(1);
        } else {
          if (this._animateBgOpacity && pswp.bg) {
            pswp.bg.style.opacity = String(MIN_OPACITY);
          }
          if (pswp.element) {
            pswp.element.style.opacity = '1';
          }
        }
        if (this._animateZoom) {
          this._setClosedStateZoomPan();
          if (this._placeholder) {
            // tell browser that we plan to animate the placeholder
            this._placeholder.style.willChange = 'transform'; // hide placeholder to allow hiding of
            // elements that overlap it (such as icons over the thumbnail)

            this._placeholder.style.opacity = String(MIN_OPACITY);
          }
        }
      } else if (this.isClosing) {
        // hide nearby slides to make sure that
        // they are not painted during the transition
        if (pswp.mainScroll.itemHolders[0]) {
          pswp.mainScroll.itemHolders[0].el.style.display = 'none';
        }
        if (pswp.mainScroll.itemHolders[2]) {
          pswp.mainScroll.itemHolders[2].el.style.display = 'none';
        }
        if (this._croppedZoom) {
          if (pswp.mainScroll.x !== 0) {
            // shift the main scroller to zero position
            pswp.mainScroll.resetPosition();
            pswp.mainScroll.resize();
          }
        }
      }
    }
    /** @private */
  }, {
    key: "_start",
    value: function _start() {
      var _this18 = this;
      if (this.isOpening && this._useAnimation && this._placeholder && this._placeholder.tagName === 'IMG') {
        // To ensure smooth animation
        // we wait till the current slide image placeholder is decoded,
        // but no longer than 250ms,
        // and no shorter than 50ms
        // (just using requestanimationframe is not enough in Firefox,
        // for some reason)
        new Promise(function (resolve) {
          var decoded = false;
          var isDelaying = true;
          decodeImage(/** @type {HTMLImageElement} */
          _this18._placeholder)["finally"](function () {
            decoded = true;
            if (!isDelaying) {
              resolve(true);
            }
          });
          setTimeout(function () {
            isDelaying = false;
            if (decoded) {
              resolve(true);
            }
          }, 50);
          setTimeout(resolve, 250);
        })["finally"](function () {
          return _this18._initiate();
        });
      } else {
        this._initiate();
      }
    }
    /** @private */
  }, {
    key: "_initiate",
    value: function _initiate() {
      var _this$pswp$element, _this$pswp$element2;
      (_this$pswp$element = this.pswp.element) === null || _this$pswp$element === void 0 || _this$pswp$element.style.setProperty('--pswp-transition-duration', this._duration + 'ms');
      this.pswp.dispatch(this.isOpening ? 'openingAnimationStart' : 'closingAnimationStart'); // legacy event

      this.pswp.dispatch(/** @type {'initialZoomIn' | 'initialZoomOut'} */
      'initialZoom' + (this.isOpening ? 'In' : 'Out'));
      (_this$pswp$element2 = this.pswp.element) === null || _this$pswp$element2 === void 0 || _this$pswp$element2.classList.toggle('pswp--ui-visible', this.isOpening);
      if (this.isOpening) {
        if (this._placeholder) {
          // unhide the placeholder
          this._placeholder.style.opacity = '1';
        }
        this._animateToOpenState();
      } else if (this.isClosing) {
        this._animateToClosedState();
      }
      if (!this._useAnimation) {
        this._onAnimationComplete();
      }
    }
    /** @private */
  }, {
    key: "_onAnimationComplete",
    value: function _onAnimationComplete() {
      var pswp = this.pswp;
      this.isOpen = this.isOpening;
      this.isClosed = this.isClosing;
      this.isOpening = false;
      this.isClosing = false;
      pswp.dispatch(this.isOpen ? 'openingAnimationEnd' : 'closingAnimationEnd'); // legacy event

      pswp.dispatch(/** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */
      'initialZoom' + (this.isOpen ? 'InEnd' : 'OutEnd'));
      if (this.isClosed) {
        pswp.destroy();
      } else if (this.isOpen) {
        var _pswp$currSlide;
        if (this._animateZoom && pswp.container) {
          pswp.container.style.overflow = 'visible';
          pswp.container.style.width = '100%';
        }
        (_pswp$currSlide = pswp.currSlide) === null || _pswp$currSlide === void 0 || _pswp$currSlide.applyCurrentZoomPan();
      }
    }
    /** @private */
  }, {
    key: "_animateToOpenState",
    value: function _animateToOpenState() {
      var pswp = this.pswp;
      if (this._animateZoom) {
        if (this._croppedZoom && this._cropContainer1 && this._cropContainer2) {
          this._animateTo(this._cropContainer1, 'transform', 'translate3d(0,0,0)');
          this._animateTo(this._cropContainer2, 'transform', 'none');
        }
        if (pswp.currSlide) {
          pswp.currSlide.zoomAndPanToInitial();
          this._animateTo(pswp.currSlide.container, 'transform', pswp.currSlide.getCurrentTransform());
        }
      }
      if (this._animateBgOpacity && pswp.bg) {
        this._animateTo(pswp.bg, 'opacity', String(pswp.options.bgOpacity));
      }
      if (this._animateRootOpacity && pswp.element) {
        this._animateTo(pswp.element, 'opacity', '1');
      }
    }
    /** @private */
  }, {
    key: "_animateToClosedState",
    value: function _animateToClosedState() {
      var pswp = this.pswp;
      if (this._animateZoom) {
        this._setClosedStateZoomPan(true);
      } // do not animate opacity if it's already at 0

      if (this._animateBgOpacity && pswp.bgOpacity > 0.01 && pswp.bg) {
        this._animateTo(pswp.bg, 'opacity', '0');
      }
      if (this._animateRootOpacity && pswp.element) {
        this._animateTo(pswp.element, 'opacity', '0');
      }
    }
    /**
     * @private
     * @param {boolean} [animate]
     */
  }, {
    key: "_setClosedStateZoomPan",
    value: function _setClosedStateZoomPan(animate) {
      if (!this._thumbBounds) return;
      var pswp = this.pswp;
      var innerRect = this._thumbBounds.innerRect;
      var currSlide = pswp.currSlide,
        viewportSize = pswp.viewportSize;
      if (this._croppedZoom && innerRect && this._cropContainer1 && this._cropContainer2) {
        var containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w;
        var containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h;
        var containerTwoPanX = viewportSize.x - innerRect.w;
        var containerTwoPanY = viewportSize.y - innerRect.h;
        if (animate) {
          this._animateTo(this._cropContainer1, 'transform', toTransformString(containerOnePanX, containerOnePanY));
          this._animateTo(this._cropContainer2, 'transform', toTransformString(containerTwoPanX, containerTwoPanY));
        } else {
          setTransform(this._cropContainer1, containerOnePanX, containerOnePanY);
          setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY);
        }
      }
      if (currSlide) {
        equalizePoints(currSlide.pan, innerRect || this._thumbBounds);
        currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width;
        if (animate) {
          this._animateTo(currSlide.container, 'transform', currSlide.getCurrentTransform());
        } else {
          currSlide.applyCurrentZoomPan();
        }
      }
    }
    /**
     * @private
     * @param {HTMLElement} target
     * @param {'transform' | 'opacity'} prop
     * @param {string} propValue
     */
  }, {
    key: "_animateTo",
    value: function _animateTo(target, prop, propValue) {
      var _this19 = this;
      if (!this._duration) {
        target.style[prop] = propValue;
        return;
      }
      var animations = this.pswp.animations;
      /** @type {AnimationProps} */

      var animProps = {
        duration: this._duration,
        easing: this.pswp.options.easing,
        onComplete: function onComplete() {
          if (!animations.activeAnimations.length) {
            _this19._onAnimationComplete();
          }
        },
        target: target
      };
      animProps[prop] = propValue;
      animations.startTransition(animProps);
    }
  }]);
}();
/**
 * @template T
 * @typedef {import('./types.js').Type<T>} Type<T>
 */
/** @typedef {import('./slide/slide.js').SlideData} SlideData */
/** @typedef {import('./slide/zoom-level.js').ZoomLevelOption} ZoomLevelOption */
/** @typedef {import('./ui/ui-element.js').UIElementData} UIElementData */
/** @typedef {import('./main-scroll.js').ItemHolder} ItemHolder */
/** @typedef {import('./core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */
/** @typedef {import('./core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */
/** @typedef {import('./slide/get-thumb-bounds').Bounds} Bounds */
/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {import('./core/eventable.js').EventCallback<T>} EventCallback<T>
 */
/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {import('./core/eventable.js').AugmentedEvent<T>} AugmentedEvent<T>
 */
/** @typedef {{ x: number; y: number; id?: string | number }} Point */
/** @typedef {{ top: number; bottom: number; left: number; right: number }} Padding */
/** @typedef {SlideData[]} DataSourceArray */
/** @typedef {{ gallery: HTMLElement; items?: HTMLElement[] }} DataSourceObject */
/** @typedef {DataSourceArray | DataSourceObject} DataSource */
/** @typedef {(point: Point, originalEvent: PointerEvent) => void} ActionFn */
/** @typedef {'close' | 'next' | 'zoom' | 'zoom-or-close' | 'toggle-controls'} ActionType */
/** @typedef {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} PhotoSwipeModule */
/** @typedef {PhotoSwipeModule | Promise<PhotoSwipeModule> | (() => Promise<PhotoSwipeModule>)} PhotoSwipeModuleOption */
/**
 * @typedef {string | NodeListOf<HTMLElement> | HTMLElement[] | HTMLElement} ElementProvider
 */
/** @typedef {Partial<PreparedPhotoSwipeOptions>} PhotoSwipeOptions https://photoswipe.com/options/ */
/**
 * @typedef {Object} PreparedPhotoSwipeOptions
 *
 * @prop {DataSource} [dataSource]
 * Pass an array of any items via dataSource option. Its length will determine amount of slides
 * (which may be modified further from numItems event).
 *
 * Each item should contain data that you need to generate slide
 * (for image slide it would be src (image URL), width (image width), height, srcset, alt).
 *
 * If these properties are not present in your initial array, you may "pre-parse" each item from itemData filter.
 *
 * @prop {number} bgOpacity
 * Background backdrop opacity, always define it via this option and not via CSS rgba color.
 *
 * @prop {number} spacing
 * Spacing between slides. Defined as ratio relative to the viewport width (0.1 = 10% of viewport).
 *
 * @prop {boolean} allowPanToNext
 * Allow swipe navigation to the next slide when the current slide is zoomed. Does not apply to mouse events.
 *
 * @prop {boolean} loop
 * If set to true you'll be able to swipe from the last to the first image.
 * Option is always false when there are less than 3 slides.
 *
 * @prop {boolean} [wheelToZoom]
 * By default PhotoSwipe zooms image with ctrl-wheel, if you enable this option - image will zoom just via wheel.
 *
 * @prop {boolean} pinchToClose
 * Pinch touch gesture to close the gallery.
 *
 * @prop {boolean} closeOnVerticalDrag
 * Vertical drag gesture to close the PhotoSwipe.
 *
 * @prop {Padding} [padding]
 * Slide area padding (in pixels).
 *
 * @prop {(viewportSize: Point, itemData: SlideData, index: number) => Padding} [paddingFn]
 * The option is checked frequently, so make sure it's performant. Overrides padding option if defined. For example:
 *
 * @prop {number | false} hideAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {number | false} showAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {number | false} zoomAnimationDuration
 * Transition duration in milliseconds, can be 0.
 *
 * @prop {string} easing
 * String, 'cubic-bezier(.4,0,.22,1)'. CSS easing function for open/close/zoom transitions.
 *
 * @prop {boolean} escKey
 * Esc key to close.
 *
 * @prop {boolean} arrowKeys
 * Left/right arrow keys for navigation.
 *
 * @prop {boolean} trapFocus
 * Trap focus within PhotoSwipe element while it's open.
 *
 * @prop {boolean} returnFocus
 * Restore focus the last active element after PhotoSwipe is closed.
 *
 * @prop {boolean} clickToCloseNonZoomable
 * If image is not zoomable (for example, smaller than viewport) it can be closed by clicking on it.
 *
 * @prop {ActionType | ActionFn | false} imageClickAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} bgClickAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} tapAction
 * Refer to click and tap actions page.
 *
 * @prop {ActionType | ActionFn | false} doubleTapAction
 * Refer to click and tap actions page.
 *
 * @prop {number} preloaderDelay
 * Delay before the loading indicator will be displayed,
 * if image is loaded during it - the indicator will not be displayed at all. Can be zero.
 *
 * @prop {string} indexIndicatorSep
 * Used for slide count indicator ("1 of 10 ").
 *
 * @prop {(options: PhotoSwipeOptions, pswp: PhotoSwipeBase) => Point} [getViewportSizeFn]
 * A function that should return slide viewport width and height, in format {x: 100, y: 100}.
 *
 * @prop {string} errorMsg
 * Message to display when the image wasn't able to load. If you need to display HTML - use contentErrorElement filter.
 *
 * @prop {[number, number]} preload
 * Lazy loading of nearby slides based on direction of movement. Should be an array with two integers,
 * first one - number of items to preload before the current image, second one - after the current image.
 * Two nearby images are always loaded.
 *
 * @prop {string} [mainClass]
 * Class that will be added to the root element of PhotoSwipe, may contain multiple separated by space.
 * Example on Styling page.
 *
 * @prop {HTMLElement} [appendToEl]
 * Element to which PhotoSwipe dialog will be appended when it opens.
 *
 * @prop {number} maxWidthToAnimate
 * Maximum width of image to animate, if initial rendered image width
 * is larger than this value - the opening/closing transition will be automatically disabled.
 *
 * @prop {string} [closeTitle]
 * Translating
 *
 * @prop {string} [zoomTitle]
 * Translating
 *
 * @prop {string} [arrowPrevTitle]
 * Translating
 *
 * @prop {string} [arrowNextTitle]
 * Translating
 *
 * @prop {'zoom' | 'fade' | 'none'} [showHideAnimationType]
 * To adjust opening or closing transition type use lightbox option `showHideAnimationType` (`String`).
 * It supports three values - `zoom` (default), `fade` (default if there is no thumbnail) and `none`.
 *
 * Animations are automatically disabled if user `(prefers-reduced-motion: reduce)`.
 *
 * @prop {number} index
 * Defines start slide index.
 *
 * @prop {(e: MouseEvent) => number} [getClickedIndexFn]
 *
 * @prop {boolean} [arrowPrev]
 * @prop {boolean} [arrowNext]
 * @prop {boolean} [zoom]
 * @prop {boolean} [close]
 * @prop {boolean} [counter]
 *
 * @prop {string} [arrowPrevSVG]
 * @prop {string} [arrowNextSVG]
 * @prop {string} [zoomSVG]
 * @prop {string} [closeSVG]
 * @prop {string} [counterSVG]
 *
 * @prop {string} [arrowPrevTitle]
 * @prop {string} [arrowNextTitle]
 * @prop {string} [zoomTitle]
 * @prop {string} [closeTitle]
 * @prop {string} [counterTitle]
 *
 * @prop {ZoomLevelOption} [initialZoomLevel]
 * @prop {ZoomLevelOption} [secondaryZoomLevel]
 * @prop {ZoomLevelOption} [maxZoomLevel]
 *
 * @prop {boolean} [mouseMovePan]
 * @prop {Point | null} [initialPointerPos]
 * @prop {boolean} [showHideOpacity]
 *
 * @prop {PhotoSwipeModuleOption} [pswpModule]
 * @prop {() => Promise<any>} [openPromise]
 * @prop {boolean} [preloadFirstSlide]
 * @prop {ElementProvider} [gallery]
 * @prop {string} [gallerySelector]
 * @prop {ElementProvider} [children]
 * @prop {string} [childSelector]
 * @prop {string | false} [thumbSelector]
 */
/** @type {PreparedPhotoSwipeOptions} */
var defaultOptions = {
  allowPanToNext: true,
  spacing: 0.1,
  loop: true,
  pinchToClose: true,
  closeOnVerticalDrag: true,
  hideAnimationDuration: 333,
  showAnimationDuration: 333,
  zoomAnimationDuration: 333,
  escKey: true,
  arrowKeys: true,
  trapFocus: true,
  returnFocus: true,
  maxWidthToAnimate: 4000,
  clickToCloseNonZoomable: true,
  imageClickAction: 'zoom-or-close',
  bgClickAction: 'close',
  tapAction: 'toggle-controls',
  doubleTapAction: 'zoom',
  indexIndicatorSep: ' / ',
  preloaderDelay: 2000,
  bgOpacity: 0.8,
  index: 0,
  errorMsg: 'The image cannot be loaded',
  preload: [1, 2],
  easing: 'cubic-bezier(.4,0,.22,1)'
};
/**
 * PhotoSwipe Core
 */
var PhotoSwipe = exports["default"] = /*#__PURE__*/function (_PhotoSwipeBase) {
  /**
   * @param {PhotoSwipeOptions} [options]
   */
  function PhotoSwipe(options) {
    var _this20;
    _classCallCheck(this, PhotoSwipe);
    _this20 = _callSuper(this, PhotoSwipe);
    _this20.options = _this20._prepareOptions(options || {});
    /**
     * offset of viewport relative to document
     *
     * @type {Point}
     */

    _this20.offset = {
      x: 0,
      y: 0
    };
    /**
     * @type {Point}
     * @private
     */

    _this20._prevViewportSize = {
      x: 0,
      y: 0
    };
    /**
     * Size of scrollable PhotoSwipe viewport
     *
     * @type {Point}
     */

    _this20.viewportSize = {
      x: 0,
      y: 0
    };
    /**
     * background (backdrop) opacity
     */

    _this20.bgOpacity = 1;
    _this20.currIndex = 0;
    _this20.potentialIndex = 0;
    _this20.isOpen = false;
    _this20.isDestroying = false;
    _this20.hasMouse = false;
    /**
     * @private
     * @type {SlideData}
     */

    _this20._initialItemData = {};
    /** @type {Bounds | undefined} */

    _this20._initialThumbBounds = undefined;
    /** @type {HTMLDivElement | undefined} */

    _this20.topBar = undefined;
    /** @type {HTMLDivElement | undefined} */

    _this20.element = undefined;
    /** @type {HTMLDivElement | undefined} */

    _this20.template = undefined;
    /** @type {HTMLDivElement | undefined} */

    _this20.container = undefined;
    /** @type {HTMLElement | undefined} */

    _this20.scrollWrap = undefined;
    /** @type {Slide | undefined} */

    _this20.currSlide = undefined;
    _this20.events = new DOMEvents();
    _this20.animations = new Animations();
    _this20.mainScroll = new MainScroll(_this20);
    _this20.gestures = new Gestures(_this20);
    _this20.opener = new Opener(_this20);
    _this20.keyboard = new Keyboard(_this20);
    _this20.contentLoader = new ContentLoader(_this20);
    return _this20;
  }
  /** @returns {boolean} */
  _inherits(PhotoSwipe, _PhotoSwipeBase);
  return _createClass(PhotoSwipe, [{
    key: "init",
    value: function init() {
      var _this21 = this;
      if (this.isOpen || this.isDestroying) {
        return false;
      }
      this.isOpen = true;
      this.dispatch('init'); // legacy

      this.dispatch('beforeOpen');
      this._createMainStructure(); // add classes to the root element of PhotoSwipe

      var rootClasses = 'pswp--open';
      if (this.gestures.supportsTouch) {
        rootClasses += ' pswp--touch';
      }
      if (this.options.mainClass) {
        rootClasses += ' ' + this.options.mainClass;
      }
      if (this.element) {
        this.element.className += ' ' + rootClasses;
      }
      this.currIndex = this.options.index || 0;
      this.potentialIndex = this.currIndex;
      this.dispatch('firstUpdate'); // starting index can be modified here
      // initialize scroll wheel handler to block the scroll

      this.scrollWheel = new ScrollWheel(this); // sanitize index

      if (Number.isNaN(this.currIndex) || this.currIndex < 0 || this.currIndex >= this.getNumItems()) {
        this.currIndex = 0;
      }
      if (!this.gestures.supportsTouch) {
        // enable mouse features if no touch support detected
        this.mouseDetected();
      } // causes forced synchronous layout

      this.updateSize();
      this.offset.y = window.pageYOffset;
      this._initialItemData = this.getItemData(this.currIndex);
      this.dispatch('gettingData', {
        index: this.currIndex,
        data: this._initialItemData,
        slide: undefined
      }); // *Layout* - calculate size and position of elements here

      this._initialThumbBounds = this.getThumbBounds();
      this.dispatch('initialLayout');
      this.on('openingAnimationEnd', function () {
        var itemHolders = _this21.mainScroll.itemHolders; // Add content to the previous and next slide

        if (itemHolders[0]) {
          itemHolders[0].el.style.display = 'block';
          _this21.setContent(itemHolders[0], _this21.currIndex - 1);
        }
        if (itemHolders[2]) {
          itemHolders[2].el.style.display = 'block';
          _this21.setContent(itemHolders[2], _this21.currIndex + 1);
        }
        _this21.appendHeavy();
        _this21.contentLoader.updateLazy();
        _this21.events.add(window, 'resize', _this21._handlePageResize.bind(_this21));
        _this21.events.add(window, 'scroll', _this21._updatePageScrollOffset.bind(_this21));
        _this21.dispatch('bindEvents');
      }); // set content for center slide (first time)

      if (this.mainScroll.itemHolders[1]) {
        this.setContent(this.mainScroll.itemHolders[1], this.currIndex);
      }
      this.dispatch('change');
      this.opener.open();
      this.dispatch('afterInit');
      return true;
    }
    /**
     * Get looped slide index
     * (for example, -1 will return the last slide)
     *
     * @param {number} index
     * @returns {number}
     */
  }, {
    key: "getLoopedIndex",
    value: function getLoopedIndex(index) {
      var numSlides = this.getNumItems();
      if (this.options.loop) {
        if (index > numSlides - 1) {
          index -= numSlides;
        }
        if (index < 0) {
          index += numSlides;
        }
      }
      return clamp(index, 0, numSlides - 1);
    }
  }, {
    key: "appendHeavy",
    value: function appendHeavy() {
      this.mainScroll.itemHolders.forEach(function (itemHolder) {
        var _itemHolder$slide;
        (_itemHolder$slide = itemHolder.slide) === null || _itemHolder$slide === void 0 || _itemHolder$slide.appendHeavy();
      });
    }
    /**
     * Change the slide
     * @param {number} index New index
     */
  }, {
    key: "goTo",
    value: function goTo(index) {
      this.mainScroll.moveIndexBy(this.getLoopedIndex(index) - this.potentialIndex);
    }
    /**
     * Go to the next slide.
     */
  }, {
    key: "next",
    value: function next() {
      this.goTo(this.potentialIndex + 1);
    }
    /**
     * Go to the previous slide.
     */
  }, {
    key: "prev",
    value: function prev() {
      this.goTo(this.potentialIndex - 1);
    }
    /**
     * @see slide/slide.js zoomTo
     *
     * @param {Parameters<Slide['zoomTo']>} args
     */
  }, {
    key: "zoomTo",
    value: function zoomTo() {
      var _this$currSlide4;
      var _this$currSlide;
      (_this$currSlide = this.currSlide) === null || _this$currSlide === void 0 || (_this$currSlide4 = _this$currSlide).zoomTo.apply(_this$currSlide4, arguments);
    }
    /**
     * @see slide/slide.js toggleZoom
     */
  }, {
    key: "toggleZoom",
    value: function toggleZoom() {
      var _this$currSlide2;
      (_this$currSlide2 = this.currSlide) === null || _this$currSlide2 === void 0 || _this$currSlide2.toggleZoom();
    }
    /**
     * Close the gallery.
     * After closing transition ends - destroy it
     */
  }, {
    key: "close",
    value: function close() {
      if (!this.opener.isOpen || this.isDestroying) {
        return;
      }
      this.isDestroying = true;
      this.dispatch('close');
      this.events.removeAll();
      this.opener.close();
    }
    /**
     * Destroys the gallery:
     * - instantly closes the gallery
     * - unbinds events,
     * - cleans intervals and timeouts
     * - removes elements from DOM
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$element;
      if (!this.isDestroying) {
        this.options.showHideAnimationType = 'none';
        this.close();
        return;
      }
      this.dispatch('destroy');
      this._listeners = {};
      if (this.scrollWrap) {
        this.scrollWrap.ontouchmove = null;
        this.scrollWrap.ontouchend = null;
      }
      (_this$element = this.element) === null || _this$element === void 0 || _this$element.remove();
      this.mainScroll.itemHolders.forEach(function (itemHolder) {
        var _itemHolder$slide2;
        (_itemHolder$slide2 = itemHolder.slide) === null || _itemHolder$slide2 === void 0 || _itemHolder$slide2.destroy();
      });
      this.contentLoader.destroy();
      this.events.removeAll();
    }
    /**
     * Refresh/reload content of a slide by its index
     *
     * @param {number} slideIndex
     */
  }, {
    key: "refreshSlideContent",
    value: function refreshSlideContent(slideIndex) {
      var _this22 = this;
      this.contentLoader.removeByIndex(slideIndex);
      this.mainScroll.itemHolders.forEach(function (itemHolder, i) {
        var _this$currSlide$index, _this$currSlide3;
        var potentialHolderIndex = ((_this$currSlide$index = (_this$currSlide3 = _this22.currSlide) === null || _this$currSlide3 === void 0 ? void 0 : _this$currSlide3.index) !== null && _this$currSlide$index !== void 0 ? _this$currSlide$index : 0) - 1 + i;
        if (_this22.canLoop()) {
          potentialHolderIndex = _this22.getLoopedIndex(potentialHolderIndex);
        }
        if (potentialHolderIndex === slideIndex) {
          // set the new slide content
          _this22.setContent(itemHolder, slideIndex, true); // activate the new slide if it's current

          if (i === 1) {
            var _itemHolder$slide3;
            _this22.currSlide = itemHolder.slide;
            (_itemHolder$slide3 = itemHolder.slide) === null || _itemHolder$slide3 === void 0 || _itemHolder$slide3.setIsActive(true);
          }
        }
      });
      this.dispatch('change');
    }
    /**
     * Set slide content
     *
     * @param {ItemHolder} holder mainScroll.itemHolders array item
     * @param {number} index Slide index
     * @param {boolean} [force] If content should be set even if index wasn't changed
     */
  }, {
    key: "setContent",
    value: function setContent(holder, index, force) {
      if (this.canLoop()) {
        index = this.getLoopedIndex(index);
      }
      if (holder.slide) {
        if (holder.slide.index === index && !force) {
          // exit if holder already contains this slide
          // this could be common when just three slides are used
          return;
        } // destroy previous slide

        holder.slide.destroy();
        holder.slide = undefined;
      } // exit if no loop and index is out of bounds

      if (!this.canLoop() && (index < 0 || index >= this.getNumItems())) {
        return;
      }
      var itemData = this.getItemData(index);
      holder.slide = new Slide(itemData, index, this); // set current slide

      if (index === this.currIndex) {
        this.currSlide = holder.slide;
      }
      holder.slide.append(holder.el);
    }
    /** @returns {Point} */
  }, {
    key: "getViewportCenterPoint",
    value: function getViewportCenterPoint() {
      return {
        x: this.viewportSize.x / 2,
        y: this.viewportSize.y / 2
      };
    }
    /**
     * Update size of all elements.
     * Executed on init and on page resize.
     *
     * @param {boolean} [force] Update size even if size of viewport was not changed.
     */
  }, {
    key: "updateSize",
    value: function updateSize(force) {
      // let item;
      // let itemIndex;
      if (this.isDestroying) {
        // exit if PhotoSwipe is closed or closing
        // (to avoid errors, as resize event might be delayed)
        return;
      } //const newWidth = this.scrollWrap.clientWidth;
      //const newHeight = this.scrollWrap.clientHeight;

      var newViewportSize = getViewportSize(this.options, this);
      if (!force && pointsEqual(newViewportSize, this._prevViewportSize)) {
        // Exit if dimensions were not changed
        return;
      } //this._prevViewportSize.x = newWidth;
      //this._prevViewportSize.y = newHeight;

      equalizePoints(this._prevViewportSize, newViewportSize);
      this.dispatch('beforeResize');
      equalizePoints(this.viewportSize, this._prevViewportSize);
      this._updatePageScrollOffset();
      this.dispatch('viewportSize'); // Resize slides only after opener animation is finished
      // and don't re-calculate size on inital size update

      this.mainScroll.resize(this.opener.isOpen);
      if (!this.hasMouse && window.matchMedia('(any-hover: hover)').matches) {
        this.mouseDetected();
      }
      this.dispatch('resize');
    }
    /**
     * @param {number} opacity
     */
  }, {
    key: "applyBgOpacity",
    value: function applyBgOpacity(opacity) {
      this.bgOpacity = Math.max(opacity, 0);
      if (this.bg) {
        this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity);
      }
    }
    /**
     * Whether mouse is detected
     */
  }, {
    key: "mouseDetected",
    value: function mouseDetected() {
      if (!this.hasMouse) {
        var _this$element2;
        this.hasMouse = true;
        (_this$element2 = this.element) === null || _this$element2 === void 0 || _this$element2.classList.add('pswp--has_mouse');
      }
    }
    /**
     * Page resize event handler
     *
     * @private
     */
  }, {
    key: "_handlePageResize",
    value: function _handlePageResize() {
      var _this23 = this;
      this.updateSize(); // In iOS webview, if element size depends on document size,
      // it'll be measured incorrectly in resize event
      //
      // https://bugs.webkit.org/show_bug.cgi?id=170595
      // https://hackernoon.com/onresize-event-broken-in-mobile-safari-d8469027bf4d

      if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {
        setTimeout(function () {
          _this23.updateSize();
        }, 500);
      }
    }
    /**
     * Page scroll offset is used
     * to get correct coordinates
     * relative to PhotoSwipe viewport.
     *
     * @private
     */
  }, {
    key: "_updatePageScrollOffset",
    value: function _updatePageScrollOffset() {
      this.setScrollOffset(0, window.pageYOffset);
    }
    /**
     * @param {number} x
     * @param {number} y
     */
  }, {
    key: "setScrollOffset",
    value: function setScrollOffset(x, y) {
      this.offset.x = x;
      this.offset.y = y;
      this.dispatch('updateScrollOffset');
    }
    /**
     * Create main HTML structure of PhotoSwipe,
     * and add it to DOM
     *
     * @private
     */
  }, {
    key: "_createMainStructure",
    value: function _createMainStructure() {
      // root DOM element of PhotoSwipe (.pswp)
      this.element = createElement('pswp', 'div');
      this.element.setAttribute('tabindex', '-1');
      this.element.setAttribute('role', 'dialog'); // template is legacy prop

      this.template = this.element; // Background is added as a separate element,
      // as animating opacity is faster than animating rgba()

      this.bg = createElement('pswp__bg', 'div', this.element);
      this.scrollWrap = createElement('pswp__scroll-wrap', 'section', this.element);
      this.container = createElement('pswp__container', 'div', this.scrollWrap); // aria pattern: carousel

      this.scrollWrap.setAttribute('aria-roledescription', 'carousel');
      this.container.setAttribute('aria-live', 'off');
      this.container.setAttribute('id', 'pswp__items');
      this.mainScroll.appendHolders();
      this.ui = new UI(this);
      this.ui.init(); // append to DOM

      (this.options.appendToEl || document.body).appendChild(this.element);
    }
    /**
     * Get position and dimensions of small thumbnail
     *   {x:,y:,w:}
     *
     * Height is optional (calculated based on the large image)
     *
     * @returns {Bounds | undefined}
     */
  }, {
    key: "getThumbBounds",
    value: function getThumbBounds() {
      return _getThumbBounds(this.currIndex, this.currSlide ? this.currSlide.data : this._initialItemData, this);
    }
    /**
     * If the PhotoSwipe can have continuous loop
     * @returns Boolean
     */
  }, {
    key: "canLoop",
    value: function canLoop() {
      return this.options.loop && this.getNumItems() > 2;
    }
    /**
     * @private
     * @param {PhotoSwipeOptions} options
     * @returns {PreparedPhotoSwipeOptions}
     */
  }, {
    key: "_prepareOptions",
    value: function _prepareOptions(options) {
      if (window.matchMedia('(prefers-reduced-motion), (update: slow)').matches) {
        options.showHideAnimationType = 'none';
        options.zoomAnimationDuration = 0;
      }
      /** @type {PreparedPhotoSwipeOptions} */

      return _objectSpread(_objectSpread({}, defaultOptions), options);
    }
  }]);
}(PhotoSwipeBase);

},{}],96:[function(require,module,exports){
(function (global){(function (){
!function(e){"use strict";function t(e,t){this.options={},e=e||this.options;var i={frequency:350,peak:1};this.inputNode=this.filterNode=s.context.createBiquadFilter(),this.filterNode.type=t,this.outputNode=o.context.createGain(),this.filterNode.connect(this.outputNode);for(var n in i)this[n]=e[n],this[n]=void 0===this[n]||null===this[n]?i[n]:this[n]}function i(){var e,t,i=s.context.sampleRate*this.time,n=o.context.createBuffer(2,i,s.context.sampleRate),a=n.getChannelData(0),r=n.getChannelData(1);for(t=0;i>t;t++)e=this.reverse?i-t:t,a[t]=(2*Math.random()-1)*Math.pow(1-e/i,this.decay),r[t]=(2*Math.random()-1)*Math.pow(1-e/i,this.decay);this.reverbNode.buffer&&(this.inputNode.disconnect(this.reverbNode),this.reverbNode.disconnect(this.wetGainNode),this.reverbNode=o.context.createConvolver(),this.inputNode.connect(this.reverbNode),this.reverbNode.connect(this.wetGainNode)),this.reverbNode.buffer=n}function n(e){for(var t=s.context.sampleRate,i=new Float32Array(t),n=Math.PI/180,o=0;t>o;o++){var a=2*o/t-1;i[o]=(3+e)*a*20*n/(Math.PI+e*Math.abs(a))}return i}var o={},s=o,a="object"==typeof module&&module.exports,r="function"==typeof define&&define.amd;a?module.exports=o:r?define([],o):e.Pizzicato=e.Pz=o;var c=e.AudioContext||e.webkitAudioContext;if(!c)return void console.error("No AudioContext found in this environment. Please ensure your window or global object contains a working AudioContext constructor function.");o.context=new c;var h=o.context.createGain();h.connect(o.context.destination),o.Util={isString:function(e){return"[object String]"===toString.call(e)},isObject:function(e){return"[object Object]"===toString.call(e)},isFunction:function(e){return"[object Function]"===toString.call(e)},isNumber:function(e){return"[object Number]"===toString.call(e)&&e===+e},isArray:function(e){return"[object Array]"===toString.call(e)},isInRange:function(e,t,i){return s.Util.isNumber(e)&&s.Util.isNumber(t)&&s.Util.isNumber(i)?e>=t&&i>=e:!1},isBool:function(e){return"boolean"==typeof e},isOscillator:function(e){return e&&"[object OscillatorNode]"===e.toString()},isAudioBufferSourceNode:function(e){return e&&"[object AudioBufferSourceNode]"===e.toString()},isSound:function(e){return e instanceof s.Sound},isEffect:function(e){for(var t in o.Effects)if(e instanceof o.Effects[t])return!0;return!1},normalize:function(e,t,i){return s.Util.isNumber(e)&&s.Util.isNumber(t)&&s.Util.isNumber(i)?(i-t)*e/1+t:void 0},getDryLevel:function(e){return!s.Util.isNumber(e)||e>1||0>e?0:.5>=e?1:1-2*(e-.5)},getWetLevel:function(e){return!s.Util.isNumber(e)||e>1||0>e?0:e>=.5?1:1-2*(.5-e)}};var u=o.context.createGain(),d=Object.getPrototypeOf(Object.getPrototypeOf(u)),l=d.connect;d.connect=function(e){var t=s.Util.isEffect(e)?e.inputNode:e;return l.call(this,t),e},Object.defineProperty(o,"volume",{enumerable:!0,get:function(){return h.gain.value},set:function(e){s.Util.isInRange(e,0,1)&&h&&(h.gain.value=e)}}),Object.defineProperty(o,"masterGainNode",{enumerable:!1,get:function(){return h},set:function(e){console.error("Can't set the master gain node")}}),o.Events={on:function(e,t,i){if(e&&t){this._events=this._events||{};var n=this._events[e]||(this._events[e]=[]);n.push({callback:t,context:i||this,handler:this})}},trigger:function(e){if(e){var t,i,n,o;if(this._events=this._events||{},t=this._events[e]||(this._events[e]=[])){for(i=Math.max(0,arguments.length-1),n=[],o=0;i>o;o++)n[o]=arguments[o+1];for(o=0;o<t.length;o++)t[o].callback.apply(t[o].context,n)}}},off:function(e){e?this._events[e]=void 0:this._events={}}},o.Sound=function(e,t){function i(e){var t=["wave","file","input","script","sound"];if(e&&!d.isFunction(e)&&!d.isString(e)&&!d.isObject(e))return"Description type not supported. Initialize a sound using an object, a function or a string.";if(d.isObject(e)){if(!d.isString(e.source)||-1===t.indexOf(e.source))return"Specified source not supported. Sources can be wave, file, input or script";if(!("file"!==e.source||e.options&&e.options.path))return"A path is needed for sounds with a file source";if(!("script"!==e.source||e.options&&e.options.audioFunction))return"An audio function is needed for sounds with a script source"}}function n(e,t){e=e||{},this.getRawSourceNode=function(){var t=this.sourceNode?this.sourceNode.frequency.value:e.frequency,i=o.context.createOscillator();return i.type=e.type||"sine",i.frequency.value=t||440,i},this.sourceNode=this.getRawSourceNode(),this.sourceNode.gainSuccessor=s.context.createGain(),this.sourceNode.connect(this.sourceNode.gainSuccessor),d.isFunction(t)&&t()}function a(e,t){e=d.isArray(e)?e:[e];var i=new XMLHttpRequest;i.open("GET",e[0],!0),i.responseType="arraybuffer",i.onload=function(i){o.context.decodeAudioData(i.target.response,function(e){u.getRawSourceNode=function(){var t=o.context.createBufferSource();return t.loop=this.loop,t.buffer=e,t},d.isFunction(t)&&t()}.bind(u),function(i){return console.error("Error decoding audio file "+e[0]),e.length>1?(e.shift(),void a(e,t)):(i=i||new Error("Error decoding audio file "+e[0]),void(d.isFunction(t)&&t(i)))}.bind(u))},i.onreadystatechange=function(t){4===i.readyState&&200!==i.status&&console.error("Error while fetching "+e[0]+". "+i.statusText)},i.send()}function r(e,t){if(navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia,!navigator.getUserMedia&&!navigator.mediaDevices.getUserMedia)return void console.error("Your browser does not support getUserMedia");var i=function(e){u.getRawSourceNode=function(){return o.context.createMediaStreamSource(e)},d.isFunction(t)&&t()}.bind(u),n=function(e){d.isFunction(t)&&t(e)};navigator.mediaDevices.getUserMedia?navigator.mediaDevices.getUserMedia({audio:!0}).then(i)["catch"](n):navigator.getUserMedia({audio:!0},i,n)}function c(e,t){var i=d.isFunction(e)?e:e.audioFunction,n=d.isObject(e)&&e.bufferSize?e.bufferSize:null;if(!n)try{o.context.createScriptProcessor()}catch(s){n=2048}this.getRawSourceNode=function(){var e=o.context.createScriptProcessor(n,1,1);return e.onaudioprocess=i,e}}function h(e,t){this.getRawSourceNode=e.sound.getRawSourceNode,e.sound.sourceNode&&s.Util.isOscillator(e.sound.sourceNode)&&(this.sourceNode=this.getRawSourceNode(),this.frequency=e.sound.frequency)}var u=this,d=o.Util,l=i(e),f=d.isObject(e)&&d.isObject(e.options),p=.04,v=.04;if(l)throw console.error(l),new Error("Error initializing Pizzicato Sound: "+l);this.detached=f&&e.options.detached,this.masterVolume=o.context.createGain(),this.fadeNode=o.context.createGain(),this.fadeNode.gain.value=0,this.detached||this.masterVolume.connect(o.masterGainNode),this.lastTimePlayed=0,this.effects=[],this.effectConnectors=[],this.playing=this.paused=!1,this.loop=f&&e.options.loop,this.attack=f&&d.isNumber(e.options.attack)?e.options.attack:p,this.volume=f&&d.isNumber(e.options.volume)?e.options.volume:1,f&&d.isNumber(e.options.release)?this.release=e.options.release:f&&d.isNumber(e.options.sustain)?(console.warn("'sustain' is deprecated. Use 'release' instead."),this.release=e.options.sustain):this.release=v,e?d.isString(e)?a.bind(this)(e,t):d.isFunction(e)?c.bind(this)(e,t):"file"===e.source?a.bind(this)(e.options.path,t):"wave"===e.source?n.bind(this)(e.options,t):"input"===e.source?r.bind(this)(e,t):"script"===e.source?c.bind(this)(e.options,t):"sound"===e.source&&h.bind(this)(e.options,t):n.bind(this)({},t)},o.Sound.prototype=Object.create(o.Events,{play:{enumerable:!0,value:function(e,t){this.playing||(s.Util.isNumber(t)||(t=this.offsetTime||0),s.Util.isNumber(e)||(e=0),this.playing=!0,this.paused=!1,this.sourceNode=this.getSourceNode(),this.applyAttack(),s.Util.isFunction(this.sourceNode.start)&&(this.lastTimePlayed=o.context.currentTime-t,this.sourceNode.start(s.context.currentTime+e,t)),this.trigger("play"))}},stop:{enumerable:!0,value:function(){(this.paused||this.playing)&&(this.paused=this.playing=!1,this.stopWithRelease(),this.offsetTime=0,this.trigger("stop"))}},pause:{enumerable:!0,value:function(){if(!this.paused&&this.playing){this.paused=!0,this.playing=!1,this.stopWithRelease();var e=s.context.currentTime-this.lastTimePlayed;this.sourceNode.buffer?this.offsetTime=e%(this.sourceNode.buffer.length/s.context.sampleRate):this.offsetTime=e,this.trigger("pause")}}},clone:{enumerable:!0,value:function(){for(var e=new o.Sound({source:"sound",options:{loop:this.loop,attack:this.attack,release:this.release,volume:this.volume,sound:this}}),t=0;t<this.effects.length;t++)e.addEffect(this.effects[t]);return e}},onEnded:{enumerable:!0,value:function(e){return function(){this.sourceNode&&this.sourceNode!==e||(this.playing&&this.stop(),this.paused||this.trigger("end"))}}},addEffect:{enumerable:!0,value:function(e){if(!s.Util.isEffect(e))return console.error("The object provided is not a Pizzicato effect."),this;this.effects.push(e);var t=this.effectConnectors.length>0?this.effectConnectors[this.effectConnectors.length-1]:this.fadeNode;t.disconnect(),t.connect(e);var i=s.context.createGain();return this.effectConnectors.push(i),e.connect(i),i.connect(this.masterVolume),this}},removeEffect:{enumerable:!0,value:function(e){var t=this.effects.indexOf(e);if(-1===t)return console.warn("Cannot remove effect that is not applied to this sound."),this;var i=this.playing;i&&this.pause();var n=0===t?this.fadeNode:this.effectConnectors[t-1];n.disconnect();var o=this.effectConnectors[t];o.disconnect(),e.disconnect(o),this.effectConnectors.splice(t,1),this.effects.splice(t,1);var s;return s=t>this.effects.length-1||0===this.effects.length?this.masterVolume:this.effects[t],n.connect(s),i&&this.play(),this}},connect:{enumerable:!0,value:function(e){return this.masterVolume.connect(e),this}},disconnect:{enumerable:!0,value:function(e){return this.masterVolume.disconnect(e),this}},connectEffects:{enumerable:!0,value:function(){for(var e=[],t=0;t<this.effects.length;t++){var i=t===this.effects.length-1,n=i?this.masterVolume:this.effects[t+1].inputNode;e[t]=s.context.createGain(),this.effects[t].outputNode.disconnect(this.effectConnectors[t]),this.effects[t].outputNode.connect(n)}}},volume:{enumerable:!0,get:function(){return this.masterVolume?this.masterVolume.gain.value:void 0},set:function(e){s.Util.isInRange(e,0,1)&&this.masterVolume&&(this.masterVolume.gain.value=e)}},frequency:{enumerable:!0,get:function(){return this.sourceNode&&s.Util.isOscillator(this.sourceNode)?this.sourceNode.frequency.value:null},set:function(e){this.sourceNode&&s.Util.isOscillator(this.sourceNode)&&(this.sourceNode.frequency.value=e)}},sustain:{enumerable:!0,get:function(){return console.warn("'sustain' is deprecated. Use 'release' instead."),this.release},set:function(e){console.warn("'sustain' is deprecated. Use 'release' instead."),s.Util.isInRange(e,0,10)&&(this.release=e)}},getSourceNode:{enumerable:!0,value:function(){if(this.sourceNode){var e=this.sourceNode;e.gainSuccessor.gain.setValueAtTime(e.gainSuccessor.gain.value,s.context.currentTime),e.gainSuccessor.gain.linearRampToValueAtTime(1e-4,s.context.currentTime+.2),setTimeout(function(){e.disconnect(),e.gainSuccessor.disconnect()},200)}var t=this.getRawSourceNode();return t.gainSuccessor=s.context.createGain(),t.connect(t.gainSuccessor),t.gainSuccessor.connect(this.fadeNode),this.fadeNode.connect(this.getInputNode()),s.Util.isAudioBufferSourceNode(t)&&(t.onended=this.onEnded(t).bind(this)),t}},getInputNode:{enumerable:!0,value:function(){return this.effects.length>0?this.effects[0].inputNode:this.masterVolume}},applyAttack:{enumerable:!1,value:function(){this.fadeNode.gain.value;if(this.fadeNode.gain.cancelScheduledValues(s.context.currentTime),!this.attack)return void this.fadeNode.gain.setTargetAtTime(1,s.context.currentTime,.001);var e=navigator.userAgent.toLowerCase().indexOf("firefox")>-1,t=this.attack;e||(t=(1-this.fadeNode.gain.value)*this.attack),this.fadeNode.gain.setTargetAtTime(1,s.context.currentTime,2*t)}},stopWithRelease:{enumerable:!1,value:function(e){var t=this.sourceNode,i=function(){return s.Util.isFunction(t.stop)?t.stop(0):t.disconnect()};this.fadeNode.gain.value;if(this.fadeNode.gain.cancelScheduledValues(s.context.currentTime),!this.release)return this.fadeNode.gain.setTargetAtTime(0,s.context.currentTime,.001),void i();var n=navigator.userAgent.toLowerCase().indexOf("firefox")>-1,o=this.release;n||(o=this.fadeNode.gain.value*this.release),this.fadeNode.gain.setTargetAtTime(1e-5,s.context.currentTime,o/5),window.setTimeout(function(){i()},1e3*o)}}}),o.Group=function(e){e=e||[],this.mergeGainNode=s.context.createGain(),this.masterVolume=s.context.createGain(),this.sounds=[],this.effects=[],this.effectConnectors=[],this.mergeGainNode.connect(this.masterVolume),this.masterVolume.connect(s.masterGainNode);for(var t=0;t<e.length;t++)this.addSound(e[t])},o.Group.prototype=Object.create(s.Events,{connect:{enumerable:!0,value:function(e){return this.masterVolume.connect(e),this}},disconnect:{enumerable:!0,value:function(e){return this.masterVolume.disconnect(e),this}},addSound:{enumerable:!0,value:function(e){return s.Util.isSound(e)?this.sounds.indexOf(e)>-1?void console.warn("The Pizzicato.Sound object was already added to this group"):e.detached?void console.warn("Groups do not support detached sounds. You can manually create an audio graph to group detached sounds together."):(e.disconnect(s.masterGainNode),e.connect(this.mergeGainNode),void this.sounds.push(e)):void console.error("You can only add Pizzicato.Sound objects")}},removeSound:{enumerable:!0,value:function(e){var t=this.sounds.indexOf(e);return-1===t?void console.warn("Cannot remove a sound that is not part of this group."):(e.disconnect(this.mergeGainNode),e.connect(s.masterGainNode),void this.sounds.splice(t,1))}},volume:{enumerable:!0,get:function(){return this.masterVolume?this.masterVolume.gain.value:void 0},set:function(e){s.Util.isInRange(e,0,1)&&(this.masterVolume.gain.value=e)}},play:{enumerable:!0,value:function(){for(var e=0;e<this.sounds.length;e++)this.sounds[e].play();this.trigger("play")}},stop:{enumerable:!0,value:function(){for(var e=0;e<this.sounds.length;e++)this.sounds[e].stop();this.trigger("stop")}},pause:{enumerable:!0,value:function(){for(var e=0;e<this.sounds.length;e++)this.sounds[e].pause();this.trigger("pause")}},addEffect:{enumerable:!0,value:function(e){if(!s.Util.isEffect(e))return console.error("The object provided is not a Pizzicato effect."),this;this.effects.push(e);var t=this.effectConnectors.length>0?this.effectConnectors[this.effectConnectors.length-1]:this.mergeGainNode;t.disconnect(),t.connect(e);var i=s.context.createGain();return this.effectConnectors.push(i),e.connect(i),i.connect(this.masterVolume),this}},removeEffect:{enumerable:!0,value:function(e){var t=this.effects.indexOf(e);if(-1===t)return console.warn("Cannot remove effect that is not applied to this group."),this;var i=0===t?this.mergeGainNode:this.effectConnectors[t-1];i.disconnect();var n=this.effectConnectors[t];n.disconnect(),e.disconnect(n),this.effectConnectors.splice(t,1),this.effects.splice(t,1);var o;return o=t>this.effects.length-1||0===this.effects.length?this.masterVolume:this.effects[t],i.connect(o),this}}}),o.Effects={};var f=Object.create(null,{connect:{enumerable:!0,value:function(e){return this.outputNode.connect(e),this}},disconnect:{enumerable:!0,value:function(e){return this.outputNode.disconnect(e),this}}});o.Effects.Delay=function(e){this.options={},e=e||this.options;var t={feedback:.5,time:.3,mix:.5};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.feedbackGainNode=o.context.createGain(),this.delayNode=o.context.createDelay(),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.delayNode.connect(this.feedbackGainNode),this.feedbackGainNode.connect(this.delayNode),this.inputNode.connect(this.delayNode),this.delayNode.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Delay.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},time:{enumerable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,0,180)&&(this.options.time=e,this.delayNode.delayTime.value=e)}},feedback:{enumerable:!0,get:function(){return this.options.feedback},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.feedback=parseFloat(e,10),this.feedbackGainNode.gain.value=this.feedback)}}}),o.Effects.Compressor=function(e){this.options={},e=e||this.options;var t={threshold:-24,knee:30,attack:.003,release:.25,ratio:12};this.inputNode=this.compressorNode=o.context.createDynamicsCompressor(),this.outputNode=o.context.createGain(),this.compressorNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Compressor.prototype=Object.create(f,{threshold:{enumerable:!0,get:function(){return this.compressorNode.threshold.value},set:function(e){o.Util.isInRange(e,-100,0)&&(this.compressorNode.threshold.value=e)}},knee:{enumerable:!0,get:function(){return this.compressorNode.knee.value},set:function(e){o.Util.isInRange(e,0,40)&&(this.compressorNode.knee.value=e)}},attack:{enumerable:!0,get:function(){return this.compressorNode.attack.value},set:function(e){o.Util.isInRange(e,0,1)&&(this.compressorNode.attack.value=e)}},release:{enumerable:!0,get:function(){return this.compressorNode.release.value},set:function(e){o.Util.isInRange(e,0,1)&&(this.compressorNode.release.value=e)}},ratio:{enumerable:!0,get:function(){return this.compressorNode.ratio.value},set:function(e){o.Util.isInRange(e,1,20)&&(this.compressorNode.ratio.value=e)}},getCurrentGainReduction:function(){return this.compressorNode.reduction}}),o.Effects.LowPassFilter=function(e){t.call(this,e,"lowpass")},o.Effects.HighPassFilter=function(e){t.call(this,e,"highpass")};var p=Object.create(f,{frequency:{enumerable:!0,get:function(){return this.filterNode.frequency.value},set:function(e){o.Util.isInRange(e,10,22050)&&(this.filterNode.frequency.value=e)}},peak:{enumerable:!0,get:function(){return this.filterNode.Q.value},set:function(e){o.Util.isInRange(e,1e-4,1e3)&&(this.filterNode.Q.value=e)}}});o.Effects.LowPassFilter.prototype=p,o.Effects.HighPassFilter.prototype=p,o.Effects.Distortion=function(e){this.options={},e=e||this.options;var t={gain:.5};this.waveShaperNode=o.context.createWaveShaper(),this.inputNode=this.outputNode=this.waveShaperNode;for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Distortion.prototype=Object.create(f,{gain:{enumerable:!0,get:function(){return this.options.gain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.gain=e,this.adjustGain())}},adjustGain:{writable:!1,configurable:!1,enumerable:!1,value:function(){for(var e,t=s.Util.isNumber(this.options.gain)?parseInt(100*this.options.gain,10):50,i=44100,n=new Float32Array(i),o=Math.PI/180,a=0;i>a;++a)e=2*a/i-1,n[a]=(3+t)*e*20*o/(Math.PI+t*Math.abs(e));this.waveShaperNode.curve=n}}}),o.Effects.Flanger=function(e){this.options={},e=e||this.options;var t={time:.45,speed:.2,depth:.1,feedback:.1,mix:.5};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.inputFeedbackNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.delayNode=o.context.createDelay(),this.oscillatorNode=o.context.createOscillator(),this.gainNode=o.context.createGain(),this.feedbackNode=o.context.createGain(),this.oscillatorNode.type="sine",this.inputNode.connect(this.inputFeedbackNode),this.inputNode.connect(this.dryGainNode),this.inputFeedbackNode.connect(this.delayNode),this.inputFeedbackNode.connect(this.wetGainNode),this.delayNode.connect(this.wetGainNode),this.delayNode.connect(this.feedbackNode),this.feedbackNode.connect(this.inputFeedbackNode),this.oscillatorNode.connect(this.gainNode),this.gainNode.connect(this.delayNode.delayTime),this.dryGainNode.connect(this.outputNode),this.wetGainNode.connect(this.outputNode),this.oscillatorNode.start(0);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Flanger.prototype=Object.create(f,{time:{enumberable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.time=e,this.delayNode.delayTime.value=s.Util.normalize(e,.001,.02))}},speed:{enumberable:!0,get:function(){return this.options.speed},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.speed=e,this.oscillatorNode.frequency.value=s.Util.normalize(e,.5,5))}},depth:{enumberable:!0,get:function(){return this.options.depth},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.depth=e,this.gainNode.gain.value=s.Util.normalize(e,5e-4,.005))}},feedback:{enumberable:!0,get:function(){return this.options.feedback},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.feedback=e,this.feedbackNode.gain.value=s.Util.normalize(e,0,.8))}},mix:{enumberable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}}}),o.Effects.StereoPanner=function(e){this.options={},e=e||this.options;var t={pan:0};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),o.context.createStereoPanner?(this.pannerNode=o.context.createStereoPanner(),this.inputNode.connect(this.pannerNode),this.pannerNode.connect(this.outputNode)):o.context.createPanner?(console.warn("Your browser does not support the StereoPannerNode. Will use PannerNode instead."),this.pannerNode=o.context.createPanner(),this.pannerNode.type="equalpower",this.inputNode.connect(this.pannerNode),this.pannerNode.connect(this.outputNode)):(console.warn("Your browser does not support the Panner effect."),this.inputNode.connect(this.outputNode));for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.StereoPanner.prototype=Object.create(f,{pan:{enumerable:!0,get:function(){return this.options.pan},set:function(e){if(s.Util.isInRange(e,-1,1)&&(this.options.pan=e,this.pannerNode)){var t=this.pannerNode.toString().indexOf("StereoPannerNode")>-1;t?this.pannerNode.pan.value=e:this.pannerNode.setPosition(e,0,1-Math.abs(e))}}}}),o.Effects.Convolver=function(e,t){this.options={},e=e||this.options;var i=this,n=new XMLHttpRequest,a={mix:.5};this.callback=t,this.inputNode=o.context.createGain(),this.convolverNode=o.context.createConvolver(),this.outputNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.inputNode.connect(this.convolverNode),this.convolverNode.connect(this.wetGainNode),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.wetGainNode.connect(this.outputNode);for(var r in a)this[r]=e[r],this[r]=void 0===this[r]||null===this[r]?a[r]:this[r];return e.impulse?(n.open("GET",e.impulse,!0),n.responseType="arraybuffer",n.onload=function(e){var t=e.target.response;o.context.decodeAudioData(t,function(e){i.convolverNode.buffer=e,i.callback&&s.Util.isFunction(i.callback)&&i.callback()},function(e){e=e||new Error("Error decoding impulse file"),i.callback&&s.Util.isFunction(i.callback)&&i.callback(e)})},n.onreadystatechange=function(t){4===n.readyState&&200!==n.status&&console.error("Error while fetching "+e.impulse+". "+n.statusText)},void n.send()):void console.error("No impulse file specified.")},o.Effects.Convolver.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}}}),o.Effects.PingPongDelay=function(e){this.options={},e=e||this.options;var t={feedback:.5,time:.3,mix:.5};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.delayNodeLeft=o.context.createDelay(),this.delayNodeRight=o.context.createDelay(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.feedbackGainNode=o.context.createGain(),this.channelMerger=o.context.createChannelMerger(2),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.delayNodeLeft.connect(this.channelMerger,0,0),this.delayNodeRight.connect(this.channelMerger,0,1),this.delayNodeLeft.connect(this.delayNodeRight),this.feedbackGainNode.connect(this.delayNodeLeft),this.delayNodeRight.connect(this.feedbackGainNode),this.inputNode.connect(this.feedbackGainNode),this.channelMerger.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.PingPongDelay.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},time:{enumerable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,0,180)&&(this.options.time=e,this.delayNodeLeft.delayTime.value=e,this.delayNodeRight.delayTime.value=e)}},feedback:{enumerable:!0,get:function(){return this.options.feedback},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.feedback=parseFloat(e,10),this.feedbackGainNode.gain.value=this.feedback)}}}),o.Effects.Reverb=function(e){this.options={},e=e||this.options;var t={mix:.5,time:.01,decay:.01,reverse:!1};this.inputNode=o.context.createGain(),this.reverbNode=o.context.createConvolver(),this.outputNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.inputNode.connect(this.reverbNode),this.reverbNode.connect(this.wetGainNode),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.wetGainNode.connect(this.outputNode);for(var n in t)this[n]=e[n],this[n]=void 0===this[n]||null===this[n]?t[n]:this[n];i.bind(this)()},o.Effects.Reverb.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},time:{enumerable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,1e-4,10)&&(this.options.time=e,i.bind(this)())}},decay:{enumerable:!0,get:function(){return this.options.decay},set:function(e){s.Util.isInRange(e,1e-4,10)&&(this.options.decay=e,i.bind(this)())}},reverse:{enumerable:!0,get:function(){return this.options.reverse},set:function(e){s.Util.isBool(e)&&(this.options.reverse=e,i.bind(this)())}}}),o.Effects.Tremolo=function(e){this.options={},e=e||this.options;var t={speed:4,depth:1,mix:.8};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.tremoloGainNode=o.context.createGain(),this.tremoloGainNode.gain.value=0,this.lfoNode=o.context.createOscillator(),this.shaperNode=o.context.createWaveShaper(),this.shaperNode.curve=new Float32Array([0,1]),this.shaperNode.connect(this.tremoloGainNode.gain),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.lfoNode.connect(this.shaperNode),this.lfoNode.type="sine",this.lfoNode.start(0),this.inputNode.connect(this.tremoloGainNode),this.tremoloGainNode.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.Tremolo.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},speed:{enumerable:!0,get:function(){return this.options.speed},set:function(e){s.Util.isInRange(e,0,20)&&(this.options.speed=e,this.lfoNode.frequency.value=e)}},depth:{enumerable:!0,get:function(){return this.options.depth},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.depth=e,this.shaperNode.curve=new Float32Array([1-e,1]))}}}),o.Effects.DubDelay=function(e){this.options={},e=e||this.options;var t={feedback:.6,time:.7,mix:.5,cutoff:700};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.feedbackGainNode=o.context.createGain(),this.delayNode=o.context.createDelay(),this.bqFilterNode=o.context.createBiquadFilter(),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.inputNode.connect(this.wetGainNode),this.inputNode.connect(this.feedbackGainNode),this.feedbackGainNode.connect(this.bqFilterNode),this.bqFilterNode.connect(this.delayNode),this.delayNode.connect(this.feedbackGainNode),this.delayNode.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]},o.Effects.DubDelay.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},time:{enumerable:!0,get:function(){return this.options.time},set:function(e){s.Util.isInRange(e,0,180)&&(this.options.time=e,this.delayNode.delayTime.value=e)}},feedback:{enumerable:!0,get:function(){return this.options.feedback},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.feedback=parseFloat(e,10),this.feedbackGainNode.gain.value=this.feedback)}},cutoff:{enumerable:!0,get:function(){return this.options.cutoff},set:function(e){s.Util.isInRange(e,0,4e3)&&(this.options.cutoff=e,this.bqFilterNode.frequency.value=this.cutoff)}}}),o.Effects.RingModulator=function(e){this.options={},e=e||this.options;var t={speed:30,distortion:1,mix:.5};this.inputNode=o.context.createGain(),this.outputNode=o.context.createGain(),this.dryGainNode=o.context.createGain(),this.wetGainNode=o.context.createGain(),this.vIn=o.context.createOscillator(),this.vIn.start(0),this.vInGain=o.context.createGain(),this.vInGain.gain.value=.5,this.vInInverter1=o.context.createGain(),this.vInInverter1.gain.value=-1,this.vInInverter2=o.context.createGain(),this.vInInverter2.gain.value=-1,this.vInDiode1=new v(o.context),this.vInDiode2=new v(o.context),this.vInInverter3=o.context.createGain(),this.vInInverter3.gain.value=-1,this.vcInverter1=o.context.createGain(),this.vcInverter1.gain.value=-1,this.vcDiode3=new v(o.context),this.vcDiode4=new v(o.context),this.outGain=o.context.createGain(),this.outGain.gain.value=3,this.compressor=o.context.createDynamicsCompressor(),this.compressor.threshold.value=-24,this.compressor.ratio.value=16,this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode),this.inputNode.connect(this.vcInverter1),this.inputNode.connect(this.vcDiode4.node),this.vcInverter1.connect(this.vcDiode3.node),this.vIn.connect(this.vInGain),this.vInGain.connect(this.vInInverter1),this.vInGain.connect(this.vcInverter1),this.vInGain.connect(this.vcDiode4.node),this.vInInverter1.connect(this.vInInverter2),this.vInInverter1.connect(this.vInDiode2.node),this.vInInverter2.connect(this.vInDiode1.node),this.vInDiode1.connect(this.vInInverter3),this.vInDiode2.connect(this.vInInverter3),this.vInInverter3.connect(this.compressor),this.vcDiode3.connect(this.compressor),this.vcDiode4.connect(this.compressor),this.compressor.connect(this.outGain),
this.outGain.connect(this.wetGainNode),this.wetGainNode.connect(this.outputNode);for(var i in t)this[i]=e[i],this[i]=void 0===this[i]||null===this[i]?t[i]:this[i]};var v=function(e){this.context=e,this.node=this.context.createWaveShaper(),this.vb=.2,this.vl=.4,this.h=1,this.setCurve()};return v.prototype.setDistortion=function(e){return this.h=e,this.setCurve()},v.prototype.setCurve=function(){var e,t,i,n,o,s,a,r;for(t=1024,o=new Float32Array(t),e=s=0,a=o.length;a>=0?a>s:s>a;e=a>=0?++s:--s)i=(e-t/2)/(t/2),i=Math.abs(i),n=i<=this.vb?0:this.vb<i&&i<=this.vl?this.h*(Math.pow(i-this.vb,2)/(2*this.vl-2*this.vb)):this.h*i-this.h*this.vl+this.h*(Math.pow(this.vl-this.vb,2)/(2*this.vl-2*this.vb)),o[e]=n;return r=this.node.curve=o},v.prototype.connect=function(e){return this.node.connect(e)},o.Effects.RingModulator.prototype=Object.create(f,{mix:{enumerable:!0,get:function(){return this.options.mix},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.mix=e,this.dryGainNode.gain.value=o.Util.getDryLevel(this.mix),this.wetGainNode.gain.value=o.Util.getWetLevel(this.mix))}},speed:{enumerable:!0,get:function(){return this.options.speed},set:function(e){s.Util.isInRange(e,0,2e3)&&(this.options.speed=e,this.vIn.frequency.value=e)}},distortion:{enumerable:!0,get:function(){return this.options.distortion},set:function(e){if(s.Util.isInRange(e,.2,50)){this.options.distortion=parseFloat(e,10);for(var t=[this.vInDiode1,this.vInDiode2,this.vcDiode3,this.vcDiode4],i=0,n=t.length;n>i;i++)t[i].setDistortion(e)}}}}),o.Effects.Quadrafuzz=function(e){this.options={},e=e||this.options;var t={lowGain:.6,midLowGain:.8,midHighGain:.5,highGain:.6};this.inputNode=s.context.createGain(),this.outputNode=s.context.createGain(),this.dryGainNode=s.context.createGain(),this.wetGainNode=s.context.createGain(),this.lowpassLeft=s.context.createBiquadFilter(),this.lowpassLeft.type="lowpass",this.lowpassLeft.frequency.value=147,this.lowpassLeft.Q.value=.7071,this.bandpass1Left=s.context.createBiquadFilter(),this.bandpass1Left.type="bandpass",this.bandpass1Left.frequency.value=587,this.bandpass1Left.Q.value=.7071,this.bandpass2Left=s.context.createBiquadFilter(),this.bandpass2Left.type="bandpass",this.bandpass2Left.frequency.value=2490,this.bandpass2Left.Q.value=.7071,this.highpassLeft=s.context.createBiquadFilter(),this.highpassLeft.type="highpass",this.highpassLeft.frequency.value=4980,this.highpassLeft.Q.value=.7071,this.overdrives=[];for(var i=0;4>i;i++)this.overdrives[i]=s.context.createWaveShaper(),this.overdrives[i].curve=n();this.inputNode.connect(this.wetGainNode),this.inputNode.connect(this.dryGainNode),this.dryGainNode.connect(this.outputNode);var o=[this.lowpassLeft,this.bandpass1Left,this.bandpass2Left,this.highpassLeft];for(i=0;i<o.length;i++)this.wetGainNode.connect(o[i]),o[i].connect(this.overdrives[i]),this.overdrives[i].connect(this.outputNode);for(var a in t)this[a]=e[a],this[a]=void 0===this[a]||null===this[a]?t[a]:this[a]},o.Effects.Quadrafuzz.prototype=Object.create(f,{lowGain:{enumerable:!0,get:function(){return this.options.lowGain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.lowGain=e,this.overdrives[0].curve=n(s.Util.normalize(this.lowGain,0,150)))}},midLowGain:{enumerable:!0,get:function(){return this.options.midLowGain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.midLowGain=e,this.overdrives[1].curve=n(s.Util.normalize(this.midLowGain,0,150)))}},midHighGain:{enumerable:!0,get:function(){return this.options.midHighGain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.midHighGain=e,this.overdrives[2].curve=n(s.Util.normalize(this.midHighGain,0,150)))}},highGain:{enumerable:!0,get:function(){return this.options.highGain},set:function(e){s.Util.isInRange(e,0,1)&&(this.options.highGain=e,this.overdrives[3].curve=n(s.Util.normalize(this.highGain,0,150)))}}}),o}("undefined"!=typeof window?window:global);
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],97:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],98:[function(require,module,exports){
"use strict";
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backoff = Backoff;
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
};

},{}],99:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebTransport = exports.WebSocket = exports.NodeWebSocket = exports.XHR = exports.NodeXHR = exports.Fetch = exports.Socket = exports.Manager = exports.protocol = void 0;
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = (0, url_js_1.url)(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
var engine_io_client_1 = require("engine.io-client");
Object.defineProperty(exports, "Fetch", { enumerable: true, get: function () { return engine_io_client_1.Fetch; } });
Object.defineProperty(exports, "NodeXHR", { enumerable: true, get: function () { return engine_io_client_1.NodeXHR; } });
Object.defineProperty(exports, "XHR", { enumerable: true, get: function () { return engine_io_client_1.XHR; } });
Object.defineProperty(exports, "NodeWebSocket", { enumerable: true, get: function () { return engine_io_client_1.NodeWebSocket; } });
Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return engine_io_client_1.WebSocket; } });
Object.defineProperty(exports, "WebTransport", { enumerable: true, get: function () { return engine_io_client_1.WebTransport; } });

module.exports = lookup;

},{"./manager.js":100,"./socket.js":102,"./url.js":103,"debug":104,"engine.io-client":67,"socket.io-parser":107}],100:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
const engine_io_client_1 = require("engine.io-client");
const socket_js_1 = require("./socket.js");
const parser = __importStar(require("socket.io-parser"));
const on_js_1 = require("./on.js");
const backo2_js_1 = require("./contrib/backo2.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:manager"); // debug()
class Manager extends component_emitter_1.Emitter {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        (0, engine_io_client_1.installTimerFunctions)(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2_js_1.Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        if (!v) {
            this.skipReconnect = true;
        }
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        debug("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
            return this;
        debug("opening %s", this.uri);
        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = (0, on_js_1.on)(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        const onError = (err) => {
            debug("error");
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                this.maybeReconnectOnOpen();
            }
        };
        // emit `error`
        const errorSub = (0, on_js_1.on)(socket, "error", onError);
        if (false !== this._timeout) {
            const timeout = this._timeout;
            debug("connect attempt will timeout after %d", timeout);
            // set timer
            const timer = this.setTimeoutFn(() => {
                debug("connect attempt timed out after %d", timeout);
                openSubDestroy();
                onError(new Error("timeout"));
                socket.close();
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        debug("open");
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push((0, on_js_1.on)(socket, "ping", this.onping.bind(this)), (0, on_js_1.on)(socket, "data", this.ondata.bind(this)), (0, on_js_1.on)(socket, "error", this.onerror.bind(this)), (0, on_js_1.on)(socket, "close", this.onclose.bind(this)), 
        // @ts-ignore
        (0, on_js_1.on)(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        try {
            this.decoder.add(data);
        }
        catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        (0, engine_io_client_1.nextTick)(() => {
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        debug("error", err);
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new socket_js_1.Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        else if (this._autoConnect && !socket.active) {
            socket.connect();
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                debug("socket %s is still active, skipping close", nsp);
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        debug("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        debug("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        debug("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called when:
     *
     * - the low-level engine is closed
     * - the parser encountered a badly formatted packet
     * - all sockets are disconnected
     *
     * @private
     */
    onclose(reason, description) {
        var _a;
        debug("closed due to %s", reason);
        this.cleanup();
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug("reconnect failed");
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", delay);
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                debug("attempting reconnect");
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        debug("reconnect attempt error");
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        debug("reconnect success");
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}
exports.Manager = Manager;

},{"./contrib/backo2.js":98,"./on.js":101,"./socket.js":102,"@socket.io/component-emitter":59,"debug":104,"engine.io-client":67,"socket.io-parser":107}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.on = on;
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}

},{}],102:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const socket_io_parser_1 = require("socket.io-parser");
const on_js_1 = require("./on.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:socket"); // debug()
/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
class Socket extends component_emitter_1.Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */
        this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */
        this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */
        this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */
        this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */
        this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */
        this._queueSeq = 0;
        this.ids = 0;
        /**
         * A map containing acknowledgement handlers.
         *
         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
         *
         * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
         * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
         * - `const value = await socket.emitWithAck("test")`
         *
         * From those that don't:
         *
         * - `socket.emit("test", (value) => { ... });`
         *
         * In the first case, the handlers will be called with an error when:
         *
         * - the timeout is reached
         * - the socket gets disconnected
         *
         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
         * an acknowledgement from the server.
         *
         * @private
         */
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            (0, on_js_1.on)(io, "open", this.onopen.bind(this)),
            (0, on_js_1.on)(io, "packet", this.onpacket.bind(this)),
            (0, on_js_1.on)(io, "error", this.onerror.bind(this)),
            (0, on_js_1.on)(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
        var _a, _b, _c;
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            debug("emitting packet with ack id %d", id);
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
        const discardPacket = this.flags.volatile && !isTransportWritable;
        if (discardPacket) {
            debug("discard packet as the transport is not currently writable");
        }
        else if (isConnected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    debug("removing packet with ack id %d from the buffer", id);
                    this.sendBuffer.splice(i, 1);
                }
            }
            debug("event with ack id %d has timed out after %d ms", id, timeout);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        const fn = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, args);
        };
        fn.withError = true;
        this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            const fn = (arg1, arg2) => {
                return arg1 ? reject(arg1) : resolve(arg2);
            };
            fn.withError = true;
            args.push(fn);
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
            ack = args.pop();
        }
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({ fromQueue: true }, this.flags),
        };
        args.push((err, ...responseArgs) => {
            if (packet !== this._queue[0]) {
                // the packet has already been acknowledged
                return;
            }
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
                    this._queue.shift();
                    if (ack) {
                        ack(err);
                    }
                }
            }
            else {
                debug("packet [%d] was successfully sent", packet.id);
                this._queue.shift();
                if (ack) {
                    ack(null, ...responseArgs);
                }
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
        debug("draining queue");
        if (!this.connected || this._queue.length === 0) {
            return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
            debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
            return;
        }
        packet.pending = true;
        packet.tryCount++;
        debug("sending packet [%d] (try n°%d)", packet.id, packet.tryCount);
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
        debug("transport is open - connecting");
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this._sendConnectPacket(data);
            });
        }
        else {
            this._sendConnectPacket(this.auth);
        }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
        this.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: this._pid
                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)
                : data,
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        debug("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
        this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
    _clearAcks() {
        Object.keys(this.acks).forEach((id) => {
            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
            if (!isBuffered) {
                // note: handlers that do not accept an error as first argument are ignored here
                const ack = this.acks[id];
                delete this.acks[id];
                if (ack.withError) {
                    ack.call(this, new Error("socket has been disconnected"));
                }
            }
        });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser_1.PacketType.CONNECT:
                if (packet.data && packet.data.sid) {
                    this.onconnect(packet.data.sid, packet.data.pid);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case socket_io_parser_1.PacketType.EVENT:
            case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.ACK:
            case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser_1.PacketType.CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
            this._lastOffset = args[args.length - 1];
        }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            debug("sending ack %j", args);
            self.packet({
                type: socket_io_parser_1.PacketType.ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack !== "function") {
            debug("bad ack %s", packet.id);
            return;
        }
        delete this.acks[packet.id];
        debug("calling ack %s with %j", packet.id, packet.data);
        // @ts-ignore FIXME ack is incorrectly inferred as 'never'
        if (ack.withError) {
            packet.data.unshift(null);
        }
        // @ts-ignore
        ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id, pid) {
        debug("socket connected with id %s", id);
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        debug("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
        if (this.connected) {
            debug("performing disconnect (%s)", this.nsp);
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
}
exports.Socket = Socket;

},{"./on.js":101,"@socket.io/component-emitter":59,"debug":104,"socket.io-parser":107}],103:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.url = url;
const engine_io_client_1 = require("engine.io-client");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("socket.io-client:url"); // debug()
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        debug("parse %s", uri);
        obj = (0, engine_io_client_1.parse)(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}

},{"debug":104,"engine.io-client":67}],104:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./common":105,"_process":97,"dup":77}],105:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"dup":78,"ms":92}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deconstructPacket = deconstructPacket;
exports.reconstructPacket = reconstructPacket;
var _isBinary = require("./is-binary.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {
    packet: pack,
    buffers: buffers
  };
}
function _deconstructPacket(data, buffers) {
  if (!data) return data;
  if ((0, _isBinary.isBinary)(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return _newData;
  }
  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments; // no longer useful
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data) return data;
  if (data && data._placeholder === true) {
    var isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num]; // appropriate buffer (should be natural order anyway)
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

},{"./is-binary.js":108}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.protocol = exports.PacketType = exports.Encoder = exports.Decoder = void 0;
var _componentEmitter = require("@socket.io/component-emitter");
var _binary = require("./binary.js");
var _isBinary = require("./is-binary.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * These strings must not be used as event names, as they have a special meaning.
 */
var RESERVED_EVENTS = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener" // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
var protocol = exports.protocol = 5;
var PacketType;
(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (exports.PacketType = PacketType = {}));
/**
 * A socket.io Encoder instance
 */
var Encoder = exports.Encoder = /*#__PURE__*/function () {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  function Encoder(replacer) {
    _classCallCheck(this, Encoder);
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  return _createClass(Encoder, [{
    key: "encode",
    value: function encode(obj) {
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if ((0, _isBinary.hasBinary)(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type;
      // attachments if we have them
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      // if we have a namespace other than `/`
      // we append it followed by a comma `,`
      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      }
      // immediately followed by the id
      if (null != obj.id) {
        str += obj.id;
      }
      // json data
      if (null != obj.data) {
        str += JSON.stringify(obj.data, this.replacer);
      }
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = (0, _binary.deconstructPacket)(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list
      return buffers; // write all the buffers
    }
  }]);
}(); // see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
var Decoder = exports.Decoder = /*#__PURE__*/function (_Emitter) {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  function Decoder(reviver) {
    var _this;
    _classCallCheck(this, Decoder);
    _this = _callSuper(this, Decoder);
    _this.reviver = reviver;
    return _this;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  _inherits(Decoder, _Emitter);
  return _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        var isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet);
          // no attachments, labeled binary but no binary data to follow
          if (packet.attachments === 0) {
            _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
          }
        } else {
          // non-binary full packet
          _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
        }
      } else if ((0, _isBinary.isBinary)(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            // received final buffer
            this.reconstructor = null;
            _superPropGet(Decoder, "emitReserved", this, 3)(["decoded", packet]);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0;
      // look up type
      var p = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      }
      // look up attachments if type binary
      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {}
        var buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      // look up namespace (if any)
      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }
        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      }
      // look up id
      var next = str.charAt(i + 1);
      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;
        while (++i) {
          var _c = str.charAt(i);
          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }
          if (i === str.length) break;
        }
        p.id = Number(str.substring(_start2, i + 1));
      }
      // look up json data
      if (str.charAt(++i)) {
        var payload = this.tryParse(str.substr(i));
        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      return p;
    }
  }, {
    key: "tryParse",
    value: function tryParse(str) {
      try {
        return JSON.parse(str, this.reviver);
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "destroy",
    value:
    /**
     * Deallocates a parser's resources
     */
    function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return isObject(payload);
        case PacketType.DISCONNECT:
          return payload === undefined;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || isObject(payload);
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);
}(_componentEmitter.Emitter);
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  return _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = (0, _binary.reconstructPacket)(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);
}();

},{"./binary.js":106,"./is-binary.js":108,"@socket.io/component-emitter":59}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasBinary = hasBinary;
exports.isBinary = isBinary;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

},{}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _objectHash = _interopRequireDefault(require("object-hash"));
var _events2 = require("events");
var _tinyEssentials = require("tiny-essentials");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Tiny AI Server Communication API
 * -----------------------------
 * This class is responsible for managing AI session data, including models, history, and content generation.
 * The script is designed to interact with the AI API, providing a complete structure for creating user interfaces (UI) or AI-powered chatbots.
 * It implements a session management system to help handle multiple different bots.
 * However, this script is not optimized for efficiently handling multiple AI instances simultaneously, which may be required for high-load scenarios or when running several AI instances at once.
 *
 * **Note**: This script does not automatically manage or track the token count for messages. Developers need to implement their own logic to monitor and manage token usage if necessary.
 *
 * Documentation written with the assistance of OpenAI's ChatGPT.
 */
var _events = /*#__PURE__*/new WeakMap();
var _sysEvents = /*#__PURE__*/new WeakMap();
var _sysEventsUsed = /*#__PURE__*/new WeakMap();
var _TinyAiInstance_brand = /*#__PURE__*/new WeakSet();
var _apiKey = /*#__PURE__*/new WeakMap();
var _getModels = /*#__PURE__*/new WeakMap();
var _countTokens = /*#__PURE__*/new WeakMap();
var _genContentApi = /*#__PURE__*/new WeakMap();
var _selectedHistory = /*#__PURE__*/new WeakMap();
var _partTypes = /*#__PURE__*/new WeakMap();
var _insertIntoHistory = /*#__PURE__*/new WeakMap();
var TinyAiInstance = /*#__PURE__*/function () {
  /**
   * Creates an instance of the TinyAiInstance class.
   * Initializes internal variables, sets up initial configurations for handling AI models,
   * session history, and content generation, with the option to use a single or multiple instances.
   *
   * @param {boolean} [isSingle] - If true, configures the instance to handle a single session only.
   */
  function TinyAiInstance() {
    var isSingle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    _classCallCheck(this, TinyAiInstance);
    /**
     * Emits an event with optional arguments to all system emit.
     * @param {string | symbol} event - The name of the event to emit.
     * @param {...any} args - Arguments passed to event listeners.
     */
    _classPrivateMethodInitSpec(this, _TinyAiInstance_brand);
    /**
     * Important instance used to make event emitter.
     * @type {EventEmitter}
     */
    _classPrivateFieldInitSpec(this, _events, new _events2.EventEmitter());
    /**
     * Important instance used to make system event emitter.
     * @type {EventEmitter}
     */
    _classPrivateFieldInitSpec(this, _sysEvents, new _events2.EventEmitter());
    _classPrivateFieldInitSpec(this, _sysEventsUsed, false);
    /**
     * @typedef {Object} AIContentData
     * @property {Array<Record<'text' | 'inlineData', string | { mime_type: string, data: string } | null>>} parts
     * @property {string|undefined} [role]
     * @property {string|number|undefined} [finishReason]
     */
    /**
     * @typedef {Record<string, any> & {
     *   data: Array<AIContentData>,
     *   ids: Array<string>,
     *   tokens: { data: Array<TokenCount>; [key: string]: * },
     *   hash: { data: Array<string>; [key: string]: * },
     *   systemInstruction: string|null,
     *   model: string|null
     * }} SessionData
     */
    /**
     * @typedef {{ count: number|null, hide?: boolean }} TokenCount
     */
    /** @type {string|null} */
    _classPrivateFieldInitSpec(this, _apiKey, null);
    /** @type {function|null} */_classPrivateFieldInitSpec(this, _getModels, null);
    /** @type {function|null} */_classPrivateFieldInitSpec(this, _countTokens, null);
    /** @type {function|null} */_classPrivateFieldInitSpec(this, _genContentApi, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _selectedHistory, null);
    /** @type {Record<string, function>} */_classPrivateFieldInitSpec(this, _partTypes, {});
    /** @type {function} */_classPrivateFieldInitSpec(this, _insertIntoHistory, function () {});
    /** @type {Record<string|number, string|{ text: string, hide?: boolean }>} */
    _defineProperty(this, "_errorCode", {});
    /** @type {string|null} */
    _defineProperty(this, "_nextModelsPageToken", null);
    /** @type {Array<*>} */
    _defineProperty(this, "models", []);
    /** @type {Object.<string, SessionData>} */
    _defineProperty(this, "history", {});
    _defineProperty(this, "_isSingle", false);
    this._isSingle = isSingle;
    /**
     * Updates an existing entry in the session history.
     *
     * @param {string} id - The session identifier.
     * @param {Record<string, any>} data - Data fields to update within the session.
     * @returns {boolean} True if the update succeeded, false otherwise.
     */
    _classPrivateFieldSet(_insertIntoHistory, this, function (id, data) {
      if (typeof id === 'string' && this.history[id]) {
        for (var where in data) {
          this.history[id][where] = data[where];
        }
        return true;
      }
      return false;
    });
    /**
     * Parsers for different part types.
     * @type {{ text: (input: any) => string|null, inlineData: (input: any) => { mime_type: string, data: string }|null }}
     */
    _classPrivateFieldSet(_partTypes, this, {
      text: function text(/** @type {string} */_text) {
        return typeof _text === 'string' ? _text : null;
      },
      inlineData: function inlineData(/** @type {{ mime_type: string; data: string; }} */data) {
        if (typeof data.mime_type === 'string' && typeof data.data === 'string') return data;
        return null;
      }
    });
    // Is single instance
    if (this._isSingle) {
      this.startDataId('main', true);
      // @ts-ignore
      this.startDataId = null;
      // @ts-ignore
      this.stopDataId = null;
      // @ts-ignore
      this.selectDataId = null;
    }
  }
  /**
   * Capitalizes the first letter of the provided string.
   *
   * @param {string} str - The input string to capitalize.
   * @returns {string} The string with the first character in uppercase.
   */
  return _createClass(TinyAiInstance, [{
    key: "getSysEvents",
    value:
    /**
     * Provides access to a secure internal EventEmitter for subclass use only.
     *
     * This method exposes a dedicated EventEmitter instance intended specifically for subclasses
     * that extend the main class. It prevents subclasses from accidentally or intentionally using
     * the primary class's public event system (`emit`), which could lead to unpredictable behavior
     * or interference in the base class's event flow.
     *
     * For security and consistency, this method is designed to be accessed only once.
     * Multiple accesses are blocked to avoid leaks or misuse of the internal event bus.
     *
     * @returns {EventEmitter} A special internal EventEmitter instance for subclass use.
     * @throws {Error} If the method is called more than once.
     */
    function getSysEvents() {
      if (_classPrivateFieldGet(_sysEventsUsed, this)) throw new Error('Access denied: getSysEvents() can only be called once. ' + 'This restriction ensures subclass event isolation and prevents accidental interference ' + 'with the main class event emitter.');
      _classPrivateFieldSet(_sysEventsUsed, this, true);
      return _classPrivateFieldGet(_sysEvents, this);
    }
    /**
     * @typedef {(...args: any[]) => void} ListenerCallback
     * A generic callback function used for event listeners.
     */
    /**
     * Sets the maximum number of listeners for the internal event emitter.
     *
     * @param {number} max - The maximum number of listeners allowed.
     */
  }, {
    key: "setMaxListeners",
    value: function setMaxListeners(max) {
      _classPrivateFieldGet(_events, this).setMaxListeners(max);
    }
    /**
     * Emits an event with optional arguments.
     * @param {string | symbol} event - The name of the event to emit.
     * @param {...any} args - Arguments passed to event listeners.
     * @returns {boolean} `true` if the event had listeners, `false` otherwise.
     */
  }, {
    key: "emit",
    value: function emit(event) {
      var _classPrivateFieldGet2;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_events, this)).emit.apply(_classPrivateFieldGet2, [event].concat(args));
    }
    /**
     * Registers a listener for the specified event.
     * @param {string | symbol} event - The name of the event to listen for.
     * @param {ListenerCallback} listener - The callback function to invoke.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "on",
    value: function on(event, listener) {
      _classPrivateFieldGet(_events, this).on(event, listener);
      return this;
    }
    /**
     * Registers a one-time listener for the specified event.
     * @param {string | symbol} event - The name of the event to listen for once.
     * @param {ListenerCallback} listener - The callback function to invoke.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "once",
    value: function once(event, listener) {
      _classPrivateFieldGet(_events, this).once(event, listener);
      return this;
    }
    /**
     * Removes a listener from the specified event.
     * @param {string | symbol} event - The name of the event.
     * @param {ListenerCallback} listener - The listener to remove.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "off",
    value: function off(event, listener) {
      _classPrivateFieldGet(_events, this).off(event, listener);
      return this;
    }
    /**
     * Alias for `on`.
     * @param {string | symbol} event - The name of the event.
     * @param {ListenerCallback} listener - The callback to register.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "addListener",
    value: function addListener(event, listener) {
      _classPrivateFieldGet(_events, this).addListener(event, listener);
      return this;
    }
    /**
     * Alias for `off`.
     * @param {string | symbol} event - The name of the event.
     * @param {ListenerCallback} listener - The listener to remove.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "removeListener",
    value: function removeListener(event, listener) {
      _classPrivateFieldGet(_events, this).removeListener(event, listener);
      return this;
    }
    /**
     * Removes all listeners for a specific event, or all events if no event is specified.
     * @param {string | symbol} [event] - The name of the event. If omitted, all listeners from all events will be removed.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(event) {
      _classPrivateFieldGet(_events, this).removeAllListeners(event);
      return this;
    }
    /**
     * Returns the number of times the given `listener` is registered for the specified `event`.
     * If no `listener` is passed, returns how many listeners are registered for the `event`.
     * @param {string | symbol} eventName - The name of the event.
     * @param {Function} [listener] - Optional listener function to count.
     * @returns {number} Number of matching listeners.
     */
  }, {
    key: "listenerCount",
    value: function listenerCount(eventName, listener) {
      return _classPrivateFieldGet(_events, this).listenerCount(eventName, listener);
    }
    /**
     * Adds a listener function to the **beginning** of the listeners array for the specified event.
     * The listener is called every time the event is emitted.
     * @param {string | symbol} eventName - The event name.
     * @param {ListenerCallback} listener - The callback function.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "prependListener",
    value: function prependListener(eventName, listener) {
      _classPrivateFieldGet(_events, this).prependListener(eventName, listener);
      return this;
    }
    /**
     * Adds a **one-time** listener function to the **beginning** of the listeners array.
     * The next time the event is triggered, this listener is removed and then invoked.
     * @param {string | symbol} eventName - The event name.
     * @param {ListenerCallback} listener - The callback function.
     * @returns {this} The current class instance (for chaining).
     */
  }, {
    key: "prependOnceListener",
    value: function prependOnceListener(eventName, listener) {
      _classPrivateFieldGet(_events, this).prependOnceListener(eventName, listener);
      return this;
    }
    /**
     * Returns an array of event names for which listeners are currently registered.
     * @returns {(string | symbol)[]} Array of event names.
     */
  }, {
    key: "eventNames",
    value: function eventNames() {
      return _classPrivateFieldGet(_events, this).eventNames();
    }
    /**
     * Gets the current maximum number of listeners allowed for any single event.
     * @returns {number} The max listener count.
     */
  }, {
    key: "getMaxListeners",
    value: function getMaxListeners() {
      return _classPrivateFieldGet(_events, this).getMaxListeners();
    }
    /**
     * Returns a copy of the listeners array for the specified event.
     * @param {string | symbol} eventName - The event name.
     * @returns {Function[]} An array of listener functions.
     */
  }, {
    key: "listeners",
    value: function listeners(eventName) {
      return _classPrivateFieldGet(_events, this).listeners(eventName);
    }
    /**
     * Returns a copy of the internal listeners array for the specified event,
     * including wrapper functions like those used by `.once()`.
     * @param {string | symbol} eventName - The event name.
     * @returns {Function[]} An array of raw listener functions.
     */
  }, {
    key: "rawListeners",
    value: function rawListeners(eventName) {
      return _classPrivateFieldGet(_events, this).rawListeners(eventName);
    }
  }, {
    key: "setCustomValue",
    value:
    /**
     * Sets a custom value in the selected session history.
     *
     * @param {string} name - The name of the custom value to set.
     * @param {*} value - The value to be assigned to the custom key.
     * @param {number} [tokenAmount] - The token amount associated with the custom value (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the custom value name is invalid (not a non-empty string) or conflicts with existing data.
     * @returns {void} This method does not return a value.
     */
    function setCustomValue(name, value, tokenAmount, id) {
      if (typeof name === 'string' && name.length > 0 && name !== 'customList') {
        // Prepare value to send
        var sendValue = _defineProperty({}, name, value);
        // This value is extremely important for the import process to identify which custom values are being used
        var selectedId = this.getId(id);
        if (selectedId && this.history[selectedId]) {
          var history = this.history[selectedId];
          if (!Array.isArray(history.customList)) history.customList = [];
          // Validate the custom value
          if (value !== null) {
            var props = history.customList.find(function (/** @type {*} */item) {
              return item.name === name;
            });
            if (!props || typeof props.type !== 'string' || typeof props.name !== 'string') {
              if (typeof history[name] === 'undefined') history.customList.push({
                name: name,
                type: (0, _tinyEssentials.objType)(value)
              });else throw new Error('This value name is already being used!');
            } else if (props.type !== (0, _tinyEssentials.objType)(value)) throw new Error("Invalid custom value type! ".concat(name, ": ").concat(props.type, " === ").concat((0, _tinyEssentials.objType)(value)));
          }
          // Add Tokens
          if (typeof tokenAmount === 'number') this.history[selectedId].tokens[name] = tokenAmount;
          // Send custom value into the history
          if (value !== null) {
            _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, sendValue);
            this.history[selectedId].hash[name] = (0, _objectHash["default"])(value);
          }
          // Complete
          _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, "set".concat(_assertClassBrand(_TinyAiInstance_brand, this, _capitalizeFirstLetter).call(this, name)), value, selectedId);
          return;
        }
      }
      throw new Error('Invalid custom value!');
    }
    /**
     * Resets a custom value in the selected session history.
     *
     * @param {string} name - The name of the custom value to reset.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the custom value name is invalid or does not match an existing entry.
     * @returns {void} This method does not return a value.
     */
  }, {
    key: "resetCustomValue",
    value: function resetCustomValue(name, id) {
      if (typeof name === 'string' && name.length > 0 && name !== 'customList') {
        // Prepare value to send
        var sendValue = _defineProperty({}, name, null);
        // This value is extremely important for the import process to identify which custom values are being used
        var selectedId = this.getId(id);
        if (selectedId && this.history[selectedId]) {
          var history = this.history[selectedId];
          if (!Array.isArray(history.customList)) history.customList = [];
          // Validate the custom value
          var props = history.customList.find(function (/** @type {*} */item) {
            return item.name === name;
          });
          if ((0, _tinyEssentials.objType)(props, 'object') && typeof props.type === 'string' && typeof props.name === 'string') {
            // Reset Tokens
            if (typeof this.history[selectedId].tokens[name] !== 'undefined') delete this.history[selectedId].tokens[name];
            // Reset custom value
            _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, sendValue);
            if (typeof this.history[selectedId].hash[name] !== 'undefined') delete this.history[selectedId].hash[name];
            // Complete
            _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, "set".concat(_assertClassBrand(_TinyAiInstance_brand, this, _capitalizeFirstLetter).call(this, name)), null, selectedId);
            return;
          }
        }
        throw new Error('Invalid custom value data type!');
      }
      throw new Error('Invalid custom value!');
    }
    /**
     * Completely removes a custom value from the selected session history.
     *
     * @param {string} name - The name of the custom value to erase.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the custom value name is invalid or does not exist.
     * @returns {void} This method does not return a value.
     */
  }, {
    key: "eraseCustomValue",
    value: function eraseCustomValue(name, id) {
      this.resetCustomValue(name, id);
      var history = this.getData(id);
      if (history) {
        // @ts-ignore
        var index = history.customList.findIndex(function (item) {
          return item.name === name;
        });
        if (index > -1) history.customList.splice(index, 1);
        return;
      }
      throw new Error('Invalid custom value!');
    }
    /**
     * Retrieves a custom value from the selected session history.
     *
     * @param {string} name - The name of the custom value to retrieve.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {*} The value associated with the specified name, or `null` if it does not exist.
     */
  }, {
    key: "getCustomValue",
    value: function getCustomValue(name, id) {
      var history = this.getData(id);
      return history && typeof history[name] !== 'undefined' && history[name] !== null ? history[name] : null;
    }
    /**
     * Retrieves the list of custom values from the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {Array<*>} An array of custom values if available, or an empty array if no custom values exist.
     */
  }, {
    key: "getCustomValueList",
    value: function getCustomValueList(id) {
      var history = this.getData(id);
      return history && Array.isArray(history.customList) ? history.customList : [];
    }
    /**
     * Set the maximum output tokens setting for an AI session.
     *
     * @param {number} value - The maximum number of output tokens to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setMaxOutputTokens",
    value: function setMaxOutputTokens(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          maxOutputTokens: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setMaxOutputTokens', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the maximum output tokens setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The maximum output tokens value, or null if not set.
     */
  }, {
    key: "getMaxOutputTokens",
    value: function getMaxOutputTokens(id) {
      var history = this.getData(id);
      return history && typeof history.maxOutputTokens === 'number' ? history.maxOutputTokens : null;
    }
    /**
     * Set the AI temperature setting for a session.
     *
     * @param {number} value - The temperature value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setTemperature",
    value: function setTemperature(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          temperature: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setTemperature', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the AI temperature setting for a session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The temperature value, or null if not set.
     */
  }, {
    key: "getTemperature",
    value: function getTemperature(id) {
      var history = this.getData(id);
      return history && _typeof(history.temperature) ? history.temperature : null;
    }
    /**
     * Set the top-p (nucleus sampling) value in an AI session.
     *
     * @param {number} value - The top-p value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setTopP",
    value: function setTopP(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          topP: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setTopP', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the top-p (nucleus sampling) setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The top-p value, or null if not set.
     */
  }, {
    key: "getTopP",
    value: function getTopP(id) {
      var history = this.getData(id);
      return history && typeof history.topP === 'number' ? history.topP : null;
    }
    /**
     * Set the top-k setting for an AI session.
     *
     * @param {number} value - The top-k value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setTopK",
    value: function setTopK(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          topK: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setTopK', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the top-k setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The top-k value, or null if not set.
     */
  }, {
    key: "getTopK",
    value: function getTopK(id) {
      var history = this.getData(id);
      return history && typeof history.topK === 'number' ? history.topK : null;
    }
    /**
     * Set the presence penalty setting for an AI session.
     *
     * @param {number} value - The presence penalty value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setPresencePenalty",
    value: function setPresencePenalty(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          presencePenalty: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setPresencePenalty', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the presence penalty setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The presence penalty value, or null if not set.
     */
  }, {
    key: "getPresencePenalty",
    value: function getPresencePenalty(id) {
      var history = this.getData(id);
      return history && typeof history.presencePenalty === 'number' ? history.presencePenalty : null;
    }
    /**
     * Set the frequency penalty setting for an AI session.
     *
     * @param {number} value - The frequency penalty value to be set.
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setFrequencyPenalty",
    value: function setFrequencyPenalty(value, id) {
      if (typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value)) {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          frequencyPenalty: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setFrequencyPenalty', value, selectedId);
        return;
      }
      throw new Error('Invalid number value!');
    }
    /**
     * Get the frequency penalty setting for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {number | null} The frequency penalty value, or null if not set.
     */
  }, {
    key: "getFrequencyPenalty",
    value: function getFrequencyPenalty(id) {
      var history = this.getData(id);
      return history && typeof history.frequencyPenalty === 'number' ? history.frequencyPenalty : null;
    }
    /**
     * Set the setting for enabling enhanced civic answers in an AI session.
     *
     * @param {boolean} value - Whether to enable enhanced civic answers (true or false).
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setEnabledEnchancedCivicAnswers",
    value: function setEnabledEnchancedCivicAnswers(value, id) {
      if (typeof value === 'boolean') {
        var selectedId = this.getId(id);
        _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
          enableEnhancedCivicAnswers: value
        });
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setEnabledEnchancedCivicAnswers', value, selectedId);
        return;
      }
      throw new Error('Invalid boolean value!');
    }
    /**
     * Get the setting for whether enhanced civic answers are enabled in an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {boolean | null} The value indicating whether enhanced civic answers are enabled, or null if not set.
     */
  }, {
    key: "isEnabledEnchancedCivicAnswers",
    value: function isEnabledEnchancedCivicAnswers(id) {
      var history = this.getData(id);
      return history && typeof history.enableEnhancedCivicAnswers === 'boolean' ? history.enableEnhancedCivicAnswers : null;
    }
    /**
     * Set the model for an AI session.
     *
     * @param {string} data - The model to be set (must be a string).
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setModel",
    value: function setModel(data, id) {
      var model = typeof data === 'string' ? data : null;
      var selectedId = this.getId(id);
      _classPrivateFieldGet(_insertIntoHistory, this).call(this, selectedId, {
        model: model
      });
      _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setModel', model, selectedId);
    }
    /**
     * Get the model for an AI session.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session will be used.
     * @returns {string | null} The model, or null if not set.
     */
  }, {
    key: "getModel",
    value: function getModel(id) {
      var history = this.getData(id);
      return history && typeof history.model === 'string' ? history.model : null;
    }
    /**
     * Build content data for an AI session.
     *
     * @param {Array<*>} [contents] - An optional array to which the built content data will be pushed.
     * @param {Record<string, any>} item - The item containing content parts or a content object.
     * @param {string|null} [role] - The role to be associated with the content (optional).
     * @param {boolean} [rmFinishReason=false] - If true, removes the `finishReason` property from the content.
     * @returns {AIContentData|number} The constructed content data object, or array length if pushed to an array.
     */
  }, {
    key: "buildContents",
    value: function buildContents(contents) {
      var item = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var role = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var rmFinishReason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      // Content Data
      var tinyThis = this;
      /** @type {{ finishReason: string|number|undefined, parts: any[], role: string|undefined }} */
      var contentData = {
        parts: [],
        finishReason: undefined,
        role: undefined
      };
      // Role
      if (typeof role === 'string') contentData.role = role;
      /** @param {Record<string, any>} content */
      var insertPart = function insertPart(content) {
        /** @type {Record<string, function>} */
        var tinyResult = {};
        for (var valName in content) {
          if (typeof _classPrivateFieldGet(_partTypes, tinyThis)[valName] === 'function') tinyResult[valName] = _classPrivateFieldGet(_partTypes, tinyThis)[valName](content[valName]);
        }
        contentData.parts.push(tinyResult);
      };
      if (Array.isArray(item.parts)) {
        for (var index in item.parts) insertPart(item.parts[index]);
      } else if (item.content) insertPart(item.content);
      if (!rmFinishReason) if (typeof item.finishReason === 'string' || typeof item.finishReason === 'number') contentData.finishReason = item.finishReason;
      // Complete
      if (Array.isArray(contents)) return contents.push(contentData);
      return contentData;
    }
    /**
     * Set the API key for the AI session.
     *
     * @param {string} apiKey - The API key to be set.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "setApiKey",
    value: function setApiKey(apiKey) {
      _classPrivateFieldSet(_apiKey, this, typeof apiKey === 'string' ? apiKey : null);
    }
    /**
     * Set the token for the next page of models in the AI session.
     *
     * @param {string} nextModelsPageToken - The token for the next models page.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "_setNextModelsPageToken",
    value: function _setNextModelsPageToken(nextModelsPageToken) {
      this._nextModelsPageToken = typeof nextModelsPageToken === 'string' ? nextModelsPageToken : null;
    }
    /**
     * Set the function to retrieve models for the AI session.
     *
     * @param {Function} getModels - The function to retrieve models.
     * @returns {void} This function does not return a value.
     */
  }, {
    key: "_setGetModels",
    value: function _setGetModels(getModels) {
      _classPrivateFieldSet(_getModels, this, typeof getModels === 'function' ? getModels : null);
    }
    /**
     * Get a list of models for the AI session.
     *
     * @param {number} [pageSize=50] - The number of models to retrieve per page. Defaults to 50.
     * @param {string|null} [pageToken=null] - The token for the next page of models, if available. Defaults to null.
     * @returns {Array<*>} The list of models retrieved.
     * @throws {Error} If no model list API function is defined.
     */
  }, {
    key: "getModels",
    value: function getModels() {
      var pageSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      var pageToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (typeof _classPrivateFieldGet(_getModels, this) === 'function') return _classPrivateFieldGet(_getModels, this).call(this, _classPrivateFieldGet(_apiKey, this), pageSize, pageToken || this._nextModelsPageToken);
      throw new Error('No model list api script defined.');
    }
    /**
     * Get the list of models for the AI session.
     *
     * @returns {Array<*>} The list of models.
     */
  }, {
    key: "getModelsList",
    value: function getModelsList() {
      return Array.isArray(this.models) ? this.models : [];
    }
    /**
     * Get model data from the list of models.
     *
     * @param {string} id - The model data id to search for in the models list.
     * @returns {Record<string, any>|null} The model data if found, otherwise null.
     */
  }, {
    key: "getModelData",
    value: function getModelData(id) {
      var model = this.models.find(function (item) {
        return item.id === id;
      });
      if (model) return model;else {
        for (var index in this.models) {
          if (this.models[index].category) {
            // @ts-ignore
            var modelCategory = this.models[index].data.find(function (item) {
              return item.id === id;
            });
            if (modelCategory) return modelCategory;
          }
        }
      }
      return null;
    }
    /**
     * Check if a model exists in the model list.
     *
     * @param {string} id - The model id to check for in the models list.
     * @returns {boolean} True if the model exists, false otherwise.
     */
  }, {
    key: "existsModel",
    value: function existsModel(id) {
      return this.getModelData(id) ? true : false;
    }
    /**
     * Insert a new model into the AI session's models list.
     * If the model already exists, it will not be inserted again.
     *
     * @param {Object} model - The model to insert.
     * @param {*} model._response - The raw response.
     * @param {number} model.index - The index position.
     * @param {string} model.id - The unique identifier for the model.
     * @param {string} [model.name] - The name of the model.
     * @param {string} [model.displayName] - The display name of the model.
     * @param {string} [model.version] - The version of the model.
     * @param {string} [model.description] - A description of the model.
     * @param {number} [model.inputTokenLimit] - The input token limit for the model.
     * @param {number} [model.outputTokenLimit] - The output token limit for the model.
     * @param {number} [model.temperature] - The temperature setting for the model.
     * @param {number} [model.maxTemperature] - The maximum temperature setting for the model.
     * @param {number} [model.topP] - The top P setting for the model.
     * @param {number} [model.topK] - The top K setting for the model.
     * @param {Array<string>} [model.supportedGenerationMethods] - The generation methods supported by the model.
     * @param {Object} [model.category] - The category of the model.
     * @param {string} model.category.id - The unique identifier for the category.
     * @param {string} model.category.displayName - The display name of the category.
     * @param {number} model.category.index - The index of the category.
     * @returns {Record<string, any>|null} The inserted model data, or null if the model already exists.
     */
  }, {
    key: "_insertNewModel",
    value: function _insertNewModel(model) {
      if (!(0, _tinyEssentials.objType)(model, 'object')) throw new Error('Model data must be a valid object.');
      if (this.models.findIndex(function (item) {
        return item.id === model.id;
      }) < 0) {
        /** @type {Record<string, any>} */
        var newData = {
          _response: model._response,
          index: typeof model.index === 'number' ? model.index : 9999999,
          name: typeof model.name === 'string' ? model.name : null,
          id: typeof model.id === 'string' ? model.id : null,
          displayName: typeof model.displayName === 'string' ? model.displayName : null,
          version: typeof model.version === 'string' ? model.version : null,
          description: typeof model.description === 'string' ? model.description : null,
          inputTokenLimit: typeof model.inputTokenLimit === 'number' ? model.inputTokenLimit : null,
          outputTokenLimit: typeof model.outputTokenLimit === 'number' ? model.outputTokenLimit : null,
          temperature: typeof model.temperature === 'number' ? model.temperature : null,
          maxTemperature: typeof model.maxTemperature === 'number' ? model.maxTemperature : null,
          topP: typeof model.topP === 'number' ? model.topP : null,
          topK: typeof model.topK === 'number' ? model.topK : null
        };
        // Supported generation methods
        if (Array.isArray(model.supportedGenerationMethods)) {
          newData.supportedGenerationMethods = [];
          for (var index in model.supportedGenerationMethods) {
            if (typeof model.supportedGenerationMethods[index] === 'string') newData.supportedGenerationMethods.push(model.supportedGenerationMethods[index]);
          }
        }
        // Is category
        if (model.category && typeof model.category.id === 'string' && typeof model.category.displayName === 'string' && typeof model.category.index === 'number') {
          // Check category
          // @ts-ignore
          var category = this.models.find(function (item) {
            return item.category === model.category.id;
          });
          // Insert new category
          if (!category) {
            category = {
              category: model.category.id,
              displayName: model.category.displayName,
              index: model.category.index,
              data: []
            };
            this.models.push(category);
          }
          // Compare function that sorts objects by their `index` property.
          category.data.push(newData);
          category.data.sort(/** @param {{ index: number, [key: string]: any }} a @param {{ index: number, [key: string]: any }} b */
          function (a, b) {
            return a.index - b.index;
          });
        }
        // Normal mode
        else this.models.push(newData);
        // Sort data
        this.models.sort(function (a, b) {
          return a.index - b.index;
        });
        return newData;
      }
      return null;
    }
    /**
     * Sets a function to handle the count of tokens in the AI session.
     * If a valid function is provided, it will be used to count tokens.
     *
     * @param {Function} countTokens - The function that will handle the token count.
     * @throws {Error} Throws an error if the provided value is not a function.
     * @returns {void}
     */
  }, {
    key: "_setCountTokens",
    value: function _setCountTokens(countTokens) {
      _classPrivateFieldSet(_countTokens, this, typeof countTokens === 'function' ? countTokens : null);
    }
    /**
     * Counts the tokens based on the provided data and model, using a defined token counting function.
     * If the function to count tokens is not set, an error is thrown.
     *
     * @param {Record<string, any>} data - The data that needs to be tokenized.
     * @param {string} [model] - The model to use for counting tokens. If not provided, the default model is used.
     * @param {AbortController} [controller] - The controller that manages the process or settings for counting tokens.
     * @throws {Error} Throws an error if no token counting function is defined.
     * @returns {Record<string, any>} The count of tokens.
     */
  }, {
    key: "countTokens",
    value: function countTokens(data, model, controller) {
      if (typeof _classPrivateFieldGet(_countTokens, this) === 'function') return _classPrivateFieldGet(_countTokens, this).call(this, _classPrivateFieldGet(_apiKey, this), model || this.getModel(), controller, data);
      throw new Error('No count token api script defined.');
    }
    /**
     * @typedef {{ text: string, hide?: boolean }} ErrorCode
     */
    /**
     * Sets the error codes for the current session.
     *
     * @param {Record<string|number, string|ErrorCode>} errors - The error codes to set, typically an object containing error code definitions.
     * @returns {void}
     */
  }, {
    key: "_setErrorCodes",
    value: function _setErrorCodes(errors) {
      this._errorCode = errors;
    }
    /**
     * Get error details based on the provided error code.
     *
     * @param {string|number} code - The error code to look up.
     * @returns {ErrorCode|null} An object containing the error message, or null if no error is found.
     */
  }, {
    key: "getErrorCode",
    value: function getErrorCode(code) {
      if (this._errorCode) {
        var errData = this._errorCode[code];
        if (errData) {
          if (typeof errData === 'string') return {
            text: errData
          };
          // @ts-ignore
          else if ((0, _tinyEssentials.objType)(errData, 'object') && typeof errData.text === 'string') return errData;
        }
      }
      return null;
    }
    /**
     * Sets the content generation callback function for the AI session.
     *
     * @param {Function} callback - The callback function that handles content generation.
     * @returns {void}
     */
  }, {
    key: "_setGenContent",
    value: function _setGenContent(callback) {
      _classPrivateFieldSet(_genContentApi, this, typeof callback === 'function' ? callback : null);
    }
    /**
     * Generates content for the AI session.
     *
     * @param {Record<string, any>} data - The data for content generation.
     * @param {string} [model] - The model to be used for content generation. If not provided, the default model is used.
     * @param {AbortController} [controller] - The controller managing the content generation process.
     * @param {Function} [streamCallback] - The callback function for streaming content (optional).
     * @returns {Record<string, any>} The generated content returned by the API.
     * @throws {Error} If no content generator API script is defined.
     */
  }, {
    key: "genContent",
    value: function genContent(data, model, controller, streamCallback) {
      if (typeof _classPrivateFieldGet(_genContentApi, this) === 'function') return _classPrivateFieldGet(_genContentApi, this).call(this, _classPrivateFieldGet(_apiKey, this), typeof streamCallback === 'function' ? true : false, data, model || this.getModel(), streamCallback, controller);
      throw new Error('No content generator api script defined.');
    }
    /**
     * Select a session history ID to set as the active session.
     * If `null` is passed, it deselects the current session ID.
     *
     * @param {string|null} id - The session history ID to select, or `null` to deselect the current session.
     * @returns {boolean} `true` if the session ID was successfully selected or deselected, `false` if the ID does not exist in history.
     */
  }, {
    key: "selectDataId",
    value: function selectDataId(id) {
      if (id !== null) {
        if (this.history[id]) {
          _classPrivateFieldSet(_selectedHistory, this, id);
          _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'selectDataId', id);
          return true;
        }
        return false;
      }
      _classPrivateFieldSet(_selectedHistory, this, null);
      _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'selectDataId', null);
      return true;
    }
    /**
     * Get the currently selected session history ID.
     * If no ID is provided, it returns the default selected session history ID.
     *
     * @param {string} [id] - The session history ID to retrieve. If not provided, it uses the default selected ID.
     * @returns {string|null} The selected session history ID, or `null` if no history ID is selected.
     */
  }, {
    key: "getId",
    value: function getId(id) {
      var result = id && !this._isSingle ? id : _classPrivateFieldGet(_selectedHistory, this);
      if (typeof result === 'string') return result;
      return null;
    }
    /**
     * Get the data associated with a specific session history ID.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {SessionData|null} The data associated with the session ID, or `null` if no data exists for that ID.
     */
  }, {
    key: "getData",
    value: function getData(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) return this.history[selectedId];
      return null;
    }
    /**
     * Calculates the total number of tokens used for messages in the session history.
     *
     * This method iterates over the `tokens` array in the session history and sums the `count` of tokens
     * from each message, returning the total sum. If no valid session history is found or if token data is
     * missing, it will return `null`.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {number|null} The total number of tokens used in the session history, or `null` if no data is available.
     */
  }, {
    key: "getTotalTokens",
    value: function getTotalTokens(id) {
      var history = this.getData(id);
      if (history) {
        var result = 0;
        for (var msgIndex in history.tokens.data) {
          if (typeof history.tokens.data[msgIndex].count === 'number') result += history.tokens.data[msgIndex].count;
        }
        for (var item in history.tokens) {
          if (typeof history.tokens[item] === 'number') {
            result += history.tokens[item];
          }
        }
        return result;
      }
      return null;
    }
    /**
     * Retrieves the token data for a specific message in the session history by its index.
     *
     * **Note**: This method does not manage the token count automatically. It assumes that token data has been added
     * to the history using the `addData` method.
     *
     * @param {number} msgIndex - The index of the message in the session history.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {TokenCount|null} The token data associated with the message at the specified index, or `null` if the data is not found.
     */
  }, {
    key: "getMsgTokensByIndex",
    value: function getMsgTokensByIndex(msgIndex, id) {
      var history = this.getData(id);
      if (history) {
        var existsIndex = this.indexExists(msgIndex, id);
        if (existsIndex) return history.tokens.data[msgIndex];
      }
      return null;
    }
    /**
     * Retrieves the token data for a specific message in the session history by its message ID.
     *
     * **Note**: This method does not manage the token count automatically. It assumes that token data has been added
     * to the history using the `addData` method.
     *
     * @param {string} msgId - The unique ID of the message in the session history.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {TokenCount|null} The token data associated with the message with the given ID, or `null` if the message is not found.
     */
  }, {
    key: "getMsgTokensById",
    value: function getMsgTokensById(msgId, id) {
      var history = this.getData(id);
      if (history) {
        var msgIndex = this.getIndexOfId(msgId);
        if (msgIndex > -1) return history.tokens.data[msgIndex];
      }
      return null;
    }
    /**
     * Retrieves the hash of a message at a specified index in the selected session history.
     *
     * @param {number} msgIndex - The index of the message whose hash is being retrieved.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The hash value of the message at the specified index, or null if the index is invalid or does not exist.
     */
  }, {
    key: "getMsgHashByIndex",
    value: function getMsgHashByIndex(msgIndex, id) {
      var history = this.getData(id);
      if (history) {
        var existsIndex = this.indexExists(msgIndex, id);
        if (existsIndex) return history.hash.data[msgIndex];
      }
      return null;
    }
    /**
     * Retrieves the hash of a message based on its ID from the selected session history.
     *
     * @param {string} msgId - The ID of the message whose hash is being retrieved.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The hash value of the message with the specified ID, or null if the message ID is invalid or does not exist.
     */
  }, {
    key: "getMsgHashById",
    value: function getMsgHashById(msgId, id) {
      var history = this.getData(id);
      if (history) {
        var msgIndex = this.getIndexOfId(msgId);
        if (msgIndex > -1) return history.hash.data[msgIndex];
      }
      return null;
    }
    /**
     * Checks if a specific index exists in the session history.
     *
     * **Note**: This method assumes that the history data is available and that the `getMsgByIndex` method is used
     * to retrieve the index. If the `getMsgByIndex` method returns a valid index, this method will return `true`.
     *
     * @param {number} index - The index to check for existence in the session history.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {boolean} `true` if the index exists, otherwise `false`.
     */
  }, {
    key: "indexExists",
    value: function indexExists(index, id) {
      return this.getMsgByIndex(index, id) ? true : false;
    }
    /**
     * Retrieve a specific data entry by its index from the session history.
     *
     * @param {number} index - The index of the data entry to retrieve.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {AIContentData|null} The data entry at the specified index, or `null` if the index is out of bounds or no data exists for the given session ID.
     */
  }, {
    key: "getMsgByIndex",
    value: function getMsgByIndex(index, id) {
      var history = this.getData(id);
      if (history && history.data[index]) return history.data[index];
      return null;
    }
    /**
     * Retrieves a specific message by its ID from the session history.
     *
     * @param {string} msgId - The ID of the message to retrieve.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {AIContentData|null} The message data associated with the given ID, or `null` if the message ID is invalid or does not exist.
     */
  }, {
    key: "getMsgById",
    value: function getMsgById(msgId, id) {
      var history = this.getData(id);
      if (history) {
        var index = this.getIndexOfId(msgId);
        if (history.data[index]) return history.data[index];
      }
      return null;
    }
    /**
     * Retrieve the index of a specific message ID in the session history.
     *
     * @param {string} msgId - The message ID to search for.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {number} The index of the message ID in the session history, or `-1` if not found.
     */
  }, {
    key: "getIndexOfId",
    value: function getIndexOfId(msgId, id) {
      var history = this.getData(id);
      if (history) return history.ids.indexOf(msgId);
      return -1;
    }
    /**
     * Retrieve the message ID at a specific index in the session history.
     *
     * @param {number} index - The index of the data to retrieve.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|number} The message ID at the specified index, or `-1` if the index is out of bounds or not found.
     */
  }, {
    key: "getIdByIndex",
    value: function getIdByIndex(index, id) {
      var history = this.getData(id);
      if (history) return history.data[index] ? history.ids[index] : -1;
      return -1;
    }
    /**
     * Delete a specific entry from the session history at the given index.
     *
     * @param {number} index - The index of the entry to delete.
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {boolean} `true` if the entry was successfully deleted, `false` if the index is invalid or the entry does not exist.
     */
  }, {
    key: "deleteIndex",
    value: function deleteIndex(index, id) {
      var history = this.getData(id);
      if (history && history.data[index]) {
        var msgId = this.getIdByIndex(index);
        history.data.splice(index, 1);
        history.ids.splice(index, 1);
        history.hash.data.splice(index, 1);
        history.tokens.data.splice(index, 1);
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'deleteIndex', index, msgId, this.getId(id));
        return true;
      }
      return false;
    }
    /**
     * Replaces an entry at the specified index in the session history with new data.
     *
     * @param {number} index - The index of the entry to replace.
     * @param {AIContentData} [data] - The new data to replace the existing entry (optional).
     * @param {TokenCount} [tokens] - The token count associated with the new entry (optional).
     * @param {string} [id] - The session ID (optional). If omitted, the currently selected session history ID will be used.
     * @returns {boolean} `true` if the entry was successfully replaced, `false` if the index is invalid or the entry does not exist.
     */
  }, {
    key: "replaceIndex",
    value: function replaceIndex(index, data, tokens, id) {
      var history = this.getData(id);
      if (history && history.data[index] && (data || tokens)) {
        var hash = null;
        if (data) {
          hash = (0, _objectHash["default"])(data);
          history.data[index] = data;
          history.hash.data[index] = hash;
        }
        if (tokens) history.tokens.data[index] = tokens;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'replaceIndex', index, data, tokens, hash, this.getId(id));
        return true;
      }
      return false;
    }
    /**
     * Retrieve the index of the last entry in the session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {number} The index of the last entry in the session history, or `-1` if the history is empty or invalid.
     */
  }, {
    key: "getLastIndex",
    value: function getLastIndex(id) {
      var history = this.getData(id);
      if (history && history.data[history.data.length - 1]) return history.data.length - 1;
      return -1;
    }
    /**
     * Retrieve the data of the last entry in the session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {AIContentData|null} The data of the last entry in the session history, or `null` if the history is empty or invalid.
     */
  }, {
    key: "getLastIndexData",
    value: function getLastIndexData(id) {
      var history = this.getData(id);
      if (history && history.data[history.data.length - 1]) return history.data[history.data.length - 1];
      return null;
    }
    /**
     * Check if the session history has at least one entry.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {boolean} `true` if the session history has at least one entry, `false` otherwise.
     */
  }, {
    key: "existsFirstIndex",
    value: function existsFirstIndex(id) {
      var history = this.getData(id);
      if (history && history.data[0]) return true;
      return false;
    }
    /**
     * Retrieve the first entry in the session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {AIContentData|null} The first entry of the session history, or `null` if no entry exists.
     */
  }, {
    key: "getFirstIndexData",
    value: function getFirstIndexData(id) {
      var history = this.getData(id);
      if (history && history.data[0]) return history.data[0];
      return null;
    }
    /**
     * Adds new data to the selected session history.
     * If no session ID is provided, the currently selected session history ID will be used.
     *
     * **Note**: The `tokenData` parameter is optional and can be used to track token-related data associated with the new entry.
     * This may include token counts, but this script does not manage token counting automatically. Developers must implement token management separately if necessary.
     *
     * @param {AIContentData} data - The data to be added to the session history.
     * @param {TokenCount} [tokenData={count: null}] - Optional token-related data to be associated with the new entry. Defaults to `{count: null}`.
     * @param {string} [id] - The session history ID. If omitted, the currently selected session ID will be used.
     * @returns {number} The new ID of the added data entry.
     * @throws {Error} If the provided session ID is invalid or the session ID does not exist in history.
     */
  }, {
    key: "addData",
    value: function addData(data) {
      var tokenData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        count: null
      };
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        if (typeof this.history[selectedId].nextId !== 'number') this.history[selectedId].nextId = 0;
        var newId = this.history[selectedId].nextId;
        this.history[selectedId].nextId++;
        var hash = (0, _objectHash["default"])(data);
        var tokenContent = (0, _tinyEssentials.objType)(tokenData, 'object') ? tokenData : {
          count: typeof tokenData === 'number' ? tokenData : null
        };
        this.history[selectedId].data.push(data);
        this.history[selectedId].tokens.data.push(tokenContent);
        this.history[selectedId].ids.push(newId);
        this.history[selectedId].hash.data.push(hash);
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'addData', newId, data, tokenContent, hash, selectedId);
        return newId;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Sets a prompt for the selected session history.
     *
     * @param {string} [promptData] - The prompt to be set for the session.
     * @param {number} [tokenAmount] - The number of tokens associated with the prompt (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the provided session ID is invalid or the prompt data is not a string.
     */
  }, {
    key: "setPrompt",
    value: function setPrompt(promptData, tokenAmount, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        if (typeof promptData === 'string') {
          var hash = (0, _objectHash["default"])(promptData);
          this.history[selectedId].prompt = promptData;
          this.history[selectedId].hash.prompt = hash;
        }
        if (typeof tokenAmount === 'number') this.history[selectedId].tokens.prompt = tokenAmount;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setPrompt', promptData, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Retrieves the prompt of the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The prompt for the session if available, otherwise null.
     */
  }, {
    key: "getPrompt",
    value: function getPrompt(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].prompt === 'string' && this.history[selectedId].prompt.length > 0) {
        return this.history[selectedId].prompt;
      }
      return null;
    }
    /**
     * Sets the first dialogue for the selected session history.
     *
     * @param {string} [dialogue] - The dialogue to set as the first dialogue.
     * @param {number} [tokenAmount] - The number of tokens associated with the dialogue (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} Throws an error if the session ID is invalid or the dialogue is not a string.
     * @returns {void}
     */
  }, {
    key: "setFirstDialogue",
    value: function setFirstDialogue(dialogue, tokenAmount, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        if (typeof dialogue === 'string') {
          var hash = (0, _objectHash["default"])(dialogue);
          this.history[selectedId].firstDialogue = dialogue;
          this.history[selectedId].hash.firstDialogue = hash;
        }
        if (typeof tokenAmount === 'number') this.history[selectedId].tokens.firstDialogue = tokenAmount;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setFirstDialogue', dialogue, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Retrieves the first dialogue from the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The first dialogue if it exists and is a non-empty string, or null if no first dialogue is set.
     */
  }, {
    key: "getFirstDialogue",
    value: function getFirstDialogue(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].firstDialogue === 'string' && this.history[selectedId].firstDialogue.length > 0) {
        return this.history[selectedId].firstDialogue;
      }
      return null;
    }
    /**
     * Sets file data for the selected session history.
     *
     * @param {string} [mime] - The MIME type of the file (e.g., 'text/plain', 'application/pdf').
     * @param {string} [data] - The file content, either as a string or base64-encoded.
     * @param {boolean} [isBase64=false] - A flag indicating whether the `data` is already base64-encoded. Defaults to false.
     * @param {number} [tokenAmount] - The token count associated with the file data (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the session ID is invalid or data/mime is not a string.
     * @returns {void}
     */
  }, {
    key: "setFileData",
    value: function setFileData(mime, data) {
      var isBase64 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tokenAmount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      var id = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        var hash;
        if (typeof data === 'string' && typeof mime === 'string') {
          this.history[selectedId].file = {
            mime: mime,
            data: data,
            // @ts-ignore
            base64: !isBase64 ? Base64.encode(data) : data
          };
          hash = (0, _objectHash["default"])(this.history[selectedId].file);
          this.history[selectedId].hash.file = hash;
        }
        if (typeof tokenAmount === 'number') this.history[selectedId].tokens.file = tokenAmount;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setFileData', this.history[selectedId].file, hash, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Removes file data from the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the session history ID is invalid.
     * @returns {void} This method does not return a value.
     */
  }, {
    key: "removeFileData",
    value: function removeFileData(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        delete this.history[selectedId].file;
        delete this.history[selectedId].hash.file;
        delete this.history[selectedId].tokens.file;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setFileData', null, null, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Retrieves file data from the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {{data: string, mime: string}|null} The file data, including MIME type and encoded content, or null if no file data is found.
     * @throws {Error} If no valid session history ID is found.
     */
  }, {
    key: "getFileData",
    value: function getFileData(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && this.history[selectedId].file && typeof this.history[selectedId].file.data === 'string' && typeof this.history[selectedId].file.mime === 'string') {
        return this.history[selectedId].file;
      }
      return null;
    }
    /**
     * Sets a system instruction for the selected session history.
     *
     * @param {string} [data] - The system instruction to set.
     * @param {number} [tokenAmount] - The token count associated with the system instruction (optional).
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @throws {Error} If the session history ID is invalid or the provided data is not a string.
     * @returns {void}
     */
  }, {
    key: "setSystemInstruction",
    value: function setSystemInstruction(data, tokenAmount, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId]) {
        if (typeof data === 'string') {
          var hash = (0, _objectHash["default"])(data);
          this.history[selectedId].systemInstruction = data;
          this.history[selectedId].hash.systemInstruction = hash;
        }
        if (typeof tokenAmount === 'number') this.history[selectedId].tokens.systemInstruction = tokenAmount;
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'setSystemInstruction', data, selectedId);
        return;
      }
      throw new Error('Invalid history id data!');
    }
    /**
     * Retrieves the system instruction for the selected session history.
     *
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The system instruction for the selected session, or `null` if no instruction is set.
     */
  }, {
    key: "getSystemInstruction",
    value: function getSystemInstruction(id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].systemInstruction === 'string') {
        return this.history[selectedId].systemInstruction;
      }
      return null;
    }
    /**
     * Retrieves the token count for a specific category within the selected session history.
     *
     * @param {string} where - The category from which to retrieve the token count (e.g., 'prompt', 'file', 'systemInstruction').
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {number|null} The token count if available, otherwise null.
     */
  }, {
    key: "getTokens",
    value: function getTokens(where, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].tokens[where] === 'number') return this.history[selectedId].tokens[where];
      return null;
    }
    /**
     * Retrieves the hash value for a specific item in the selected session history.
     *
     * @param {string} where - The key representing the item whose hash value is being retrieved (e.g., 'prompt', 'file', 'systemInstruction').
     * @param {string} [id] - The session ID. If omitted, the currently selected session history ID will be used.
     * @returns {string|null} The hash value of the specified item, or null if the item does not exist.
     */
  }, {
    key: "getHash",
    value: function getHash(where, id) {
      var selectedId = this.getId(id);
      if (selectedId && this.history[selectedId] && typeof this.history[selectedId].hash[where] === 'string') return this.history[selectedId].hash[where];
      return null;
    }
    /**
     * Starts a new data session with the given session ID.
     *
     * @param {string} id - The session ID for the new data session.
     * @param {boolean} [selected=false] - A flag to indicate whether this session should be selected as the active session.
     * @returns {SessionData} The newly created session data, which includes an empty data array, an empty IDs array, and null values for system instruction and model.
     */
  }, {
    key: "startDataId",
    value: function startDataId(id) {
      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.history[id] = {
        data: [],
        ids: [],
        tokens: {
          data: []
        },
        hash: {
          data: []
        },
        systemInstruction: null,
        model: null
      };
      if (selected) this.selectDataId(id);
      _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'startDataId', this.history[id], id, selected ? true : false);
      return this.history[id];
    }
    /**
     * Stop the data session associated with the provided ID.
     * This will remove the session data from history and reset the selected session ID if necessary.
     *
     * @param {string} id - The session history ID to stop and remove from history.
     * @returns {boolean} `true` if the session ID was found and successfully stopped, `false` otherwise.
     */
  }, {
    key: "stopDataId",
    value: function stopDataId(id) {
      if (this.history[id]) {
        delete this.history[id];
        if (this.getId() === id) this.selectDataId(null);
        _assertClassBrand(_TinyAiInstance_brand, this, _emit).call(this, 'stopDataId', id);
        return true;
      }
      return false;
    }
    /**
     * Destroys the instance by clearing history and removing all event listeners.
     *
     * This method resets the internal `history` object, effectively discarding any stored
     * data or state associated with the instance's operations. It also removes all listeners
     * from both `#events` and `#sysEvents` to ensure no further event handling occurs and to
     * prevent memory leaks.
     *
     * This method should be called when the instance is no longer needed.
     *
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.history = {};
      _classPrivateFieldGet(_events, this).removeAllListeners();
      _classPrivateFieldGet(_sysEvents, this).removeAllListeners();
    }
  }]);
}();
function _emit(event) {
  var _classPrivateFieldGet3, _classPrivateFieldGet4;
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  (_classPrivateFieldGet3 = _classPrivateFieldGet(_events, this)).emit.apply(_classPrivateFieldGet3, [event].concat(args));
  if (_classPrivateFieldGet(_sysEventsUsed, this)) (_classPrivateFieldGet4 = _classPrivateFieldGet(_sysEvents, this)).emit.apply(_classPrivateFieldGet4, [event].concat(args));
}
function _capitalizeFirstLetter(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var _default = exports["default"] = TinyAiInstance;

},{"events":84,"object-hash":93,"tiny-essentials":124}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "TinyAiInstance", {
  enumerable: true,
  get: function get() {
    return _TinyAiInstance["default"];
  }
});
Object.defineProperty(exports, "TinyGoogleAi", {
  enumerable: true,
  get: function get() {
    return _Google.TinyGoogleAi;
  }
});
Object.defineProperty(exports, "setTinyGoogleAi", {
  enumerable: true,
  get: function get() {
    return _Google.setTinyGoogleAi;
  }
});
var _Google = require("./services/Google.mjs");
var _TinyAiInstance = _interopRequireDefault(require("./TinyAiInstance.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"./TinyAiInstance.mjs":109,"./services/Google.mjs":111}],111:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyGoogleAi = void 0;
exports.setTinyGoogleAi = setTinyGoogleAi;
var _jsonrepair = require("jsonrepair");
var _TinyAiInstance2 = _interopRequireDefault(require("../TinyAiInstance.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/**
 * Configures the Tiny AI Api to use the Google Gemini API.
 *
 * This function sets up the Google Gemini API in a TinyAiApi instance, providing
 * the required authentication and model parameters.
 *
 * @param {TinyAiInstance} tinyGoogleAI - The TinyAiApi instance to be configured.
 * @param {string} GEMINI_API_KEY - The API key for Google Gemini.
 * @param {string} [MODEL_DATA='gemini-2.0-flash'] - The model to use (default is 'gemini-2.0-flash').
 */
function setTinyGoogleAi(tinyGoogleAI, GEMINI_API_KEY) {
  var MODEL_DATA = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'gemini-2.0-flash';
  var apiUrl = 'https://generativelanguage.googleapis.com/v1beta';
  tinyGoogleAI.setApiKey(GEMINI_API_KEY);
  tinyGoogleAI.setModel(MODEL_DATA);
  /**
   * A comprehensive map of HTTP status codes and their corresponding human-readable descriptions.
   *
   * This object includes:
   * - Standard HTTP status codes (1xx–5xx)
   * - Cloudflare-specific codes (520–530, 598–599)
   * - Nginx-specific codes (444, 494–499)
   *
   * These codes are useful for interpreting responses from HTTP requests and displaying
   * user-friendly messages or handling programmatic logic based on response status.
   *
   * @constant
   * @type {Object<number, string>}
   *
   * @example
   * const message = errorCodes[404]; // "Not Found"
   * if (status >= 400) {
   *   console.warn(`Error ${status}: ${errorCodes[status] || 'Unknown Status Code'}`);
   * }
   */
  var errorCodes = {
    100: 'Continue',
    101: 'Switching Protocols',
    102: 'Processing',
    103: 'Early Hints',
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    207: 'Multi-Status',
    208: 'Already Reported',
    226: 'IM Used',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    306: 'Switch Proxy',
    307: 'Temporary Redirect',
    308: 'Permanent Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Payload Too Large',
    414: 'URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Range Not Satisfiable',
    417: 'Expectation Failed',
    418: "I'm a teapot",
    421: 'Misdirected Request',
    422: 'Unprocessable Entity',
    423: 'Locked',
    424: 'Failed Dependency',
    425: 'Too Early',
    426: 'Upgrade Required',
    428: 'Precondition Required',
    429: 'Too Many Requests',
    431: 'Request Header Fields Too Large',
    451: 'Unavailable For Legal Reasons',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported',
    506: 'Variant Also Negotiates',
    507: 'Insufficient Storage',
    508: 'Loop Detected',
    510: 'Not Extended',
    511: 'Network Authentication Required',
    520: 'Web Server Returned an Unknown Error',
    521: 'Web Server Is Down',
    522: 'Connection Timed Out',
    523: 'Origin Is Unreachable',
    524: 'A Timeout Occurred',
    525: 'SSL Handshake Failed',
    526: 'Invalid SSL Certificate',
    527: 'Railgun Error',
    530: 'Site Frozen',
    598: 'Network Read Timeout Error',
    599: 'Network Connect Timeout Error',
    // Nginx
    444: 'No Response',
    494: 'Request Header Too Large',
    495: 'SSL Certificate Error',
    496: 'SSL Certificate Required',
    497: 'HTTP Request Sent to HTTPS Port',
    499: 'Client Closed Request'
  };
  /**
   * Registers a predefined set of error codes and their associated messages for interpreting
   * the finish reasons returned by the Google Generative AI API.
   *
   * Each error code maps to a human-readable explanation and optional display rules (e.g. `hide`).
   * These can be used to provide meaningful messages in the UI or logs when handling model responses.
   *
   * @function
   * @name tinyGoogleAI._setErrorCodes
   * @param {Object<string, {text: string, hide?: boolean}>} errorCodes - An object where each key is an error/finish reason returned by the API,
   * and the value contains a `text` message and optionally a `hide` flag to control visibility in UI.
   *
   * @returns {void}
   *
   * @example
   * tinyGoogleAI._setErrorCodes({
   *   STOP: { text: 'Natural stop point of the model or provided stop sequence.', hide: true },
   *   MAX_TOKENS: { text: 'The maximum number of tokens as specified in the request was reached.' },
   *   SAFETY: { text: 'The response candidate content was flagged for safety reasons.' },
   *   ...
   * });
   *
   * Example usage:
   * const reason = response.finishReason;
   * const errorInfo = tinyGoogleAI.getErrorCode(reason);
   * console.log(errorInfo.text); // Shows friendly explanation for the finish reason
   */
  tinyGoogleAI._setErrorCodes({
    FINISH_REASON_UNSPECIFIED: {
      text: 'Default value. This value is unused.'
    },
    STOP: {
      text: 'Natural stop point of the model or provided stop sequence.',
      hide: true
    },
    MAX_TOKENS: {
      text: 'The maximum number of tokens as specified in the request was reached.'
    },
    SAFETY: {
      text: 'The response candidate content was flagged for safety reasons.'
    },
    RECITATION: {
      text: 'The response candidate content was flagged for recitation reasons.'
    },
    LANGUAGE: {
      text: 'The response candidate content was flagged for using an unsupported language.'
    },
    OTHER: {
      text: 'Unknown reason.'
    },
    BLOCKLIST: {
      text: 'Token generation stopped because the content contains forbidden terms.'
    },
    PROHIBITED_CONTENT: {
      text: 'Token generation stopped for potentially containing prohibited content.'
    },
    SPII: {
      text: 'Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).'
    },
    MALFORMED_FUNCTION_CALL: {
      text: 'The function call generated by the model is invalid.'
    },
    IMAGE_SAFETY: {
      text: 'Token generation stopped because generated images contain safety violations.'
    }
  });
  /**
   * @param {*} [result={ error: { code: null, message: null, status: null, details: null } }]
   * @param {*} [finalData={ error: { code: null, message: null, status: null, details: null } }]
   */
  var buildErrorData = function buildErrorData() {
    var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      error: {
        code: null,
        message: null,
        status: null,
        details: null
      }
    };
    var finalData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      error: {
        code: null,
        message: null,
        status: null,
        details: null
      }
    };
    if (typeof result === 'undefined') throw new Error('Invalid result or missing error object');
    finalData.error = {
      code: typeof result.error.code === 'number' ? result.error.code : null,
      message: typeof result.error.message === 'string' ? result.error.message : null,
      status: typeof result.error.status === 'string' ? result.error.status : null
    };
    if (result.error.details) finalData.error.details = result.error.details;
  };
  /**
   * Constructs the full request body for the Google Gemini API call.
   *
   * @param {*} data
   * @param {*} [config={}]
   * @param {*} [cache=null]
   * @param {boolean} [cacheMode=false]
   * @returns {*}
   */
  var requestBuilder = function requestBuilder(data) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var cacheMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    /**
     * @type {{
     * safetySettings: {};
     * model: any;
     * ttl: any;
     * name: any;
     * contents: Array<any>;
     * systemInstruction: any;
     * generationConfig: {
     *    maxOutputTokens: any;
     *    temperature: any;
     *    topP: any;
     *    topK: any;
     *    presencePenalty: any;
     *    frequencyPenalty: any;
     *    enableEnhancedCivicAnswers: any;
     * };
     *  cachedContent: any;
     * }}
     */
    var requestBody = {};
    if (!cacheMode) requestBody.safetySettings = [];
    // Model
    if (typeof config.model === 'string') requestBody.model = config.model;
    // Expiration
    if (typeof config.ttl === 'string') requestBody.ttl = config.ttl;
    // Expiration
    if (typeof config.name === 'string') requestBody.name = config.name;
    // Execute builder
    for (var index in data) {
      var item = data[index];
      if (item) {
        if (item.role !== 'system') {
          if (!Array.isArray(requestBody.contents)) requestBody.contents = [];
          tinyGoogleAI.buildContents(requestBody.contents, item, item.role, true);
        } else {
          if (!Array.isArray(requestBody.systemInstruction)) requestBody.systemInstruction = [];
          tinyGoogleAI.buildContents(requestBody.systemInstruction, item, undefined, true);
          requestBody.systemInstruction = requestBody.systemInstruction[0];
        }
      }
    }
    // Config
    if (!cacheMode) {
      requestBody.generationConfig = {};
      if (typeof tinyGoogleAI.getMaxOutputTokens() === 'number') requestBody.generationConfig.maxOutputTokens = tinyGoogleAI.getMaxOutputTokens();
      if (typeof tinyGoogleAI.getTemperature() === 'number') requestBody.generationConfig.temperature = tinyGoogleAI.getTemperature();
      if (typeof tinyGoogleAI.getTopP() === 'number') requestBody.generationConfig.topP = tinyGoogleAI.getTopP();
      if (typeof tinyGoogleAI.getTopK() === 'number') requestBody.generationConfig.topK = tinyGoogleAI.getTopK();
      if (typeof tinyGoogleAI.getPresencePenalty() === 'number') requestBody.generationConfig.presencePenalty = tinyGoogleAI.getPresencePenalty();
      if (typeof tinyGoogleAI.getFrequencyPenalty() === 'number') requestBody.generationConfig.frequencyPenalty = tinyGoogleAI.getFrequencyPenalty();
      if (typeof tinyGoogleAI.isEnabledEnchancedCivicAnswers() === 'boolean') requestBody.generationConfig.enableEnhancedCivicAnswers = tinyGoogleAI.isEnabledEnchancedCivicAnswers();
    }
    // Cache
    if (cache) requestBody.cachedContent = cache;
    // Complete
    return requestBody;
  };
  // https://ai.google.dev/api/generate-content?hl=pt-br#method:-models.generatecontent
  /**
   * Internal method that integrates with Google Gemini via generateContent or streamGenerateContent.
   * It builds the request body, handles normal and streaming responses, parses tokens and content,
   * and returns structured response data.
   *
   * @function
   * @name tinyGoogleAI._setGenContent
   * @param {string} apiKey - Your Google AI API key.
   * @param {boolean} isStream - Whether the request is a streaming request.
   * @param {object[]} data - An array of messages to send (prompt).
   * @param {string} model - The Gemini model ID (e.g., "gemini-pro").
   * @param {Function} streamingCallback - Callback for streaming results. Called with partials.
   * @param {AbortController} controller - Optional abort controller for cancelling requests.
   * @returns {Promise<object>} finalData - A promise that resolves with a structured response object:
   * - finalData.contents: Parsed content output
   * - finalData.tokenUsage: Usage info with prompt/candidate/total counts
   * - finalData.modelVersion: Model version string
   * - finalData._response: Raw response
   * - finalData.error: (If error occurred) contains message, status, and code
   */
  tinyGoogleAI._setGenContent(
  /**
   * @param {string} apiKey
   * @param {boolean} isStream
   * @param {any} data
   * @param {string} model
   * @param {function} streamingCallback
   * @param {AbortController} controller
   * @returns {any}
   */
  function (apiKey, isStream, data, model, streamingCallback, controller) {
    return new Promise(function (resolve, reject) {
      // Request
      var requestBody = requestBuilder(data);
      /**
       * Parses token usage metadata from the result object.
       *
       * @param {*} result - The API response containing usageMetadata.
       * @returns {[object, boolean]} Tuple of metadata object and whether an error occurred.
       * @private
       */
      var buildUsageMetada = function buildUsageMetada(result) {
        var usageMetadata = {
          count: {
            candidates: null,
            prompt: null,
            total: null
          }
        };
        var needShowMetadataError = false;
        if (result.usageMetadata) {
          // Candidates
          if (typeof result.usageMetadata.candidatesTokenCount === 'number') usageMetadata.count.candidates = result.usageMetadata.candidatesTokenCount;
          // Prompt
          if (typeof result.usageMetadata.promptTokenCount === 'number') usageMetadata.count.prompt = result.usageMetadata.promptTokenCount;
          // Total
          if (typeof result.usageMetadata.totalTokenCount === 'number') usageMetadata.count.total = result.usageMetadata.totalTokenCount;
        }
        // Error
        else needShowMetadataError = true;
        return [usageMetadata, needShowMetadataError];
      };
      /**
       * Parses and adds content candidates to the final result object.
       *
       * @param {*} result - The result object from the API response.
       * @param {*} finalData - The object where content candidates are appended.
       * @private
       */
      var buildContent = function buildContent(result, finalData) {
        if (Array.isArray(result.candidates)) {
          for (var index in result.candidates) {
            var item = result.candidates[index];
            if (item.content) {
              // Finished reason
              var finishReason = null;
              if (typeof item.finishReason === 'string') finishReason = item.finishReason.toUpperCase();
              // Build content
              tinyGoogleAI.buildContents(finalData.contents, item.content, item.content.role);
              finalData.contents[finalData.contents.length - 1].finishReason = finishReason;
            }
          }
        }
      };
      /**
       * Final handler that transforms the result into a structured response.
       *
       * @param {*} result - The response from the Gemini API.
       * @returns {*} finalData - Structured result with content, usage, model version, or error.
       * @private
       */
      var finalPromise = function finalPromise(result) {
        // Prepare final data
        /** @type {*} */
        var finalData = {
          _response: result
        };
        if (!result.error) {
          // Content
          finalData.contents = [];
          // Model Version
          finalData.modelVersion = typeof result.modelVersion === 'string' ? result.modelVersion : null;
          // Token Usage
          var _buildUsageMetada = buildUsageMetada(result),
            _buildUsageMetada2 = _slicedToArray(_buildUsageMetada, 2),
            tokenUsage = _buildUsageMetada2[0],
            needShowMetadataError = _buildUsageMetada2[1];
          finalData.tokenUsage = tokenUsage;
          if (needShowMetadataError) {
            console.error('Usage Metadata not found in the Google AI result.');
            console.log(result);
          }
          // Build content
          buildContent(result, finalData);
        }
        // Error result
        else buildErrorData(result, finalData);
        // Complete
        return finalData;
      };
      /**
       * Handles streaming Gemini response via Fetch and TextDecoder.
       * Buffers content and sends back partials using the streamingCallback.
       *
       * @async
       * @param {ReadableStream} stream - The ReadableStream from fetch().body
       * @returns {Promise<void>}
       * @private
       */
      var streamingResponse = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(stream) {
          var reader, decoder, done, countData, streamResult, streamCache, readerData, value, streamDone, chunk, cleanedJson, jsonChunk, indexResult, result, tinyData, tinyResult, index, index2, item, finalData, _index, _index2, _t;
          return _regenerator().w(function (_context) {
            while (1) switch (_context.n) {
              case 0:
                _context.p = 0;
                reader = stream.getReader();
                decoder = new TextDecoder('utf-8');
                done = false;
                countData = 0;
                streamResult = {};
                /** @type {*} */
                streamCache = []; // Read streaming
                console.groupCollapsed('[google-generative] Streaming request.');
                console.log("[ai-config] [".concat(model, "]"), requestBody, data);
              case 1:
                if (done) {
                  _context.n = 5;
                  break;
                }
                if (!(reader && typeof reader.read === 'function')) {
                  _context.n = 3;
                  break;
                }
                _context.n = 2;
                return reader.read();
              case 2:
                readerData = _context.v;
                value = readerData.value, streamDone = readerData.done;
                done = streamDone;
                if (value) {
                  chunk = decoder.decode(value, {
                    stream: true
                  });
                  if (!done) {
                    cleanedJson = '';
                    try {
                      cleanedJson = chunk.trim();
                      if (cleanedJson.startsWith(',')) cleanedJson = cleanedJson.substring(1);
                      if (cleanedJson.length > 1) {
                        cleanedJson = (0, _jsonrepair.jsonrepair)(cleanedJson);
                        cleanedJson = "".concat(!cleanedJson.startsWith('[') ? '[' : '').concat(cleanedJson).concat(!cleanedJson.endsWith(']') ? ']' : '');
                        jsonChunk = JSON.parse(cleanedJson);
                        console.log("[".concat(countData, "]"), chunk);
                        console.log("[".concat(countData, "]"), cleanedJson);
                        console.log("[".concat(countData, "]"), jsonChunk);
                        // Send temp data
                        for (indexResult in jsonChunk) {
                          result = jsonChunk[indexResult];
                          if (result) {
                            /** @type {*} */
                            tinyData = {
                              contents: []
                            };
                            buildContent(result, tinyData);
                            /** @type {*} */
                            tinyResult = {
                              tokenUsage: buildUsageMetada(result)[0]
                            };
                            for (index in tinyData.contents) {
                              if (!Array.isArray(streamCache[index])) streamCache[index] = [];
                              for (index2 in tinyData.contents[index].parts) {
                                item = tinyData.contents[index].parts[index2];
                                if (typeof item.text === 'string') {
                                  if (!streamCache[index][index2]) streamCache[index][index2] = {};
                                  if (typeof streamCache[index][index2].text !== 'string') streamCache[index][index2].text = '';
                                  streamCache[index][index2].text += item.text;
                                  item.text = streamCache[index][index2].text;
                                  if (typeof tinyData.contents[index].role === 'string') streamCache[index][index2].role = tinyData.contents[index].role;
                                }
                              }
                            }
                            // Complete
                            streamResult = result;
                            tinyResult.contents = tinyData.contents;
                            tinyResult.done = false;
                            streamingCallback(tinyResult);
                          }
                        }
                      }
                    } catch (_unused) {
                      console.log("[google-generative] [ai-error] [chuck] [".concat(countData, "]"), chunk);
                      console.log("[google-generative] [ai-error] [cleanedJson] [".concat(countData, "]"), cleanedJson);
                    }
                  }
                }
                countData++;
                _context.n = 4;
                break;
              case 3:
                done = true;
              case 4:
                _context.n = 1;
                break;
              case 5:
                console.groupEnd();
                // Complete
                streamingCallback({
                  done: true
                });
                finalData = finalPromise(streamResult);
                for (_index in finalData.contents) {
                  for (_index2 in finalData.contents[_index].parts) {
                    if (typeof finalData.contents[_index].parts[_index2].text === 'string') finalData.contents[_index].parts[_index2].text = streamCache[_index][_index2];
                  }
                }
                resolve(finalData);
                _context.n = 7;
                break;
              case 6:
                _context.p = 6;
                _t = _context.v;
                reject(_t);
              case 7:
                return _context.a(2);
            }
          }, _callee, null, [[0, 6]]);
        }));
        return function streamingResponse(_x) {
          return _ref.apply(this, arguments);
        };
      }();
      // Request
      var fetchRequest = fetch("".concat(apiUrl, "/models/").concat(model, ":").concat(!isStream ? 'generateContent' : 'streamGenerateContent', "?key=").concat(encodeURIComponent(apiKey)), {
        signal: controller ? controller.signal : undefined,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });
      // Normal
      // Request
      fetchRequest.then(function (res) {
        // Normal
        if (!isStream) res.json().then(function (result) {
          return resolve(finalPromise(result));
        })["catch"](reject);else {
          // Error Streaming
          if (!res.body) reject(new Error('No AI streaming value found.'));else if (!res.ok) reject(new Error("Error ".concat(typeof res.status === 'number' ? "HTTP ".concat(res.status) : 'UNKNOWN ERROR', ": ").concat(typeof res.statusText === 'string' ? res.statusText.length > 0 ? res.statusText : typeof errorCodes[Number(res.status)] === 'string' ? errorCodes[Number(res.status)] : '???' : 'Unknown')));
          // Streaming
          else streamingResponse(res.body);
        }
      })
      // Error
      ["catch"](reject);
    });
  });
  // https://ai.google.dev/api/models?hl=pt_br#method:-models.list
  /**
   * Registers a function to fetch and organize the list of available Google AI models.
   * The returned models are grouped into categories (`main`, `exp`, `others`) and sorted based on a predefined versioning logic.
   *
   * @function
   * @name tinyGoogleAI._setGetModels
   * @param {function(string, number, string=): Promise<Object>} callback - A function that takes an API key, an optional page size, and an optional page token,
   * and returns a Promise with the processed models data.
   *
   * @returns {void}
   *
   * @example
   * tinyGoogleAI._setGetModels((apiKey, pageSize, pageToken) => { ... });
   *
   * Returned object when resolved:
   * {
   *   _response: <original API response>,
   *   newData: [<processed and inserted model objects>]
   * }
   *
   * Model structure inserted into `tinyGoogleAI`:
   * {
   *   _response: <original model>,
   *   category: { displayName, id, index },
   *   index: <number>,
   *   name: <string>,
   *   id: <string>,
   *   displayName: <string>,
   *   version: <string>,
   *   description: <string>,
   *   inputTokenLimit: <number>,
   *   outputTokenLimit: <number>,
   *   temperature: <number>,
   *   maxTemperature: <number>,
   *   topP: <number>,
   *   topK: <number>,
   *   supportedGenerationMethods: [<string>]
   * }
   */
  tinyGoogleAI._setGetModels(
  /**
   * @param {string} apiKey
   * @param {number} pageSize
   * @param {string} pageToken
   * @returns {any}
   */
  function (apiKey, pageSize, pageToken) {
    return new Promise(function (resolve, reject) {
      return fetch("".concat(apiUrl, "/models?key=").concat(encodeURIComponent(apiKey), "&pageSize=").concat(encodeURIComponent(pageSize)).concat(pageToken ? "&pageToken=".concat(encodeURIComponent(pageToken)) : ''), {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      })
      // Request
      .then(function (res) {
        return res.json();
      }).then(function (result) {
        // Prepare final data
        /** @type {*} */
        var finalData = {
          _response: result
        };
        if (!result.error) {
          finalData.newData = [];
          // Update Token
          tinyGoogleAI._setNextModelsPageToken(result.nextPageToken);
          // Categories
          /** @type {*} */
          var newModels = [{
            category: 'main',
            index: 0,
            displayName: '--> Main models',
            data: []
          }, {
            category: 'exp',
            index: 1,
            displayName: '--> Experimental models',
            data: []
          }, {
            category: 'others',
            index: 2,
            displayName: '--> Other models',
            data: []
          }];
          var modelOrderIndexUsed = {
            main: -1,
            exp: -1
          };
          /** @type {*} */
          var modelOrder = {};
          var addModelVersions = function addModelVersions() {
            var version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            // Release
            modelOrderIndexUsed.main++;
            modelOrder["gemini-".concat(version, "-flash")] = {
              index: modelOrderIndexUsed.main,
              category: 'main'
            };
            modelOrderIndexUsed.main++;
            modelOrder["gemini-".concat(version, "-pro")] = {
              index: modelOrderIndexUsed.main,
              category: 'main'
            };
            // Exp
            modelOrderIndexUsed.exp++;
            modelOrder["gemini-".concat(version, "-flash-exp")] = {
              index: modelOrderIndexUsed.exp,
              category: 'exp'
            };
            modelOrderIndexUsed.exp++;
            modelOrder["gemini-".concat(version, "-pro-exp")] = {
              index: modelOrderIndexUsed.exp,
              category: 'exp'
            };
          };
          for (var versionNumber = 99; versionNumber >= 2; versionNumber--) {
            addModelVersions("".concat(versionNumber, ".0"));
            addModelVersions("".concat(versionNumber, ".5"));
          }
          addModelVersions('1.5');
          // Read models
          console.log('[Google Generative] Models list', result.models);
          var _loop = function _loop() {
            var id = result.models[index].name.substring(7);
            var allowed = false;
            if (Array.isArray(result.models[index].supportedGenerationMethods) && result.models[index].supportedGenerationMethods.indexOf('generateContent') > -1 && result.models[index].supportedGenerationMethods.indexOf('countTokens') > -1) {
              for (var id2 in modelOrder) {
                if (id.startsWith(id2) || id === id2) allowed = true;
              }
            }
            // Allow add the model
            if (allowed) {
              // Add custom order
              if (modelOrder[id] && typeof modelOrder[id].index === 'number') result.models[index]._NEW_ORDER = modelOrder[id].index;else result.models[index]._NEW_ORDER = 999999;
              // Add Category
              if (modelOrder[id] && typeof modelOrder[id].category === 'string') {
                var category = newModels.find(function (/** @type {any} */item) {
                  return item.category === modelOrder[id].category;
                });
                if (category) category.data.push(result.models[index]);
                // Nope
                else newModels[newModels.length - 1].data.push(result.models[index]);
              } else newModels[newModels.length - 1].data.push(result.models[index]);
            }
          };
          for (var index in result.models) {
            _loop();
          }
          // Send data
          for (var _index3 in newModels) {
            for (var index2 in newModels[_index3].data) {
              var newModel = {
                _response: newModels[_index3].data[index2],
                category: {
                  displayName: newModels[_index3].displayName,
                  id: newModels[_index3].category,
                  index: newModels[_index3].index
                },
                index: newModels[_index3].data[index2]._NEW_ORDER,
                name: newModels[_index3].data[index2].name,
                id: newModels[_index3].data[index2].name.substring(7),
                displayName: newModels[_index3].data[index2].displayName,
                version: newModels[_index3].data[index2].version,
                description: newModels[_index3].data[index2].description,
                inputTokenLimit: newModels[_index3].data[index2].inputTokenLimit,
                outputTokenLimit: newModels[_index3].data[index2].outputTokenLimit,
                temperature: newModels[_index3].data[index2].temperature,
                maxTemperature: newModels[_index3].data[index2].maxTemperature,
                topP: newModels[_index3].data[index2].topP,
                topK: newModels[_index3].data[index2].topK,
                supportedGenerationMethods: newModels[_index3].data[index2].supportedGenerationMethods
              };
              var inserted = tinyGoogleAI._insertNewModel(newModel);
              if (inserted) finalData.newData.push(inserted);
            }
          }
        }
        // Error result
        else buildErrorData(result, finalData);
        // Complete
        resolve(finalData);
      })
      // Error
      ["catch"](reject);
    });
  });
  // https://ai.google.dev/api/tokens?hl=pt-br#method:-models.counttokens
  /**
   * Registers a function to calculate token usage for a given model and input data using Google AI's `countTokens` endpoint.
   *
   * @function
   * @name tinyGoogleAI._setCountTokens
   * @param {function(string, string, AbortController?, Object): Promise<Object>} callback - A function that takes an API key, model ID,
   * an optional AbortController, and the input data for the token count request. Returns a Promise with token count information.
   *
   * @returns {void}
   *
   * @example
   * tinyGoogleAI._setCountTokens((apiKey, model, controller, data) => { ... });
   *
   * Returned object when resolved:
   * {
   *   _response: <original API response>,
   *   totalTokens: <number|null>,
   *   cachedContentTokenCount: <number|null>,
   *   promptTokensDetails: {
   *     tokenCount: <number|null>,
   *     modality: <string|null>
   *   }
   * }
   */
  tinyGoogleAI._setCountTokens(
  /**
   * @param {string} apiKey
   * @param {string} model
   * @param {AbortController} controller
   * @param {any} data
   * @returns {any}
   */
  function (apiKey, model, controller, data) {
    return new Promise(function (resolve, reject) {
      var dataContent = requestBuilder(data);
      /** @type {*} */
      var modelInfo = tinyGoogleAI.getModelData(model);
      dataContent.model = modelInfo === null || modelInfo === void 0 ? void 0 : modelInfo.name;
      if (Array.isArray(dataContent.contents) && dataContent.contents.length > 0) {
        fetch("".concat(apiUrl, "/models/").concat(model, ":countTokens?key=").concat(encodeURIComponent(apiKey)), {
          signal: controller ? controller.signal : undefined,
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            generateContentRequest: dataContent
          })
        })
        // Request
        .then(function (res) {
          return res.json();
        }).then(function (result) {
          /** @type {*} */
          var finalData = {
            _response: result
          };
          if (!result.error) {
            // Total tokens
            if (typeof result.totalTokens === 'number') finalData.totalTokens = result.totalTokens;else finalData.totalTokens = null;
            // Cached Content Token Count
            if (typeof result.cachedContentTokenCount === 'number') finalData.cachedContentTokenCount = result.cachedContentTokenCount;else finalData.cachedContentTokenCount = null;
            // Prompt tokens details
            if (result.promptTokensDetails) {
              if (!finalData.promptTokensDetails) finalData.promptTokensDetails = {};
              // Token Count
              if (typeof result.promptTokensDetails.tokenCount === 'number') finalData.promptTokensDetails.tokenCount = result.promptTokensDetails.tokenCount;else finalData.promptTokensDetails.tokenCount = null;
              // Modality
              if (typeof result.promptTokensDetails.modality === 'string') finalData.promptTokensDetails.modality = result.promptTokensDetails.modality;else finalData.promptTokensDetails.modality = null;
            }
          }
          // Error result
          else buildErrorData(result, finalData);
          // Complete
          resolve(finalData);
        })
        // Error
        ["catch"](reject);
      } else resolve({
        _response: {},
        totalTokens: null,
        cachedContentTokenCount: null
      });
    });
  });
  // Complete
  return tinyGoogleAI;
}
/**
 * Creates and configures a new TinyAiInstance that is set up with the Google Gemini API.
 *
 * @class
 * @extends TinyAiInstance
 * @param {string} GEMINI_API_KEY - The API key used to authenticate with the Google Gemini API.
 * @param {string} [MODEL_DATA='gemini-2.0-flash'] - Optional. The model identifier to use. Defaults to `'gemini-2.0-flash'`.
 * @param {boolean} [isSingle=false] - If true, configures the instance to handle a single session only.
 * @returns {TinyAiInstance} A configured instance of TinyAiApi.
 */
var TinyGoogleAi = exports.TinyGoogleAi = /*#__PURE__*/function (_TinyAiInstance) {
  function TinyGoogleAi() {
    var _this;
    var GEMINI_API_KEY = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var MODEL_DATA = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'gemini-2.0-flash';
    var isSingle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    _classCallCheck(this, TinyGoogleAi);
    _this = _callSuper(this, TinyGoogleAi, [isSingle]);
    setTinyGoogleAi(_this, GEMINI_API_KEY, MODEL_DATA);
    return _this;
  }
  _inherits(TinyGoogleAi, _TinyAiInstance);
  return _createClass(TinyGoogleAi);
}(_TinyAiInstance2["default"]);

},{"../TinyAiInstance.mjs":109,"jsonrepair":88}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = arraySortPositions;
/**
 * Generates a comparator function to sort an array of objects by a given key.
 *
 * @param {string} item - The object key to sort by.
 * @param {boolean} [isReverse=false] - If `true`, the sorting will be in descending order.
 * @returns {(a: Object<string|number, *>, b: Object<string|number, *>) => number} Comparator function compatible with Array.prototype.sort().
 *
 * @example
 * const arr = [{ pos: 2 }, { pos: 1 }, { pos: 3 }];
 * arr.sort(arraySortPositions('pos')); // Ascending: [{pos: 1}, {pos: 2}, {pos: 3}]
 *
 * @example
 * const arr = [{ pos: 2 }, { pos: 1 }, { pos: 3 }];
 * arr.sort(arraySortPositions('pos', true)); // Descending: [{pos: 3}, {pos: 2}, {pos: 1}]
 */
function arraySortPositions(item) {
  var isReverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!isReverse) {
    return function (a, b) {
      return a[item] < b[item] ? -1 : a[item] > b[item] ? 1 : 0;
    };
  } else {
    return function (a, b) {
      return a[item] > b[item] ? -1 : a[item] < b[item] ? 1 : 0;
    };
  }
}

},{}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = asyncReplace;
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Asynchronously replaces matches in a string using a regex and an async function.
 *
 * @param {string} str - The input string to perform replacements on.
 * @param {RegExp} regex - The regular expression to match substrings for replacement.
 * @param {Function} asyncFn - An asynchronous function that returns a replacement for each match.
 *                             It receives the same arguments as a standard `replace` callback.
 * @returns {Promise<string>} The resulting string with all async replacements applied.
 *
 * @example
 * await asyncReplace("Hello @user1 and @user2!", /@\w+/g, async (mention) => {
 *   return await getUserNameFromMention(mention);
 * });
 */
function asyncReplace(_x, _x2, _x3) {
  return _asyncReplace.apply(this, arguments);
}
function _asyncReplace() {
  _asyncReplace = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(str, regex, asyncFn) {
    var promises, data;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          /**
           * @type {any[]}
           */
          promises = []; // Collect promises
          str.replace(regex, function (match) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            promises.push(asyncFn.apply(void 0, [match].concat(args)));
            return match;
          });
          _context.n = 1;
          return Promise.all(promises);
        case 1:
          data = _context.v;
          return _context.a(2, str.replace(regex, function () {
            return data.shift();
          }));
      }
    }, _callee);
  }));
  return _asyncReplace.apply(this, arguments);
}

},{}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Represents a user object used.
 *
 * @typedef {Object} UserEditor
 * @property {number} exp - Current experience points of the user.
 * @property {number} level - Current level of the user.
 * @property {number} totalExp - Total accumulated experience.
 */
/**
 * Class to manage user level-up logic based on experience points.
 */
var TinyLevelUp = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {number} giveExp - Base experience value for random experience generation.
   * @param {number} expLevel - Base experience needed to level up (per level).
   */
  function TinyLevelUp(giveExp, expLevel) {
    _classCallCheck(this, TinyLevelUp);
    if (typeof giveExp !== 'number' || Number.isNaN(giveExp)) throw new Error('giveExp must be a valid number');
    if (typeof expLevel !== 'number' || Number.isNaN(expLevel)) throw new Error('expLevel must be a valid number');
    this.giveExp = giveExp;
    this.expLevel = expLevel;
  }
  /**
   * Creates a new user object starting at level 0 with 0 experience.
   * @returns {UserEditor} A fresh user object.
   */
  return _createClass(TinyLevelUp, [{
    key: "createUser",
    value: function createUser() {
      return {
        exp: 0,
        level: 1,
        totalExp: 0
      };
    }
    /**
     * Validates if the given user object has valid numeric properties.
     * Throws an error if any property is invalid.
     *
     * @param {UserEditor} user - The user object to validate.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "validateUser",
    value: function validateUser(user) {
      if (typeof user.exp !== 'number' || Number.isNaN(user.exp)) throw new Error('exp must be a valid number');
      if (typeof user.level !== 'number' || Number.isNaN(user.level)) throw new Error('level must be a valid number');
      if (user.level < 1) throw new Error('level must be at least 1');
      if (typeof user.totalExp !== 'number' || Number.isNaN(user.totalExp)) throw new Error('totalExp must be a valid number');
    }
    /**
     * Checks if the given user object is valid by verifying its numeric properties.
     *
     * @param {UserEditor} user - The user object to check.
     * @returns {boolean} `true` if all properties (exp, level, totalExp) are valid numbers; otherwise `false`.
     */
  }, {
    key: "isValidUser",
    value: function isValidUser(user) {
      if (typeof user.exp !== 'number' || Number.isNaN(user.exp)) return false;
      if (typeof user.level !== 'number' || Number.isNaN(user.level)) return false;
      if (user.level < 1) return false;
      if (typeof user.totalExp !== 'number' || Number.isNaN(user.totalExp)) return false;
      return true;
    }
    /**
     * Returns the base experience value used for random experience generation.
     * Throws an error if the internal giveExp value is not a valid number.
     *
     * @returns {number} The base experience value.
     * @throws {Error} If giveExp is not a valid number.
     */
  }, {
    key: "getGiveExpBase",
    value: function getGiveExpBase() {
      if (typeof this.giveExp !== 'number' || Number.isNaN(this.giveExp)) throw new Error('giveExp must be a valid number');
      return this.giveExp;
    }
    /**
     * Returns the base experience required to level up.
     * Throws an error if the internal expLevel value is not a valid number.
     *
     * @returns {number} The base experience needed per level.
     * @throws {Error} If expLevel is not a valid number.
     */
  }, {
    key: "getExpLevelBase",
    value: function getExpLevelBase() {
      if (typeof this.expLevel !== 'number' || Number.isNaN(this.expLevel)) throw new Error('expLevel must be a valid number');
      return this.expLevel;
    }
    /**
     * Validates and adjusts the user's level based on their current experience.
     * @param {UserEditor} user - The user object containing experience and level properties.
     * @returns {UserEditor} The updated user object.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "expValidator",
    value: function expValidator(user) {
      var expLevel = this.getExpLevelBase();
      this.validateUser(user);
      var extraValue = 0;
      var nextLevelExp = expLevel * user.level;
      // Level Up
      if (user.exp >= nextLevelExp) {
        user.level++;
        extraValue = user.exp - nextLevelExp;
        user.exp = 0;
        if (extraValue > 0) return this.give(user, extraValue, 'extra');
      }
      // Level Down
      if (user.exp < 1 && user.level > 1) {
        user.level--;
        extraValue = Math.abs(user.exp);
        user.exp = expLevel * user.level;
        if (extraValue > 0) return this.remove(user, extraValue, 'extra');
      }
      return user;
    }
    /**
     * Calculates the total experience based on the user's level.
     * @param {UserEditor} user - The user object containing experience and level properties.
     * @returns {number} The total experience of the user.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "getTotalExp",
    value: function getTotalExp(user) {
      this.validateUser(user);
      var totalExp = 0;
      for (var p = 1; p <= user.level; p++) totalExp += this.getExpLevelBase() * p;
      totalExp += user.exp;
      return totalExp;
    }
    /**
     * Generates random experience points based on the configured multiplier.
     * @param {number} [multi] - A multiplier for the generated experience.
     * @returns {number} The generated experience points.
     */
  }, {
    key: "expGenerator",
    value: function expGenerator() {
      var multi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      if (typeof multi !== 'number' || Number.isNaN(multi)) throw new Error('multi must be a valid number');
      return Math.floor(Math.random() * this.getGiveExpBase()) * multi;
    }
    /**
     * Calculates how much experience is missing to next level.
     * @param {UserEditor} user
     * @returns {number}
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "getMissingExp",
    value: function getMissingExp(user) {
      return this.getProgress(user) - user.exp;
    }
    /**
     * Gets the experience points required to reach the next level.
     * @param {UserEditor} user - The user object containing the level.
     * @returns {number} The experience required for the next level.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "progress",
    value: function progress(user) {
      return this.getProgress(user);
    }
    /**
     * Gets the experience points required to reach the next level.
     * @param {UserEditor} user - The user object containing the level.
     * @returns {number} The experience required for the next level.
     * @throws {Error} If any property (exp, level, totalExp) is not a valid number.
     */
  }, {
    key: "getProgress",
    value: function getProgress(user) {
      this.validateUser(user);
      return this.getExpLevelBase() * user.level;
    }
    /**
     * Sets the experience value for the user, adjusting their level if necessary.
     * @param {UserEditor} user - The user object.
     * @param {number} value - The new experience value to set.
     * @returns {UserEditor} The updated user object.
     */
  }, {
    key: "set",
    value: function set(user, value) {
      if (typeof value !== 'number' || Number.isNaN(value)) throw new Error('value must be a valid number');
      user.exp = value;
      this.expValidator(user);
      user.totalExp = this.getTotalExp(user);
      return user;
    }
    /**
     * Adds experience to the user, adjusting their level if necessary.
     * @param {UserEditor} user - The user object.
     * @param {number} [extraExp] - Additional experience to be added.
     * @param {'add' | 'extra'} [type] - Type of addition ('add' or 'extra').
     * @param {number} [multi] - Multiplier for experience generation.
     * @returns {UserEditor} The updated user object.
     */
  }, {
    key: "give",
    value: function give(user) {
      var extraExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'add';
      var multi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if (typeof multi !== 'number' || Number.isNaN(multi)) throw new Error('multi must be a valid number');
      if (typeof extraExp !== 'number' || Number.isNaN(extraExp)) throw new Error('extraExp must be a valid number');
      if (typeof type !== 'string') throw new Error('type must be a valid string');
      if (type === 'add') user.exp += this.expGenerator(multi) + extraExp;else if (type === 'extra') user.exp += extraExp;
      this.expValidator(user);
      user.totalExp = this.getTotalExp(user);
      return user;
    }
    /**
     * Removes experience from the user, adjusting their level if necessary.
     * @param {UserEditor} user - The user object.
     * @param {number} [extraExp] - Additional experience to remove.
     * @param {'add' | 'extra'} [type] - Type of removal ('add' or 'extra').
     * @param {number} [multi] - Multiplier for experience generation.
     * @returns {UserEditor} The updated user object.
     */
  }, {
    key: "remove",
    value: function remove(user) {
      var extraExp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'add';
      var multi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if (typeof multi !== 'number' || Number.isNaN(multi)) throw new Error('multi must be a valid number');
      if (typeof extraExp !== 'number' || Number.isNaN(extraExp)) throw new Error('extraExp must be a valid number');
      if (typeof type !== 'string') throw new Error('type must be a valid string');
      if (type === 'add') user.exp -= this.expGenerator(multi) + extraExp;else if (type === 'extra') user.exp -= extraExp;
      this.expValidator(user);
      user.totalExp = this.getTotalExp(user);
      return user;
    }
  }]);
}();
var _default = exports["default"] = TinyLevelUp;

},{}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shuffleArray = shuffleArray;
// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
/**
 * Randomly shuffles the elements of an array in place using the Fisher–Yates algorithm.
 *
 * This implementation ensures a uniform distribution of permutations.
 * Original algorithm source: StackOverflow (link above).
 *
 * @param {any[]} items - The array to shuffle.
 * @returns {any[]} The same array instance, now shuffled in place.
 */
function shuffleArray(items) {
  var currentIndex = items.length,
    randomIndex;
  // While there remain elements to shuffle...
  while (currentIndex !== 0) {
    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    // And swap it with the current element.
    var _ref = [items[randomIndex], items[currentIndex]];
    items[currentIndex] = _ref[0];
    items[randomIndex] = _ref[1];
  }
  return items;
}

},{}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatCustomTimer = formatCustomTimer;
exports.formatDayTimer = formatDayTimer;
exports.formatTimer = formatTimer;
exports.getTimeDuration = getTimeDuration;
/**
 * Calculates the time duration between the current time and a given time offset.
 *
 * @param {Date} timeData - The target time as a Date object.
 * @param {string} [durationType='asSeconds'] - The type of duration to return. Can be 'asMilliseconds', 'asSeconds', 'asMinutes', 'asHours', 'asDays'.
 * @param {Date|null} [now=null] - The current time as a Date object. Defaults to the current date and time if not provided.
 * @returns {number|null} The calculated duration in the specified unit, or `null` if `timeData` is not provided.
 */
function getTimeDuration() {
  var timeData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  var durationType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'asSeconds';
  var now = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (timeData instanceof Date) {
    var currentTime = now instanceof Date ? now : new Date();
    /** @type {number} */
    var diffMs = timeData.getTime() - currentTime.getTime();
    switch (durationType) {
      case 'asMilliseconds':
        return diffMs;
      case 'asSeconds':
        return diffMs / 1000;
      case 'asMinutes':
        return diffMs / (1000 * 60);
      case 'asHours':
        return diffMs / (1000 * 60 * 60);
      case 'asDays':
        return diffMs / (1000 * 60 * 60 * 24);
      default:
        return diffMs / 1000;
      // default to seconds
    }
  }
  return null;
}
/**
 * Formats a custom timer string based on total seconds and a detail level.
 * Includes proper reallocation of lower units into higher ones, ensuring consistent hierarchy.
 *
 * @param {number} totalSeconds - The total amount of seconds to convert.
 * @param {'seconds'|'minutes'|'hours'|'days'|'months'|'years'} [level] - The highest level to calculate and display.
 * @param {string} [format='{time}'] - Output template with placeholders like {years}, {months}, {days}, {hours}, {minutes}, {seconds}, {time}, {total}.
 * @returns {string} The formatted timer string.
 */
function formatCustomTimer(totalSeconds) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'seconds';
  var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '{time}';
  totalSeconds = Math.max(0, Math.floor(totalSeconds));
  var levels = ['seconds', 'minutes', 'hours', 'days', 'months', 'years'];
  var index = levels.indexOf(level);
  var include = {
    years: index >= 5,
    months: index >= 4,
    days: index >= 3,
    hours: index >= 2,
    minutes: index >= 1,
    seconds: index >= 0
  };
  /**
   * @type {{
   *   years: number|NaN,
   *   months: number|NaN,
   *   days: number|NaN,
   *   hours: number|NaN,
   *   minutes: number|NaN,
   *   seconds: number|NaN,
   *   total: number|NaN
   * }}
   */
  var parts = {
    years: include.years ? 0 : NaN,
    months: include.months ? 0 : NaN,
    days: include.days ? 0 : NaN,
    hours: include.hours ? 0 : NaN,
    minutes: include.minutes ? 0 : NaN,
    seconds: include.seconds ? 0 : NaN,
    total: NaN
  };
  var remaining = totalSeconds;
  if (include.years || include.months || include.days) {
    var baseDate = new Date(1980, 0, 1);
    var targetDate = new Date(baseDate.getTime() + remaining * 1000);
    var workingDate = new Date(baseDate);
    // Years
    if (include.years) {
      while (new Date(workingDate.getFullYear() + 1, workingDate.getMonth(), workingDate.getDate()).getTime() <= targetDate.getTime()) {
        workingDate.setFullYear(workingDate.getFullYear() + 1);
        parts.years++;
      }
    }
    // Months
    if (include.months) {
      while (new Date(workingDate.getFullYear(), workingDate.getMonth() + 1, workingDate.getDate()).getTime() <= targetDate.getTime()) {
        workingDate.setMonth(workingDate.getMonth() + 1);
        parts.months++;
      }
    }
    // Days
    if (include.days) {
      while (new Date(workingDate.getFullYear(), workingDate.getMonth(), workingDate.getDate() + 1).getTime() <= targetDate.getTime()) {
        workingDate.setDate(workingDate.getDate() + 1);
        parts.days++;
      }
    }
    remaining = Math.floor((targetDate.getTime() - workingDate.getTime()) / 1000);
  }
  if (include.hours) {
    parts.hours = Math.floor(remaining / 3600);
    remaining %= 3600;
  }
  if (include.minutes) {
    parts.minutes = Math.floor(remaining / 60);
    remaining %= 60;
  }
  if (include.seconds) {
    parts.seconds = remaining;
  }
  // Calculate total
  var totalMap = {
    seconds: include.seconds ? totalSeconds : NaN,
    minutes: include.minutes ? totalSeconds / 60 : NaN,
    hours: include.hours ? totalSeconds / 3600 : NaN,
    days: include.days ? totalSeconds / 86400 : NaN,
    months: include.months ? parts.years * 12 + parts.months + (parts.days || 0) / 30 : NaN,
    years: include.years ? parts.years + (parts.months || 0) / 12 + (parts.days || 0) / 365 : NaN
  };
  parts.total = +(totalMap[level] || 0).toFixed(2).replace(/\.00$/, '');
  /**
   * Pads a number to ensure it is at least two digits long, using leading zeros if necessary.
   *
   * @param {number|string} n - The number or string to pad.
   * @returns {string} The padded string.
   */
  var pad = function pad(n) {
    var num = typeof n === 'string' ? parseInt(n) : n;
    return Number.isNaN(num) ? 'NaN' : String(num).padStart(2, '0');
  };
  var timeString = [include.hours ? pad(parts.hours) : null, include.minutes ? pad(parts.minutes) : null, include.seconds ? pad(parts.seconds) : null].filter(function (v) {
    return v !== null;
  }).join(':');
  return format.replace(/\{years\}/g, String(parts.years)).replace(/\{months\}/g, String(parts.months)).replace(/\{days\}/g, String(parts.days)).replace(/\{hours\}/g, pad(parts.hours)).replace(/\{minutes\}/g, pad(parts.minutes)).replace(/\{seconds\}/g, pad(parts.seconds)).replace(/\{time\}/g, timeString).replace(/\{total\}/g, String(parts.total)).trim();
}
/**
 * Formats a duration (in seconds) into a timer string showing only hours, minutes, and seconds.
 *
 * Example output: "05:32:10"
 *
 * @param {number} seconds - The total number of seconds to format.
 * @returns {string} The formatted timer string in "HH:MM:SS" format.
 */
function formatTimer(seconds) {
  return formatCustomTimer(seconds, 'hours', '{hours}:{minutes}:{seconds}');
}
/**
 * Formats a duration (in seconds) into a timer string including days, hours, minutes, and seconds.
 *
 * Example output: "2d 05:32:10"
 *
 * @param {number} seconds - The total number of seconds to format.
 * @returns {string} The formatted timer string in "Xd HH:MM:SS" format.
 */
function formatDayTimer(seconds) {
  return formatCustomTimer(seconds, 'days', '{days}d {hours}:{minutes}:{seconds}');
}

},{}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requestFullScreen = exports.onFullScreenChange = exports.offFullScreenChange = exports.isScreenFilled = exports.isFullScreenMode = exports.exitFullScreen = exports.documentIsFullScreen = void 0;
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Checks if the document is currently in fullscreen mode.
 *
 * @returns {boolean}
 */
var documentIsFullScreen = exports.documentIsFullScreen = function documentIsFullScreen() {
  return !!(document.fullscreenElement ||
  // @ts-ignore
  document.webkitFullscreenElement ||
  // @ts-ignore
  document.mozFullScreenElement ||
  // @ts-ignore
  document.msFullscreenElement ||
  // @ts-ignore
  document.webkitIsFullScreen ||
  // @ts-ignore
  document.mozFullScreen);
};
/**
 * Checks if the window occupies the entire screen dimensions.
 *
 * @returns {boolean}
 */
var isScreenFilled = exports.isScreenFilled = function isScreenFilled() {
  return window.innerHeight === screen.height && window.innerWidth === screen.width;
};
/**
 * Checks if fullscreen mode is active either via document API or by matching screen dimensions.
 *
 * @returns {boolean}
 */
var isFullScreenMode = exports.isFullScreenMode = function isFullScreenMode() {
  return documentIsFullScreen() || isScreenFilled();
};
/**
 * Requests fullscreen mode for the document.
 *
 * @param {FullscreenOptions} [ops]
 * @returns {Promise<void>}
 */
var requestFullScreen = exports.requestFullScreen = function requestFullScreen(ops) {
  return new Promise(/*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(resolve, reject) {
      var docElm, _t;
      return _regenerator().w(function (_context) {
        while (1) switch (_context.n) {
          case 0:
            docElm = document.documentElement;
            _context.p = 1;
            if (!docElm.requestFullscreen) {
              _context.n = 3;
              break;
            }
            _context.n = 2;
            return docElm.requestFullscreen(ops);
          case 2:
            _context.n = 4;
            break;
          case 3:
            if (docElm.mozRequestFullScreen) {
              // @ts-ignore
              docElm.mozRequestFullScreen(ops);
              // @ts-ignore
            } else if (docElm.webkitRequestFullScreen) {
              // @ts-ignore
              docElm.webkitRequestFullScreen(ops);
              // @ts-ignore
            } else if (docElm.msRequestFullscreen) {
              // @ts-ignore
              docElm.msRequestFullscreen(ops);
            }
          case 4:
            resolve();
            _context.n = 6;
            break;
          case 5:
            _context.p = 5;
            _t = _context.v;
            reject(_t);
          case 6:
            return _context.a(2);
        }
      }, _callee, null, [[1, 5]]);
    }));
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
};
/**
 * Exits fullscreen mode.
 *
 * @returns {Promise<void>}
 */
var exitFullScreen = exports.exitFullScreen = function exitFullScreen() {
  return new Promise(function (resolve, reject) {
    if (document.exitFullscreen) {
      document.exitFullscreen().then(resolve)["catch"](reject);
    } else {
      try {
        // @ts-ignore
        if (document.mozCancelFullScreen) document.mozCancelFullScreen();
        // @ts-ignore
        else if (document.webkitCancelFullScreen) document.webkitCancelFullScreen();
        // @ts-ignore
        else if (document.msExitFullscreen) document.msExitFullscreen();else throw new Error('Fullscreen API is not supported');
        resolve();
      } catch (err) {
        reject(err);
      }
    }
  });
};
/** @type {readonly string[]} */
var fullScreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
/**
 * Attaches a listener to fullscreen change events.
 *
 * @param {EventListenerOrEventListenerObject} listener
 * @param {boolean|AddEventListenerOptions} [ops]
 * @returns {void}
 */
var onFullScreenChange = exports.onFullScreenChange = function onFullScreenChange(listener, ops) {
  fullScreenEvents.forEach(function (event) {
    document.addEventListener(event, listener, ops);
  });
};
/**
 * Removes a listener from fullscreen change events.
 *
 * @param {EventListenerOrEventListenerObject} listener
 * @param {boolean|AddEventListenerOptions} [ops]
 * @returns {void}
 */
var offFullScreenChange = exports.offFullScreenChange = function offFullScreenChange(listener, ops) {
  fullScreenEvents.forEach(function (event) {
    document.removeEventListener(event, listener, ops);
  });
};

},{}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areHtmlElsColliding = areHtmlElsColliding;
exports.fetchJson = fetchJson;
exports.getHtmlElPadding = exports.getHtmlElMargin = exports.getHtmlElBordersWidth = exports.getHtmlElBorders = void 0;
exports.readJsonBlob = readJsonBlob;
exports.saveJsonFile = saveJsonFile;
var _objFilter = require("./objFilter.mjs");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Checks if two DOM elements are colliding on the screen.
 *
 * @param {Element} elem1 - First DOM element.
 * @param {Element} elem2 - Second DOM element.
 * @returns {boolean} - Returns true if the elements are colliding.
 */
function areHtmlElsColliding(elem1, elem2) {
  var rect1 = elem1.getBoundingClientRect();
  var rect2 = elem2.getBoundingClientRect();
  return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);
}
/**
 * Reads and parses a JSON data using FileReader.
 * Throws an error if the content is not valid JSON.
 * @param {File} file
 * @returns {Promise<any>}
 */
function readJsonBlob(file) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();
    reader.onload = function () {
      try {
        // @ts-ignore
        var result = JSON.parse(reader.result);
        resolve(result);
      } catch (error) {
        // @ts-ignore
        reject(new Error("Invalid JSON in file: ".concat(file.name, "\n").concat(error.message)));
      }
    };
    reader.onerror = function () {
      reject(new Error("Error reading file: ".concat(file.name)));
    };
    reader.readAsText(file);
  });
}
/**
 * Saves a JSON object as a downloadable file.
 * @param {string} filename
 * @param {any} data
 * @param {number} [spaces=2]
 */
function saveJsonFile(filename, data) {
  var spaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var json = JSON.stringify(data, null, spaces);
  var blob = new Blob([json], {
    type: 'application/json'
  });
  var url = URL.createObjectURL(blob);
  var link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
/**
 * Loads and parses a JSON from a remote URL using Fetch API.
 *
 * @param {string} url - The full URL to fetch JSON from.
 * @param {Object} [options] - Optional settings.
 * @param {string} [options.method="GET"] - HTTP method to use (GET, POST, etc.).
 * @param {any} [options.body] - Request body (only for methods like POST, PUT).
 * @param {number} [options.timeout=0] - Timeout in milliseconds (ignored if signal is provided).
 * @param {number} [options.retries=0] - Number of retry attempts (ignored if signal is provided).
 * @param {Headers|Record<string, *>} [options.headers={}] - Additional headers.
 * @param {AbortSignal|null} [options.signal] - External AbortSignal; disables timeout and retries.
 * @returns {Promise<*>} Parsed JSON object.
 * @throws {Error} Throws if fetch fails, times out, or returns invalid JSON.
 */
function fetchJson(_x) {
  return _fetchJson.apply(this, arguments);
}
/**
 * @typedef {Object} HtmlElBoxSides
 * @property {number} x - Total horizontal size (left + right)
 * @property {number} y - Total vertical size (top + bottom)
 * @property {number} left
 * @property {number} right
 * @property {number} top
 * @property {number} bottom
 */
/**
 * Returns the total border width and individual sides from `border{Side}Width` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border widths, and each side individually.
 */
function _fetchJson() {
  _fetchJson = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(url) {
    var _ref,
      _ref$method,
      method,
      body,
      _ref$timeout,
      timeout,
      _ref$retries,
      retries,
      _ref$headers,
      headers,
      _ref$signal,
      signal,
      attempts,
      lastError,
      _loop,
      _ret,
      attempt,
      _args2 = arguments;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          _ref = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, _ref$method = _ref.method, method = _ref$method === void 0 ? 'GET' : _ref$method, body = _ref.body, _ref$timeout = _ref.timeout, timeout = _ref$timeout === void 0 ? 0 : _ref$timeout, _ref$retries = _ref.retries, retries = _ref$retries === void 0 ? 0 : _ref$retries, _ref$headers = _ref.headers, headers = _ref$headers === void 0 ? {} : _ref$headers, _ref$signal = _ref.signal, signal = _ref$signal === void 0 ? null : _ref$signal;
          if (!(typeof url !== 'string' || !url.startsWith('../') && !url.startsWith('./') && !url.startsWith('/') && !url.startsWith('https://') && !url.startsWith('http://'))) {
            _context2.n = 1;
            break;
          }
          throw new Error('Invalid URL: must be a valid http or https address.');
        case 1:
          if (!(typeof method !== 'string' || !method.trim())) {
            _context2.n = 2;
            break;
          }
          throw new Error('Invalid method: must be a non-empty string.');
        case 2:
          if (signal) {
            _context2.n = 4;
            break;
          }
          if (!(typeof timeout !== 'number' || !Number.isFinite(timeout) || Number.isNaN(timeout) || timeout < 0)) {
            _context2.n = 3;
            break;
          }
          throw new Error('Invalid timeout: must be a positive number.');
        case 3:
          if (!(typeof retries !== 'number' || !Number.isFinite(retries) || Number.isNaN(retries) || retries < 0)) {
            _context2.n = 4;
            break;
          }
          throw new Error('Invalid retries: must be a positive number.');
        case 4:
          attempts = signal ? 1 : retries + 1;
          /** @type {Error|null} */
          lastError = null;
          _loop = /*#__PURE__*/_regenerator().m(function _loop(attempt) {
            var _controller$signal;
            var controller, localSignal, timer, response, contentType, data, _t;
            return _regenerator().w(function (_context) {
              while (1) switch (_context.n) {
                case 0:
                  controller = signal ? null : new AbortController();
                  localSignal = signal || ((_controller$signal = controller === null || controller === void 0 ? void 0 : controller.signal) !== null && _controller$signal !== void 0 ? _controller$signal : null);
                  timer = !signal && timeout && controller ? setTimeout(function () {
                    return controller.abort();
                  }, timeout) : null;
                  _context.p = 1;
                  _context.n = 2;
                  return fetch(url, {
                    method: method.toUpperCase(),
                    headers: _objectSpread({
                      Accept: 'application/json'
                    }, headers),
                    body: body !== undefined ? (0, _objFilter.isJsonObject)(body) ? JSON.stringify(body) : body : undefined,
                    signal: localSignal
                  });
                case 2:
                  response = _context.v;
                  if (timer) clearTimeout(timer);
                  if (response.ok) {
                    _context.n = 3;
                    break;
                  }
                  throw new Error("HTTP error: ".concat(response.status, " ").concat(response.statusText));
                case 3:
                  contentType = response.headers.get('content-type') || '';
                  if (contentType.includes('application/json')) {
                    _context.n = 4;
                    break;
                  }
                  throw new Error("Unexpected content-type: ".concat(contentType));
                case 4:
                  _context.n = 5;
                  return response.json();
                case 5:
                  data = _context.v;
                  if ((0, _objFilter.isJsonObject)(data)) {
                    _context.n = 6;
                    break;
                  }
                  throw new Error('Received invalid data instead of valid JSON.');
                case 6:
                  return _context.a(2, {
                    v: data
                  });
                case 7:
                  _context.p = 7;
                  _t = _context.v;
                  lastError = /** @type {Error} */_t;
                  if (!signal) {
                    _context.n = 8;
                    break;
                  }
                  return _context.a(2, 0);
                case 8:
                  if (!(attempt < retries)) {
                    _context.n = 9;
                    break;
                  }
                  _context.n = 9;
                  return new Promise(function (resolve) {
                    return setTimeout(resolve, 300 * (attempt + 1));
                  });
                case 9:
                  return _context.a(2);
              }
            }, _loop, null, [[1, 7]]);
          });
          attempt = 0;
        case 5:
          if (!(attempt < attempts)) {
            _context2.n = 9;
            break;
          }
          return _context2.d(_regeneratorValues(_loop(attempt)), 6);
        case 6:
          _ret = _context2.v;
          if (!(_ret === 0)) {
            _context2.n = 7;
            break;
          }
          return _context2.a(3, 9);
        case 7:
          if (!_ret) {
            _context2.n = 8;
            break;
          }
          return _context2.a(2, _ret.v);
        case 8:
          attempt++;
          _context2.n = 5;
          break;
        case 9:
          throw new Error("Failed to fetch JSON from \"".concat(url, "\"").concat(lastError ? ": ".concat(lastError.message) : '.'));
        case 10:
          return _context2.a(2);
      }
    }, _callee);
  }));
  return _fetchJson.apply(this, arguments);
}
var getHtmlElBordersWidth = exports.getHtmlElBordersWidth = function getHtmlElBordersWidth(el) {
  var styles = getComputedStyle(el);
  var left = parseFloat(styles.borderLeftWidth) || 0;
  var right = parseFloat(styles.borderRightWidth) || 0;
  var top = parseFloat(styles.borderTopWidth) || 0;
  var bottom = parseFloat(styles.borderBottomWidth) || 0;
  var x = left + right;
  var y = top + bottom;
  return {
    x: x,
    y: y,
    left: left,
    right: right,
    top: top,
    bottom: bottom
  };
};
/**
 * Returns the total border size and individual sides from `border{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border sizes, and each side individually.
 */
var getHtmlElBorders = exports.getHtmlElBorders = function getHtmlElBorders(el) {
  var styles = getComputedStyle(el);
  var left = parseFloat(styles.borderLeft) || 0;
  var right = parseFloat(styles.borderRight) || 0;
  var top = parseFloat(styles.borderTop) || 0;
  var bottom = parseFloat(styles.borderBottom) || 0;
  var x = left + right;
  var y = top + bottom;
  return {
    x: x,
    y: y,
    left: left,
    right: right,
    top: top,
    bottom: bottom
  };
};
/**
 * Returns the total margin and individual sides from `margin{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) margins, and each side individually.
 */
var getHtmlElMargin = exports.getHtmlElMargin = function getHtmlElMargin(el) {
  var styles = getComputedStyle(el);
  var left = parseFloat(styles.marginLeft) || 0;
  var right = parseFloat(styles.marginRight) || 0;
  var top = parseFloat(styles.marginTop) || 0;
  var bottom = parseFloat(styles.marginBottom) || 0;
  var x = left + right;
  var y = top + bottom;
  return {
    x: x,
    y: y,
    left: left,
    right: right,
    top: top,
    bottom: bottom
  };
};
/**
 * Returns the total padding and individual sides from `padding{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) paddings, and each side individually.
 */
var getHtmlElPadding = exports.getHtmlElPadding = function getHtmlElPadding(el) {
  var styles = getComputedStyle(el);
  var left = parseFloat(styles.paddingLeft) || 0;
  var right = parseFloat(styles.paddingRight) || 0;
  var top = parseFloat(styles.paddingTop) || 0;
  var bottom = parseFloat(styles.paddingBottom) || 0;
  var x = left + right;
  var y = top + bottom;
  return {
    x: x,
    y: y,
    left: left,
    right: right,
    top: top,
    bottom: bottom
  };
};

},{"./objFilter.mjs":119}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkObj = checkObj;
exports.cloneObjTypeOrder = cloneObjTypeOrder;
exports.countObj = countObj;
exports.extendObjType = extendObjType;
exports.getCheckObj = getCheckObj;
exports.isJsonObject = isJsonObject;
exports.objType = objType;
exports.reorderObjTypeOrder = reorderObjTypeOrder;
var _buffer = require("buffer");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
/**
 * An object containing type validation functions and their evaluation order.
 *
 * Each item in `typeValidator.items` is a function that receives any value
 * and returns a boolean indicating whether the value matches the corresponding type.
 *
 * The `order` array defines the priority in which types should be checked,
 * which can be useful for functions that infer types in a consistent manner.
 *
 */
var typeValidator = {
  items: {},
  /**
   * Evaluation order of the type checkers.
   * @type {string[]}
   * */
  order: []
};
/** @typedef {Object.<string, (val: any) => *>} ExtendObjType */
/** @typedef {Array<[string, (val: any) => *]>} ExtendObjTypeArray */
/**
 * Adds new type checkers to the typeValidator without overwriting existing ones.
 *
 * Accepts either an object with named functions or an array of [key, fn] arrays.
 * If no index is provided, the type is inserted just before 'object' (if it exists), or at the end.
 *
 * @param {ExtendObjType|ExtendObjTypeArray} newItems
 *        - New type validators to be added.
 * @param {number} [index] - Optional. Position at which to insert each new type. Ignored if the type already exists.
 * @returns {string[]} - A list of successfully added type names.
 *
 * @example
 * extendObjType({
 *   htmlElement2: val => typeof HTMLElement !== 'undefined' && val instanceof HTMLElement
 * });
 *
 * @example
 * extendObjType([
 *   ['alpha', val => typeof val === 'string'],
 *   ['beta', val => Array.isArray(val)]
 * ]);
 */
function extendObjType(newItems, index) {
  var added = [];
  var entries = Array.isArray(newItems) ? newItems : Object.entries(newItems);
  var _iterator = _createForOfIteratorHelper(entries),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        key = _step$value[0],
        fn = _step$value[1];
      if (!typeValidator.items.hasOwnProperty(key)) {
        // @ts-ignore
        typeValidator.items[key] = fn;
        var insertAt = typeof index === 'number' ? index : -1; // Default to -1 if index isn't provided
        // Default to before 'object', or to the end
        if (insertAt === -1) {
          var objectIndex = typeValidator.order.indexOf('object');
          insertAt = objectIndex > -1 ? objectIndex : typeValidator.order.length;
        }
        // Ensure insertAt is a valid number and not out of bounds
        insertAt = Math.min(Math.max(0, insertAt), typeValidator.order.length);
        typeValidator.order.splice(insertAt, 0, key);
        added.push(key);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return added;
}
/**
 * Reorders the typeValidator.order array according to a custom new order.
 * All values in the new order must already exist in the current order.
 * The function does not mutate the original array structure directly.
 *
 * @param {string[]} newOrder - The new order of type names.
 * @returns {boolean} - Returns true if the reorder was successful, false if invalid keys were found.
 *
 * @example
 * reorderObjTypeOrder([
 *   'string', 'number', 'array', 'object'
 * ]);
 */
function reorderObjTypeOrder(newOrder) {
  var currentOrder = _toConsumableArray(typeValidator.order); // shallow clone
  // All keys in newOrder must exist in currentOrder
  var isValid = newOrder.every(function (type) {
    return currentOrder.includes(type);
  });
  if (!isValid) return false;
  // Reassign only if valid
  typeValidator.order = newOrder.slice(); // assign shallow copy
  return true;
}
/**
 * Returns a cloned version of the `typeValidator.order` array.
 * The cloned array will not be affected by future changes to the original `order`.
 *
 * @returns {string[]} - A new array with the same values as `typeValidator.order`.
 */
function cloneObjTypeOrder() {
  return _toConsumableArray(typeValidator.order); // Creates a shallow copy of the array
}
/**
 * Returns the detected type name of a given value based on predefined type validators.
 *
 * This function uses `getType` with a predefined `typeValidator` to determine or compare types safely.
 * in the specified `typeValidator.order`. The first matching type is returned.
 *
 * If `val` is `null`, it immediately returns `'null'`.
 * If no match is found, it returns `'unknown'`.
 *
 * @param {any} val - The value whose type should be determined.
 * @returns {string} - The type name of the value (e.g., "array", "date", "map"), or "unknown" if no match is found.
 *
 * @example
 * getType([]); // "array"
 * getType(null); // "null"
 * getType(new Set()); // "set"
 * getType(() => {}); // "unknown"
 */
var getType = function getType(val) {
  if (val === null) return 'null';
  // @ts-ignore
  var _iterator2 = _createForOfIteratorHelper(typeValidator.order),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var name = _step2.value;
      // @ts-ignore
      if (typeof typeValidator.items[name] !== 'function' || typeValidator.items[name](val)) return name;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return 'unknown';
};
/**
 * Checks the type of a given object or returns its type as a string.
 *
 * @param {*} obj - The object to check or identify.
 * @param {string} [type] - Optional. If provided, checks whether the object matches this type (e.g., "object", "array", "string").
 * @returns {boolean|string|null} - Returns `true` if the type matches, `false` if not,
 *                                   the type string if no type is provided, or `null` if the object is `undefined`.
 *
 * @example
 * objType([], 'array'); // true
 * objType({}, 'object'); // true
 * objType('hello'); // "string"
 * objType(undefined); // null
 */
function objType(obj, type) {
  if (typeof obj === 'undefined') return null;
  var result = getType(obj);
  if (typeof type === 'string') return result === type.toLowerCase();
  return result;
}
/**
 * Checks the type of a given object and returns the validation value if a known type is detected.
 *
 * @param {*} obj - The object to check or identify.
 * @returns {{ valid:*; type: string | null }} - Returns the type result.
 */
function checkObj(obj) {
  /** @type {{ valid:*; type: string | null }} */
  var data = {
    valid: null,
    type: null
  };
  var _iterator3 = _createForOfIteratorHelper(typeValidator.order),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var name = _step3.value;
      // @ts-ignore
      if (typeof typeValidator.items[name] === 'function') {
        // @ts-ignore
        var result = typeValidator.items[name](obj);
        if (result) {
          data.valid = result;
          data.type = name;
          break;
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return data;
}
/**
 * Creates a clone of the functions from the `typeValidator` object.
 * It returns a new object where the keys are the same and the values are the cloned functions.
 */
function getCheckObj() {
  return Object.fromEntries(Object.entries(typeValidator.items).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[0],
      fn = _ref2[1];
    return [key, fn];
  }));
}
/**
 * Counts the number of elements in an array or the number of properties in an object.
 *
 * @param {Array<*>|Record<string|number, any>} obj - The array or object to count.
 * @returns {number} - The count of items (array elements or object keys), or `0` if the input is neither an array nor an object.
 *
 * @example
 * countObj([1, 2, 3]); // 3
 * countObj({ a: 1, b: 2 }); // 2
 * countObj('not an object'); // 0
 */
function countObj(obj) {
  // Is Array
  if (Array.isArray(obj)) return obj.length;
  // Object
  if (objType(obj, 'object')) return Object.keys(obj).length;
  // Nothing
  return 0;
}
/**
 * Determines whether a given value is a pure JSON object (plain object).
 *
 * A pure object satisfies the following:
 * - It is not null.
 * - Its type is "object".
 * - Its internal [[Class]] is "[object Object]".
 * - It is not an instance of built-in types like Array, Date, Map, Set, etc.
 *
 * This function is useful for strict data validation when you want to ensure
 * a value is a clean JSON-compatible object, free of class instances or special types.
 *
 * @param {unknown} value - The value to test.
 * @returns {value is Record<string | number | symbol, unknown>} Returns true if the value is a pure object.
 */
function isJsonObject(value) {
  if (value === null || _typeof(value) !== 'object') return false;
  if (Array.isArray(value)) return false;
  if (Object.prototype.toString.call(value) !== '[object Object]') return false;
  return true;
}
// Insert obj types
extendObjType([['undefined', /** @param {*} val @returns {val is undefined} */
function (val) {
  return typeof val === 'undefined';
}], ['null', /** @param {*} val @returns {val is null} */
function (val) {
  return val === null;
}], ['boolean', /** @param {*} val @returns {val is boolean} */
function (val) {
  return typeof val === 'boolean';
}], ['number', /** @param {*} val @returns {val is number} */
function (val) {
  return typeof val === 'number' && !Number.isNaN(val);
}], ['bigint', /** @param {*} val @returns {val is bigint} */
function (val) {
  return typeof val === 'bigint';
}], ['string', /** @param {*} val @returns {val is string} */
function (val) {
  return typeof val === 'string';
}], ['symbol', /** @param {*} val @returns {val is symbol} */
function (val) {
  return _typeof(val) === 'symbol';
}], ['function', /** @param {*} val @returns {val is Function} */
function (val) {
  return typeof val === 'function';
}], ['array', /** @param {*} val @returns {val is any[]} */
function (val) {
  return Array.isArray(val);
}]]);
if (!isBrowser) {
  extendObjType([['buffer', /** @param {*} val @returns {val is Buffer} */
  function (val) {
    return typeof _buffer.Buffer !== 'undefined' && _buffer.Buffer.isBuffer(val);
  }]]);
}
if (isBrowser) {
  extendObjType([['file', /** @param {*} val @returns {val is File} */
  function (val) {
    return typeof File !== 'undefined' && val instanceof File;
  }]]);
}
extendObjType([['date', /** @param {*} val @returns {val is Date} */
function (val) {
  return val instanceof Date;
}], ['regexp', /** @param {*} val @returns {val is RegExp} */
function (val) {
  return val instanceof RegExp;
}], ['map', /** @param {*} val @returns {val is Map<unknown, unknown>} */
function (val) {
  return val instanceof Map;
}], ['set', /** @param {*} val @returns {val is Set<unknown>} */
function (val) {
  return val instanceof Set;
}], ['weakmap', /** @param {*} val @returns {val is WeakMap<unknown, unknown>} */
function (val) {
  return val instanceof WeakMap;
}], ['weakset', /** @param {*} val @returns {val is WeakSet<unknown>} */
function (val) {
  return val instanceof WeakSet;
}], ['promise', /** @param {*} val @returns {val is Promise<unknown>} */
function (val) {
  return val instanceof Promise;
}]]);
if (isBrowser) {
  extendObjType([['htmlelement', /** @param {*} val @returns {val is HTMLElement} */
  function (val) {
    return typeof HTMLElement !== 'undefined' && val instanceof HTMLElement;
  }]]);
}
extendObjType([['object', /** @param {*} val @returns {val is Record<string | number | symbol, unknown>} */
function (val) {
  return isJsonObject(val);
}]]);

},{"buffer":62}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatBytes = formatBytes;
exports.genFibonacciSeq = genFibonacciSeq;
exports.getAge = getAge;
exports.getSimplePerc = getSimplePerc;
exports.ruleOfThree = ruleOfThree;
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * Executes a Rule of Three calculation.
 *
 * @param {number} val1 - The first reference value (numerator in direct proportion, denominator in inverse).
 * @param {number} val2 - The second reference value (denominator in direct proportion, numerator in inverse).
 * @param {number} val3 - The third value (numerator in direct proportion, denominator in inverse).
 * @param {boolean} [inverse] - Whether the calculation should use inverse proportion (true for inverse, false for direct).
 * @returns {number} The result of the Rule of Three operation.
 *
 * Rule of Three Formula (Direct Proportion):
 *      val1 / val2 = val3 / result
 *
 * For Inverse Proportion:
 *      val1 / val3 = val2 / result
 *
 * Visual Representation:
 *
 * For Direct Proportion:
 *      val1      val2
 *      -----  =  ------
 *      val3      result
 *
 * For Inverse Proportion:
 *      val1      val2
 *      -----  =  ------
 *      val3      result
 *
 * @example
 * // Direct proportion:
 * ruleOfThree.execute(2, 6, 3, false); // → 9
 *
 * @example
 * // Inverse proportion:
 * ruleOfThree.execute(2, 6, 3, true); // → 4
 */
function ruleOfThree(val1, val2, val3) {
  var inverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return inverse ? Number(val1 * val2) / val3 : Number(val3 * val2) / val1;
}
/**
 * Calculates a percentage of a given base value.
 * @param {number} price - The base value.
 * @param {number} percentage - The percentage to apply.
 * @returns {number} The result of the percentage calculation.
 *
 * @example
 * getSimplePerc(200, 15); // 30
 */
function getSimplePerc(price, percentage) {
  return price * (percentage / 100);
}
/**
 * Calculates the age based on the given date.
 *
 * @param {number|string|Date} timeData - The birth date (can be a timestamp, ISO string, or Date object).
 * @param {Date|null} [now=null] - The Date object representing the current date. Defaults to the current date and time if not provided.
 * @returns {number|null} The age in years, or null if `timeData` is not provided or invalid.
 */
function getAge() {
  var timeData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (typeof timeData !== 'undefined' && timeData !== null && timeData !== 0) {
    var birthDate = new Date(timeData);
    if (Number.isNaN(birthDate.getTime())) return null;
    var currentDate = now instanceof Date ? now : new Date();
    var age = currentDate.getFullYear() - birthDate.getFullYear();
    var currentMonth = currentDate.getMonth();
    var birthMonth = birthDate.getMonth();
    var currentDay = currentDate.getDate();
    var birthDay = birthDate.getDate();
    // Adjust if birthday hasn't occurred yet this year
    if (currentMonth < birthMonth || currentMonth === birthMonth && currentDay < birthDay) age--;
    return Math.abs(age);
  }
  return null;
}
/**
 * @typedef {Object} FormattedByteResult
 * @property {string|null} unit - The resulting unit (e.g., 'MB', 'GB') or null if input is invalid.
 * @property {number|null} value - The numerical value in the chosen unit, or null if input is invalid.
 */
/**
 * Converts a byte value into a human-readable format with unit and value separated.
 *
 * @param {number} bytes - The number of bytes to format. Must be a non-negative number.
 * @param {number|null} [decimals=null] - The number of decimal places to include in the result. Defaults to null. If negative, it will be treated as 0. If null, no rounding is applied.
 * @param {string|null} [maxUnit=null] - Optional unit limit. If provided, restricts conversion to this unit at most (e.g., 'MB' prevents conversion to 'GB' or higher). Must be one of: 'Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'.
 * @returns {FormattedByteResult} An object with the converted value and its corresponding unit. Returns nulls if input is invalid.
 *
 * @example
 * formatBytes(123456789);
 * // → { unit: 'MB', value: 117.74 }
 *
 * @example
 * formatBytes(1073741824, 2, 'MB');
 * // → { unit: 'MB', value: 1024 }
 */
function formatBytes(bytes) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var maxUnit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (typeof bytes !== 'number' || bytes < 0) return {
    unit: null,
    value: null
  };
  if (bytes === 0) return {
    unit: 'Bytes',
    value: 0
  };
  var k = 1024;
  var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  var maxIndex = maxUnit && sizes.includes(maxUnit) ? sizes.indexOf(maxUnit) : sizes.length - 1;
  var i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), maxIndex);
  var value = bytes / Math.pow(k, i);
  if (decimals !== null) {
    var dm = decimals < 0 ? 0 : decimals;
    value = parseFloat(value.toFixed(dm));
  }
  var unit = sizes[i];
  return {
    unit: unit,
    value: value
  };
}
/**
 * Generates a Fibonacci-like sequence as an array of vectors.
 *
 * @param {Object} [settings={}]
 * @param {number[]} [settings.baseValues=[0, 1]] - An array of two starting numbers (e.g. [0, 1] or [1, 1]).
 * @param {number} [settings.length=10] - Total number of items to generate in the sequence.
 * @param {(a: number, b: number, index: number) => number} [settings.combiner=((a, b) => a + b)] - A custom function to combine previous two numbers.
 * @returns {number[]} The resulting Fibonacci sequence.
 *
 * FibonacciVectors2D
 * @example
 * generateFibonacciSequence({
 *   baseValues: [[0, 1], [1, 1]],
 *   length: 10,
 *   combiner: ([x1, y1], [x2, y2]) => [x1 + x2, y1 + y2]
 * });
 *
 * @beta
 */
function genFibonacciSeq() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$baseValues = _ref.baseValues,
    baseValues = _ref$baseValues === void 0 ? [0, 1] : _ref$baseValues,
    _ref$length = _ref.length,
    length = _ref$length === void 0 ? 10 : _ref$length,
    _ref$combiner = _ref.combiner,
    combiner = _ref$combiner === void 0 ? function (a, b) {
      return a + b;
    } : _ref$combiner;
  if (!Array.isArray(baseValues) || baseValues.length !== 2) throw new Error('baseValues must be an array of exactly two numbers');
  var sequence = _toConsumableArray(baseValues.slice(0, 2));
  for (var i = 2; i < length; i++) {
    var next = combiner(sequence[i - 2], sequence[i - 1], i);
    sequence.push(next);
  }
  return sequence;
}

},{}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAiMarkerShortcut = addAiMarkerShortcut;
exports.toTitleCase = toTitleCase;
exports.toTitleCaseLowerFirst = toTitleCaseLowerFirst;
/**
 * Converts a string to title case where the first letter of each word is capitalized.
 * All other letters are converted to lowercase.
 *
 * Example: "hello world" -> "Hello World"
 *
 * @param {string} str - The string to be converted to title case.
 * @returns {string} The string converted to title case.
 */
function toTitleCase(str) {
  return str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}
/**
 * Converts a string to title case where the first letter of each word is capitalized,
 * but the first letter of the entire string is left lowercase.
 *
 * Example: "hello world" -> "hello World"
 *
 * @param {string} str - The string to be converted to title case with the first letter in lowercase.
 * @returns {string} The string converted to title case with the first letter in lowercase.
 */
function toTitleCaseLowerFirst(str) {
  var titleCased = str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
  return titleCased.charAt(0).toLowerCase() + titleCased.slice(1);
}
/**
 * Enables a keyboard shortcut to toggle a CSS class on the document body.
 *
 * This function listens for a specific key combination: `Ctrl + Alt + [key]`.
 * When triggered, it prevents the default behavior and toggles the
 * `detect-made-by-ai` class on the `<body>`, which can be used to apply visual
 * indicators or filters on AI-generated content.
 *
 * If executed outside of a browser environment (e.g., in Node.js), the function logs an error and exits.
 * If the `<body>` is not available at the moment the shortcut is triggered, a warning is logged.
 *
 * @param {string} [key='a'] - The lowercase character key to be used in combination with Ctrl and Alt.
 */
function addAiMarkerShortcut() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'a';
  if (typeof HTMLElement === 'undefined') {
    console.error('[AiMarkerShortcut] Environment does not support the DOM. This function must be run in a browser.');
    return;
  }
  document.addEventListener('keydown', function (event) {
    if (event.ctrlKey && event.altKey && event.key.toLowerCase() === key) {
      event.preventDefault(); // Prevent any default behavior
      if (!document.body) {
        console.warn('[AiMarkerShortcut] <body> element not found. Cannot toggle class. Ensure the DOM is fully loaded when using the shortcut.');
        return;
      }
      document.body.classList.toggle('detect-made-by-ai');
    }
  });
}
/*
import { useEffect } from "react";

function KeyPressHandler() {
    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.ctrlKey && event.altKey && event.key.toLowerCase() === "a") {
                event.preventDefault();
                document.body.classList.toggle("detect-made-by-ai");
            }
        };
        
        document.addEventListener("keydown", handleKeyDown);
        return () => {
            document.removeEventListener("keydown", handleKeyDown);
        };
    }, []);

    return null;
}

export default KeyPressHandler;
*/

},{}],122:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backupFileAsync = backupFileAsync;
exports.clearDirectoryAsync = clearDirectoryAsync;
exports.dirSizeAsync = dirSizeAsync;
exports.ensureCopyFileAsync = ensureCopyFileAsync;
exports.fileSizeAsync = fileSizeAsync;
exports.isDirEmptyAsync = isDirEmptyAsync;
exports.listDirsAsync = listDirsAsync;
exports.listFilesAsync = listFilesAsync;
exports.readJsonFileAsync = readJsonFileAsync;
exports.restoreLatestBackupAsync = restoreLatestBackupAsync;
exports.tryDeleteFileAsync = tryDeleteFileAsync;
exports.writeJsonFileAsync = writeJsonFileAsync;
exports.writeTextFileAsync = writeTextFileAsync;
var _fs = require("fs");
var _promises = require("fs/promises");
var _path = require("path");
var _normalFuncs = require("./normalFuncs.mjs");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/*========================*
 * JSON Operations
 *========================*/
/**
 * Reads and parses a JSON file.
 * Throws an error if the file content is not valid JSON.
 * @param {string} filePath
 * @returns {Promise<any>}
 */
function readJsonFileAsync(_x) {
  return _readJsonFileAsync.apply(this, arguments);
}
/**
 * Saves an object as JSON to a file.
 * Automatically creates the directory if it does not exist.
 * @param {string} filePath
 * @param {any} data
 * @param {number} [spaces=2]
 * @returns {Promise<void>}
 */
function _readJsonFileAsync() {
  _readJsonFileAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(filePath) {
    var content;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          if ((0, _fs.existsSync)(filePath)) {
            _context.n = 1;
            break;
          }
          throw new Error("File not found: ".concat(filePath));
        case 1:
          _context.n = 2;
          return (0, _promises.readFile)(filePath, 'utf-8');
        case 2:
          content = _context.v;
          return _context.a(2, JSON.parse(content));
      }
    }, _callee);
  }));
  return _readJsonFileAsync.apply(this, arguments);
}
function writeJsonFileAsync(filePath, data) {
  var spaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var json = JSON.stringify(data, null, spaces);
  return (0, _promises.writeFile)(filePath, json, 'utf-8');
}
/*========================*
 * Directory Management
 *========================*/
/**
 * Clears all contents inside a directory but keeps the directory.
 * @param {string} dirPath
 */
function clearDirectoryAsync(_x2) {
  return _clearDirectoryAsync.apply(this, arguments);
}
/*========================*
 * File Checks
 *========================*/
/**
 * Checks whether a directory is empty.
 * @param {string} dirPath
 * @returns {Promise<boolean>}
 */
function _clearDirectoryAsync() {
  _clearDirectoryAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(dirPath) {
    var files, dataList, promises, _iterator, _step, _loop, promises2, fullPath, statData, _t;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          if ((0, _fs.existsSync)(dirPath)) {
            _context3.n = 1;
            break;
          }
          return _context3.a(2);
        case 1:
          _context3.n = 2;
          return (0, _promises.readdir)(dirPath);
        case 2:
          files = _context3.v;
          /** @type {Record<string, import('fs').Stats>} */
          dataList = {};
          promises = [];
          _iterator = _createForOfIteratorHelper(files);
          _context3.p = 3;
          _loop = /*#__PURE__*/_regenerator().m(function _loop() {
            var file, fullPath, lsResult;
            return _regenerator().w(function (_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  file = _step.value;
                  fullPath = (0, _path.join)(dirPath, file);
                  lsResult = (0, _promises.lstat)(fullPath);
                  lsResult.then(function (statData) {
                    dataList[fullPath] = statData;
                    return statData;
                  });
                  promises.push(lsResult);
                case 1:
                  return _context2.a(2);
              }
            }, _loop);
          });
          _iterator.s();
        case 4:
          if ((_step = _iterator.n()).done) {
            _context3.n = 6;
            break;
          }
          return _context3.d(_regeneratorValues(_loop()), 5);
        case 5:
          _context3.n = 4;
          break;
        case 6:
          _context3.n = 8;
          break;
        case 7:
          _context3.p = 7;
          _t = _context3.v;
          _iterator.e(_t);
        case 8:
          _context3.p = 8;
          _iterator.f();
          return _context3.f(8);
        case 9:
          _context3.n = 10;
          return Promise.all(promises);
        case 10:
          promises2 = [];
          for (fullPath in dataList) {
            statData = dataList[fullPath];
            if (statData.isDirectory()) {
              promises2.push((0, _promises.rm)(fullPath, {
                recursive: true,
                force: true
              }));
            } else {
              promises2.push((0, _promises.unlink)(fullPath));
            }
          }
          _context3.n = 11;
          return Promise.all(promises2);
        case 11:
          return _context3.a(2);
      }
    }, _callee2, null, [[3, 7, 8, 9]]);
  }));
  return _clearDirectoryAsync.apply(this, arguments);
}
function isDirEmptyAsync(_x3) {
  return _isDirEmptyAsync.apply(this, arguments);
}
/*========================*
 * File Operations
 *========================*/
/**
 * Copies a file to a destination.
 * @param {string} src
 * @param {string} dest
 * @param {number} [mode]
 * @returns {Promise<void>}
 */
function _isDirEmptyAsync() {
  _isDirEmptyAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(dirPath) {
    var data;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          _context4.n = 1;
          return (0, _promises.readdir)(dirPath);
        case 1:
          data = _context4.v;
          return _context4.a(2, data.length === 0);
      }
    }, _callee3);
  }));
  return _isDirEmptyAsync.apply(this, arguments);
}
function ensureCopyFileAsync(src, dest, mode) {
  (0, _normalFuncs.ensureDirectory)((0, _path.dirname)(dest));
  return (0, _promises.copyFile)(src, dest, mode);
}
/**
 * Deletes a file (If the file exists).
 * @param {string} filePath
 * @returns {Promise<boolean>}
 */
function tryDeleteFileAsync(_x4) {
  return _tryDeleteFileAsync.apply(this, arguments);
}
/*========================*
 * Text Operations
 *========================*/
/**
 * Writes text to a file (Ensures that the directory exists, creating it recursively if needed).
 * @param {string} filePath
 * @param {string} content
 * @param {import('fs').WriteFileOptions} [ops='utf-8']
 * @returns {Promise<void>}
 */
function _tryDeleteFileAsync() {
  _tryDeleteFileAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(filePath) {
    return _regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          if (!(0, _normalFuncs.fileExists)(filePath)) {
            _context5.n = 2;
            break;
          }
          _context5.n = 1;
          return (0, _promises.unlink)(filePath);
        case 1:
          return _context5.a(2, true);
        case 2:
          return _context5.a(2, false);
      }
    }, _callee4);
  }));
  return _tryDeleteFileAsync.apply(this, arguments);
}
function writeTextFileAsync(filePath, content) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf-8';
  var dir = (0, _path.dirname)(filePath);
  (0, _normalFuncs.ensureDirectory)(dir);
  return (0, _promises.writeFile)(filePath, content, ops);
}
/*========================*
 * Directory Listings
 *========================*/
/**
 * Lists all files and dirs in a directory (optionally recursive).
 * @param {string} dirPath
 * @param {boolean} [recursive=false]
 * @returns {Promise<{ files: string[]; dirs: string[] }>}
 */
function listFilesAsync(_x5) {
  return _listFilesAsync.apply(this, arguments);
}
/**
 * Lists all directories in a directory (optionally recursive).
 * @param {string} dirPath
 * @param {boolean} [recursive=false]
 * @returns {Promise<string[]>}
 */
function _listFilesAsync() {
  _listFilesAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(dirPath) {
    var recursive,
      results,
      entries,
      _iterator2,
      _step2,
      entry,
      fullPath,
      statData,
      _results$files,
      _results$dirs,
      results2,
      _args6 = arguments,
      _t2;
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          recursive = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : false;
          /** @type {{ files: string[]; dirs: string[] }} */
          results = {
            files: [],
            dirs: []
          };
          if ((0, _normalFuncs.dirExists)(dirPath)) {
            _context6.n = 1;
            break;
          }
          return _context6.a(2, results);
        case 1:
          _context6.n = 2;
          return (0, _promises.readdir)(dirPath);
        case 2:
          entries = _context6.v;
          _iterator2 = _createForOfIteratorHelper(entries);
          _context6.p = 3;
          _iterator2.s();
        case 4:
          if ((_step2 = _iterator2.n()).done) {
            _context6.n = 10;
            break;
          }
          entry = _step2.value;
          fullPath = (0, _path.join)(dirPath, entry);
          _context6.n = 5;
          return (0, _promises.lstat)(fullPath);
        case 5:
          statData = _context6.v;
          if (!statData.isDirectory()) {
            _context6.n = 8;
            break;
          }
          results.dirs.push(fullPath);
          if (!recursive) {
            _context6.n = 7;
            break;
          }
          _context6.n = 6;
          return listFilesAsync(fullPath, true);
        case 6:
          results2 = _context6.v;
          (_results$files = results.files).push.apply(_results$files, _toConsumableArray(results2.files));
          (_results$dirs = results.dirs).push.apply(_results$dirs, _toConsumableArray(results2.dirs));
        case 7:
          _context6.n = 9;
          break;
        case 8:
          results.files.push(fullPath);
        case 9:
          _context6.n = 4;
          break;
        case 10:
          _context6.n = 12;
          break;
        case 11:
          _context6.p = 11;
          _t2 = _context6.v;
          _iterator2.e(_t2);
        case 12:
          _context6.p = 12;
          _iterator2.f();
          return _context6.f(12);
        case 13:
          return _context6.a(2, results);
      }
    }, _callee5, null, [[3, 11, 12, 13]]);
  }));
  return _listFilesAsync.apply(this, arguments);
}
function listDirsAsync(_x6) {
  return _listDirsAsync.apply(this, arguments);
}
/*========================*
 * File Info
 *========================*/
/**
 * Returns the size of a file in bytes.
 * @param {string} filePath
 * @returns {Promise<number>}
 */
function _listDirsAsync() {
  _listDirsAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(dirPath) {
    var recursive,
      results,
      entries,
      _iterator3,
      _step3,
      entry,
      fullPath,
      statData,
      _args7 = arguments,
      _t3,
      _t4,
      _t5,
      _t6,
      _t7,
      _t8;
    return _regenerator().w(function (_context7) {
      while (1) switch (_context7.n) {
        case 0:
          recursive = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : false;
          /** @type {string[]} */
          results = [];
          if ((0, _normalFuncs.dirExists)(dirPath)) {
            _context7.n = 1;
            break;
          }
          return _context7.a(2, results);
        case 1:
          _context7.n = 2;
          return (0, _promises.readdir)(dirPath);
        case 2:
          entries = _context7.v;
          _iterator3 = _createForOfIteratorHelper(entries);
          _context7.p = 3;
          _iterator3.s();
        case 4:
          if ((_step3 = _iterator3.n()).done) {
            _context7.n = 8;
            break;
          }
          entry = _step3.value;
          fullPath = (0, _path.join)(dirPath, entry);
          _context7.n = 5;
          return (0, _promises.lstat)(fullPath);
        case 5:
          statData = _context7.v;
          if (!statData.isDirectory()) {
            _context7.n = 7;
            break;
          }
          results.push(fullPath);
          if (!recursive) {
            _context7.n = 7;
            break;
          }
          _t3 = results.push;
          _t4 = results;
          _t5 = _toConsumableArray;
          _context7.n = 6;
          return listDirsAsync(fullPath, true);
        case 6:
          _t6 = _context7.v;
          _t7 = _t5(_t6);
          _t3.apply.call(_t3, _t4, _t7);
        case 7:
          _context7.n = 4;
          break;
        case 8:
          _context7.n = 10;
          break;
        case 9:
          _context7.p = 9;
          _t8 = _context7.v;
          _iterator3.e(_t8);
        case 10:
          _context7.p = 10;
          _iterator3.f();
          return _context7.f(10);
        case 11:
          return _context7.a(2, results);
      }
    }, _callee6, null, [[3, 9, 10, 11]]);
  }));
  return _listDirsAsync.apply(this, arguments);
}
function fileSizeAsync(_x7) {
  return _fileSizeAsync.apply(this, arguments);
}
/**
 * Returns the total size of a directory in bytes.
 * @param {string} dirPath
 * @returns {Promise<number>}
 */
function _fileSizeAsync() {
  _fileSizeAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(filePath) {
    var stats;
    return _regenerator().w(function (_context8) {
      while (1) switch (_context8.n) {
        case 0:
          if ((0, _normalFuncs.fileExists)(filePath)) {
            _context8.n = 1;
            break;
          }
          return _context8.a(2, 0);
        case 1:
          _context8.n = 2;
          return (0, _promises.stat)(filePath);
        case 2:
          stats = _context8.v;
          return _context8.a(2, stats.size);
      }
    }, _callee7);
  }));
  return _fileSizeAsync.apply(this, arguments);
}
function dirSizeAsync(_x8) {
  return _dirSizeAsync.apply(this, arguments);
}
/*========================*
 * Backup Utilities
 *========================*/
/**
 * Restores the most recent backup of a file.
 * @param {string} filePath
 * @param {string} [ext='bak']
 * @returns {Promise<void>}
 */
function _dirSizeAsync() {
  _dirSizeAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(dirPath) {
    var total, _yield$listFilesAsync, files, promises, _iterator4, _step4, file, result;
    return _regenerator().w(function (_context9) {
      while (1) switch (_context9.n) {
        case 0:
          total = 0;
          _context9.n = 1;
          return listFilesAsync(dirPath, true);
        case 1:
          _yield$listFilesAsync = _context9.v;
          files = _yield$listFilesAsync.files;
          promises = [];
          _iterator4 = _createForOfIteratorHelper(files);
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              file = _step4.value;
              result = fileSizeAsync(file);
              result.then(function (item) {
                total += item;
                return item;
              });
              promises.push(result);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          _context9.n = 2;
          return Promise.all(promises);
        case 2:
          return _context9.a(2, total);
      }
    }, _callee8);
  }));
  return _dirSizeAsync.apply(this, arguments);
}
function restoreLatestBackupAsync(filePath) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bak';
  var latestBackup = (0, _normalFuncs.getLatestBackupPath)(filePath, ext);
  return ensureCopyFileAsync(latestBackup, filePath);
}
/**
 * Creates a backup copy of a file with .bak timestamp suffix.
 * @param {string} filePath
 * @param {string} [ext='bak']
 * @returns {Promise<void>}
 */
function backupFileAsync(_x9) {
  return _backupFileAsync.apply(this, arguments);
}
function _backupFileAsync() {
  _backupFileAsync = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(filePath) {
    var ext,
      timestamp,
      backupPath,
      _args0 = arguments;
    return _regenerator().w(function (_context0) {
      while (1) switch (_context0.n) {
        case 0:
          ext = _args0.length > 1 && _args0[1] !== undefined ? _args0[1] : 'bak';
          if ((0, _normalFuncs.fileExists)(filePath)) {
            _context0.n = 1;
            break;
          }
          return _context0.a(2);
        case 1:
          timestamp = new Date().toISOString().replace(/[:.]/g, '-');
          backupPath = "".concat(filePath, ".").concat(ext, ".").concat(timestamp);
          return _context0.a(2, ensureCopyFileAsync(filePath, backupPath));
      }
    }, _callee9);
  }));
  return _backupFileAsync.apply(this, arguments);
}

},{"./normalFuncs.mjs":123,"fs":61,"fs/promises":61,"path":94}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backupFile = backupFile;
exports.clearDirectory = clearDirectory;
exports.dirExists = dirExists;
exports.dirSize = dirSize;
exports.ensureCopyFile = ensureCopyFile;
exports.ensureDirectory = ensureDirectory;
exports.fileExists = fileExists;
exports.fileSize = fileSize;
exports.getLatestBackupPath = getLatestBackupPath;
exports.isDirEmpty = isDirEmpty;
exports.listDirs = listDirs;
exports.listFiles = listFiles;
exports.readJsonFile = readJsonFile;
exports.renameFileAddPrefixSuffix = renameFileAddPrefixSuffix;
exports.renameFileBatch = renameFileBatch;
exports.renameFileNormalizeCase = renameFileNormalizeCase;
exports.renameFilePadNumbers = renameFilePadNumbers;
exports.renameFileRegex = renameFileRegex;
exports.restoreLatestBackup = restoreLatestBackup;
exports.tryDeleteFile = tryDeleteFile;
exports.writeJsonFile = writeJsonFile;
exports.writeTextFile = writeTextFile;
var _fs = require("fs");
var _path = require("path");
var _text = require("../basics/text.mjs");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/*========================*
 * JSON Operations
 *========================*/
/**
 * Reads and parses a JSON file.
 * Throws an error if the file content is not valid JSON.
 * @param {string} filePath
 * @returns {any}
 */
function readJsonFile(filePath) {
  if (!(0, _fs.existsSync)(filePath)) throw new Error("File not found: ".concat(filePath));
  var content = (0, _fs.readFileSync)(filePath, 'utf-8');
  return JSON.parse(content);
}
/**
 * Saves an object as JSON to a file.
 * Automatically creates the directory if it does not exist.
 * @param {string} filePath
 * @param {any} data
 * @param {number} [spaces=2]
 */
function writeJsonFile(filePath, data) {
  var spaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var json = JSON.stringify(data, null, spaces);
  (0, _fs.writeFileSync)(filePath, json, 'utf-8');
}
/*========================*
 * Directory Management
 *========================*/
/**
 * Ensures that the directory exists, creating it recursively if needed.
 * @param {string} dirPath
 */
function ensureDirectory(dirPath) {
  if (!(0, _fs.existsSync)(dirPath)) {
    (0, _fs.mkdirSync)(dirPath, {
      recursive: true
    });
  }
}
/**
 * Clears all contents inside a directory but keeps the directory.
 * @param {string} dirPath
 */
function clearDirectory(dirPath) {
  if (!(0, _fs.existsSync)(dirPath)) return;
  var files = (0, _fs.readdirSync)(dirPath);
  var _iterator = _createForOfIteratorHelper(files),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var file = _step.value;
      var fullPath = (0, _path.join)(dirPath, file);
      var statData = (0, _fs.lstatSync)(fullPath);
      if (statData.isDirectory()) {
        (0, _fs.rmSync)(fullPath, {
          recursive: true,
          force: true
        });
      } else {
        (0, _fs.unlinkSync)(fullPath);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
/*========================*
 * File Checks
 *========================*/
/**
 * Checks whether a file exists.
 * @param {string} filePath
 * @returns {boolean}
 */
function fileExists(filePath) {
  return (0, _fs.existsSync)(filePath) && (0, _fs.lstatSync)(filePath).isFile();
}
/**
 * Checks whether a directory exists.
 * @param {string} dirPath
 * @returns {boolean}
 */
function dirExists(dirPath) {
  return (0, _fs.existsSync)(dirPath) && (0, _fs.lstatSync)(dirPath).isDirectory();
}
/**
 * Checks whether a directory is empty.
 * @param {string} dirPath
 * @returns {boolean}
 */
function isDirEmpty(dirPath) {
  return (0, _fs.readdirSync)(dirPath).length === 0;
}
/*========================*
 * File Operations
 *========================*/
/**
 * Copies a file to a destination.
 * @param {string} src
 * @param {string} dest
 * @param {number} [mode]
 */
function ensureCopyFile(src, dest, mode) {
  ensureDirectory((0, _path.dirname)(dest));
  (0, _fs.copyFileSync)(src, dest, mode);
}
/**
 * Deletes a file (If the file exists).
 * @param {string} filePath
 * @returns {boolean}
 */
function tryDeleteFile(filePath) {
  if (fileExists(filePath)) {
    (0, _fs.unlinkSync)(filePath);
    return true;
  }
  return false;
}
/*========================*
 * Text Operations
 *========================*/
/**
 * Writes text to a file (Ensures that the directory exists, creating it recursively if needed).
 * @param {string} filePath
 * @param {string} content
 * @param {import('fs').WriteFileOptions} [ops='utf-8']
 */
function writeTextFile(filePath, content) {
  var ops = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf-8';
  var dir = (0, _path.dirname)(filePath);
  ensureDirectory(dir);
  (0, _fs.writeFileSync)(filePath, content, ops);
}
/*========================*
 * Directory Listings
 *========================*/
/**
 * Lists all files and dirs in a directory (optionally recursive).
 * @param {string} dirPath
 * @param {boolean} [recursive=false]
 * @returns {{ files: string[]; dirs: string[] }}
 */
function listFiles(dirPath) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  /** @type {{ files: string[]; dirs: string[] }} */
  var results = {
    files: [],
    dirs: []
  };
  if (!dirExists(dirPath)) return results;
  var entries = (0, _fs.readdirSync)(dirPath);
  var _iterator2 = _createForOfIteratorHelper(entries),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var entry = _step2.value;
      var fullPath = (0, _path.join)(dirPath, entry);
      var statData = (0, _fs.lstatSync)(fullPath);
      if (statData.isDirectory()) {
        results.dirs.push(fullPath);
        if (recursive) {
          var _results$files, _results$dirs;
          var results2 = listFiles(fullPath, true);
          (_results$files = results.files).push.apply(_results$files, _toConsumableArray(results2.files));
          (_results$dirs = results.dirs).push.apply(_results$dirs, _toConsumableArray(results2.dirs));
        }
      } else {
        results.files.push(fullPath);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return results;
}
/**
 * Lists all directories in a directory (optionally recursive).
 * @param {string} dirPath
 * @param {boolean} [recursive=false]
 * @returns {string[]}
 */
function listDirs(dirPath) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  /** @type {string[]} */
  var results = [];
  if (!dirExists(dirPath)) return results;
  var entries = (0, _fs.readdirSync)(dirPath);
  var _iterator3 = _createForOfIteratorHelper(entries),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var entry = _step3.value;
      var fullPath = (0, _path.join)(dirPath, entry);
      var statData = (0, _fs.lstatSync)(fullPath);
      if (statData.isDirectory()) {
        results.push(fullPath);
        if (recursive) {
          results.push.apply(results, _toConsumableArray(listDirs(fullPath, true)));
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return results;
}
/*========================*
 * File Info
 *========================*/
/**
 * Returns the size of a file in bytes.
 * @param {string} filePath
 * @returns {number}
 */
function fileSize(filePath) {
  if (!fileExists(filePath)) return 0;
  var stats = (0, _fs.statSync)(filePath);
  return stats.size;
}
/**
 * Returns the total size of a directory in bytes.
 * @param {string} dirPath
 * @returns {number}
 */
function dirSize(dirPath) {
  var total = 0;
  var files = listFiles(dirPath, true).files;
  var _iterator4 = _createForOfIteratorHelper(files),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var file = _step4.value;
      total += fileSize(file);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return total;
}
/*========================*
 * Backup Utilities
 *========================*/
/**
 * Creates a backup copy of a file with .bak timestamp suffix.
 * @param {string} filePath
 * @param {string} [ext='bak']
 */
function backupFile(filePath) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bak';
  if (!fileExists(filePath)) return;
  var timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  var backupPath = "".concat(filePath, ".").concat(ext, ".").concat(timestamp);
  ensureCopyFile(filePath, backupPath);
}
/**
 * Returns the most recent backup file path for a given file.
 * @param {string} filePath
 * @param {string} [ext='bak']
 * @returns {string} Full path to the most recent backup
 */
function getLatestBackupPath(filePath) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bak';
  var dir = (0, _path.dirname)(filePath);
  var baseName = (0, _path.basename)(filePath);
  var backups = (0, _fs.readdirSync)(dir).filter(function (name) {
    return name.startsWith("".concat(baseName, ".").concat(ext, "."));
  }).sort().reverse();
  if (backups.length === 0) throw new Error("No backups found for ".concat(filePath));
  return (0, _path.join)(dir, backups[0]);
}
/**
 * Restores the most recent backup of a file.
 * @param {string} filePath
 * @param {string} [ext='bak']
 */
function restoreLatestBackup(filePath) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bak';
  var latestBackup = getLatestBackupPath(filePath, ext);
  ensureCopyFile(latestBackup, filePath);
}
/*========================*
 * Rename Utilities
 *========================*/
/**
 * Renames multiple files in a directory using a rename function.
 * @param {string} dirPath - The target directory.
 * @param {(original: string, index: number) => string} renameFn - Function that returns new filename.
 * @param {string[]} [extensions] - Optional: Only rename files with these extensions.
 *
 * @throws {TypeError} If any argument has an invalid type.
 * @throws {Error} If the directory does not exist or contains invalid files.
 */
function renameFileBatch(dirPath, renameFn) {
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  // Validate types
  if (typeof dirPath !== 'string') throw new TypeError('dirPath must be a string');
  if (typeof renameFn !== 'function') throw new TypeError('renameFn must be a function');
  if (!Array.isArray(extensions)) throw new TypeError('extensions must be an array of strings');
  if (!(0, _fs.existsSync)(dirPath) || !(0, _fs.statSync)(dirPath).isDirectory()) throw new Error("Directory not found or invalid: ".concat(dirPath));
  var _iterator5 = _createForOfIteratorHelper(extensions),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var ext = _step5.value;
      if (typeof ext !== 'string' || !ext.startsWith('.')) throw new TypeError("Invalid extension: ".concat(ext));
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  var files = listFiles(dirPath).files;
  var index = 0;
  var _iterator6 = _createForOfIteratorHelper(files),
    _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var file = _step6.value;
      var _ext = (0, _path.extname)(file);
      if (extensions.length && !extensions.includes(_ext)) continue;
      var originalName = (0, _path.basename)(file);
      var newName = renameFn(originalName, index++);
      var newPath = (0, _path.join)(dirPath, newName);
      if (originalName === newName) continue;
      (0, _fs.renameSync)(file, newPath);
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
}
/**
 * Renames files using regex replacement.
 * @param {string} dirPath
 * @param {RegExp} pattern - Regex to match in the filename.
 * @param {string} replacement - Replacement string.
 * @param {string[]} [extensions]
 */
function renameFileRegex(dirPath, pattern, replacement) {
  var extensions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  renameFileBatch(dirPath, function (filename) {
    var ext = (0, _path.extname)(filename);
    var name = (0, _path.basename)(filename, ext).replace(pattern, replacement);
    return "".concat(name).concat(ext);
  }, extensions);
}
/**
 * Adds a prefix or suffix to filenames.
 * @param {string} dirPath
 * @param {{ prefix?: string, suffix?: string }} options
 * @param {string[]} [extensions]
 */
function renameFileAddPrefixSuffix(dirPath, _ref) {
  var _ref$prefix = _ref.prefix,
    prefix = _ref$prefix === void 0 ? '' : _ref$prefix,
    _ref$suffix = _ref.suffix,
    suffix = _ref$suffix === void 0 ? '' : _ref$suffix;
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  renameFileBatch(dirPath, function (filename) {
    var ext = (0, _path.extname)(filename);
    var name = (0, _path.basename)(filename, ext);
    return "".concat(prefix).concat(name).concat(suffix).concat(ext);
  }, extensions);
}
/**
 * Normalizes all filenames to lowercase (or uppercase).
 * @param {string} dirPath
 * @param {'lower' | 'upper' | 'title'} mode
 * @param {string[]} [extensions]
 * @param {boolean} [normalizeExt=false] - Whether to apply case change to file extensions too.
 * @throws {Error} If mode is invalid.
 */
function renameFileNormalizeCase(dirPath) {
  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'lower';
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var normalizeExt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (typeof mode !== 'string' || !['lower', 'upper', 'title'].includes(mode)) throw new Error("Invalid mode \"".concat(mode, "\". Must be 'lower', 'upper' or 'title'."));
  renameFileBatch(dirPath, function (filename) {
    /**
     * @param {string} text
     * @returns {string}
     */
    var changeToMode = function changeToMode(text) {
      if (mode === 'lower') return text.toLowerCase();else if (mode === 'upper') return text.toUpperCase();else if (mode === 'title') return (0, _text.toTitleCase)(text);else return text;
    };
    var rawExt = (0, _path.extname)(filename);
    var ext = normalizeExt ? changeToMode(rawExt) : rawExt;
    var name = changeToMode((0, _path.basename)(filename, rawExt));
    return "".concat(name).concat(ext);
  }, extensions);
}
/**
 * Pads numbers in filenames (e.g., "img1.jpg" -> "img001.jpg").
 * @param {string} dirPath
 * @param {number} totalDigits
 * @param {string[]} [extensions]
 */
function renameFilePadNumbers(dirPath) {
  var totalDigits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  renameFileBatch(dirPath, function (filename) {
    return filename.replace(/\d+/, function (match) {
      return match.padStart(totalDigits, '0');
    });
  }, extensions);
}

},{"../basics/text.mjs":121,"fs":61,"path":94}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ColorSafeStringify", {
  enumerable: true,
  get: function get() {
    return _ColorSafeStringify["default"];
  }
});
Object.defineProperty(exports, "TinyDomReadyManager", {
  enumerable: true,
  get: function get() {
    return _TinyDomReadyManager["default"];
  }
});
Object.defineProperty(exports, "TinyDragDropDetector", {
  enumerable: true,
  get: function get() {
    return _TinyDragDropDetector["default"];
  }
});
Object.defineProperty(exports, "TinyDragger", {
  enumerable: true,
  get: function get() {
    return _TinyDragger["default"];
  }
});
Object.defineProperty(exports, "TinyLevelUp", {
  enumerable: true,
  get: function get() {
    return _userLevel["default"];
  }
});
Object.defineProperty(exports, "TinyNotifyCenter", {
  enumerable: true,
  get: function get() {
    return _TinyNotifyCenter["default"];
  }
});
Object.defineProperty(exports, "TinyPromiseQueue", {
  enumerable: true,
  get: function get() {
    return _TinyPromiseQueue["default"];
  }
});
Object.defineProperty(exports, "TinyRateLimiter", {
  enumerable: true,
  get: function get() {
    return _TinyRateLimiter["default"];
  }
});
Object.defineProperty(exports, "TinyToastNotify", {
  enumerable: true,
  get: function get() {
    return _TinyToastNotify["default"];
  }
});
Object.defineProperty(exports, "addAiMarkerShortcut", {
  enumerable: true,
  get: function get() {
    return _text.addAiMarkerShortcut;
  }
});
Object.defineProperty(exports, "areHtmlElsColliding", {
  enumerable: true,
  get: function get() {
    return _html.areHtmlElsColliding;
  }
});
Object.defineProperty(exports, "arraySortPositions", {
  enumerable: true,
  get: function get() {
    return _arraySortPositions["default"];
  }
});
Object.defineProperty(exports, "asyncReplace", {
  enumerable: true,
  get: function get() {
    return _replaceAsync["default"];
  }
});
Object.defineProperty(exports, "backupFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.backupFile;
  }
});
Object.defineProperty(exports, "checkObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.checkObj;
  }
});
Object.defineProperty(exports, "clearDirectory", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.clearDirectory;
  }
});
Object.defineProperty(exports, "clearDirectoryAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.clearDirectoryAsync;
  }
});
Object.defineProperty(exports, "cloneObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.cloneObjTypeOrder;
  }
});
Object.defineProperty(exports, "countObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.countObj;
  }
});
Object.defineProperty(exports, "dirExists", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.dirExists;
  }
});
Object.defineProperty(exports, "dirSize", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.dirSize;
  }
});
Object.defineProperty(exports, "dirSizeAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.dirSizeAsync;
  }
});
Object.defineProperty(exports, "documentIsFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.documentIsFullScreen;
  }
});
Object.defineProperty(exports, "ensureCopyFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.ensureCopyFile;
  }
});
Object.defineProperty(exports, "ensureDirectory", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.ensureDirectory;
  }
});
Object.defineProperty(exports, "exitFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.exitFullScreen;
  }
});
Object.defineProperty(exports, "extendObjType", {
  enumerable: true,
  get: function get() {
    return _objFilter.extendObjType;
  }
});
Object.defineProperty(exports, "fetchJson", {
  enumerable: true,
  get: function get() {
    return _html.fetchJson;
  }
});
Object.defineProperty(exports, "fileExists", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.fileExists;
  }
});
Object.defineProperty(exports, "fileSize", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.fileSize;
  }
});
Object.defineProperty(exports, "fileSizeAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.fileSizeAsync;
  }
});
Object.defineProperty(exports, "formatBytes", {
  enumerable: true,
  get: function get() {
    return _simpleMath.formatBytes;
  }
});
Object.defineProperty(exports, "formatCustomTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatCustomTimer;
  }
});
Object.defineProperty(exports, "formatDayTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatDayTimer;
  }
});
Object.defineProperty(exports, "formatTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatTimer;
  }
});
Object.defineProperty(exports, "genFibonacciSeq", {
  enumerable: true,
  get: function get() {
    return _simpleMath.genFibonacciSeq;
  }
});
Object.defineProperty(exports, "getAge", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getAge;
  }
});
Object.defineProperty(exports, "getHtmlElBorders", {
  enumerable: true,
  get: function get() {
    return _html.getHtmlElBorders;
  }
});
Object.defineProperty(exports, "getHtmlElBordersWidth", {
  enumerable: true,
  get: function get() {
    return _html.getHtmlElBordersWidth;
  }
});
Object.defineProperty(exports, "getHtmlElMargin", {
  enumerable: true,
  get: function get() {
    return _html.getHtmlElMargin;
  }
});
Object.defineProperty(exports, "getHtmlElPadding", {
  enumerable: true,
  get: function get() {
    return _html.getHtmlElPadding;
  }
});
Object.defineProperty(exports, "getLatestBackupPath", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.getLatestBackupPath;
  }
});
Object.defineProperty(exports, "getSimplePerc", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getSimplePerc;
  }
});
Object.defineProperty(exports, "getTimeDuration", {
  enumerable: true,
  get: function get() {
    return _clock.getTimeDuration;
  }
});
Object.defineProperty(exports, "isDirEmpty", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.isDirEmpty;
  }
});
Object.defineProperty(exports, "isDirEmptyAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.isDirEmptyAsync;
  }
});
Object.defineProperty(exports, "isFullScreenMode", {
  enumerable: true,
  get: function get() {
    return _fullScreen.isFullScreenMode;
  }
});
Object.defineProperty(exports, "isJsonObject", {
  enumerable: true,
  get: function get() {
    return _objFilter.isJsonObject;
  }
});
Object.defineProperty(exports, "isScreenFilled", {
  enumerable: true,
  get: function get() {
    return _fullScreen.isScreenFilled;
  }
});
Object.defineProperty(exports, "listDirs", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.listDirs;
  }
});
Object.defineProperty(exports, "listDirsAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.listDirsAsync;
  }
});
Object.defineProperty(exports, "listFiles", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.listFiles;
  }
});
Object.defineProperty(exports, "listFilesAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.listFilesAsync;
  }
});
Object.defineProperty(exports, "objType", {
  enumerable: true,
  get: function get() {
    return _objFilter.objType;
  }
});
Object.defineProperty(exports, "offFullScreenChange", {
  enumerable: true,
  get: function get() {
    return _fullScreen.offFullScreenChange;
  }
});
Object.defineProperty(exports, "onFullScreenChange", {
  enumerable: true,
  get: function get() {
    return _fullScreen.onFullScreenChange;
  }
});
Object.defineProperty(exports, "readJsonBlob", {
  enumerable: true,
  get: function get() {
    return _html.readJsonBlob;
  }
});
Object.defineProperty(exports, "readJsonFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.readJsonFile;
  }
});
Object.defineProperty(exports, "renameFileAddPrefixSuffix", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileAddPrefixSuffix;
  }
});
Object.defineProperty(exports, "renameFileBatch", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileBatch;
  }
});
Object.defineProperty(exports, "renameFileNormalizeCase", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileNormalizeCase;
  }
});
Object.defineProperty(exports, "renameFilePadNumbers", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFilePadNumbers;
  }
});
Object.defineProperty(exports, "renameFileRegex", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileRegex;
  }
});
Object.defineProperty(exports, "reorderObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.reorderObjTypeOrder;
  }
});
Object.defineProperty(exports, "requestFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.requestFullScreen;
  }
});
Object.defineProperty(exports, "restoreLatestBackup", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.restoreLatestBackup;
  }
});
Object.defineProperty(exports, "ruleOfThree", {
  enumerable: true,
  get: function get() {
    return _simpleMath.ruleOfThree;
  }
});
Object.defineProperty(exports, "saveJsonFile", {
  enumerable: true,
  get: function get() {
    return _html.saveJsonFile;
  }
});
Object.defineProperty(exports, "shuffleArray", {
  enumerable: true,
  get: function get() {
    return _array.shuffleArray;
  }
});
Object.defineProperty(exports, "toTitleCase", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCase;
  }
});
Object.defineProperty(exports, "toTitleCaseLowerFirst", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCaseLowerFirst;
  }
});
Object.defineProperty(exports, "tryDeleteFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.tryDeleteFile;
  }
});
Object.defineProperty(exports, "writeJsonFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.writeJsonFile;
  }
});
Object.defineProperty(exports, "writeTextFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.writeTextFile;
  }
});
var _replaceAsync = _interopRequireDefault(require("../legacy/libs/replaceAsync.mjs"));
var _userLevel = _interopRequireDefault(require("../legacy/libs/userLevel.mjs"));
var _arraySortPositions = _interopRequireDefault(require("../legacy/libs/arraySortPositions.mjs"));
var _array = require("./basics/array.mjs");
var _clock = require("./basics/clock.mjs");
var _objFilter = require("./basics/objFilter.mjs");
var _fullScreen = require("./basics/fullScreen.mjs");
var _simpleMath = require("./basics/simpleMath.mjs");
var _text = require("./basics/text.mjs");
var _ColorSafeStringify = _interopRequireDefault(require("./libs/ColorSafeStringify.mjs"));
var _TinyPromiseQueue = _interopRequireDefault(require("./libs/TinyPromiseQueue.mjs"));
var _TinyRateLimiter = _interopRequireDefault(require("./libs/TinyRateLimiter.mjs"));
var _TinyNotifyCenter = _interopRequireDefault(require("./libs/TinyNotifyCenter.mjs"));
var _TinyToastNotify = _interopRequireDefault(require("./libs/TinyToastNotify.mjs"));
var _html = require("./basics/html.mjs");
var _TinyDragDropDetector = _interopRequireDefault(require("./libs/TinyDragDropDetector.mjs"));
var _normalFuncs = require("./fileManager/normalFuncs.mjs");
var _asyncFuncs = require("./fileManager/asyncFuncs.mjs");
var _TinyDragger = _interopRequireDefault(require("./libs/TinyDragger.mjs"));
var _TinyDomReadyManager = _interopRequireDefault(require("./libs/TinyDomReadyManager.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"../legacy/libs/arraySortPositions.mjs":112,"../legacy/libs/replaceAsync.mjs":113,"../legacy/libs/userLevel.mjs":114,"./basics/array.mjs":115,"./basics/clock.mjs":116,"./basics/fullScreen.mjs":117,"./basics/html.mjs":118,"./basics/objFilter.mjs":119,"./basics/simpleMath.mjs":120,"./basics/text.mjs":121,"./fileManager/asyncFuncs.mjs":122,"./fileManager/normalFuncs.mjs":123,"./libs/ColorSafeStringify.mjs":125,"./libs/TinyDomReadyManager.mjs":126,"./libs/TinyDragDropDetector.mjs":127,"./libs/TinyDragger.mjs":128,"./libs/TinyNotifyCenter.mjs":129,"./libs/TinyPromiseQueue.mjs":130,"./libs/TinyRateLimiter.mjs":131,"./libs/TinyToastNotify.mjs":132}],125:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _colors = /*#__PURE__*/new WeakMap();
var _ColorSafeStringify_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {Record<string, string>} ColorsList
 * Represents a mapping of color keys to ANSI escape codes.
 */
var ColorSafeStringify = /*#__PURE__*/function () {
  /**
   * Constructs a new instance with an optional base preset or custom override.
   * @param {ColorsList} [defaultColors] - Optional override for the default color scheme.
   */
  function ColorSafeStringify() {
    var defaultColors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, ColorSafeStringify);
    /**
     * Internal method to apply ANSI color codes to different parts of a JSON string.
     * @param {string} str - Raw JSON string to be colorized.
     * @param {ColorsList} colors - ANSI color mapping to be applied to each JSON element type.
     * @returns {string} Colorized JSON string.
     */
    _classPrivateMethodInitSpec(this, _ColorSafeStringify_brand);
    /**
     * Currently active color configuration.
     * @type {ColorsList}
     */
    _classPrivateFieldInitSpec(this, _colors, void 0);
    _classPrivateFieldSet(_colors, this, _objectSpread(_objectSpread({}, _PRESETS._["default"]), defaultColors));
  }
  return _createClass(ColorSafeStringify, [{
    key: "colorize",
    value:
    /**
     * Colorizes a JSON string using the active or optionally overridden color set.
     * @param {string} json - The JSON string to format.
     * @param {ColorsList} [customColors] - Optional temporary color override.
     * @returns {string}
     */
    function colorize(json) {
      var customColors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var colors = _objectSpread(_objectSpread({}, _classPrivateFieldGet(_colors, this)), customColors);
      return _assertClassBrand(_ColorSafeStringify_brand, this, _colorizeJSON).call(this, json, colors);
    }
    /**
     * Returns the currently active color scheme.
     * @returns {ColorsList}
     */
  }, {
    key: "getColors",
    value: function getColors() {
      return _objectSpread({}, _classPrivateFieldGet(_colors, this));
    }
    /**
     * Updates the current color scheme with a partial override.
     * @param {Partial<ColorsList>} newColors
     */
  }, {
    key: "updateColors",
    value: function updateColors(newColors) {
      Object.assign(_classPrivateFieldGet(_colors, this), newColors);
    }
    /**
     * Resets the current color scheme to the default preset.
     */
  }, {
    key: "resetColors",
    value: function resetColors() {
      _classPrivateFieldSet(_colors, this, _objectSpread({}, _PRESETS._["default"]));
    }
    /**
     * Loads a color preset by name.
     * @param {string} presetName - Name of the preset to load.
     * @throws Will throw if the preset doesn't exist.
     */
  }, {
    key: "loadColorPreset",
    value: function loadColorPreset(presetName) {
      var preset = _PRESETS._[presetName];
      if (!preset) throw new Error("Preset \"".concat(presetName, "\" not found."));
      _classPrivateFieldSet(_colors, this, _objectSpread({}, preset));
    }
    /**
     * Saves a new custom color preset.
     * @param {string} name - Name of the new preset.
     * @param {ColorsList} colors - ANSI color map to save.
     */
  }, {
    key: "saveColorPreset",
    value: function saveColorPreset(name, colors) {
      _PRESETS._[name] = _objectSpread({}, colors);
    }
    /**
     * Returns a list of all available color preset names.
     * @returns {string[]}
     */
  }, {
    key: "getAvailablePresets",
    value: function getAvailablePresets() {
      return Object.keys(_PRESETS._);
    }
  }]);
}();
function _colorizeJSON(str, colors) {
  /** @type {{ marker: string, key: string }[]} */
  var keyMatches = [];
  // Colorize numeric values
  str = str.replace(/(?<!")\b(-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b(?!")/g, "".concat(colors.number, "$1").concat(colors.reset));
  // Replace keys with temporary markers for later colorization
  str = str.replace(/"([^"]+)":/g, function (_, key) {
    var marker = "___KEY".concat(keyMatches.length, "___");
    keyMatches.push({
      marker: marker,
      key: key
    });
    return "".concat(marker, ":"); // Keep the colon for valid syntax
  });
  // Replace strings and apply specific colors based on their content
  str = str.replace(/"(?:\\.|[^"\\])*?"/g, function (match) {
    var val = match.slice(1, -1); // Remove surrounding quotes
    if (/^(https?|ftp):\/\/[^\s]+$/i.test(val)) {
      return "".concat(colors.string_url).concat(match).concat(colors.reset);
    }
    if (/^(true|false|null)$/.test(val)) {
      return "".concat(colors.string_bool).concat(match).concat(colors.reset);
    }
    if (/^-?\d+(\.\d+)?([eE][+-]?\d+)?$/.test(val)) {
      return "".concat(colors.string_number).concat(match).concat(colors.reset);
    }
    return "".concat(colors.string).concat(match).concat(colors.reset);
  });
  // Replace markers with colorized keys
  for (var _i = 0, _keyMatches = keyMatches; _i < _keyMatches.length; _i++) {
    var _keyMatches$_i = _keyMatches[_i],
      marker = _keyMatches$_i.marker,
      key = _keyMatches$_i.key;
    var regex = new RegExp(marker, 'g');
    str = str.replace(regex, "".concat(colors.key, "\"").concat(key, "\"").concat(colors.reset));
  }
  // Colorize boolean values
  str = str.replace(/(?<!")\b(true|false)\b(?!")/g, "".concat(colors["boolean"], "$1").concat(colors.reset));
  // Colorize null values
  str = str.replace(/(?<!")\bnull\b(?!")/g, "".concat(colors["null"], "null").concat(colors.reset));
  // Highlight special placeholder values
  str = str.replace(/\[Circular\]/g, "".concat(colors.special, "[Circular]").concat(colors.reset));
  str = str.replace(/\[undefined\]/g, "".concat(colors.special, "[undefined]").concat(colors.reset));
  // Colorize function string representations
  str = str.replace(/"function[^]*?[^\\]"/g, "".concat(colors.func, "$&").concat(colors.reset));
  return str;
}
/**
 * Preset collections (internal and user-defined).
 * @type {Record<string, ColorsList>}
 * @static
 */
var _PRESETS = {
  _: {
    "default": {
      reset: '\x1b[0m',
      key: '\x1b[36m',
      // Cyan (object keys)
      string: '\x1b[32m',
      // Green (regular strings)
      string_url: '\x1b[34m',
      // Blue (URLs)
      string_bool: '\x1b[35m',
      // Magenta (boolean/null in string form)
      string_number: '\x1b[33m',
      // Yellow (numbers in string form)
      number: '\x1b[33m',
      // Yellow (raw numbers)
      "boolean": '\x1b[35m',
      // Magenta (true/false)
      "null": '\x1b[1;30m',
      // Gray (null)
      special: '\x1b[31m',
      // Red (e.g., [Circular], [undefined])
      func: '\x1b[90m' // Dim (function string representations)
    },
    solarized: {
      reset: '\x1b[0m',
      key: '\x1b[38;5;37m',
      string: '\x1b[38;5;136m',
      string_url: '\x1b[38;5;33m',
      string_bool: '\x1b[38;5;166m',
      string_number: '\x1b[38;5;136m',
      number: '\x1b[38;5;136m',
      "boolean": '\x1b[38;5;166m',
      "null": '\x1b[38;5;241m',
      special: '\x1b[38;5;160m',
      func: '\x1b[38;5;244m'
    },
    monokai: {
      reset: '\x1b[0m',
      key: '\x1b[38;5;81m',
      string: '\x1b[38;5;114m',
      string_url: '\x1b[38;5;75m',
      string_bool: '\x1b[38;5;204m',
      string_number: '\x1b[38;5;221m',
      number: '\x1b[38;5;221m',
      "boolean": '\x1b[38;5;204m',
      "null": '\x1b[38;5;241m',
      special: '\x1b[38;5;160m',
      func: '\x1b[38;5;102m'
    }
  }
};
var _default = exports["default"] = ColorSafeStringify;

},{}],126:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _handlers = /*#__PURE__*/new WeakMap();
var _isDomReady = /*#__PURE__*/new WeakMap();
var _isFullyReady = /*#__PURE__*/new WeakMap();
var _promises = /*#__PURE__*/new WeakMap();
var _TinyDomReadyManager_brand = /*#__PURE__*/new WeakSet();
/**
 * A basic function that performs a task when the system is ready.
 * Used for handlers in the readiness queue.
 *
 * @typedef {() => void} Fn
 */
/**
 * A function that determines whether a specific handler should be executed.
 * Should return `true` to allow execution, or `false` to skip the handler.
 *
 * @typedef {() => boolean} FnFilter
 */
/**
 * @typedef {Object} Handler
 * @property {Fn} fn - Function to execute when ready.
 * @property {boolean} once - Whether to execute only once.
 * @property {number} priority - Execution order (higher priority runs first).
 * @property {FnFilter|null} filter - Optional filter function to determine execution.
 * @property {boolean} domOnly - Whether to run as soon as DOM is ready (before full readiness).
 */
var TinyDomReadyManager = /*#__PURE__*/function () {
  function TinyDomReadyManager() {
    _classCallCheck(this, TinyDomReadyManager);
    /**
     * Checks if the DOM is ready and if all Promises have been resolved.
     */
    _classPrivateMethodInitSpec(this, _TinyDomReadyManager_brand);
    /** @type {Handler[]} */
    _classPrivateFieldInitSpec(this, _handlers, []);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _isDomReady, false);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _isFullyReady, false);
    /** @type {Promise<any>[]} */
    _classPrivateFieldInitSpec(this, _promises, []);
  }
  return _createClass(TinyDomReadyManager, [{
    key: "_markDomReady",
    value:
    /**
     * Marks the system as DOM-ready and runs DOM-only handlers.
     * @private
     */
    function _markDomReady() {
      _classPrivateFieldSet(_isDomReady, this, true);
      _assertClassBrand(_TinyDomReadyManager_brand, this, _runHandlers).call(this, true); // Run domOnly
      _assertClassBrand(_TinyDomReadyManager_brand, this, _checkAllReady).call(this); // Then check for full readiness
    }
    /**
     * Initializes the manager using `DOMContentLoaded`.
     */
  }, {
    key: "init",
    value: function init() {
      var _this = this;
      if (_classPrivateFieldGet(_isDomReady, this)) throw new Error('[TinyDomReadyManager] init() has already been called.');
      if (document.readyState === 'interactive' || document.readyState === 'complete') {
        this._markDomReady();
      } else {
        document.addEventListener('DOMContentLoaded', function () {
          return _this._markDomReady();
        });
      }
    }
    /**
     * Adds a Promise to delay full readiness.
     * @param {Promise<any>} promise
     * @throws {TypeError}
     */
  }, {
    key: "addPromise",
    value: function addPromise(promise) {
      if (!(promise instanceof Promise)) throw new TypeError('[TinyDomReadyManager] promise must be a valid Promise.');
      if (_classPrivateFieldGet(_isFullyReady, this)) return;
      _classPrivateFieldGet(_promises, this).push(promise);
      if (_classPrivateFieldGet(_isDomReady, this)) _assertClassBrand(_TinyDomReadyManager_brand, this, _checkAllReady).call(this);
    }
    /**
     * Registers a handler to run either after DOM is ready or after full readiness.
     *
     * @param {Fn} fn - Function to execute.
     * @param {Object} [options]
     * @param {boolean} [options.once=true] - Execute only once.
     * @param {number} [options.priority=0] - Higher priority runs first.
     * @param {FnFilter|null} [options.filter=null] - Optional filter function.
     * @param {boolean} [options.domOnly=false] - If true, executes after DOM ready only.
     * @throws {TypeError} If fn is not a function.
     */
  }, {
    key: "onReady",
    value: function onReady(fn) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$once = _ref.once,
        once = _ref$once === void 0 ? true : _ref$once,
        _ref$priority = _ref.priority,
        priority = _ref$priority === void 0 ? 0 : _ref$priority,
        _ref$filter = _ref.filter,
        filter = _ref$filter === void 0 ? null : _ref$filter,
        _ref$domOnly = _ref.domOnly,
        domOnly = _ref$domOnly === void 0 ? false : _ref$domOnly;
      if (typeof fn !== 'function') throw new TypeError('[TinyDomReadyManager] fn must be a function.');
      var handler = {
        fn: fn,
        once: once,
        priority: priority,
        filter: filter,
        domOnly: domOnly
      };
      if (domOnly && _classPrivateFieldGet(_isDomReady, this)) {
        _assertClassBrand(_TinyDomReadyManager_brand, this, _invokeHandler).call(this, handler);
        if (!once) _classPrivateFieldGet(_handlers, this).push(handler);
        return;
      }
      if (!domOnly && _classPrivateFieldGet(_isFullyReady, this)) {
        _assertClassBrand(_TinyDomReadyManager_brand, this, _invokeHandler).call(this, handler);
      } else {
        _classPrivateFieldGet(_handlers, this).push(handler);
      }
    }
    /**
     * Returns whether the system is fully ready (DOM + Promises).
     * @returns {boolean}
     */
  }, {
    key: "isReady",
    value: function isReady() {
      return _classPrivateFieldGet(_isFullyReady, this);
    }
    /**
     * Returns whether the DOM is ready (DOMContentLoaded has fired).
     * Does not wait for promises.
     * @returns {boolean}
     */
  }, {
    key: "isDomReady",
    value: function isDomReady() {
      return _classPrivateFieldGet(_isDomReady, this);
    }
  }]);
}();
function _checkAllReady() {
  var _this2 = this;
  if (_classPrivateFieldGet(_isDomReady, this)) {
    Promise.all(_classPrivateFieldGet(_promises, this)).then(function () {
      _classPrivateFieldSet(_isFullyReady, _this2, true);
      _assertClassBrand(_TinyDomReadyManager_brand, _this2, _runHandlers).call(_this2, false); // run non-domOnly
    })["catch"](function (err) {
      console.error('[TinyDomReadyManager] Promise rejected:', err);
    });
  }
}
/**
 * Executes handlers by filtering them by `domOnly` flag and sorting by priority.
 * @param {boolean} domOnlyOnly - Whether to run only `domOnly` handlers.
 */
function _runHandlers(domOnlyOnly) {
  var _this3 = this;
  _classPrivateFieldGet(_handlers, this).filter(function (h) {
    return h.domOnly === domOnlyOnly;
  }).sort(function (a, b) {
    return b.priority - a.priority;
  }).forEach(function (handler) {
    return _assertClassBrand(_TinyDomReadyManager_brand, _this3, _invokeHandler).call(_this3, handler);
  });
  _classPrivateFieldSet(_handlers, this, _classPrivateFieldGet(_handlers, this).filter(function (h) {
    return !(h.once && (domOnlyOnly ? h.domOnly : true));
  }));
}
/**
 * Executes a handler if its filter passes.
 * @param {Handler} handler
 */
function _invokeHandler(handler) {
  if (typeof handler.filter === 'function') {
    try {
      if (!handler.filter()) return;
    } catch (err) {
      console.warn('[TinyDomReadyManager] Filter error:', err);
      return;
    }
  }
  try {
    handler.fn();
  } catch (err) {
    console.error('[TinyDomReadyManager] Handler error:', err);
  }
}
var _default = exports["default"] = TinyDomReadyManager;

},{}],127:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _target = /*#__PURE__*/new WeakMap();
var _fullscreen = /*#__PURE__*/new WeakMap();
var _hoverClass = /*#__PURE__*/new WeakMap();
var _onDropCallback = /*#__PURE__*/new WeakMap();
var _onEnterCallback = /*#__PURE__*/new WeakMap();
var _onLeaveCallback = /*#__PURE__*/new WeakMap();
var _isDragging = /*#__PURE__*/new WeakMap();
var _bound = /*#__PURE__*/new WeakMap();
var _TinyDragDropDetector_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {Object} DragAndDropOptions
 * @property {HTMLElement} [target=document.body] - The DOM element where drag listeners will be attached. Defaults to `document.body` if `fullscreen` is true or no target is provided.
 * @property {boolean} [fullscreen=true] - If true, listeners are attached to the entire page (`document.body`). If false, the `target` must be specified.
 * @property {string} [hoverClass="dnd-hover"] - CSS class applied to the target element while files are being dragged over it.
 * @property {(files: FileList, event: DragEvent) => void} [onDrop] - Callback function executed when files are dropped onto the target.
 * @property {(event: DragEvent) => void} [onEnter] - Optional callback triggered when dragging enters the target area.
 * @property {(event: DragEvent) => void} [onLeave] - Optional callback triggered when dragging leaves the target area.
 */
/**
 * TinyDragDropDetector
 *
 * A lightweight utility to detect drag-and-drop file operations on a specific DOM element or the entire page.
 * It handles the drag lifecycle (enter, over, leave, drop) and provides hooks for developers to handle file uploads or UI changes.
 *
 * @class
 */
var TinyDragDropDetector = /*#__PURE__*/function () {
  /**
   * Creates a new instance of TinyDragDropDetector to handle drag-and-drop file detection.
   *
   * @param {DragAndDropOptions} [options={}] - Configuration options for the detector.
   * @throws {TypeError} If `target` is not an HTMLElement.
   * @throws {TypeError} If `fullscreen` is not a boolean.
   * @throws {TypeError} If `hoverClass` is not a string.
   * @throws {TypeError} If `onDrop` is defined but not a function.
   * @throws {TypeError} If `onEnter` is defined but not a function.
   * @throws {TypeError} If `onLeave` is defined but not a function.
   */
  function TinyDragDropDetector() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, TinyDragDropDetector);
    /**
     * Binds the drag-and-drop event listeners to the target element.
     * Automatically called on instantiation.
     * @returns {void}
     */
    _classPrivateMethodInitSpec(this, _TinyDragDropDetector_brand);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _target, void 0);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _fullscreen, void 0);
    /** @type {string} */
    _classPrivateFieldInitSpec(this, _hoverClass, void 0);
    /** @type {(files: FileList, event: DragEvent) => void} */
    _classPrivateFieldInitSpec(this, _onDropCallback, void 0);
    /** @type {(event: DragEvent) => void} */
    _classPrivateFieldInitSpec(this, _onEnterCallback, void 0);
    /** @type {(event: DragEvent) => void} */
    _classPrivateFieldInitSpec(this, _onLeaveCallback, void 0);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _isDragging, void 0);
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _bound, void 0);
    var _target2 = options.target,
      _options$fullscreen = options.fullscreen,
      fullscreen = _options$fullscreen === void 0 ? true : _options$fullscreen,
      _options$hoverClass = options.hoverClass,
      hoverClass = _options$hoverClass === void 0 ? 'dnd-hover' : _options$hoverClass,
      onDrop = options.onDrop,
      onEnter = options.onEnter,
      onLeave = options.onLeave;
    // Validate fullscreen
    if (typeof fullscreen !== 'boolean') throw new TypeError('The "fullscreen" option must be a boolean.');
    // Validate target
    var resolvedTarget = fullscreen ? document.body : _target2 || document.body;
    if (!(resolvedTarget instanceof HTMLElement)) throw new TypeError('The "target" option must be an instance of HTMLElement.');
    // Validate hoverClass
    if (typeof hoverClass !== 'string') throw new TypeError('The "hoverClass" option must be a string.');
    // Validate onDrop
    if (typeof onDrop !== 'function') throw new TypeError('The "onDrop" option must be a function.');
    // Validate onEnter
    if (typeof onEnter !== 'function') throw new TypeError('The "onEnter" option must be a function.');
    // Validate onLeave
    if (typeof onLeave !== 'function') throw new TypeError('The "onLeave" option must be a function.');
    // Store properties
    _classPrivateFieldSet(_target, this, resolvedTarget);
    _classPrivateFieldSet(_fullscreen, this, fullscreen);
    _classPrivateFieldSet(_hoverClass, this, hoverClass);
    _classPrivateFieldSet(_onDropCallback, this, onDrop || function () {});
    _classPrivateFieldSet(_onEnterCallback, this, onEnter);
    _classPrivateFieldSet(_onLeaveCallback, this, onLeave);
    _classPrivateFieldSet(_isDragging, this, false);
    _classPrivateFieldSet(_bound, this, false);
    // Bind event handlers
    this._handleDragEnter = this._handleDragEnter.bind(this);
    this._handleDragOver = this._handleDragOver.bind(this);
    this._handleDragLeave = this._handleDragLeave.bind(this);
    this._handleDrop = this._handleDrop.bind(this);
    _assertClassBrand(_TinyDragDropDetector_brand, this, _bindEvents).call(this);
  }
  /**
   * Returns the current target DOM element where the listeners are attached.
   * @returns {HTMLElement}
   */
  return _createClass(TinyDragDropDetector, [{
    key: "getTarget",
    value: function getTarget() {
      return _classPrivateFieldGet(_target, this);
    }
    /**
     * Returns the CSS class applied during drag hover.
     * @returns {string}
     */
  }, {
    key: "getHoverClass",
    value: function getHoverClass() {
      return _classPrivateFieldGet(_hoverClass, this);
    }
    /**
     * Indicates whether the detector is operating in fullscreen mode.
     * @returns {boolean}
     */
  }, {
    key: "isFullScreen",
    value: function isFullScreen() {
      return _classPrivateFieldGet(_fullscreen, this);
    }
    /**
     * Returns whether a drag operation is currently active over the target.
     * @returns {boolean}
     */
  }, {
    key: "isDragging",
    value: function isDragging() {
      return _classPrivateFieldGet(_isDragging, this);
    }
    /**
     * Returns whether the event listeners are currently bound to the target.
     * @returns {boolean}
     */
  }, {
    key: "bound",
    value: function bound() {
      return _classPrivateFieldGet(_bound, this);
    }
  }, {
    key: "_handleDragEnter",
    value:
    /**
     * Handles the `dragenter` event.
     * Adds the hover CSS class and triggers the `onEnter` callback if provided.
     * @private
     * @param {DragEvent} event - The dragenter event.
     * @returns {void}
     */
    function _handleDragEnter(event) {
      event.preventDefault();
      if (!_classPrivateFieldGet(_isDragging, this)) {
        var target = this.getTarget();
        _classPrivateFieldSet(_isDragging, this, true);
        target.classList.add(_classPrivateFieldGet(_hoverClass, this));
        _classPrivateFieldGet(_onEnterCallback, this).call(this, event);
      }
    }
    /**
     * Handles the `dragover` event.
     * Prevents default to allow drop and sets the drop effect.
     * @private
     * @param {DragEvent} event - The dragover event.
     * @returns {void}
     */
  }, {
    key: "_handleDragOver",
    value: function _handleDragOver(event) {
      event.preventDefault(); // Required to allow drop
      if (!event.dataTransfer) {
        console.warn('[TinyDragDropDetector] [handleDragOver] DragOver event missing dataTransfer.');
        return;
      }
      event.dataTransfer.dropEffect = 'copy';
    }
    /**
     * Handles the `dragleave` event.
     * Removes the hover class and triggers the `onLeave` callback if provided.
     * @private
     * @param {DragEvent} event - The dragleave event.
     * @returns {void}
     */
  }, {
    key: "_handleDragLeave",
    value: function _handleDragLeave(event) {
      event.preventDefault();
      var target = this.getTarget();
      // Check if you've completely left the area
      // @ts-ignore
      if (event.relatedTarget === null || !target.contains(event.relatedTarget)) {
        _classPrivateFieldSet(_isDragging, this, false);
        target.classList.remove(_classPrivateFieldGet(_hoverClass, this));
        _classPrivateFieldGet(_onLeaveCallback, this).call(this, event);
      }
    }
    /**
     * Handles the `drop` event.
     * Removes the hover class, resets dragging state, and triggers the `onDrop` callback.
     * @private
     * @param {DragEvent} event - The drop event.
     * @returns {void}
     */
  }, {
    key: "_handleDrop",
    value: function _handleDrop(event) {
      event.preventDefault();
      if (!event.dataTransfer) {
        console.warn('[TinyDragDropDetector] [handleDrop] DragOver event missing dataTransfer.');
        return;
      }
      var target = this.getTarget();
      _classPrivateFieldSet(_isDragging, this, false);
      target.classList.remove(_classPrivateFieldGet(_hoverClass, this));
      var files = event.dataTransfer.files;
      if (files.length > 0) {
        _classPrivateFieldGet(_onDropCallback, this).call(this, files, event);
      }
    }
    /**
     * Destroys the detector instance, unbinding all event listeners and cleaning up.
     * Should be called when the detector is no longer needed to avoid memory leaks.
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _assertClassBrand(_TinyDragDropDetector_brand, this, _unbindEvents).call(this);
      var target = this.getTarget();
      target.classList.remove(_classPrivateFieldGet(_hoverClass, this));
    }
  }]);
}();
function _bindEvents() {
  if (_classPrivateFieldGet(_bound, this)) return;
  var target = this.getTarget();
  target.addEventListener('dragenter', this._handleDragEnter);
  target.addEventListener('dragover', this._handleDragOver);
  target.addEventListener('dragleave', this._handleDragLeave);
  target.addEventListener('drop', this._handleDrop);
  _classPrivateFieldSet(_bound, this, true);
}
/**
 * Removes all previously attached drag-and-drop event listeners from the target.
 * @returns {void}
 */
function _unbindEvents() {
  if (!_classPrivateFieldGet(_bound, this)) return;
  var target = this.getTarget();
  target.removeEventListener('dragenter', this._handleDragEnter);
  target.removeEventListener('dragover', this._handleDragOver);
  target.removeEventListener('dragleave', this._handleDragLeave);
  target.removeEventListener('drop', this._handleDrop);
  _classPrivateFieldSet(_bound, this, false);
}
var _default = exports["default"] = TinyDragDropDetector;

},{}],128:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _html = require("../basics/html.mjs");
var _objFilter = require("../basics/objFilter.mjs");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @typedef {Object} VibrationPatterns
 * @property {number[]|false} start - Pattern to vibrate on start
 * @property {number[]|false} end - Pattern to vibrate on end
 * @property {number[]|false} collide - Pattern to vibrate on collision
 * @property {number[]|false} move - Pattern to vibrate while moving
 */
/**
 * TinyDragger enables drag-and-drop functionality for a DOM element.
 * It supports jail boundaries, optional collision detection, vibration feedback,
 * automatic reverting, proxy dragging, and event dispatching.
 */
var _enabled = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _offsetY = /*#__PURE__*/new WeakMap();
var _offsetX = /*#__PURE__*/new WeakMap();
var _multiCollision = /*#__PURE__*/new WeakMap();
var _lockInsideJail = /*#__PURE__*/new WeakMap();
var _revertOnDrop = /*#__PURE__*/new WeakMap();
var _dragging = /*#__PURE__*/new WeakMap();
var _collisionByMouse = /*#__PURE__*/new WeakMap();
var _dropInJailOnly = /*#__PURE__*/new WeakMap();
var _lastCollision = /*#__PURE__*/new WeakMap();
var _collidables = /*#__PURE__*/new WeakMap();
var _dragProxy = /*#__PURE__*/new WeakMap();
var _vibration = /*#__PURE__*/new WeakMap();
var _jail = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _dragHiddenClass = /*#__PURE__*/new WeakMap();
var _classDragging = /*#__PURE__*/new WeakMap();
var _classBodyDragging = /*#__PURE__*/new WeakMap();
var _classJailDragging = /*#__PURE__*/new WeakMap();
var _classJailDragDisabled = /*#__PURE__*/new WeakMap();
var _classDragCollision = /*#__PURE__*/new WeakMap();
var _TinyDragger_brand = /*#__PURE__*/new WeakSet();
var _collisionsMarked = /*#__PURE__*/new WeakMap();
var TinyDragger = /*#__PURE__*/function () {
  /** @typedef {(event: TouchEvent) => void} TouchDragEvent */
  /**
   * @param {HTMLElement} targetElement - The element to make draggable.
   * @param {Object} [options={}] - Configuration options.
   * @param {HTMLElement} [options.jail] - Optional container to restrict dragging within.
   * @param {boolean} [options.collisionByMouse=false] - Use mouse position for collision instead of element rect.
   * @param {string} [options.classDragging='dragging'] - CSS class applied to the clone during dragging.
   * @param {string} [options.classBodyDragging='drag-active'] - CSS class applied to <body> during dragging.
   * @param {string} [options.classJailDragging='jail-drag-active'] - CSS class applied to jail element during drag.
   * @param {string} [options.classJailDragDisabled='jail-drag-disabled'] - CSS class applied to jail element disabled.
   * @param {string} [options.classDragCollision='dragging-collision'] - CSS class applied to collision element.
   * @param {boolean} [options.lockInsideJail=false] - Restrict movement within the jail container.
   * @param {boolean} [options.dropInJailOnly=false] - Restrict drop within the jail container.
   * @param {boolean} [options.multiCollision=false] - Enables returning multiple collided elements.
   * @param {VibrationPatterns|false} [options.vibration=false] - Vibration feedback configuration.
   * @param {boolean} [options.revertOnDrop=false] - Whether to return to original position on drop.
   * @param {string} [options.classHidden='drag-hidden'] - CSS class to hide original element during dragging.
   * @throws {Error} If any option has an invalid type.
   */
  function TinyDragger(targetElement) {
    var _this = this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, TinyDragger);
    /**
     * Handles the start of a drag event.
     * @param {MouseEvent|Touch} event - The initiating event.
     */
    _classPrivateMethodInitSpec(this, _TinyDragger_brand);
    _classPrivateFieldInitSpec(this, _enabled, true);
    _classPrivateFieldInitSpec(this, _destroyed, false);
    _classPrivateFieldInitSpec(this, _offsetY, 0);
    _classPrivateFieldInitSpec(this, _offsetX, 0);
    _classPrivateFieldInitSpec(this, _multiCollision, false);
    _classPrivateFieldInitSpec(this, _lockInsideJail, false);
    _classPrivateFieldInitSpec(this, _revertOnDrop, false);
    _classPrivateFieldInitSpec(this, _dragging, false);
    _classPrivateFieldInitSpec(this, _collisionByMouse, false);
    _classPrivateFieldInitSpec(this, _dropInJailOnly, false);
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _lastCollision, null);
    /** @type {HTMLElement[]} */
    _classPrivateFieldInitSpec(this, _collidables, []);
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _dragProxy, null);
    /** @type {VibrationPatterns} */
    _classPrivateFieldInitSpec(this, _vibration, {
      start: false,
      end: false,
      collide: false,
      move: false
    });
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _jail, null);
    _classPrivateFieldInitSpec(this, _target, void 0);
    _classPrivateFieldInitSpec(this, _dragHiddenClass, 'drag-hidden');
    _classPrivateFieldInitSpec(this, _classDragging, 'dragging');
    _classPrivateFieldInitSpec(this, _classBodyDragging, 'drag-active');
    _classPrivateFieldInitSpec(this, _classJailDragging, 'jail-drag-active');
    _classPrivateFieldInitSpec(this, _classJailDragDisabled, 'jail-drag-disabled');
    _classPrivateFieldInitSpec(this, _classDragCollision, 'dragging-collision');
    /** @type {HTMLElement[]} */
    _classPrivateFieldInitSpec(this, _collisionsMarked, []);
    if (!(targetElement instanceof HTMLElement)) throw new Error('TinyDragger requires a valid target HTMLElement to initialize.');
    _classPrivateFieldSet(_target, this, targetElement);
    // === Validations ===
    if (options.jail !== undefined && !(options.jail instanceof HTMLElement)) throw new Error('The "jail" option must be an HTMLElement if provided.');
    if (options.vibration !== undefined && options.vibration !== false && !(0, _objFilter.isJsonObject)(options.vibration)) throw new Error('The "vibration" option must be an object or false.');
    /**
     * @param {any} val
     * @param {string} name
     */
    var validateBoolean = function validateBoolean(val, name) {
      if (val !== undefined && typeof val !== 'boolean') {
        throw new Error("The \"".concat(name, "\" option must be a boolean."));
      }
    };
    /**
     * @param {any} val
     * @param {string} name
     */
    var validateString = function validateString(val, name) {
      if (val !== undefined && typeof val !== 'string') {
        throw new Error("The \"".concat(name, "\" option must be a string."));
      }
    };
    validateBoolean(options.collisionByMouse, 'collisionByMouse');
    validateBoolean(options.lockInsideJail, 'lockInsideJail');
    validateBoolean(options.dropInJailOnly, 'dropInJailOnly');
    validateBoolean(options.revertOnDrop, 'revertOnDrop');
    validateBoolean(options.multiCollision, 'multiCollision');
    validateString(options.classDragging, 'classDragging');
    validateString(options.classBodyDragging, 'classBodyDragging');
    validateString(options.classJailDragging, 'classJailDragging');
    validateString(options.classJailDragDisabled, 'classJailDragDisabled');
    validateString(options.classDragCollision, 'classDragCollision');
    validateString(options.classHidden, 'classHidden');
    if (options.jail instanceof HTMLElement) _classPrivateFieldSet(_jail, this, options.jail);
    /** @type {VibrationPatterns} */
    var vibrationTemplate = {
      start: false,
      end: false,
      collide: false,
      move: false
    };
    _classPrivateFieldSet(_vibration, this, Object.assign(vibrationTemplate, (0, _objFilter.isJsonObject)(options.vibration) ? options.vibration : {}));
    if (typeof options.classDragging === 'string') _classPrivateFieldSet(_classDragging, this, options.classDragging);
    if (typeof options.classBodyDragging === 'string') _classPrivateFieldSet(_classBodyDragging, this, options.classBodyDragging);
    if (typeof options.classJailDragging === 'string') _classPrivateFieldSet(_classJailDragging, this, options.classJailDragging);
    if (typeof options.classJailDragDisabled === 'string') _classPrivateFieldSet(_classJailDragDisabled, this, options.classJailDragDisabled);
    if (typeof options.classHidden === 'string') _classPrivateFieldSet(_dragHiddenClass, this, options.classHidden);
    if (typeof options.classDragCollision === 'string') _classPrivateFieldSet(_classDragCollision, this, options.classDragCollision);
    if (typeof options.collisionByMouse === 'boolean') _classPrivateFieldSet(_collisionByMouse, this, options.collisionByMouse);
    if (typeof options.revertOnDrop === 'boolean') _classPrivateFieldSet(_revertOnDrop, this, options.revertOnDrop);
    if (typeof options.lockInsideJail === 'boolean') _classPrivateFieldSet(_lockInsideJail, this, options.lockInsideJail);
    if (typeof options.dropInJailOnly === 'boolean') _classPrivateFieldSet(_dropInJailOnly, this, options.dropInJailOnly);
    if (typeof options.multiCollision === 'boolean') _classPrivateFieldSet(_multiCollision, this, options.multiCollision);
    /** @private */
    this._onMouseDown = _assertClassBrand(_TinyDragger_brand, this, _startDrag).bind(this);
    /** @private */
    this._onMouseMove = _assertClassBrand(_TinyDragger_brand, this, _drag).bind(this);
    /** @private */
    this._onMouseUp = _assertClassBrand(_TinyDragger_brand, this, _endDrag).bind(this);
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchStart = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _startDrag).call(_this, e.touches[0]);
    };
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchMove = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _drag).call(_this, e.touches[0]);
    };
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchEnd = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _endDrag).call(_this, e.changedTouches[0]);
    };
    _classPrivateFieldGet(_target, this).addEventListener('mousedown', this._onMouseDown);
    _classPrivateFieldGet(_target, this).addEventListener('touchstart', this._onTouchStart, {
      passive: false
    });
  }
  /**
   * Enables the drag functionality.
   */
  return _createClass(TinyDragger, [{
    key: "enable",
    value: function enable() {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.add(_classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_enabled, this, true);
    }
    /**
     * Disables the drag functionality.
     */
  }, {
    key: "disable",
    value: function disable() {
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_enabled, this, false);
    }
    /**
     * Adds an element to be considered for collision detection.
     * @param {HTMLElement} element - The element to track collisions with.
     * @throws {Error} If the element is not a valid HTMLElement.
     */
  }, {
    key: "addCollidable",
    value: function addCollidable(element) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(element instanceof HTMLElement)) throw new Error('addCollidable expects an HTMLElement as argument.');
      if (!_classPrivateFieldGet(_collidables, this).includes(element)) _classPrivateFieldGet(_collidables, this).push(element);
    }
    /**
     * Removes a collidable element from the tracking list.
     * @param {HTMLElement} element - The element to remove.
     * @throws {Error} If the element is not a valid HTMLElement.
     */
  }, {
    key: "removeCollidable",
    value: function removeCollidable(element) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(element instanceof HTMLElement)) throw new Error('removeCollidable expects an HTMLElement as argument.');
      _classPrivateFieldSet(_collidables, this, _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return el !== element;
      }));
    }
    /**
     * Sets vibration patterns for drag events.
     * @param {Object} [param0={}] - Vibration pattern configuration.
     * @param {number[]|false} [param0.startPattern=false] - Vibration on drag start.
     * @param {number[]|false} [param0.endPattern=false] - Vibration on drag end.
     * @param {number[]|false} [param0.collidePattern=false] - Vibration on collision.
     * @param {number[]|false} [param0.movePattern=false] - Vibration during movement.
     * @throws {Error} If any pattern is not false or an array of numbers.
     */
  }, {
    key: "setVibrationPattern",
    value: function setVibrationPattern() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$startPattern = _ref.startPattern,
        startPattern = _ref$startPattern === void 0 ? false : _ref$startPattern,
        _ref$endPattern = _ref.endPattern,
        endPattern = _ref$endPattern === void 0 ? false : _ref$endPattern,
        _ref$collidePattern = _ref.collidePattern,
        collidePattern = _ref$collidePattern === void 0 ? false : _ref$collidePattern,
        _ref$movePattern = _ref.movePattern,
        movePattern = _ref$movePattern === void 0 ? false : _ref$movePattern;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      /** @param {any} value */
      var isValidPattern = function isValidPattern(value) {
        return value === false || Array.isArray(value) && value.every(function (n) {
          return typeof n === 'number';
        });
      };
      if (!isValidPattern(startPattern)) throw new Error('Invalid "startPattern": must be false or an array of numbers.');
      if (!isValidPattern(endPattern)) throw new Error('Invalid "endPattern": must be false or an array of numbers.');
      if (!isValidPattern(collidePattern)) throw new Error('Invalid "collidePattern": must be false or an array of numbers.');
      if (!isValidPattern(movePattern)) throw new Error('Invalid "movePattern": must be false or an array of numbers.');
      _classPrivateFieldSet(_vibration, this, {
        start: startPattern,
        end: endPattern,
        collide: collidePattern,
        move: movePattern
      });
    }
    /**
     * Disables all vibration feedback.
     */
  }, {
    key: "disableVibration",
    value: function disableVibration() {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      _classPrivateFieldSet(_vibration, this, {
        start: false,
        end: false,
        collide: false,
        move: false
      });
    }
    /**
     * Calculates the cursor offset relative to the top-left of the target element.
     * @param {MouseEvent|Touch} event - The mouse or touch event.
     * @returns {{x: number, y: number}} The offset in pixels.
     * @throws {Error} If event is not a MouseEvent or Touch with clientX/clientY.
     */
  }, {
    key: "getOffset",
    value: function getOffset(event) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(event instanceof MouseEvent) && !(event instanceof Touch) || typeof event.clientX !== 'number' || typeof event.clientY !== 'number') throw new Error('getOffset expects an event with valid clientX and clientY coordinates.');
      var targetRect = _classPrivateFieldGet(_target, this).getBoundingClientRect();
      var _getHtmlElBordersWidt = (0, _html.getHtmlElBordersWidth)(_classPrivateFieldGet(_target, this)),
        borderLeft = _getHtmlElBordersWidt.left,
        borderTop = _getHtmlElBordersWidt.top;
      return {
        x: event.clientX - targetRect.left + borderLeft,
        y: event.clientY - targetRect.top + borderTop
      };
    }
  }, {
    key: "checkDragCollision",
    value:
    /**
     * Handles dragging collision.
     * @param {MouseEvent|Touch} event - The drag event.
     */
    function checkDragCollision(event) {
      var _this2 = this;
      var _this$execCollision = this.execCollision(event),
        collidedElements = _this$execCollision.collidedElements;
      var first = collidedElements[0] || null;
      // Removes old marking if necessary
      if (_classPrivateFieldGet(_lastCollision, this) && !collidedElements.includes(_classPrivateFieldGet(_lastCollision, this))) {
        _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
      }
      // Adds Marking for All Colluded
      collidedElements.forEach(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this2, _addCollision).call(_this2, el);
      });
      // Removes markings from who no longer collided
      _classPrivateFieldGet(_collidables, this).forEach(function (el) {
        if (!collidedElements.includes(el)) {
          el.classList.remove(_classPrivateFieldGet(_classDragCollision, _this2));
        }
      });
      if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).collide) && collidedElements.length > 0) {
        navigator.vibrate(_classPrivateFieldGet(_vibration, this).collide);
      }
      _classPrivateFieldSet(_lastCollision, this, first);
    }
    /**
     * Handles dragging movement.
     * @param {MouseEvent|Touch} event - The drag event.
     */
  }, {
    key: "execCollision",
    value:
    /**
     * Handles the collision of a drag.
     * @param {MouseEvent|Touch} event - The release event.
     * @returns {{ inJail: boolean; collidedElements: (HTMLElement | null)[] }}
     */
    function execCollision(event) {
      var _classPrivateFieldGet2;
      if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragProxy, this)) return {
        inJail: false,
        collidedElements: []
      };
      var collidedElements = [];
      var inJail = true;
      var jailRect = (_classPrivateFieldGet2 = _classPrivateFieldGet(_jail, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.getBoundingClientRect();
      if (_classPrivateFieldGet(_collisionByMouse, this)) {
        var x = event.clientX;
        var y = event.clientY;
        if (_classPrivateFieldGet(_dropInJailOnly, this) && _classPrivateFieldGet(_jail, this) && jailRect) {
          inJail = x >= jailRect.left && x <= jailRect.right && y >= jailRect.top && y <= jailRect.bottom;
        }
        collidedElements = inJail ? _classPrivateFieldGet(_multiCollision, this) ? this.getAllCollidedElements(x, y) : [this.getCollidedElement(x, y)].filter(Boolean) : [];
      } else {
        var rect = _classPrivateFieldGet(_dragProxy, this).getBoundingClientRect();
        if (_classPrivateFieldGet(_dropInJailOnly, this) && _classPrivateFieldGet(_jail, this) && jailRect) {
          inJail = rect.left >= jailRect.left && rect.right <= jailRect.right && rect.top >= jailRect.top && rect.bottom <= jailRect.bottom;
        }
        collidedElements = inJail ? _classPrivateFieldGet(_multiCollision, this) ? this.getAllCollidedElementsByRect(rect) : [this.getCollidedElementByRect(rect)].filter(Boolean) : [];
      }
      return {
        inJail: inJail,
        collidedElements: collidedElements
      };
    }
    /**
     * Handles the end of a drag.
     * @param {MouseEvent|Touch} event - The release event.
     */
  }, {
    key: "getAllCollidedElementsByRect",
    value:
    /**
     * Returns all elements currently colliding with the given rectangle.
     *
     * @param {DOMRect} rect - Bounding rectangle of the dragged proxy.
     * @returns {HTMLElement[]} A list of all collided elements.
     * @throws {Error} If the input is not a valid DOMRect with numeric bounds.
     */
    function getAllCollidedElementsByRect(rect) {
      var _this3 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(rect instanceof DOMRect) || typeof rect.left !== 'number' || typeof rect.right !== 'number' || typeof rect.top !== 'number' || typeof rect.bottom !== 'number') throw new Error('getCollidedElementByRect expects a valid DOMRect object.');
      return _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this3, _getCollidedElementByRect).call(_this3, el, rect);
      });
    }
    /**
     * Detects collision based on rectangle intersection.
     * @param {DOMRect} rect - Bounding rectangle of the dragged proxy.
     * @returns {HTMLElement|null} The collided element or null.
     * @throws {Error} If rect is not a DOMRect with valid numeric properties.
     */
  }, {
    key: "getCollidedElementByRect",
    value: function getCollidedElementByRect(rect) {
      var _this4 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(rect instanceof DOMRect) || typeof rect.left !== 'number' || typeof rect.right !== 'number' || typeof rect.top !== 'number' || typeof rect.bottom !== 'number') throw new Error('getCollidedElementByRect expects a valid DOMRect object.');
      return _classPrivateFieldGet(_collidables, this).find(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this4, _getCollidedElementByRect).call(_this4, el, rect);
      }) || null;
    }
    /**
     * Checks whether a given (x, y) coordinate is inside the bounding rectangle of an element.
     *
     * @param {HTMLElement} el - The element to test for collision.
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {boolean} True if the point is within the element's bounds.
     */
  }, {
    key: "getAllCollidedElements",
    value:
    /**
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {HTMLElement[]} The collided element or null.
     */
    function getAllCollidedElements(x, y) {
      var _this5 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (typeof x !== 'number' || typeof y !== 'number') throw new Error('getCollidedElement expects numeric x and y coordinates.');
      return _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this5, _getCollidedElement).call(_this5, el, x, y);
      });
    }
    /**
     * Detects collision with a point using element bounding rectangles.
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {HTMLElement|null} The collided element or null.
     */
  }, {
    key: "getCollidedElement",
    value: function getCollidedElement(x, y) {
      var _this6 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (typeof x !== 'number' || typeof y !== 'number') throw new Error('getCollidedElement expects numeric x and y coordinates.');
      return _classPrivateFieldGet(_collidables, this).find(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this6, _getCollidedElement).call(_this6, el, x, y);
      }) || null;
    }
    /**
     * Dispatches a custom event from the target element.
     * @param {string} type - The event name.
     */
  }, {
    key: "getDragging",
    value:
    /**
     * Gets whether dragging is currently active.
     * @returns {boolean}
     */
    function getDragging() {
      return _classPrivateFieldGet(_dragging, this);
    }
    /**
     * Gets whether movement is restricted inside the jail container.
     * @returns {boolean}
     */
  }, {
    key: "getLockInsideJail",
    value: function getLockInsideJail() {
      return _classPrivateFieldGet(_lockInsideJail, this);
    }
    /**
     * Sets whether movement is restricted inside the jail container.
     * @param {boolean} value
     */
  }, {
    key: "setLockInsideJail",
    value: function setLockInsideJail(value) {
      if (typeof value !== 'boolean') throw new Error('lockInsideJail must be a boolean.');
      _classPrivateFieldSet(_lockInsideJail, this, value);
    }
    /**
     * Gets whether the element should revert to original position on drop.
     * @returns {boolean}
     */
  }, {
    key: "getRevertOnDrop",
    value: function getRevertOnDrop() {
      return _classPrivateFieldGet(_revertOnDrop, this);
    }
    /**
     * Sets whether the element should revert to original position on drop.
     * @param {boolean} value
     */
  }, {
    key: "setRevertOnDrop",
    value: function setRevertOnDrop(value) {
      if (typeof value !== 'boolean') throw new Error('revertOnDrop must be a boolean.');
      _classPrivateFieldSet(_revertOnDrop, this, value);
    }
    /**
     * Gets whether collision detection uses mouse position.
     * @returns {boolean}
     */
  }, {
    key: "getCollisionByMouse",
    value: function getCollisionByMouse() {
      return _classPrivateFieldGet(_collisionByMouse, this);
    }
    /**
     * Sets whether collision detection uses mouse position.
     * @param {boolean} value
     */
  }, {
    key: "setCollisionByMouse",
    value: function setCollisionByMouse(value) {
      if (typeof value !== 'boolean') throw new Error('collisionByMouse must be a boolean.');
      _classPrivateFieldSet(_collisionByMouse, this, value);
    }
    /**
     * Gets whether dropping is restricted inside the jail container.
     * @returns {boolean}
     */
  }, {
    key: "getDropInJailOnly",
    value: function getDropInJailOnly() {
      return _classPrivateFieldGet(_dropInJailOnly, this);
    }
    /**
     * Sets whether dropping is restricted inside the jail container.
     * @param {boolean} value
     */
  }, {
    key: "setDropInJailOnly",
    value: function setDropInJailOnly(value) {
      if (typeof value !== 'boolean') throw new Error('dropInJailOnly must be a boolean.');
      _classPrivateFieldSet(_dropInJailOnly, this, value);
    }
    /**
     * Returns the original target element being dragged.
     * @returns {HTMLElement}
     */
  }, {
    key: "getTarget",
    value: function getTarget() {
      return _classPrivateFieldGet(_target, this);
    }
    /**
     * Returns the current jail container (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getJail",
    value: function getJail() {
      return _classPrivateFieldGet(_jail, this);
    }
    /**
     * Returns the current proxy element being dragged (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getDragProxy",
    value: function getDragProxy() {
      return _classPrivateFieldGet(_dragProxy, this);
    }
    /**
     * Returns the last collided element (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getLastCollision",
    value: function getLastCollision() {
      return _classPrivateFieldGet(_lastCollision, this);
    }
    /**
     * Returns all registered collidable elements.
     * @returns {HTMLElement[]}
     */
  }, {
    key: "getCollidables",
    value: function getCollidables() {
      return _toConsumableArray(_classPrivateFieldGet(_collidables, this));
    }
    /**
     * Returns the CSS class used to hide the target during drag.
     * @returns {string}
     */
  }, {
    key: "getDragHiddenClass",
    value: function getDragHiddenClass() {
      return _classPrivateFieldGet(_dragHiddenClass, this);
    }
    /**
     * Returns the CSS class applied to the clone during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassDragging",
    value: function getClassDragging() {
      return _classPrivateFieldGet(_classDragging, this);
    }
    /**
     * Returns the CSS class applied to <body> during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassBodyDragging",
    value: function getClassBodyDragging() {
      return _classPrivateFieldGet(_classBodyDragging, this);
    }
    /**
     * Returns the CSS class applied to the jail during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassJailDragging",
    value: function getClassJailDragging() {
      return _classPrivateFieldGet(_classJailDragging, this);
    }
    /**
     * Returns the CSS class applied to the jail when dragging is disabled.
     * @returns {string}
     */
  }, {
    key: "getClassJailDragDisabled",
    value: function getClassJailDragDisabled() {
      return _classPrivateFieldGet(_classJailDragDisabled, this);
    }
    /**
     * Returns the CSS class applied to a collided element.
     * @returns {string}
     */
  }, {
    key: "getClassDragCollision",
    value: function getClassDragCollision() {
      return _classPrivateFieldGet(_classDragCollision, this);
    }
    /**
     * Returns the full vibration configuration.
     * @returns {VibrationPatterns}
     */
  }, {
    key: "getVibrations",
    value: function getVibrations() {
      return _objectSpread({}, _classPrivateFieldGet(_vibration, this));
    }
    /**
     * Returns the vibration pattern for drag start.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getStartVibration",
    value: function getStartVibration() {
      return _classPrivateFieldGet(_vibration, this).start;
    }
    /**
     * Returns the vibration pattern for drag end.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getEndVibration",
    value: function getEndVibration() {
      return _classPrivateFieldGet(_vibration, this).end;
    }
    /**
     * Returns the vibration pattern for collisions.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getCollideVibration",
    value: function getCollideVibration() {
      return _classPrivateFieldGet(_vibration, this).collide;
    }
    /**
     * Returns the vibration pattern during movement.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getMoveVibration",
    value: function getMoveVibration() {
      return _classPrivateFieldGet(_vibration, this).move;
    }
    /**
     * Returns whether the dragger is currently enabled.
     * @returns {boolean}
     */
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return _classPrivateFieldGet(_enabled, this);
    }
    /**
     * Internal method to verify if the instance has been destroyed.
     * Throws an error if any operation is attempted after destruction.
     */
  }, {
    key: "destroy",
    value:
    /**
     * Completely disables drag-and-drop and cleans up all event listeners.
     * Does NOT remove the original HTML element.
     */
    function destroy() {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      this.disable();
      _classPrivateFieldGet(_target, this).removeEventListener('mousedown', this._onMouseDown);
      _classPrivateFieldGet(_target, this).removeEventListener('touchstart', this._onTouchStart);
      document.removeEventListener('mousemove', this._onMouseMove);
      document.removeEventListener('mouseup', this._onMouseUp);
      document.removeEventListener('touchmove', this._onTouchMove);
      document.removeEventListener('touchend', this._onTouchEnd);
      if (_classPrivateFieldGet(_lastCollision, this)) _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
      if (_classPrivateFieldGet(_dragProxy, this)) {
        _classPrivateFieldGet(_dragProxy, this).remove();
        _classPrivateFieldSet(_dragProxy, this, null);
      }
      _classPrivateFieldSet(_collidables, this, []);
      _classPrivateFieldSet(_dragging, this, false);
      _classPrivateFieldSet(_lastCollision, this, null);
      _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_dragHiddenClass, this), _classPrivateFieldGet(_classDragging, this));
      document.body.classList.remove(_classPrivateFieldGet(_classBodyDragging, this));
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragging, this), _classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_destroyed, this, true);
    }
  }]);
}();
function _startDrag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_enabled, this) || !_classPrivateFieldGet(_target, this).parentElement) return;
  var dragProxy = _classPrivateFieldGet(_target, this).cloneNode(true);
  if (!(dragProxy instanceof HTMLElement)) return;
  _classPrivateFieldSet(_dragProxy, this, dragProxy);
  _classPrivateFieldSet(_dragging, this, true);
  var rect = _classPrivateFieldGet(_target, this).getBoundingClientRect();
  Object.assign(_classPrivateFieldGet(_dragProxy, this).style, {
    position: 'absolute',
    pointerEvents: 'none',
    left: "".concat(_classPrivateFieldGet(_target, this).offsetLeft, "px"),
    top: "".concat(_classPrivateFieldGet(_target, this).offsetTop, "px"),
    width: "".concat(rect.width, "px"),
    height: "".concat(rect.height, "px"),
    zIndex: 9999
  });
  _classPrivateFieldGet(_target, this).classList.add(_classPrivateFieldGet(_dragHiddenClass, this));
  _classPrivateFieldGet(_target, this).parentElement.appendChild(_classPrivateFieldGet(_dragProxy, this));
  var _this$getOffset = this.getOffset(event),
    offsetX = _this$getOffset.x,
    offsetY = _this$getOffset.y;
  _classPrivateFieldSet(_offsetX, this, offsetX);
  _classPrivateFieldSet(_offsetY, this, offsetY);
  _classPrivateFieldGet(_dragProxy, this).classList.add(_classPrivateFieldGet(_classDragging, this));
  document.body.classList.add(_classPrivateFieldGet(_classBodyDragging, this));
  if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.add(_classPrivateFieldGet(_classJailDragging, this));
  document.addEventListener('mousemove', this._onMouseMove);
  document.addEventListener('mouseup', this._onMouseUp);
  document.addEventListener('touchmove', this._onTouchMove, {
    passive: false
  });
  document.addEventListener('touchend', this._onTouchEnd);
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).start)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).start);
  }
  this.checkDragCollision(event);
  _assertClassBrand(_TinyDragger_brand, this, _dispatchEvent).call(this, 'drag');
}
/**
 * Marks an element as currently collided by adding the collision CSS class.
 * The element is stored in an internal list for easy removal later.
 *
 * @param {HTMLElement|null} el - The element to mark as collided.
 */
function _addCollision(el) {
  if (!el) return;
  el.classList.add(_classPrivateFieldGet(_classDragCollision, this));
  _classPrivateFieldGet(_collisionsMarked, this).push(el);
}
/**
 * Removes the collision CSS class from all previously marked elements.
 * Also clears the last single collision element, if set.
 *
 */
function _removeCollision() {
  while (_classPrivateFieldGet(_collisionsMarked, this).length > 0) {
    var el = _classPrivateFieldGet(_collisionsMarked, this).shift();
    if (el) el.classList.remove(_classPrivateFieldGet(_classDragCollision, this));
  }
  if (!_classPrivateFieldGet(_lastCollision, this)) return;
  _classPrivateFieldGet(_lastCollision, this).classList.remove(_classPrivateFieldGet(_classDragCollision, this));
}
function _drag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragging, this) || !_classPrivateFieldGet(_enabled, this) || !_classPrivateFieldGet(_dragProxy, this)) return;
  var parent = _classPrivateFieldGet(_dragProxy, this).offsetParent || document.body;
  var parentRect = parent.getBoundingClientRect();
  var x = event.clientX - parentRect.left - _classPrivateFieldGet(_offsetX, this);
  var y = event.clientY - parentRect.top - _classPrivateFieldGet(_offsetY, this);
  if (_classPrivateFieldGet(_lockInsideJail, this) && _classPrivateFieldGet(_jail, this)) {
    var jailRect = _classPrivateFieldGet(_jail, this).getBoundingClientRect();
    var targetRect = _classPrivateFieldGet(_dragProxy, this).getBoundingClientRect();
    var jailLeft = jailRect.left - parentRect.left;
    var jailTop = jailRect.top - parentRect.top;
    var _getHtmlElBordersWidt2 = (0, _html.getHtmlElBordersWidth)(_classPrivateFieldGet(_jail, this)),
      borderX = _getHtmlElBordersWidt2.x,
      borderY = _getHtmlElBordersWidt2.y;
    var maxX = jailLeft + jailRect.width - targetRect.width - borderY;
    var maxY = jailTop + jailRect.height - targetRect.height - borderX;
    x = Math.max(jailLeft, Math.min(x, maxX));
    y = Math.max(jailTop, Math.min(y, maxY));
  }
  _classPrivateFieldGet(_dragProxy, this).style.position = 'absolute';
  _classPrivateFieldGet(_dragProxy, this).style.left = "".concat(x, "px");
  _classPrivateFieldGet(_dragProxy, this).style.top = "".concat(y, "px");
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).move)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).move);
  }
  this.checkDragCollision(event);
  _assertClassBrand(_TinyDragger_brand, this, _dispatchEvent).call(this, 'dragging');
}
function _endDrag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragging, this)) return;
  _classPrivateFieldSet(_dragging, this, false);
  if (!_classPrivateFieldGet(_dragProxy, this)) return;
  _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_classDragging, this));
  document.body.classList.remove(_classPrivateFieldGet(_classBodyDragging, this));
  if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragging, this));
  document.removeEventListener('mousemove', this._onMouseMove);
  document.removeEventListener('mouseup', this._onMouseUp);
  document.removeEventListener('touchmove', this._onTouchMove);
  document.removeEventListener('touchend', this._onTouchEnd);
  var _this$execCollision2 = this.execCollision(event),
    collidedElements = _this$execCollision2.collidedElements;
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).end)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).end);
  }
  var newX = _classPrivateFieldGet(_dragProxy, this).style.left;
  var newY = _classPrivateFieldGet(_dragProxy, this).style.top;
  if (_classPrivateFieldGet(_dragProxy, this)) {
    _classPrivateFieldGet(_dragProxy, this).remove();
    _classPrivateFieldSet(_dragProxy, this, null);
  }
  if (_classPrivateFieldGet(_lastCollision, this)) _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
  _classPrivateFieldSet(_lastCollision, this, null);
  _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_dragHiddenClass, this));
  if (!_classPrivateFieldGet(_revertOnDrop, this)) {
    _classPrivateFieldGet(_target, this).style.left = newX;
    _classPrivateFieldGet(_target, this).style.top = newY;
  }
  var dropEvent = new CustomEvent('drop', {
    detail: {
      targets: collidedElements,
      first: collidedElements[0] || null
    }
  });
  _classPrivateFieldGet(_target, this).dispatchEvent(dropEvent);
}
/**
 * Checks if the provided element intersects with the given bounding rectangle.
 *
 * @param {HTMLElement} el - The element to test for collision.
 * @param {DOMRect} rect - The bounding rectangle to check against.
 * @returns {boolean} True if the element intersects with the rectangle.
 */
function _getCollidedElementByRect(el, rect) {
  var elRect = el.getBoundingClientRect();
  return !(rect.right < elRect.left || rect.left > elRect.right || rect.bottom < elRect.top || rect.top > elRect.bottom);
}
function _getCollidedElement(el, x, y) {
  var rect = el.getBoundingClientRect();
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}
function _dispatchEvent(type) {
  var event = new CustomEvent(type);
  _classPrivateFieldGet(_target, this).dispatchEvent(event);
}
function _checkDestroy() {
  if (_classPrivateFieldGet(_destroyed, this)) throw new Error('This TinyDragger instance has been destroyed and can no longer be used.');
}
var _default = exports["default"] = TinyDragger;

},{"../basics/html.mjs":118,"../basics/objFilter.mjs":119}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _center = /*#__PURE__*/new WeakMap();
var _list = /*#__PURE__*/new WeakMap();
var _badge = /*#__PURE__*/new WeakMap();
var _button = /*#__PURE__*/new WeakMap();
var _overlay = /*#__PURE__*/new WeakMap();
var _count = /*#__PURE__*/new WeakMap();
var _maxCount = /*#__PURE__*/new WeakMap();
var _removeDelay = /*#__PURE__*/new WeakMap();
var _markAllAsReadOnClose = /*#__PURE__*/new WeakMap();
var _modes = /*#__PURE__*/new WeakMap();
var _TinyNotifyCenter_brand = /*#__PURE__*/new WeakSet();
/**
 * Represents a single notification entry.
 *
 * A notification can be provided as a simple string (treated as a plain message),
 * or as an object with additional data such as a title, an avatar image, and a click handler.
 *
 * @typedef {string | {
 *   title?: string,              // Optional title displayed above the message
 *   message: string,             // Required message content
 *   avatar?: string,             // Optional avatar image URL (displayed on the left)
 *   onClick?: (e: MouseEvent) => void // Optional click handler for the entire notification
 * }} NotifyData
 */
/**
 * A notification center component for displaying interactive alerts in the UI.
 *
 * This class renders a notification overlay on the page and allows dynamically
 * adding, clearing, or interacting with notification items. Notifications can
 * contain plain text or HTML, and optionally support click events, titles, and avatars.
 *
 * Features:
 * - Dynamic rendering of notification UI with `insertTemplate()`
 * - Supports text and HTML content modes
 * - Optional avatars for each notification
 * - Callback support on notification click
 * - Per-notification close buttons
 * - Notification count badge
 *
 * @class
 */
var TinyNotifyCenter = /*#__PURE__*/function () {
  /**
   * Options for configuring the NotificationCenter instance.
   *
   * Allows manual specification of the main elements used by the notification center.
   * If not provided, default elements will be selected from the DOM automatically.
   *
   * @param {Object} options - Configuration object.
   * @param {HTMLElement} [options.center=document.getElementById('notifCenter')] - The container element that holds the list of notifications.
   * @param {HTMLElement} [options.badge=document.getElementById('notifBadge')] - The badge element used to display the current notification count.
   * @param {HTMLElement} [options.button=document.querySelector('.notify-bell')] - The button element that toggles the notification center.
   * @param {HTMLElement} [options.overlay=document.querySelector('.notify-overlay')] - The overlay element that covers the screen when the center is visible.
   */
  function TinyNotifyCenter() {
    var _center$querySelector,
      _this = this,
      _classPrivateFieldGet2;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, TinyNotifyCenter);
    /** @param {HTMLElement|ChildNode} item */
    _classPrivateMethodInitSpec(this, _TinyNotifyCenter_brand);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _center, void 0);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _list, void 0);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _badge, void 0);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _button, void 0);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _overlay, void 0);
    _classPrivateFieldInitSpec(this, _count, 0);
    _classPrivateFieldInitSpec(this, _maxCount, 99);
    _classPrivateFieldInitSpec(this, _removeDelay, 300);
    _classPrivateFieldInitSpec(this, _markAllAsReadOnClose, false);
    _classPrivateFieldInitSpec(this, _modes, new WeakMap());
    var _options$center = options.center,
      center = _options$center === void 0 ? document.getElementById('notifCenter') : _options$center,
      _options$badge = options.badge,
      badge = _options$badge === void 0 ? document.getElementById('notifBadge') : _options$badge,
      _options$button = options.button,
      button = _options$button === void 0 ? document.querySelector('.notify-bell') : _options$button,
      _options$overlay = options.overlay,
      overlay = _options$overlay === void 0 ? document.querySelector('.notify-overlay') : _options$overlay;
    // Element existence and type validation
    if (!(center instanceof HTMLElement)) throw new Error("NotificationCenter: \"center\" must be an HTMLElement. Got: ".concat(center));
    if (!(overlay instanceof HTMLElement)) throw new Error("NotificationCenter: \"overlay\" must be an HTMLElement. Got: ".concat(overlay));
    if (!(badge instanceof HTMLElement)) throw new Error("NotificationCenter: \"badge\" must be an HTMLElement. Got: ".concat(badge));
    if (!(button instanceof HTMLElement)) throw new Error("NotificationCenter: \"button\" must be an HTMLElement. Got: ".concat(button));
    var clearAllBtn = center === null || center === void 0 ? void 0 : center.querySelector('.clear-all');
    var list = (_center$querySelector = center === null || center === void 0 ? void 0 : center.querySelector('.list')) !== null && _center$querySelector !== void 0 ? _center$querySelector : null;
    if (!(list instanceof HTMLElement)) throw new Error("NotificationCenter: \".list\" inside center must be an HTMLElement. Got: ".concat(list));
    _classPrivateFieldSet(_center, this, center);
    _classPrivateFieldSet(_list, this, list);
    _classPrivateFieldSet(_badge, this, badge);
    _classPrivateFieldSet(_button, this, button);
    _classPrivateFieldSet(_overlay, this, overlay);
    _classPrivateFieldGet(_button, this).addEventListener('click', function () {
      return _this.toggle();
    });
    (_classPrivateFieldGet2 = _classPrivateFieldGet(_center, this).querySelector('.close')) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.addEventListener('click', function () {
      return _this.close();
    });
    if (clearAllBtn) clearAllBtn.addEventListener('click', function () {
      return _this.clear();
    });
    _classPrivateFieldGet(_overlay, this).addEventListener('click', function (e) {
      if (e.target === _classPrivateFieldGet(_overlay, _this)) _this.close();
    });
  }
  /**
   * Enable or disable automatic mark-as-read on close.
   * @param {boolean} value
   */
  return _createClass(TinyNotifyCenter, [{
    key: "setMarkAllAsReadOnClose",
    value: function setMarkAllAsReadOnClose(value) {
      if (typeof value !== 'boolean') throw new TypeError("Expected boolean for markAllAsReadOnClose, got ".concat(_typeof(value)));
      _classPrivateFieldSet(_markAllAsReadOnClose, this, value);
    }
    /**
     * Define how long the remove animation takes (in ms).
     * @param {number} ms
     */
  }, {
    key: "setRemoveDelay",
    value: function setRemoveDelay(ms) {
      if (typeof ms !== 'number') throw new Error("NotificationCenter: \"ms\" must be an number.");
      _classPrivateFieldSet(_removeDelay, this, ms);
    }
    /**
     * Get rendering mode ('text' or 'html') by index.
     * @param {number} index
     * @returns {'text' | 'html' | null}
     */
  }, {
    key: "getItemMode",
    value: function getItemMode(index) {
      var item = this.getItem(index);
      return item ? _classPrivateFieldGet(_modes, this).get(item) : null;
    }
    /**
     * Get a notify element by index.
     * @param {number} index
     * @returns {HTMLElement}
     */
  }, {
    key: "getItem",
    value: function getItem(index) {
      var element = _classPrivateFieldGet(_list, this).children.item(index);
      if (!(element instanceof HTMLElement)) throw new Error("NotificationCenter: \"item\" must be an HTMLElement. Got: ".concat(element));
      return element;
    }
    /**
     * Check if a notify exists at the given index.
     * @param {number} index
     * @returns {boolean}
     */
  }, {
    key: "hasItem",
    value: function hasItem(index) {
      return index >= 0 && index < _classPrivateFieldGet(_list, this).children.length;
    }
    /**
     * Mark a notification index as read.
     * @param {number|HTMLElement} index
     */
  }, {
    key: "markAsRead",
    value: function markAsRead(index) {
      var item = index instanceof HTMLElement ? index : this.getItem(index);
      if (item.classList.contains('unread')) {
        item.classList.remove('unread');
        _assertClassBrand(_TinyNotifyCenter_brand, this, _updateCount).call(this, _classPrivateFieldGet(_count, this) - 1);
      }
    }
    /**
     * Add a new notify to the center.
     *
     * @param {NotifyData} message - Notification content or a full object with title, avatar, and callback.
     * @param {'text'|'html'} [mode='text'] - How to treat the message content.
     */
  }, {
    key: "add",
    value: function add(message) {
      var _this2 = this;
      var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
      var item = document.createElement('div');
      item.className = 'item unread';
      var titleText = null;
      var messageText = null;
      var avatarUrl = null;
      var onClick = null;
      if (_typeof(message) === 'object' && message !== null) {
        titleText = message.title;
        messageText = message.message;
        avatarUrl = message.avatar;
        onClick = message.onClick;
      } else {
        messageText = message;
      }
      // Optional avatar
      if (avatarUrl) {
        var avatarElem = document.createElement('div');
        avatarElem.className = 'avatar';
        avatarElem.style.backgroundImage = "url(\"".concat(avatarUrl, "\")");
        item.appendChild(avatarElem);
      }
      // Content wrapper
      var contentWrapper = document.createElement('div');
      contentWrapper.className = 'content';
      // Optional title
      if (titleText) {
        var titleElem = document.createElement('div');
        titleElem.className = 'title';
        titleElem.textContent = titleText;
        contentWrapper.appendChild(titleElem);
      }
      // Message
      var messageElem = document.createElement('div');
      messageElem.className = 'message';
      if (mode === 'html') {
        messageElem.innerHTML = messageText;
      } else {
        messageElem.textContent = messageText;
      }
      contentWrapper.appendChild(messageElem);
      // Action by clicking (if provided)
      if (typeof onClick === 'function') {
        item.classList.add('clickable');
        item.addEventListener('click', function (e) {
          // Prevents the close button from clicking
          if (e.target instanceof HTMLElement && !e.target.closest('.notify-close')) {
            onClick(e);
          }
        });
      }
      // Close button
      var closeBtn = document.createElement('button');
      closeBtn.className = 'notify-close';
      closeBtn.setAttribute('type', 'button');
      closeBtn.innerHTML = '&times;';
      closeBtn.addEventListener('click', function (e) {
        e.stopPropagation(); // prevents propagation for the main onClick
        _assertClassBrand(_TinyNotifyCenter_brand, _this2, _removeItem).call(_this2, item);
      });
      item.append(contentWrapper, closeBtn);
      _classPrivateFieldGet(_list, this).prepend(item);
      _classPrivateFieldGet(_modes, this).set(item, mode);
      _assertClassBrand(_TinyNotifyCenter_brand, this, _updateCount).call(this, _classPrivateFieldGet(_count, this) + 1);
    }
    /**
     * Remove a notify by index.
     * @param {number} index
     */
  }, {
    key: "remove",
    value: function remove(index) {
      var item = this.getItem(index);
      _assertClassBrand(_TinyNotifyCenter_brand, this, _removeItem).call(this, item);
    }
    /**
     * Clear all notifications safely.
     */
  }, {
    key: "clear",
    value: function clear() {
      var needAgain = true;
      while (needAgain) {
        needAgain = false;
        var items = Array.from(_classPrivateFieldGet(_list, this).children);
        for (var _i = 0, _items = items; _i < _items.length; _i++) {
          var item = _items[_i];
          if (item instanceof HTMLElement && !item.classList.contains('removing')) {
            _assertClassBrand(_TinyNotifyCenter_brand, this, _removeItem).call(this, item);
            needAgain = true;
          }
        }
      }
    }
    /**
     * Open the notify center.
     */
  }, {
    key: "open",
    value: function open() {
      _classPrivateFieldGet(_overlay, this).classList.remove('hidden');
      _classPrivateFieldGet(_center, this).classList.add('open');
    }
    /**
     * Close the notify center.
     */
  }, {
    key: "close",
    value: function close() {
      _classPrivateFieldGet(_overlay, this).classList.add('hidden');
      _classPrivateFieldGet(_center, this).classList.remove('open');
      if (_classPrivateFieldGet(_markAllAsReadOnClose, this)) {
        var items = _classPrivateFieldGet(_list, this).querySelectorAll('.item.unread');
        var _iterator = _createForOfIteratorHelper(items),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var item = _step.value;
            if (item instanceof HTMLElement) this.markAsRead(item);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    /**
     * Toggle open/close state.
     */
  }, {
    key: "toggle",
    value: function toggle() {
      if (_classPrivateFieldGet(_center, this).classList.contains('open')) this.close();else this.open();
    }
    /**
     * Recalculate the number of notifications based on the actual DOM list.
     */
  }, {
    key: "recount",
    value: function recount() {
      var count = _classPrivateFieldGet(_list, this).querySelectorAll('.item.unread').length;
      _assertClassBrand(_TinyNotifyCenter_brand, this, _updateCount).call(this, count);
    }
    /**
     * Get current count.
     * @returns {number}
     */
  }, {
    key: "count",
    get: function get() {
      return _classPrivateFieldGet(_count, this);
    }
    /**
     * Destroys the notification center instance, removing all event listeners,
     * clearing notifications, and optionally removing DOM elements.
     *
     * Call this when the notification center is no longer needed to prevent memory leaks.
     *
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _classPrivateFieldGet3, _classPrivateFieldGet4, _classPrivateFieldGet5, _classPrivateFieldGet6, _classPrivateFieldGet7, _classPrivateFieldGet8, _classPrivateFieldGet9;
      // Remove event listeners
      (_classPrivateFieldGet3 = _classPrivateFieldGet(_button, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.removeEventListener('click', this.toggle);
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_center, this)) === null || _classPrivateFieldGet4 === void 0 || (_classPrivateFieldGet4 = _classPrivateFieldGet4.querySelector('.close')) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.removeEventListener('click', this.close);
      (_classPrivateFieldGet5 = _classPrivateFieldGet(_center, this)) === null || _classPrivateFieldGet5 === void 0 || (_classPrivateFieldGet5 = _classPrivateFieldGet5.querySelector('.clear-all')) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.removeEventListener('click', this.clear);
      (_classPrivateFieldGet6 = _classPrivateFieldGet(_overlay, this)) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.removeEventListener('click', this.close);
      // Clear all notifications
      this.clear();
      (_classPrivateFieldGet7 = _classPrivateFieldGet(_center, this)) === null || _classPrivateFieldGet7 === void 0 || _classPrivateFieldGet7.remove();
      (_classPrivateFieldGet8 = _classPrivateFieldGet(_overlay, this)) === null || _classPrivateFieldGet8 === void 0 || _classPrivateFieldGet8.remove();
      (_classPrivateFieldGet9 = _classPrivateFieldGet(_button, this)) === null || _classPrivateFieldGet9 === void 0 || _classPrivateFieldGet9.remove();
      // Clean internal references
      // this.#center = null;
      // this.#list = null;
      // this.#badge = null;
      // this.#button = null;
      // this.#overlay = null;
      _classPrivateFieldSet(_count, this, 0);
      _classPrivateFieldSet(_modes, this, new WeakMap());
    }
  }], [{
    key: "getTemplate",
    value:
    /**
     * Returns the full HTML structure for the notification system as a string.
     *
     * This includes:
     * - A hidden `.notify-overlay` containing the central notification panel (`#notifCenter`),
     *   which has a header with a "Notifications" label, a "clear all" button, and a close button.
     * - A `.list` container for dynamically added notifications.
     * - A bell button (`.notify-bell`) to toggle the notification center, with an embedded badge.
     *
     * This template can be inserted into the DOM using `insertAdjacentHTML()` or parsed dynamically
     * into elements using JavaScript or jQuery, depending on the needs of the system.
     *
     * @returns {string} The complete HTML structure for the notification center.
     */
    function getTemplate() {
      return "\n<div class=\"notify-overlay hidden\">\n  <div class=\"notify-center\" id=\"notifCenter\">\n    <div class=\"header\">\n      <div>Notifications</div>\n      <div class=\"options\">\n        <button class=\"clear-all\" type=\"button\">\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            viewBox=\"0 0 24 24\"\n            width=\"24\"\n            height=\"24\"\n            fill=\"currentColor\"\n          >\n            <path\n              d=\"M21.6 2.4a1 1 0 0 0-1.4 0L13 9.6l-1.3-1.3a1 1 0 0 0-1.4 0L3 15.6a1 1 0 0 0 0 1.4l4 4a1 1 0 0 0 1.4 0l7.3-7.3a1 1 0 0 0 0-1.4l-1.3-1.3 7.2-7.2a1 1 0 0 0 0-1.4zM6 17l3.5-3.5 1.5 1.5L7.5 18.5 6 17z\"\n            />\n          </svg>\n        </button>\n        <button class=\"close\">\xD7</button>\n      </div>\n    </div>\n    <div class=\"list\"></div>\n  </div>\n</div>\n\n<button class=\"notify-bell\" aria-label=\"Open notifications\">\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"20\"\n    height=\"20\"\n    fill=\"currentColor\"\n    viewBox=\"0 0 24 24\"\n  >\n    <path\n      d=\"M12 2C10.3 2 9 3.3 9 5v1.1C6.7 7.2 5 9.4 5 12v5l-1 1v1h16v-1l-1-1v-5c0-2.6-1.7-4.8-4-5.9V5c0-1.7-1.3-3-3-3zm0 20c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2z\"\n    />\n  </svg>\n  <span class=\"badge\" id=\"notifBadge\">0</span>\n</button>\n    ";
    }
    /**
     * Inserts the full notification center template into the document body.
     *
     * The structure is injected directly into the DOM using
     * `insertAdjacentHTML`.
     *
     * The `where` parameter allows control over where inside the `document.body`
     * the HTML is inserted:
     * - `'afterbegin'` (default): Inserts right after the opening <body> tag.
     * - `'beforeend'`: Inserts right before the closing </body> tag.
     * - Any valid position accepted by `insertAdjacentHTML`.
     *
     * @param {'beforebegin'|'afterbegin'|'beforeend'|'afterend'} [where='afterbegin']
     * The position relative to `document.body` where the HTML should be inserted.
     */
  }, {
    key: "insertTemplate",
    value: function insertTemplate() {
      var where = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'afterbegin';
      document.body.insertAdjacentHTML(where, TinyNotifyCenter.getTemplate());
    }
  }]);
}();
function _removeItem(item) {
  var _this3 = this;
  _classPrivateFieldGet(_modes, this)["delete"](item);
  if (item instanceof HTMLElement) {
    item.classList.add('removing');
    setTimeout(function () {
      _this3.markAsRead(item);
      item.remove();
    }, _classPrivateFieldGet(_removeDelay, this));
  } else throw new Error('Invalid HTMLElement to clear.');
}
/**
 * Update notify count and badge.
 * @param {number} value
 */
function _updateCount(value) {
  _classPrivateFieldSet(_count, this, Math.max(0, value));
  _classPrivateFieldGet(_badge, this).setAttribute('data-value', String(_classPrivateFieldGet(_count, this)));
  _classPrivateFieldGet(_badge, this).textContent = _classPrivateFieldGet(_count, this) > _classPrivateFieldGet(_maxCount, this) ? "".concat(_classPrivateFieldGet(_maxCount, this), "+") : String(_classPrivateFieldGet(_count, this));
}
var _default = exports["default"] = TinyNotifyCenter;

},{}],130:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _queue = /*#__PURE__*/new WeakMap();
var _running = /*#__PURE__*/new WeakMap();
var _timeouts = /*#__PURE__*/new WeakMap();
var _blacklist = /*#__PURE__*/new WeakMap();
var _TinyPromiseQueue_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {Object} QueuedTask
 * @property {(...args: any[]) => Promise<any>|Promise<any>} task - The async task to execute.
 * @property {(value: any) => any} resolve - The resolve function from the Promise.
 * @property {(reason?: any) => any} reject - The reject function from the Promise.
 * @property {string|undefined} [id] - Optional identifier for the task.
 * @property {string|null|undefined} [marker] - Optional marker for the task.
 * @property {number|null|undefined} [delay] - Optional delay (in ms) before the task is executed.
 */
/**
 * A queue system for managing and executing asynchronous tasks sequentially, one at a time.
 *
 * Tasks can be delayed, reordered, canceled, and processed in strict order. The queue ensures that each task
 * is executed after the previous one finishes, and any task can be skipped or canceled if needed.
 *
 * @class
 */
var TinyPromiseQueue = /*#__PURE__*/function () {
  function TinyPromiseQueue() {
    _classCallCheck(this, TinyPromiseQueue);
    /**
     * Processes the a normal task.
     *
     * @param {QueuedTask} data
     *
     * @returns {Promise<void>}
     */
    _classPrivateMethodInitSpec(this, _TinyPromiseQueue_brand);
    /** @type {QueuedTask[]} */
    _classPrivateFieldInitSpec(this, _queue, []);
    _classPrivateFieldInitSpec(this, _running, false);
    /** @type {Record<string, ReturnType<typeof setTimeout>>} */
    _classPrivateFieldInitSpec(this, _timeouts, {});
    /** @type {Set<string>} */
    _classPrivateFieldInitSpec(this, _blacklist, new Set());
  }
  return _createClass(TinyPromiseQueue, [{
    key: "isRunning",
    value:
    /**
     * Returns whether the queue is currently processing a task.
     *
     * @returns {boolean}
     */
    function isRunning() {
      return _classPrivateFieldGet(_running, this);
    }
  }, {
    key: "getIndexById",
    value:
    /**
     * Returns the index of a task by its ID.
     *
     * @param {string} id The ID of the task to locate.
     * @returns {number} The index of the task in the queue, or -1 if not found.
     */
    function getIndexById(id) {
      return _classPrivateFieldGet(_queue, this).findIndex(function (item) {
        return item.id === id;
      });
    }
    /**
     * Returns a list of IDs for all tasks currently in the queue.
     *
     * @returns {{ index: number, id: string }[]} An array of task IDs currently queued.
     */
  }, {
    key: "getQueuedIds",
    value: function getQueuedIds() {
      // @ts-ignore
      return _classPrivateFieldGet(_queue, this).map(function (item, index) {
        return {
          index: index,
          id: item.id
        };
      }).filter(function (entry) {
        return typeof entry.id === 'string';
      });
    }
    /**
     * Reorders a task in the queue from one index to another.
     *
     * @param {number} fromIndex The current index of the task to move.
     * @param {number} toIndex The index where the task should be placed.
     */
  }, {
    key: "reorderQueue",
    value: function reorderQueue(fromIndex, toIndex) {
      if (typeof fromIndex !== 'number' || typeof toIndex !== 'number' || fromIndex < 0 || toIndex < 0 || fromIndex >= _classPrivateFieldGet(_queue, this).length || toIndex >= _classPrivateFieldGet(_queue, this).length) return;
      var _classPrivateFieldGet2 = _classPrivateFieldGet(_queue, this).splice(fromIndex, 1),
        _classPrivateFieldGet3 = _slicedToArray(_classPrivateFieldGet2, 1),
        item = _classPrivateFieldGet3[0];
      _classPrivateFieldGet(_queue, this).splice(toIndex, 0, item);
    }
    /**
     * Inserts a point in the queue where subsequent tasks will be grouped and executed together in a Promise.all.
     * If the queue is currently empty, behaves like a regular promise.
     *
     * @param {(...args: any[]) => Promise<any>|Promise<any>} task A function that returns a Promise.
     * @param {string} [id] Optional ID to identify the task in the queue.
     * @returns {Promise<any>} A Promise that resolves or rejects with the result of the task once it's processed.
     * @throws {Error} Throws if param is invalid.
     */
  }, {
    key: "enqueuePoint",
    value: (function () {
      var _enqueuePoint = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(task, id) {
        var _this = this;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!(typeof task !== 'function')) {
                _context.n = 1;
                break;
              }
              return _context.a(2, Promise.reject(new Error('Task must be a function returning a Promise.')));
            case 1:
              if (!(typeof id !== 'undefined' && typeof id !== 'string')) {
                _context.n = 2;
                break;
              }
              throw new Error('The "id" parameter must be a string.');
            case 2:
              if (_classPrivateFieldGet(_running, this)) {
                _context.n = 3;
                break;
              }
              return _context.a(2, task());
            case 3:
              return _context.a(2, new Promise(function (resolve, reject) {
                _classPrivateFieldGet(_queue, _this).push({
                  marker: 'POINT_MARKER',
                  task: task,
                  resolve: resolve,
                  reject: reject,
                  id: id
                });
                _assertClassBrand(_TinyPromiseQueue_brand, _this, _processQueue).call(_this);
              }));
          }
        }, _callee, this);
      }));
      function enqueuePoint(_x, _x2) {
        return _enqueuePoint.apply(this, arguments);
      }
      return enqueuePoint;
    }()
    /**
     * Adds a new async task to the queue and ensures it runs in order after previous tasks.
     * Optionally, a delay can be added before the task is executed.
     *
     * If the task is canceled before execution, it will be rejected with the message:
     * "The function was canceled on TinyPromiseQueue."
     *
     * @param {(...args: any[]) => Promise<any>|Promise<any>} task A function that returns a Promise to be executed sequentially.
     * @param {number|null} [delay] Optional delay (in ms) before the task is executed.
     * @param {string} [id] Optional ID to identify the task in the queue.
     * @returns {Promise<any>} A Promise that resolves or rejects with the result of the task once it's processed.
     * @throws {Error} Throws if param is invalid.
     */
    )
  }, {
    key: "enqueue",
    value: function enqueue(task, delay, id) {
      var _this2 = this;
      if (typeof task !== 'function') return Promise.reject(new Error('Task must be a function returning a Promise.'));
      if (typeof delay !== 'undefined' && (typeof delay !== 'number' || delay < 0)) return Promise.reject(new Error('Delay must be a positive number or undefined.'));
      if (typeof id !== 'undefined' && typeof id !== 'string') throw new Error('The "id" parameter must be a string.');
      return new Promise(function (resolve, reject) {
        _classPrivateFieldGet(_queue, _this2).push({
          task: task,
          resolve: resolve,
          reject: reject,
          id: id,
          delay: delay
        });
        _assertClassBrand(_TinyPromiseQueue_brand, _this2, _processQueue).call(_this2);
      });
    }
    /**
     * Cancels a scheduled delay and removes the task from the queue.
     * Adds the ID to a blacklist so the task is skipped if already being processed.
     *
     * @param {string} id The ID of the task to cancel.
     * @returns {boolean} True if a delay was cancelled and the task was removed.
     * @throws {Error} Throws if `id` is not a string.
     */
  }, {
    key: "cancelTask",
    value: function cancelTask(id) {
      if (typeof id !== 'string') throw new Error('The "id" parameter must be a string.');
      var cancelled = false;
      if (id in _classPrivateFieldGet(_timeouts, this)) {
        clearTimeout(_classPrivateFieldGet(_timeouts, this)[id]);
        delete _classPrivateFieldGet(_timeouts, this)[id];
        cancelled = true;
      }
      var index = this.getIndexById(id);
      if (index !== -1) {
        var _removed$reject;
        var _classPrivateFieldGet4 = _classPrivateFieldGet(_queue, this).splice(index, 1),
          _classPrivateFieldGet5 = _slicedToArray(_classPrivateFieldGet4, 1),
          removed = _classPrivateFieldGet5[0];
        removed === null || removed === void 0 || (_removed$reject = removed.reject) === null || _removed$reject === void 0 || _removed$reject.call(removed, new Error('The function was canceled on TinyPromiseQueue.'));
        cancelled = true;
      }
      if (cancelled) _classPrivateFieldGet(_blacklist, this).add(id);
      return cancelled;
    }
  }]);
}();
function _normalProcessQueue(_x3) {
  return _normalProcessQueue2.apply(this, arguments);
}
function _normalProcessQueue2() {
  _normalProcessQueue2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(data) {
    var _this3 = this;
    var task, resolve, reject, delay, id, result, _t;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          if (!(data && typeof data.task === 'function' && typeof data.resolve === 'function' && typeof data.reject === 'function')) {
            _context2.n = 7;
            break;
          }
          task = data.task, resolve = data.resolve, reject = data.reject, delay = data.delay, id = data.id;
          _context2.p = 1;
          if (!(id && _classPrivateFieldGet(_blacklist, this).has(id))) {
            _context2.n = 2;
            break;
          }
          reject(new Error('The function was canceled on TinyPromiseQueue.'));
          _classPrivateFieldGet(_blacklist, this)["delete"](id);
          _classPrivateFieldSet(_running, this, false);
          _assertClassBrand(_TinyPromiseQueue_brand, this, _processQueue).call(this);
          return _context2.a(2);
        case 2:
          if (!(delay && id)) {
            _context2.n = 3;
            break;
          }
          _context2.n = 3;
          return new Promise(function (resolveDelay) {
            var timeoutId = setTimeout(function () {
              delete _classPrivateFieldGet(_timeouts, _this3)[id];
              resolveDelay(null);
            }, delay);
            _classPrivateFieldGet(_timeouts, _this3)[id] = timeoutId;
          });
        case 3:
          _context2.n = 4;
          return task();
        case 4:
          result = _context2.v;
          resolve(result);
          _context2.n = 6;
          break;
        case 5:
          _context2.p = 5;
          _t = _context2.v;
          reject(_t);
        case 6:
          _context2.p = 6;
          _classPrivateFieldSet(_running, this, false);
          _assertClassBrand(_TinyPromiseQueue_brand, this, _processQueue).call(this);
          return _context2.f(6);
        case 7:
          return _context2.a(2);
      }
    }, _callee2, this, [[1, 5, 6, 7]]);
  }));
  return _normalProcessQueue2.apply(this, arguments);
}
/**
 * Processes a group task.
 *
 * @returns {Promise<void>}
 */
function _groupProcessQueue() {
  return _groupProcessQueue2.apply(this, arguments);
}
function _groupProcessQueue2() {
  _groupProcessQueue2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
    var _this4 = this;
    var grouped, _classPrivateFieldGet6;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          /** @type {Array<QueuedTask>} */
          grouped = [];
          while (_classPrivateFieldGet(_queue, this).length && ((_classPrivateFieldGet6 = _classPrivateFieldGet(_queue, this)[0]) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.marker) === 'POINT_MARKER') {
            // @ts-ignore
            grouped.push(_classPrivateFieldGet(_queue, this).shift());
          }
          if (!(grouped.length === 0)) {
            _context4.n = 1;
            break;
          }
          _classPrivateFieldSet(_running, this, false);
          _assertClassBrand(_TinyPromiseQueue_brand, this, _processQueue).call(this);
          return _context4.a(2);
        case 1:
          _context4.n = 2;
          return Promise.all(grouped.map(function (_ref) {
            var task = _ref.task,
              resolve = _ref.resolve,
              reject = _ref.reject,
              id = _ref.id;
            return new Promise(/*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(pResolve) {
                return _regenerator().w(function (_context3) {
                  while (1) switch (_context3.n) {
                    case 0:
                      if (!(id && _classPrivateFieldGet(_blacklist, _this4).has(id))) {
                        _context3.n = 1;
                        break;
                      }
                      _classPrivateFieldGet(_blacklist, _this4)["delete"](id);
                      reject(new Error('The function was canceled on TinyPromiseQueue.'));
                      pResolve(true);
                      return _context3.a(2);
                    case 1:
                      _context3.n = 2;
                      return task().then(resolve)["catch"](reject);
                    case 2:
                      pResolve(true);
                    case 3:
                      return _context3.a(2);
                  }
                }, _callee3);
              }));
              return function (_x4) {
                return _ref2.apply(this, arguments);
              };
            }());
          }));
        case 2:
          _classPrivateFieldSet(_running, this, false);
          _assertClassBrand(_TinyPromiseQueue_brand, this, _processQueue).call(this);
        case 3:
          return _context4.a(2);
      }
    }, _callee4, this);
  }));
  return _groupProcessQueue2.apply(this, arguments);
}
/**
 * Processes the next task in the queue if not already running.
 * Ensures tasks are executed in order, one at a time.
 *
 * @returns {Promise<void>}
 */
function _processQueue() {
  return _processQueue2.apply(this, arguments);
}
function _processQueue2() {
  _processQueue2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
    var _classPrivateFieldGet7, _classPrivateFieldGet8;
    var data;
    return _regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          if (!(_classPrivateFieldGet(_running, this) || _classPrivateFieldGet(_queue, this).length === 0)) {
            _context5.n = 1;
            break;
          }
          return _context5.a(2);
        case 1:
          _classPrivateFieldSet(_running, this, true);
          if (typeof ((_classPrivateFieldGet7 = _classPrivateFieldGet(_queue, this)[0]) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.marker) !== 'string' || ((_classPrivateFieldGet8 = _classPrivateFieldGet(_queue, this)[0]) === null || _classPrivateFieldGet8 === void 0 ? void 0 : _classPrivateFieldGet8.marker) !== 'POINT_MARKER') {
            data = _classPrivateFieldGet(_queue, this).shift(); // @ts-ignore
            _assertClassBrand(_TinyPromiseQueue_brand, this, _normalProcessQueue).call(this, data);
          } else _assertClassBrand(_TinyPromiseQueue_brand, this, _groupProcessQueue).call(this);
        case 2:
          return _context5.a(2);
      }
    }, _callee5, this);
  }));
  return _processQueue2.apply(this, arguments);
}
var _default = exports["default"] = TinyPromiseQueue;

},{}],131:[function(require,module,exports){
(function (process){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _maxMemory = /*#__PURE__*/new WeakMap();
var _cleanupTimer = /*#__PURE__*/new WeakMap();
var _maxHits = /*#__PURE__*/new WeakMap();
var _interval = /*#__PURE__*/new WeakMap();
var _cleanupInterval = /*#__PURE__*/new WeakMap();
var _maxIdle = /*#__PURE__*/new WeakMap();
var _onMemoryExceeded = /*#__PURE__*/new WeakMap();
var _onGroupExpired = /*#__PURE__*/new WeakMap();
/** @typedef {(groupId: string) => void} OnMemoryExceeded */
/** @typedef {(groupId: string) => void} OnGroupExpired */
/**
 * Class representing a flexible rate limiter per user or group.
 *
 * This rate limiter supports limiting per user or per group by mapping
 * userIds to a common groupId. All users within the same group share
 * rate limits.
 */
var TinyRateLimiter = /*#__PURE__*/function () {
  /**
   * @param {Object} options
   * @param {number|null} [options.maxMemory] - Max memory allowed
   * @param {number} [options.maxHits] - Max interactions allowed
   * @param {number} [options.interval] - Time window in milliseconds
   * @param {number} [options.cleanupInterval] - Interval for automatic cleanup (ms)
   * @param {number} [options.maxIdle=300000] - Max idle time for a user before being cleaned (ms)
   */
  function TinyRateLimiter(_ref) {
    var _this = this;
    var maxHits = _ref.maxHits,
      interval = _ref.interval,
      cleanupInterval = _ref.cleanupInterval,
      _ref$maxIdle = _ref.maxIdle,
      maxIdle = _ref$maxIdle === void 0 ? 300000 : _ref$maxIdle,
      _ref$maxMemory = _ref.maxMemory,
      maxMemory = _ref$maxMemory === void 0 ? 100000 : _ref$maxMemory;
    _classCallCheck(this, TinyRateLimiter);
    /** @type {number|null} */
    _classPrivateFieldInitSpec(this, _maxMemory, null);
    /** @type {NodeJS.Timeout|null} */
    _classPrivateFieldInitSpec(this, _cleanupTimer, null);
    /** @type {number|null|undefined} */
    _classPrivateFieldInitSpec(this, _maxHits, null);
    /** @type {number|null|undefined} */
    _classPrivateFieldInitSpec(this, _interval, null);
    /** @type {number|null|undefined} */
    _classPrivateFieldInitSpec(this, _cleanupInterval, null);
    /** @type {number|null|undefined} */
    _classPrivateFieldInitSpec(this, _maxIdle, null);
    /** @type {Map<string, number[]>} */
    _defineProperty(this, "groupData", new Map());
    // groupId -> timestamps[]
    /** @type {Map<string, number>} */
    _defineProperty(this, "lastSeen", new Map());
    // groupId -> timestamp
    /** @type {Map<string, string>} */
    _defineProperty(this, "userToGroup", new Map());
    // userId -> groupId
    /** @type {Map<string, boolean>} */
    _defineProperty(this, "groupFlags", new Map());
    // groupId -> boolean
    /**
     * @type {Map<string, number>}
     * Stores TTL (in ms) for each groupId individually
     */
    _defineProperty(this, "groupTTL", new Map());
    /**
     * @type {null|OnMemoryExceeded}
     */
    _classPrivateFieldInitSpec(this, _onMemoryExceeded, null);
    /**
     * @type {null|OnGroupExpired}
     */
    _classPrivateFieldInitSpec(this, _onGroupExpired, null);
    /** @param {number|undefined} val */
    var isPositiveInteger = function isPositiveInteger(val) {
      return typeof val === 'number' && Number.isFinite(val) && val >= 1 && Number.isInteger(val);
    };
    var isMaxHitsValid = isPositiveInteger(maxHits);
    var isIntervalValid = isPositiveInteger(interval);
    var isCleanupValid = isPositiveInteger(cleanupInterval);
    var isMaxIdleValid = isPositiveInteger(maxIdle);
    if (!isMaxHitsValid && !isIntervalValid) throw new Error("RateLimiter requires at least one valid option: 'maxHits' or 'interval'.");
    if (maxHits !== undefined && !isMaxHitsValid) throw new Error("'maxHits' must be a positive integer if defined.");
    if (interval !== undefined && !isIntervalValid) throw new Error("'interval' must be a positive integer in milliseconds if defined.");
    if (cleanupInterval !== undefined && !isCleanupValid) throw new Error("'cleanupInterval' must be a positive integer in milliseconds if defined.");
    if (!isMaxIdleValid) throw new Error("'maxIdle' must be a positive integer in milliseconds.");
    if (typeof maxMemory === 'number' && Number.isFinite(maxMemory) && maxMemory > 0) {
      _classPrivateFieldSet(_maxMemory, this, Math.floor(maxMemory));
    } else if (maxMemory === null || maxMemory === undefined) {
      _classPrivateFieldSet(_maxMemory, this, null);
    } else {
      throw new Error('maxMemory must be a positive number or null');
    }
    _classPrivateFieldSet(_maxHits, this, isMaxHitsValid ? maxHits : null);
    _classPrivateFieldSet(_interval, this, isIntervalValid ? interval : null);
    _classPrivateFieldSet(_cleanupInterval, this, isCleanupValid ? cleanupInterval : null);
    _classPrivateFieldSet(_maxIdle, this, maxIdle);
    // Start automatic cleanup only if cleanupInterval is valid
    if (_classPrivateFieldGet(_cleanupInterval, this) !== null) _classPrivateFieldSet(_cleanupTimer, this, setInterval(function () {
      return _this._cleanup();
    }, _classPrivateFieldGet(_cleanupInterval, this)));
  }
  /**
   * Check if a given ID is a groupId (not a userId)
   * @param {string} id
   * @returns {boolean}
   */
  return _createClass(TinyRateLimiter, [{
    key: "setOnMemoryExceeded",
    value:
    /**
     * Set the callback to be triggered when a group exceeds its limit
     * @param {OnMemoryExceeded} callback
     */
    function setOnMemoryExceeded(callback) {
      if (typeof callback !== 'function') throw new Error('onMemoryExceeded must be a function');
      _classPrivateFieldSet(_onMemoryExceeded, this, callback);
    }
    /**
     * Clear the onMemoryExceeded callback
     */
  }, {
    key: "clearOnMemoryExceeded",
    value: function clearOnMemoryExceeded() {
      _classPrivateFieldSet(_onMemoryExceeded, this, null);
    }
  }, {
    key: "setOnGroupExpired",
    value:
    /**
     * Set the callback to be triggered when a group expires and is removed.
     *
     * This callback is called automatically during cleanup when a group
     * becomes inactive for longer than its TTL.
     *
     * @param {OnGroupExpired} callback - A function that receives the expired groupId.
     */
    function setOnGroupExpired(callback) {
      if (typeof callback !== 'function') throw new Error('onGroupExpired must be a function');
      _classPrivateFieldSet(_onGroupExpired, this, callback);
    }
    /**
     * Clear the onGroupExpired callback
     */
  }, {
    key: "clearOnGroupExpired",
    value: function clearOnGroupExpired() {
      _classPrivateFieldSet(_onGroupExpired, this, null);
    }
  }, {
    key: "isGroupId",
    value: function isGroupId(id) {
      var result = this.groupFlags.get(id);
      return typeof result === 'boolean' ? result : false;
    }
    /**
     * Get all user IDs that belong to a given group.
     * @param {string} groupId
     * @returns {string[]}
     */
  }, {
    key: "getUsersInGroup",
    value: function getUsersInGroup(groupId) {
      var users = [];
      var _iterator = _createForOfIteratorHelper(this.userToGroup.entries()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            userId = _step$value[0],
            assignedGroup = _step$value[1];
          if (assignedGroup === groupId) {
            users.push(userId);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return users;
    }
    /**
     * Set TTL (in milliseconds) for a specific group
     * @param {string} groupId
     * @param {number} ttl
     */
  }, {
    key: "setGroupTTL",
    value: function setGroupTTL(groupId, ttl) {
      if (typeof ttl !== 'number' || !Number.isFinite(ttl) || ttl <= 0) throw new Error('TTL must be a positive number in milliseconds');
      this.groupTTL.set(groupId, ttl);
    }
    /**
     * Get TTL (in ms) for a specific group.
     * @param {string} groupId
     * @returns {number|null}
     */
  }, {
    key: "getGroupTTL",
    value: function getGroupTTL(groupId) {
      var _this$groupTTL$get;
      return (_this$groupTTL$get = this.groupTTL.get(groupId)) !== null && _this$groupTTL$get !== void 0 ? _this$groupTTL$get : null;
    }
    /**
     * Delete the TTL setting for a specific group
     * @param {string} groupId
     */
  }, {
    key: "deleteGroupTTL",
    value: function deleteGroupTTL(groupId) {
      this.groupTTL["delete"](groupId);
    }
    /**
     * Assign a userId to a groupId, with merge if user has existing data.
     * @param {string} userId
     * @param {string} groupId
     * @throws {Error} If userId is already assigned to a different group
     */
  }, {
    key: "assignToGroup",
    value: function assignToGroup(userId, groupId) {
      var existingGroup = this.userToGroup.get(userId);
      if (existingGroup && existingGroup !== groupId) throw new Error("User ".concat(userId, " is already assigned to group ").concat(existingGroup));
      // If the user is already in the group, nothing needs to be done
      if (existingGroup === groupId) return;
      var userData = this.groupData.get(userId);
      // Associates the user to the group
      if (this.isGroupId(userId)) {
        var _iterator2 = _createForOfIteratorHelper(this.userToGroup.entries()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
              uid = _step2$value[0],
              gId = _step2$value[1];
            if (gId === userId) this.userToGroup.set(uid, groupId);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        this.userToGroup["delete"](userId);
      } else this.userToGroup.set(userId, groupId);
      // If the user has no data, nothing needs to be done
      if (!userData) return;
      var groupData = this.groupData.get(groupId);
      if (groupData) {
        var _iterator3 = _createForOfIteratorHelper(userData),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var item = _step3.value;
            groupData.push(item);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } else {
        var newData = [];
        var _iterator4 = _createForOfIteratorHelper(userData),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _item = _step4.value;
            newData.push(_item);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        this.groupData.set(groupId, newData);
      }
      this.lastSeen.set(groupId, Date.now());
      // Removes individual data as they are now in the group
      this.groupFlags["delete"](userId);
      this.groupData["delete"](userId);
      this.lastSeen["delete"](userId);
      this.groupTTL["delete"](userId);
      this.groupFlags.set(groupId, true);
    }
    /**
     * Get the groupId for a given userId
     * @param {string} userId
     * @returns {string}
     */
  }, {
    key: "getGroupId",
    value: function getGroupId(userId) {
      return this.userToGroup.get(userId) || userId; // fallback: use userId as own group
    }
    /**
     * Register a hit for a specific user
     * @param {string} userId
     */
  }, {
    key: "hit",
    value: function hit(userId) {
      var groupId = this.getGroupId(userId);
      var now = Date.now();
      if (!this.groupData.has(groupId)) {
        this.groupData.set(groupId, []);
        this.groupFlags.set(groupId, false);
      }
      var history = this.groupData.get(groupId);
      if (!history) throw new Error("No data found for groupId: ".concat(groupId));
      history.push(now);
      this.lastSeen.set(groupId, now);
      // Clean up old entries
      if (_classPrivateFieldGet(_interval, this) !== null) {
        var interval = this.getInterval();
        var cutoff = now - interval;
        while (history.length && history[0] < cutoff) {
          history.shift();
        }
      }
      // Optional: keep only the last N entries for memory optimization
      if (_classPrivateFieldGet(_maxMemory, this) !== null && typeof _classPrivateFieldGet(_maxMemory, this) === 'number') {
        if (history.length > _classPrivateFieldGet(_maxMemory, this)) {
          history.splice(0, history.length - _classPrivateFieldGet(_maxMemory, this));
          if (typeof _classPrivateFieldGet(_onMemoryExceeded, this) === 'function') _classPrivateFieldGet(_onMemoryExceeded, this).call(this, groupId);
        }
      }
    }
    /**
     * Check if the user (via their group) is currently rate limited
     * @param {string} userId
     * @returns {boolean}
     */
  }, {
    key: "isRateLimited",
    value: function isRateLimited(userId) {
      var groupId = this.getGroupId(userId);
      if (!this.groupData.has(groupId)) return false;
      var history = this.groupData.get(groupId);
      if (!history) throw new Error("No data found for groupId: ".concat(groupId));
      if (_classPrivateFieldGet(_interval, this) !== null) {
        var now = Date.now();
        var interval = this.getInterval();
        var cutoff = now - interval;
        var count = 0;
        for (var i = history.length - 1; i >= 0; i--) {
          if (history[i] > cutoff) count++;else break;
        }
        if (_classPrivateFieldGet(_maxHits, this) !== null) return count > this.getMaxHits();
        return count > 0;
      }
      if (_classPrivateFieldGet(_maxHits, this) !== null) {
        return history.length > this.getMaxHits();
      }
      return false;
    }
    /**
     * Manually reset group data
     * @param {string} groupId
     */
  }, {
    key: "resetGroup",
    value: function resetGroup(groupId) {
      this.groupFlags["delete"](groupId);
      this.groupData["delete"](groupId);
      this.lastSeen["delete"](groupId);
      this.groupTTL["delete"](groupId);
    }
    /**
     * Manually reset user data.
     *
     * @deprecated Use `resetUserGroup(userId)` instead. This method will be removed in future versions.
     * @param {string} userId
     * @returns {void}
     */
  }, {
    key: "reset",
    value: function reset(userId) {
      var _process;
      if (((_process = process) === null || _process === void 0 || (_process = _process.env) === null || _process === void 0 ? void 0 : _process.NODE_ENV) !== 'production') console.warn("[TinyRateLimiter] 'reset()' is deprecated. Use 'resetUserGroup()' instead.");
      return this.resetUserGroup(userId);
    }
    /**
     * Manually reset a user mapping
     * @param {string} userId
     */
  }, {
    key: "resetUserGroup",
    value: function resetUserGroup(userId) {
      this.userToGroup["delete"](userId);
    }
    /**
     * Set custom timestamps to a group
     * @param {string} groupId
     * @param {number[]} timestamps
     */
  }, {
    key: "setData",
    value: function setData(groupId, timestamps) {
      if (!Array.isArray(timestamps)) throw new Error('timestamps must be an array of numbers.');
      var _iterator5 = _createForOfIteratorHelper(timestamps),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var t = _step5.value;
          if (typeof t !== 'number' || !Number.isFinite(t)) {
            throw new Error('All timestamps must be finite numbers.');
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      if (!this.groupData.has(groupId)) this.groupFlags.set(groupId, false);
      this.groupData.set(groupId, timestamps);
      this.lastSeen.set(groupId, Date.now());
    }
    /**
     * Check if a group has data
     * @param {string} groupId
     * @returns {boolean}
     */
  }, {
    key: "hasData",
    value: function hasData(groupId) {
      return this.groupData.has(groupId);
    }
    /**
     * Get timestamps from a group
     * @param {string} groupId
     * @returns {number[]}
     */
  }, {
    key: "getData",
    value: function getData(groupId) {
      return this.groupData.get(groupId) || [];
    }
    /**
     * Get the maximum idle time (in milliseconds) before a group is considered expired.
     * @returns {number}
     */
  }, {
    key: "getMaxIdle",
    value: function getMaxIdle() {
      if (typeof _classPrivateFieldGet(_maxIdle, this) !== 'number' || !Number.isFinite(_classPrivateFieldGet(_maxIdle, this)) || _classPrivateFieldGet(_maxIdle, this) < 0) {
        throw new Error("'maxIdle' must be a non-negative finite number.");
      }
      return _classPrivateFieldGet(_maxIdle, this);
    }
    /**
     * Set the maximum idle time (in milliseconds) before a group is considered expired.
     * @param {number} ms
     */
  }, {
    key: "setMaxIdle",
    value: function setMaxIdle(ms) {
      if (typeof ms !== 'number' || !Number.isFinite(ms) || ms < 0) {
        throw new Error("'maxIdle' must be a non-negative finite number.");
      }
      _classPrivateFieldSet(_maxIdle, this, ms);
    }
    /**
     * Cleanup old/inactive groups with individual TTLs
     * @private
     */
  }, {
    key: "_cleanup",
    value: function _cleanup() {
      var now = Date.now();
      var _iterator6 = _createForOfIteratorHelper(this.lastSeen.entries()),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _this$getGroupTTL;
          var _step6$value = _slicedToArray(_step6.value, 2),
            groupId = _step6$value[0],
            last = _step6$value[1];
          var ttl = (_this$getGroupTTL = this.getGroupTTL(groupId)) !== null && _this$getGroupTTL !== void 0 ? _this$getGroupTTL : this.getMaxIdle();
          if (now - last > ttl) {
            this.groupFlags["delete"](groupId);
            this.groupData["delete"](groupId);
            this.lastSeen["delete"](groupId);
            this.groupTTL["delete"](groupId);
            // Notify subclass or external binding
            if (typeof _classPrivateFieldGet(_onGroupExpired, this) === 'function') {
              _classPrivateFieldGet(_onGroupExpired, this).call(this, groupId);
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
    /**
     * Get list of active group IDs
     * @returns {string[]}
     */
  }, {
    key: "getActiveGroups",
    value: function getActiveGroups() {
      return Array.from(this.groupData.keys());
    }
    /**
     * Get a shallow copy of all user-to-group mappings as a plain object
     * @returns {Record<string, string>}
     */
  }, {
    key: "getAllUserMappings",
    value: function getAllUserMappings() {
      return Object.fromEntries(this.userToGroup);
    }
    /**
     * Get the interval window in milliseconds.
     * @returns {number}
     */
  }, {
    key: "getInterval",
    value: function getInterval() {
      if (typeof _classPrivateFieldGet(_interval, this) !== 'number' || !Number.isFinite(_classPrivateFieldGet(_interval, this))) {
        throw new Error("'interval' is not a valid finite number.");
      }
      return _classPrivateFieldGet(_interval, this);
    }
    /**
     * Get the maximum number of allowed hits.
     * @returns {number}
     */
  }, {
    key: "getMaxHits",
    value: function getMaxHits() {
      if (typeof _classPrivateFieldGet(_maxHits, this) !== 'number' || !Number.isFinite(_classPrivateFieldGet(_maxHits, this))) {
        throw new Error("'maxHits' is not a valid finite number.");
      }
      return _classPrivateFieldGet(_maxHits, this);
    }
    /**
     * Get the total number of hits recorded for a group.
     * @param {string} groupId
     * @returns {number}
     */
  }, {
    key: "getTotalHits",
    value: function getTotalHits(groupId) {
      var history = this.groupData.get(groupId);
      return Array.isArray(history) ? history.length : 0;
    }
    /**
     * Get the timestamp of the last hit for a group.
     * @param {string} groupId
     * @returns {number|null}
     */
  }, {
    key: "getLastHit",
    value: function getLastHit(groupId) {
      var history = this.groupData.get(groupId);
      return history !== null && history !== void 0 && history.length ? history[history.length - 1] : null;
    }
    /**
     * Get milliseconds since the last hit for a group.
     * @param {string} groupId
     * @returns {number|null}
     */
  }, {
    key: "getTimeSinceLastHit",
    value: function getTimeSinceLastHit(groupId) {
      var last = this.getLastHit(groupId);
      return last !== null ? Date.now() - last : null;
    }
    /**
     * Internal utility to compute average spacing
     * @private
     * @param {number[]|undefined} history
     * @returns {number|null}
     */
  }, {
    key: "_calculateAverageSpacing",
    value: function _calculateAverageSpacing(history) {
      if (!Array.isArray(history) || history.length < 2) return null;
      var total = 0;
      for (var i = 1; i < history.length; i++) {
        total += history[i] - history[i - 1];
      }
      return total / (history.length - 1);
    }
    /**
     * Get average time between hits for a group (ms).
     * @param {string} groupId
     * @returns {number|null}
     */
  }, {
    key: "getAverageHitSpacing",
    value: function getAverageHitSpacing(groupId) {
      return this._calculateAverageSpacing(this.groupData.get(groupId));
    }
    /**
     * Get metrics about a group's activity.
     * @param {string} groupId
     * @returns {{
     *   totalHits: number,
     *   lastHit: number|null,
     *   timeSinceLastHit: number|null,
     *   averageHitSpacing: number|null
     * }}
     */
  }, {
    key: "getMetrics",
    value: function getMetrics(groupId) {
      var history = this.groupData.get(groupId);
      if (!Array.isArray(history) || history.length === 0) {
        return {
          totalHits: 0,
          lastHit: null,
          timeSinceLastHit: null,
          averageHitSpacing: null
        };
      }
      var totalHits = history.length;
      var lastHit = history[totalHits - 1];
      var timeSinceLastHit = Date.now() - lastHit;
      var averageHitSpacing = this._calculateAverageSpacing(history);
      return {
        totalHits: totalHits,
        lastHit: lastHit,
        timeSinceLastHit: timeSinceLastHit,
        averageHitSpacing: averageHitSpacing
      };
    }
    /**
     * Destroy the rate limiter, stopping cleanup and clearing data
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (_classPrivateFieldGet(_cleanupTimer, this)) clearInterval(_classPrivateFieldGet(_cleanupTimer, this));
      this._cleanup();
      this.groupData.clear();
      this.lastSeen.clear();
      this.userToGroup.clear();
      this.groupTTL.clear();
      this.groupFlags.clear();
    }
  }]);
}();
var _default = exports["default"] = TinyRateLimiter;

}).call(this)}).call(this,require('_process'))
},{"_process":97}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _y = /*#__PURE__*/new WeakMap();
var _x = /*#__PURE__*/new WeakMap();
var _baseDuration = /*#__PURE__*/new WeakMap();
var _extraPerChar = /*#__PURE__*/new WeakMap();
var _fadeOutDuration = /*#__PURE__*/new WeakMap();
var _container = /*#__PURE__*/new WeakMap();
var _TinyToastNotify_brand = /*#__PURE__*/new WeakSet();
/**
 * A callback function used to manually close a notification.
 * Passed as a second argument to `onClick` handlers, allowing programmatic dismissal of the toast.
 *
 * @typedef {() => void} CloseToastFunc
 */
/**
 * Represents the data used to display a notification.
 * Can be a plain string (used as the message), or an object with more customization options.
 *
 * @typedef {string | {
 *   message: string, // The main message to display
 *   title?: string,  // Optional title to appear above the message
 *   onClick?: function(MouseEvent, CloseToastFunc): void, // Optional click handler for the notification
 *   html?: boolean,  // Whether the message should be interpreted as raw HTML
 *   avatar?: string  // Optional URL to an avatar image shown on the left
 * }} NotifyData
 */
/**
 * A lightweight notification system designed to display timed messages inside a container.
 * Supports positioning, timing customization, click actions, HTML content, and optional avatars.
 *
 * ## Features:
 * - Positioning via `x` (`left`, `center`, `right`) and `y` (`top`, `bottom`).
 * - Dynamic display time based on message length.
 * - Optional `title`, `avatar`, `onClick`, and `html` message rendering.
 * - Fade-out animation with customizable duration.
 * - Rigid validation of inputs and internal state.
 *
 * ## Customization via setters:
 * - `setX(position)` — horizontal alignment.
 * - `setY(position)` — vertical alignment.
 * - `setBaseDuration(ms)` — base visible time in milliseconds.
 * - `setExtraPerChar(ms)` — extra time added per character.
 * - `setFadeOutDuration(ms)` — fade-out animation duration in milliseconds.
 *
 * @class
 */
var TinyToastNotify = /*#__PURE__*/function () {
  /**
   * @param {'top'|'bottom'} y - 'top' or 'bottom'
   * @param {'right'|'left'|'center'} x - 'right', 'left', or 'center'
   * @param {number} baseDuration - Base display time in ms
   * @param {number} extraPerChar - Extra ms per character
   * @param {number} fadeOutDuration - Time in ms for fade-out effect
   * @param {string} [selector='.notify-container'] - Base selector for container
   */
  function TinyToastNotify() {
    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'top';
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'right';
    var baseDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;
    var extraPerChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 50;
    var fadeOutDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 300;
    var selector = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '.notify-container';
    _classCallCheck(this, TinyToastNotify);
    /**
     * Validates the vertical position value.
     * Must be either 'top' or 'bottom'.
     *
     * @param {string} value - The vertical position to validate.
     * @throws {Error} If the value is not 'top' or 'bottom'.
     */
    _classPrivateMethodInitSpec(this, _TinyToastNotify_brand);
    _classPrivateFieldInitSpec(this, _y, void 0);
    _classPrivateFieldInitSpec(this, _x, void 0);
    _classPrivateFieldInitSpec(this, _baseDuration, void 0);
    _classPrivateFieldInitSpec(this, _extraPerChar, void 0);
    _classPrivateFieldInitSpec(this, _fadeOutDuration, void 0);
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _container, void 0);
    _assertClassBrand(_TinyToastNotify_brand, this, _validateY).call(this, y);
    _assertClassBrand(_TinyToastNotify_brand, this, _validateX).call(this, x);
    _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, baseDuration, 'baseDuration');
    _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, extraPerChar, 'extraPerChar');
    _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, fadeOutDuration, 'fadeOutDuration');
    _classPrivateFieldSet(_y, this, y);
    _classPrivateFieldSet(_x, this, x);
    _classPrivateFieldSet(_baseDuration, this, baseDuration);
    _classPrivateFieldSet(_extraPerChar, this, extraPerChar);
    _classPrivateFieldSet(_fadeOutDuration, this, fadeOutDuration);
    var container = document.querySelector("".concat(selector, ".").concat(y, ".").concat(x));
    if (!(container instanceof HTMLElement)) {
      _classPrivateFieldSet(_container, this, document.createElement('div'));
      _classPrivateFieldGet(_container, this).className = "notify-container ".concat(y, " ").concat(x);
      document.body.appendChild(_classPrivateFieldGet(_container, this));
    } else _classPrivateFieldSet(_container, this, container);
  }
  /**
   * Returns the notification container element.
   * Ensures that the container is a valid HTMLElement.
   *
   * @returns {HTMLElement} The notification container.
   * @throws {Error} If the container is not a valid HTMLElement.
   */
  return _createClass(TinyToastNotify, [{
    key: "getContainer",
    value: function getContainer() {
      if (!(_classPrivateFieldGet(_container, this) instanceof HTMLElement)) throw new Error('Container is not a valid HTMLElement.');
      return _classPrivateFieldGet(_container, this);
    }
  }, {
    key: "getY",
    value:
    /**
     * Returns the current vertical position.
     *
     * @returns {'top'|'bottom'} The vertical direction of the notification container.
     */
    function getY() {
      return _classPrivateFieldGet(_y, this);
    }
    /**
     * Sets the vertical position of the notification container.
     * Updates the container's class to reflect the new position.
     *
     * @param {'top'|'bottom'} value - The vertical direction to set.
     * @throws {Error} If the value is invalid.
     */
  }, {
    key: "setY",
    value: function setY(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateY).call(this, value);
      var container = this.getContainer();
      container.classList.remove(_classPrivateFieldGet(_y, this));
      container.classList.add(value);
      _classPrivateFieldSet(_y, this, value);
    }
    /**
     * Returns the current horizontal position.
     *
     * @returns {'left'|'right'|'center'} The horizontal direction of the notification container.
     */
  }, {
    key: "getX",
    value: function getX() {
      return _classPrivateFieldGet(_x, this);
    }
    /**
     * Sets the horizontal position of the notification container.
     * Updates the container's class to reflect the new position.
     *
     * @param {'left'|'right'|'center'} value - The horizontal direction to set.
     * @throws {Error} If the value is invalid.
     */
  }, {
    key: "setX",
    value: function setX(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateX).call(this, value);
      var container = this.getContainer();
      container.classList.remove(_classPrivateFieldGet(_x, this));
      container.classList.add(value);
      _classPrivateFieldSet(_x, this, value);
    }
    /**
     * Returns the base duration for displaying the notification.
     *
     * @returns {number} Base time (in milliseconds) that a notification stays on screen.
     */
  }, {
    key: "getBaseDuration",
    value: function getBaseDuration() {
      return _classPrivateFieldGet(_baseDuration, this);
    }
    /**
     * Sets the base duration for the notification display time.
     *
     * @param {number} value - Base display time in milliseconds.
     * @throws {Error} If the value is not a valid non-negative finite number.
     */
  }, {
    key: "setBaseDuration",
    value: function setBaseDuration(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, value, 'baseDuration');
      _classPrivateFieldSet(_baseDuration, this, value);
    }
    /**
     * Returns the extra display time added per character.
     *
     * @returns {number} Extra time (in milliseconds) per character in the notification.
     */
  }, {
    key: "getExtraPerChar",
    value: function getExtraPerChar() {
      return _classPrivateFieldGet(_extraPerChar, this);
    }
    /**
     * Sets the additional display time per character.
     *
     * @param {number} value - Extra time in milliseconds per character.
     * @throws {Error} If the value is not a valid non-negative finite number.
     */
  }, {
    key: "setExtraPerChar",
    value: function setExtraPerChar(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, value, 'extraPerChar');
      _classPrivateFieldSet(_extraPerChar, this, value);
    }
    /**
     * Returns the fade-out duration.
     *
     * @returns {number} Time (in milliseconds) used for fade-out transition.
     */
  }, {
    key: "getFadeOutDuration",
    value: function getFadeOutDuration() {
      return _classPrivateFieldGet(_fadeOutDuration, this);
    }
    /**
     * Sets the fade-out transition time for notifications.
     *
     * @param {number} value - Fade-out duration in milliseconds.
     * @throws {Error} If the value is not a valid non-negative finite number.
     */
  }, {
    key: "setFadeOutDuration",
    value: function setFadeOutDuration(value) {
      _assertClassBrand(_TinyToastNotify_brand, this, _validateTiming).call(this, value, 'fadeOutDuration');
      _classPrivateFieldSet(_fadeOutDuration, this, value);
    }
    /**
     * Displays a notification for a time based on message length.
     * Accepts a string or an object with:
     * {
     *   message: string,
     *   title?: string,
     *   onClick?: function(MouseEvent, CloseToastFunc): void,
     *   html?: boolean,
     *   avatar?: string // Optional avatar image URL
     * }
     *
     * @param {NotifyData} data
     */
  }, {
    key: "show",
    value: function show(data) {
      var _this = this;
      var message = '';
      var title = '';
      var onClick = null;
      var useHTML = false;
      var avatarUrl = null;
      var notify = document.createElement('div');
      notify.className = 'notify enter';
      if (typeof data === 'string') {
        message = data;
      } else if (_typeof(data) === 'object' && data !== null && typeof data.message === 'string') {
        message = data.message;
        title = typeof data.title === 'string' ? data.title : '';
        useHTML = data.html === true;
        avatarUrl = typeof data.avatar === 'string' ? data.avatar : null;
        if (data.onClick !== undefined) {
          if (typeof data.onClick !== 'function') {
            throw new Error('onClick must be a function if defined');
          }
          onClick = data.onClick;
          notify.classList.add('clickable');
        }
      } else {
        throw new Error("Invalid argument for show(): expected string or { message: string, title?: string, onClick?: function, html?: boolean, avatar?: string }");
      }
      // Add close button
      var closeBtn = document.createElement('button');
      closeBtn.innerHTML = '&times;';
      closeBtn.className = 'close';
      closeBtn.setAttribute('aria-label', 'Close');
      // Optional hover effect
      closeBtn.addEventListener('mouseenter', function () {
        closeBtn.style.color = 'var(--notif-close-color-hover)';
      });
      closeBtn.addEventListener('mouseleave', function () {
        closeBtn.style.color = 'var(--notif-close-color)';
      });
      // Avatar
      if (avatarUrl) {
        var avatar = document.createElement('img');
        avatar.src = avatarUrl;
        avatar.alt = 'avatar';
        avatar.className = 'avatar';
        notify.appendChild(avatar);
      }
      // Title
      if (title) {
        var titleElem = document.createElement('strong');
        titleElem.textContent = title;
        titleElem.style.display = 'block';
        notify.appendChild(titleElem);
      }
      // Message
      if (useHTML) {
        var msgWrapper = document.createElement('div');
        msgWrapper.innerHTML = message;
        notify.appendChild(msgWrapper);
      } else {
        notify.appendChild(document.createTextNode(message));
      }
      notify.appendChild(closeBtn);
      this.getContainer().appendChild(notify);
      var visibleTime = _classPrivateFieldGet(_baseDuration, this) + message.length * _classPrivateFieldGet(_extraPerChar, this);
      var totalTime = visibleTime + _classPrivateFieldGet(_fadeOutDuration, this);
      // Close logic
      var removed = false;
      var close = function close() {
        if (removed) return;
        removed = true;
        notify.classList.remove('enter', 'show');
        notify.classList.add('exit');
        setTimeout(function () {
          return notify.remove();
        }, _classPrivateFieldGet(_fadeOutDuration, _this));
      };
      // Click handler
      if (typeof onClick === 'function') {
        notify.addEventListener('click', function (e) {
          if (e.target === closeBtn) return;
          onClick(e, close);
        });
      }
      // Close button click
      closeBtn.addEventListener('click', function (e) {
        e.stopPropagation();
        close();
      });
      // Transition activation force soon after the element is added
      setTimeout(function () {
        notify.classList.remove('enter');
        notify.classList.add('show');
      }, 1);
      setTimeout(function () {
        return close();
      }, totalTime);
    }
    /**
     * Destroys the notification container and removes all active notifications.
     * This should be called when the notification system is no longer needed,
     * such as when unloading a page or switching views in a single-page app.
     *
     * @returns {void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (!(_classPrivateFieldGet(_container, this) instanceof HTMLElement)) return;
      // Remove all child notifications
      _classPrivateFieldGet(_container, this).querySelectorAll('.notify').forEach(function (el) {
        return el.remove();
      });
      // Remove the container itself from the DOM
      if (_classPrivateFieldGet(_container, this).parentNode) {
        _classPrivateFieldGet(_container, this).parentNode.removeChild(_classPrivateFieldGet(_container, this));
      }
      // Optional: Clean internal references (safe practice)
      _classPrivateFieldSet(_container, this, null);
    }
  }]);
}();
function _validateY(value) {
  if (!['top', 'bottom'].includes(value)) {
    throw new Error("Invalid vertical direction \"".concat(value, "\". Expected \"top\" or \"bottom\"."));
  }
}
/**
 * Validates the horizontal position value.
 * Must be 'left', 'right', or 'center'.
 *
 * @param {string} value - The horizontal position to validate.
 * @throws {Error} If the value is not one of the accepted directions.
 */
function _validateX(value) {
  if (!['left', 'right', 'center'].includes(value)) {
    throw new Error("Invalid horizontal position \"".concat(value, "\". Expected \"left\", \"right\" or \"center\"."));
  }
}
/**
 * Validates a numeric timing value.
 * Must be a non-negative finite number.
 *
 * @param {number} value - The number to validate.
 * @param {string} name - The name of the parameter (used for error messaging).
 * @throws {Error} If the number is invalid.
 */
function _validateTiming(value, name) {
  if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {
    throw new Error("Invalid value for \"".concat(name, "\": ").concat(value, ". Must be a non-negative finite number."));
  }
}
var _default = exports["default"] = TinyToastNotify;

},{}],133:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _tinyEssentials = require("tiny-essentials");
var _validateColor = _interopRequireDefault(require("validate-color"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * TinyDices - JavaScript class for rendering animated 3D dice with HTML/CSS.
 *
 * Created by: Yasmin Seidel (JasminDreasond)
 * Co-developed with: ChatGPT (OpenAI) as coding assistant
 *
 * Features:
 * - Roll any number of dice
 * - Supports custom max values per die
 * - Optional spinning animation (infinite or ending)
 * - Dynamic cube generation and animation
 * - Option to include zero in rolls (canZero)
 *
 * Usage:
 * const container = document.getElementById('myDice');
 * const dice = new TinyDices(container);
 *
 * dice.roll('7,7,7');                    // Rolls 3d6
 * dice.roll('6,12,20');                 // Rolls d6, d12, and d20
 * dice.roll([10, 10], false, true);     // Rolls 2d10 with infinite spin
 * dice.roll([10, 10], true);            // Rolls 2d10 starting from 0
 * dice.roll([4, 8, 6], true, true);     // Rolls d4, d8, and d6 from 0 with infinite spin
 *
 * Customization:
 * dice.setBgSkin('gray');                // Sets background skin to gray
 * dice.setTextSkin('red');               // Sets text skin to red
 * dice.setBorderSkin('2px solid black'); // Sets border skin to black
 *
 * dice.getBgSkin();                       // Gets current or default background skin
 * dice.getTextSkin();                     // Gets current or default text skin
 * dice.getBorderSkin();                   // Gets current or default border skin
 */
var _elements = /*#__PURE__*/new WeakMap();
var _cubeId = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _defaultBgSkin = /*#__PURE__*/new WeakMap();
var _defaultBorderSkin = /*#__PURE__*/new WeakMap();
var _defaultSelectionTextSkin = /*#__PURE__*/new WeakMap();
var _defaultSelectionBgSkin = /*#__PURE__*/new WeakMap();
var _defaultTextSkin = /*#__PURE__*/new WeakMap();
var _selectionBgSkin = /*#__PURE__*/new WeakMap();
var _selectionTextSkin = /*#__PURE__*/new WeakMap();
var _bgSkin = /*#__PURE__*/new WeakMap();
var _bgImg = /*#__PURE__*/new WeakMap();
var _textSkin = /*#__PURE__*/new WeakMap();
var _borderSkin = /*#__PURE__*/new WeakMap();
var _diceBase = /*#__PURE__*/new WeakMap();
var _createCube = /*#__PURE__*/new WeakMap();
var _TinyDices_brand = /*#__PURE__*/new WeakSet();
var TinyDices = /*#__PURE__*/function () {
  /**
   * Creates a new TinyDices instance attached to a specified HTML element.
   *
   * @param {HTMLElement} diceBase - The HTML container element where the dice will be rendered.
   * @param {(result: number, max: number, canZero?: boolean, rollInfinity?: boolean) => CubeResult} [createCubeScript=null]
   *        - Optional function to override the internal cube creation logic.
   *          If provided, it will be used instead of the built-in method.
   *
   *          The function should accept the following parameters:
   *            - result {number} - The main value to appear on the front face of the die.
   *            - max {number} - The maximum value allowed for a face of the die.
   *            - canZero {boolean} [optional] - If true, faces can include the number 0.
   *            - rollInfinity {boolean} [optional] - If true, the die spins infinitely.
   *
   *          And return:
   *            - {HTMLElement} cube - The DOM element representing the dice cube.
   *            - {number[]} sequence - An array containing all the face values of the die.
   *
   *
   * When implementing a custom dice creation logic, you can use the following internal methods:
   *
   * @function tinyDice.addElement
   * Adds a structured dice object to the internal list for tracking and future cleanup.
   * This method expects an object with `faces`, `container`, and `wrapper` properties.
   *
   * @function tinyDice.rollNumber(max: number, canZero: boolean): number
   * Generates a random number based on the maximum value and zero allowance.
   * Useful when assigning values to non-front faces of the die.
   *
   * @function tinyDice.updateDiceFaceSkin(face: HTMLElement): void
   * Applies the dice face style or skin to a given face element.
   * This is usually a visual effect or texture that the user can define.
   *
   * @function tinyDice.addCubeId(): number
   * Returns a unique identifier for each die. This value is typically used to set the `z-index`
   * of the container, so that new dice appear above older ones.
   *
   *
   */
  function TinyDices(diceBase, createCubeScript) {
    _classCallCheck(this, TinyDices);
    /**
     * Internal helper to check if the dice base element is a valid HTMLElement.
     *
     * @returns {boolean} - True if #diceBase is a valid HTMLElement.
     */
    _classPrivateMethodInitSpec(this, _TinyDices_brand);
    /**
     * @typedef {Object} DiceElement
     * @property {HTMLElement[]} faces - An array of six face elements.
     * @property {HTMLElement|null} container - The outer wrapper element.
     * @property {HTMLElement|null} wrapper - The rotating inner cube element.
     */
    /**
     * @typedef {Object} CubeResult
     * @property {HTMLDivElement} cube - The DOM element representing the cube container.
     * @property {number[]} sequence - The final sequence of values shown on each face.
     */
    /**
     * Stores all current dice elements created by the instance.
     *
     * Each element follows the `DiceElement` structure, containing cube faces,
     * its container, and the cube wrapper for rotation.
     *
     * @type {DiceElement[]}
     */
    _classPrivateFieldInitSpec(this, _elements, []);
    _classPrivateFieldInitSpec(this, _cubeId, 0);
    // used for incremental z-index to avoid overlapping issues
    _classPrivateFieldInitSpec(this, _destroyed, false);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultBgSkin, 'linear-gradient(135deg, #ff3399, #33ccff)');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultBorderSkin, '2px solid rgba(255, 255, 255, 0.2)');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultSelectionTextSkin, '#FFF');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultSelectionBgSkin, '#000');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _defaultTextSkin, 'white');
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _selectionBgSkin, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _selectionTextSkin, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _bgSkin, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _bgImg, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _textSkin, null);
    /** @type {string|null} */_classPrivateFieldInitSpec(this, _borderSkin, null);
    /** @type {HTMLElement|null} */_classPrivateFieldInitSpec(this, _diceBase, null);
    /** @type {HTMLElement|null} */
    _defineProperty(this, "diceArea", null);
    /** @type {HTMLElement|null} */
    _defineProperty(this, "container", null);
    /**
     * Creates a cube DOM element with animated faces and randomized values.
     *
     * @param {number} result - The main value to appear on the front face.
     * @param {number} max - The maximum possible value for the die.
     * @param {boolean} [rollInfinity=false] - If true, the cube will spin infinitely.
     * @returns {CubeResult} - The cube element and an array of all face values.
     */
    _classPrivateFieldInitSpec(this, _createCube, void 0);
    if (typeof createCubeScript === 'function') _classPrivateFieldSet(_createCube, this, createCubeScript);else _assertClassBrand(_TinyDices_brand, this, _insertCreateCube).call(this);
    if (typeof HTMLElement !== 'undefined' && diceBase instanceof HTMLElement) {
      _classPrivateFieldSet(_diceBase, this, diceBase);
      _classPrivateFieldGet(_diceBase, this).classList.add('tiny-dices-body');
      this.diceArea = document.createElement('div');
      this.diceArea.classList.add('dice-area');
      _classPrivateFieldGet(_diceBase, this).appendChild(this.diceArea);
    }
  }
  return _createClass(TinyDices, [{
    key: "existsHtml",
    value:
    /**
     * Checks if the internal HTML structure (dice base container) still exists in the DOM.
     *
     * Useful to verify if the TinyDices component is still rendered and operational.
     *
     * @returns {boolean} - Returns `true` if the HTML elements exist, otherwise `false`.
     */
    function existsHtml() {
      return _assertClassBrand(_TinyDices_brand, this, _existsHtml).call(this);
    }
    /**
     * Increments and returns the current cube ID.
     *
     * This ID is used to set a unique z-index for each die,
     * ensuring that newer dice appear above older ones in the stack.
     *
     * @returns {number} The current cube ID before incrementing.
     */
  }, {
    key: "addCubeId",
    value: function addCubeId() {
      var _this$cubeId, _this$cubeId2;
      return _classPrivateFieldSet(_cubeId, this, (_this$cubeId = _classPrivateFieldGet(_cubeId, this), _this$cubeId2 = _this$cubeId++, _this$cubeId)), _this$cubeId2;
    }
    /**
     * Validates and stores a new dice element into the internal list.
     *
     * This method ensures that the given object has the correct structure
     * before appending it to the internal array of rendered dice elements.
     *
     * @param {DiceElement} item - The dice element object to validate and store.
     * @returns {boolean} `true` if the item was valid and added; otherwise, `false`.
     */
  }, {
    key: "addElement",
    value:
    /**
     * Adds a new dice element to the internal storage.
     *
     * This is the public wrapper for the internal method `#addElement`.
     * It validates the structure of the dice element before adding.
     *
     * @param {DiceElement} item
     *        - The dice element object to add. It must contain:
     *          - `faces`: an array of six face elements,
     *          - `container`: the outer wrapper element,
     *          - `wrapper`: the rotating inner cube element.
     *
     * @returns {boolean} `true` if the element was valid and added, otherwise `false`.
     */
    function addElement(item) {
      return _assertClassBrand(_TinyDices_brand, this, _addElement).call(this, item);
    }
    /**
     * Validates a background-image value restricted to safe data:image URLs only.
     *
     * @param {string} value - The CSS background-image value.
     * @returns {boolean}
     */
  }, {
    key: "setBgImg",
    value:
    /**
     * Sets the background image using a `data:` URL or, optionally, a standard image URL if forced.
     *
     * For security reasons, only `data:` URLs are accepted by default to avoid external resource injection.
     * You can override this restriction using the `forceUnsafe` flag, but this is discouraged unless trusted.
     *
     * @param {string|null} value - The background-image URL (must be a `data:` image by default).
     * @param {boolean} [forceUnsafe=false] - Allows setting non-data URLs if true (use with caution).
     */
    function setBgImg(value) {
      var forceUnsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      _classPrivateFieldSet(_bgImg, this, typeof value === 'string' && (forceUnsafe || _assertClassBrand(_TinyDices_brand, this, _isValidDataImage).call(this, value)) ? value : null);
    }
    /**
     * Returns the currently set background image if valid, or null.
     *
     * @returns {string|null} - The current background-image value (data:image URL) or null if none is set.
     */
  }, {
    key: "getBgImg",
    value: function getBgImg() {
      return _classPrivateFieldGet(_bgImg, this) || null;
    }
    /**
     * Sets the background skin style if it's a valid CSS color or linear-gradient.
     * Prevents injection of unsafe or malformed styles.
     *
     * @param {string} skin - A valid CSS color string or gradient.
     */
  }, {
    key: "setBgSkin",
    value: function setBgSkin(skin) {
      if (typeof skin !== 'string') {
        _classPrivateFieldSet(_bgSkin, this, null);
        return;
      }
      var trimmed = skin.trim();
      var isGradient = _assertClassBrand(_TinyDices_brand, this, _isValidLinearGradient).call(this, trimmed);
      var isColor = (0, _validateColor["default"])(trimmed);
      _classPrivateFieldSet(_bgSkin, this, isGradient || isColor ? trimmed : null);
    }
    /**
     * Gets the currently applied background skin.
     * @returns {string|null} The current background skin, or the default if not set.
     */
  }, {
    key: "getBgSkin",
    value: function getBgSkin() {
      return _classPrivateFieldGet(_bgSkin, this) || _classPrivateFieldGet(_defaultBgSkin, this);
    }
    /**
     * Sets the text skin (style) of the dice numbers.
     * @param {string|null} skin - The skin name to apply to the text. Pass null or non-string to reset to default.
     */
  }, {
    key: "setTextSkin",
    value: function setTextSkin(skin) {
      _classPrivateFieldSet(_textSkin, this, typeof skin === 'string' && (0, _validateColor["default"])(skin) ? skin : null);
    }
    /**
     * Gets the currently applied text skin.
     * @returns {string|null} The current text skin, or the default if not set.
     */
  }, {
    key: "getTextSkin",
    value: function getTextSkin() {
      return _classPrivateFieldGet(_textSkin, this) || _classPrivateFieldGet(_defaultTextSkin, this);
    }
    /**
     * Sets the border skin (style) of the dice edges.
     * @param {string|null} skin - The skin name to apply to the border. Pass null or non-string to reset to default.
     */
  }, {
    key: "setBorderSkin",
    value: function setBorderSkin(skin) {
      _classPrivateFieldSet(_borderSkin, this, typeof skin === 'string' && _assertClassBrand(_TinyDices_brand, this, _isValidCssBorder).call(this, skin) ? skin : null);
    }
    /**
     * Gets the currently applied border skin.
     * @returns {string|null} The current border skin, or the default if not set.
     */
  }, {
    key: "getBorderSkin",
    value: function getBorderSkin() {
      return _classPrivateFieldGet(_borderSkin, this) || _classPrivateFieldGet(_defaultBorderSkin, this);
    }
    /**
     * Sets the background skin for selected dice.
     * Accepts valid CSS color strings or `linear-gradient(...)`.
     * Invalid values reset the skin to `null`.
     *
     * @param {string} skin - The CSS background to apply when a die is selected.
     */
  }, {
    key: "setSelectionBgSkin",
    value: function setSelectionBgSkin(skin) {
      if (typeof skin !== 'string') {
        _classPrivateFieldSet(_selectionBgSkin, this, null);
        return;
      }
      var trimmed = skin.trim();
      var isGradient = _assertClassBrand(_TinyDices_brand, this, _isValidLinearGradient).call(this, trimmed);
      var isColor = (0, _validateColor["default"])(trimmed);
      _classPrivateFieldSet(_selectionBgSkin, this, isGradient || isColor ? trimmed : null);
    }
    /**
     * Gets the background skin used for selected dice.
     * Returns the custom value if set; otherwise, returns the default.
     *
     * @returns {string|null} The current background skin for selected dice.
     */
  }, {
    key: "getSelectionBgSkin",
    value: function getSelectionBgSkin() {
      return _classPrivateFieldGet(_selectionBgSkin, this) || _classPrivateFieldGet(_defaultSelectionBgSkin, this);
    }
    /**
     * Sets the text color for selected dice.
     * Only valid CSS color values are accepted.
     * Invalid inputs will reset the color to `null`.
     *
     * @param {string} skin - The text color for selected dice.
     */
  }, {
    key: "setSelectionTextSkin",
    value: function setSelectionTextSkin(skin) {
      _classPrivateFieldSet(_selectionTextSkin, this, typeof skin === 'string' && (0, _validateColor["default"])(skin) ? skin : null);
    }
    /**
     * Gets the text color used for selected dice.
     * Returns the custom value if set; otherwise, returns the default.
     *
     * @returns {string|null} The current text color for selected dice.
     */
  }, {
    key: "getSelectionTextSkin",
    value: function getSelectionTextSkin() {
      return _classPrivateFieldGet(_selectionTextSkin, this) || _classPrivateFieldGet(_defaultSelectionTextSkin, this);
    }
    /**
     * Applies the current visual skin to a specific dice face element.
     * This includes background color, text color, border style, and optionally
     * a `background-image` if set via `setBgImg`.
     *
     * @param {HTMLElement} face - The HTML element representing a dice face.
     */
  }, {
    key: "updateDiceFaceSkin",
    value:
    /**
     * Updates the visual skin or style of a single dice face element.
     *
     * This is a public wrapper around the internal method `#updateDiceFaceSkin`,
     * allowing external calls to apply the dice face style dynamically.
     *
     * @param {HTMLElement} face - The DOM element representing a single face of the die.
     * @returns {void}
     */
    function updateDiceFaceSkin(face) {
      return _assertClassBrand(_TinyDices_brand, this, _updateDiceFaceSkin).call(this, face);
    }
    /**
     * Updates the visual skin of all dice face elements currently rendered.
     * Iterates through each dice in `this.#elements` and applies the active
     * background, text color, border, and background image styles using `#updateDiceFaceSkin`.
     *
     */
  }, {
    key: "updateDicesSkin",
    value: function updateDicesSkin() {
      for (var index in _classPrivateFieldGet(_elements, this)) this.updateDiceSkin(index);
    }
    /**
     * Updates the visual skin of a specific die by index.
     * Applies current background color, text color, border style, and background image
     * to all face elements of the selected die using `#updateDiceFaceSkin`.
     *
     * @param {number|string} index - The index of the die to update.
     * @throws {Error} If the index is not a valid number or string convertible to number.
     *
     * @returns {boolean} Returns `true` if the die was found and updated; otherwise `false`.
     */
  }, {
    key: "updateDiceSkin",
    value: function updateDiceSkin(index) {
      var parsedIndex = typeof index === 'string' ? parseInt(index) : typeof index === 'number' ? index : -1;
      if (Number.isNaN(parsedIndex)) throw new Error('updateDiceSkin: index must be a number or a numeric string.');
      var element = _classPrivateFieldGet(_elements, this)[parsedIndex];
      if (element) {
        for (var index2 in element.faces) _assertClassBrand(_TinyDices_brand, this, _updateDiceFaceSkin).call(this, element.faces[index2]);
        return true;
      } else return false;
    }
    /**
     * Generates a random integer between 1 and max (inclusive).
     * If `canZero` is true, the range becomes 0 to max (inclusive).
     *
     * @param {number} max - The maximum value for the roll (inclusive).
     * @param {boolean} [canZero=false] - Whether the result can include 0.
     * @returns {number} A random integer between 1 and max, or 0 and max if `canZero` is true. Returns 0 if max <= 0.
     */
  }, {
    key: "rollNumber",
    value:
    /**
     * Generates a random integer between a lower bound and a maximum value.
     *
     * This is a public wrapper for the internal method `#rollNumber`, which handles
     * dice-style number generation, optionally allowing zero as a result.
     *
     * @param {number} [max=0] - The maximum value (inclusive upper bound if `canZero` is true).
     * @param {boolean} [canZero=false] - If true, the roll can return 0 (or a range starting from 0).
     * @returns {number} A pseudo-random integer within the expected range.
     *
     * - If `canZero` is false: returns a number from 1 to `max`.
     * - If `canZero` is true: returns a number from 0 to `max`.
     * - If `max <= 0`: always returns 0.
     */
    function rollNumber() {
      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return _assertClassBrand(_TinyDices_brand, this, _rollNumber).call(this, max, canZero);
    }
    /**
     * Parses input parameters to determine the dice configuration.
     *
     * @param {string|Array<number>} perDieValues - Optional: a comma-separated string or array of individual max values.
     * @returns {number[]} - Parsed dice configuration.
     */
  }, {
    key: "parseRollConfig",
    value: function parseRollConfig() {
      var perDieValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      // Get per die data
      return typeof perDieValues === 'string' && perDieValues.length > 0 ? perDieValues.trim().split(',').map(function (raw) {
        var val = 0;
        try {
          val = parseInt(raw.trim(), 10);
        } catch (_unused) {
          val = 0;
        }
        if (typeof val === 'number' && !Number.isNaN(val) && Number.isFinite(val) && val > -1) return val;
        return -1;
      }) : Array.isArray(perDieValues) ? perDieValues : [];
    }
    /**
     * Inserts a single 3D die into the DOM with animation.
     *
     * @param {number} result - The value displayed on the front face of the die.
     * @param {number} max - The maximum value for the die (used to generate other random faces).
     * @param {boolean} [canZero=false] - Whether 0 is a valid face value.
     * @param {boolean} [rollInfinity=false] - Whether the die should spin indefinitely.
     *
     * @throws {Error} If `this.diceArea` is not a valid HTMLElement.
     * @throws {Error} If `this.#createCube` is not a function.
     * @throws {Error} If cube creation fails or returns an invalid sequence.
     * @returns {number[]} - An array representing the values on all six faces of the cube.
     */
  }, {
    key: "insertDiceElement",
    value: function insertDiceElement(result, max, canZero, rollInfinity) {
      if (typeof HTMLElement === 'undefined' || !(this.diceArea instanceof HTMLElement)) throw new Error('insertDiceElement: this.diceArea is not a valid HTMLElement.');
      if (typeof _classPrivateFieldGet(_createCube, this) !== 'function') throw new Error('insertDiceElement: this.#createCube is not a valid function.');
      var _classPrivateFieldGet2 = _classPrivateFieldGet(_createCube, this).call(this, result, max, canZero, rollInfinity),
        cube = _classPrivateFieldGet2.cube,
        sequence = _classPrivateFieldGet2.sequence;
      if (!Array.isArray(sequence)) throw new Error('insertDiceElement: invalid cube sequence returned.');
      this.diceArea.appendChild(cube);
      return sequence;
    }
    /**
     * Clears all dice cubes from the display area.
     * Resets internal cube counter to avoid z-index conflicts.
     */
  }, {
    key: "clearDiceArea",
    value: function clearDiceArea() {
      _classPrivateFieldSet(_cubeId, this, 0);
      if (typeof HTMLElement !== 'undefined' && this.diceArea instanceof HTMLElement) this.diceArea.innerHTML = '';
      _classPrivateFieldSet(_elements, this, []);
    }
    /**
     * Initializes the default cube creation function and assigns it to `this.#createCube`.
     *
     * This function builds a customizable cube with 6 animated faces, where each face is
     * assigned a unique number (avoiding duplicates when possible). The front face shows the
     * result value passed in, and the others are randomized based on the `max` value.
     *
     * @remarks
     * If `createCubeScript` was not provided to the constructor, this method sets up the default cube generator.
     *
     * @returns {void}
     *
     * @function
     */
  }, {
    key: "rollDice",
    value:
    /**
     * Inserts a single die cube into the DOM using the specified configuration.
     *
     * @param {number} max - Default maximum value for dice (if no individual values are given).
     * @param {boolean} [canZero=false] - Whether 0 is a valid result.
     * @param {boolean} [rollInfinity=false] - Whether all dice should spin infinitely.
     * @returns {{ result: number, sequence?: number[] }} - Array with results and face sequences for each die.
     */
    function rollDice(max) {
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rollInfinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var cube = {
        result: _assertClassBrand(_TinyDices_brand, this, _rollNumber).call(this, max, canZero)
      };
      if (_assertClassBrand(_TinyDices_brand, this, _existsHtml).call(this))
        // @ts-ignore
        cube.sequence = this.insertDiceElement(cube.result, max, canZero, rollInfinity);
      return cube;
    }
    /**
     * Inserts multiple dice cubes into the DOM using the specified configuration.
     *
     * @param {number[]} perDieData - Array of individual max values per die.
     * @param {boolean} [canZero=false] - Whether 0 is a valid result on any die.
     * @param {boolean} [rollInfinity=false] - Whether all dice should spin infinitely.
     * @returns {Array<{ result: number, sequence?: number[] }>} - Array with results and face sequences for each die.
     */
  }, {
    key: "rollDices",
    value: function rollDices(perDieData) {
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rollInfinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var cubes = [];
      for (var i = 0; i < perDieData.length; i++) {
        var max = perDieData[i];
        var cube = {
          result: _assertClassBrand(_TinyDices_brand, this, _rollNumber).call(this, max, canZero)
        };
        if (_assertClassBrand(_TinyDices_brand, this, _existsHtml).call(this))
          // @ts-ignore
          cube.sequence = this.insertDiceElement(cube.result, max, canZero, rollInfinity);
        cubes.push(cube);
      }
      return cubes;
    }
    /**
     * Rolls the dice by clearing existing cubes and inserting new ones.
     *
     * @param {string|Array<number>} perDieInput - Either a comma-separated string or array of max values per die.
     * @param {boolean} [canZero=false] - Whether 0 is a valid result.
     * @param {boolean} [rollInfinity=false] - Whether dice spin infinitely.
     * @returns {Array<{ result: number, sequence?: number[] }>} - Array with results and face sequences for each die.
     */
  }, {
    key: "roll",
    value: function roll(perDieInput) {
      var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rollInfinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var perDieData = this.parseRollConfig(perDieInput);
      this.clearDiceArea();
      return this.rollDices(perDieData, canZero, rollInfinity);
    }
    /**
     * Checks whether the TinyDices instance has been destroyed.
     *
     * @returns {boolean} - Returns `true` if the instance was destroyed, otherwise `false`.
     *
     * @example
     * if (dice.isDestroyed()) {
     *   console.warn('This instance is no longer usable.');
     * }
     */
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return _classPrivateFieldGet(_destroyed, this);
    }
    /**
     * Completely destroys the TinyDices instance by removing DOM elements and resetting internal state.
     *
     * This method:
     * - Clears all rendered dice.
     * - Empties the base DOM elements (container, diceBase, diceArea).
     * - Resets all visual skin configurations.
     * - Nullifies DOM references.
     * - Sets an internal flag to block further usage of the instance.
     *
     * @example
     * dice.destroy(); // 💣 Cleans up everything and makes the instance unusable
     */
  }, {
    key: "destroy",
    value: function destroy() {
      // Clear any dice already rendered
      this.clearDiceArea();
      // Remove container element content (optional: comment if you want to preserve it)
      if (typeof HTMLElement !== 'undefined') {
        if (this.container instanceof HTMLElement) this.container.innerHTML = '';
        if (_classPrivateFieldGet(_diceBase, this) instanceof HTMLElement) _classPrivateFieldGet(_diceBase, this).innerHTML = '';
        if (this.diceArea instanceof HTMLElement) this.diceArea.innerHTML = '';
      }
      // Optionally, unset the container reference
      _classPrivateFieldSet(_diceBase, this, null);
      this.diceArea = null;
      this.container = null;
      // Reset any styles or configs (if you store them in other properties, reset them here)
      _classPrivateFieldSet(_defaultBgSkin, this, null);
      _classPrivateFieldSet(_defaultBorderSkin, this, null);
      _classPrivateFieldSet(_defaultSelectionTextSkin, this, null);
      _classPrivateFieldSet(_defaultSelectionBgSkin, this, null);
      _classPrivateFieldSet(_defaultTextSkin, this, null);
      _classPrivateFieldSet(_selectionBgSkin, this, null);
      _classPrivateFieldSet(_selectionTextSkin, this, null);
      _classPrivateFieldSet(_bgSkin, this, null);
      _classPrivateFieldSet(_bgImg, this, null);
      _classPrivateFieldSet(_textSkin, this, null);
      _classPrivateFieldSet(_borderSkin, this, null);
      // Optionally, mark as destroyed to prevent further use
      _classPrivateFieldSet(_destroyed, this, true);
    }
  }]);
}();
function _existsHtml() {
  return typeof HTMLElement !== 'undefined' && _classPrivateFieldGet(_diceBase, this) instanceof HTMLElement ? true : false;
}
function _addElement(item) {
  if ((0, _tinyEssentials.objType)(item, 'object') && Array.isArray(item.faces) && typeof HTMLElement !== 'undefined' && item.container instanceof HTMLElement && item.wrapper instanceof HTMLElement) {
    _classPrivateFieldGet(_elements, this).push(item);
    return true;
  }
  return false;
}
function _isValidDataImage(value) {
  if (typeof value !== 'string') return false;
  var normalized = value.trim();
  // Only allow data:image/... base64 or URL-encoded images
  var dataUrlPattern = /^data:image\/(png|jpeg|jpg|gif|webp);base64,[a-z0-9+\/=]+$/i;
  return dataUrlPattern.test(normalized);
}
/**
 * Validates a linear-gradient string to prevent unsafe or malformed styles.
 *
 * @param {string} value - The CSS gradient string.
 * @returns {boolean}
 */
function _isValidLinearGradient(value) {
  if (typeof value !== 'string') return false;
  var normalized = value.trim().toLowerCase();
  // Must start with 'linear-gradient(' and end with ')'
  if (!normalized.startsWith('linear-gradient(') || !normalized.endsWith(')')) {
    return false;
  }
  // Block unsafe patterns
  var unsafePattern = /(url\s*\(|expression\s*\(|javascript:|<|>|data:)/i;
  if (unsafePattern.test(value)) {
    return false;
  }
  // Extract content inside the parentheses
  var content = value.slice(value.indexOf('(') + 1, -1).trim();
  if (!content) return false;
  // Safe split by commas outside of parentheses
  var parts = [];
  var buffer = '';
  var depth = 0;
  var _iterator = _createForOfIteratorHelper(content),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _char = _step.value;
      if (_char === '(') depth++;
      if (_char === ')') depth--;
      if (_char === ',' && depth === 0) {
        parts.push(buffer.trim());
        buffer = '';
      } else {
        buffer += _char;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (buffer.trim()) parts.push(buffer.trim());
  if (parts.length < 1) return false; // needs at least one component
  var colorCount = 0;
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    // First item can optionally be a direction or angle
    if (i === 0 && /^(to\s+\w+|\d+deg|[+-]?\d+rad|[+-]?\d+turn)$/i.test(part)) {
      continue;
    }
    if ((0, _validateColor["default"])(part.trim())) {
      colorCount++;
    } else {
      // Extract possible color value before any stop (e.g. "red 20%" → "red")
      var colorCandidate = part.trim().split(/\s+/)[0];
      if ((0, _validateColor["default"])(colorCandidate)) {
        colorCount++;
      } else {
        return false; // invalid color
      }
    }
  }
  // Must have at least 1 valid color and no more than 50
  return colorCount >= 1 && colorCount <= 50;
}
/**
 * Validates a CSS border string like '1px solid red' or '2px dashed linear-gradient(...)'.
 *
 * @param {string} value - The CSS border string.
 * @returns {boolean}
 */
function _isValidCssBorder(value) {
  if (typeof value !== 'string') return false;
  var parts = value.trim().split(/\s+/);
  if (parts.length < 3) return false;
  var _parts = _toArray(parts),
    width = _parts[0],
    style = _parts[1],
    colorParts = _parts.slice(2);
  var color = colorParts.join(' ');
  // Validate width (basic check for length units)
  var isValidWidth = /^(\d+(\.\d+)?)(px|em|rem|%)$/.test(width);
  if (!isValidWidth) return false;
  // Validate border style
  var validStyles = ['none', 'solid', 'dashed', 'dotted', 'double', 'groove', 'ridge', 'inset', 'outset', 'hidden'];
  if (!validStyles.includes(style)) return false;
  // Validate color (either direct or linear-gradient)
  return (0, _validateColor["default"])(color) || _assertClassBrand(_TinyDices_brand, this, _isValidLinearGradient).call(this, color);
}
function _updateDiceFaceSkin(face) {
  // Skin
  face.style.background = this.getBgSkin() || '';
  face.style.color = this.getTextSkin() || '';
  face.style.border = this.getBorderSkin() || '';
  face.style.setProperty('--dice-selection-bg', this.getSelectionBgSkin());
  face.style.setProperty('--dice-selection-text', this.getSelectionTextSkin());
  // Background image
  var bgImg = this.getBgImg();
  if (bgImg) {
    face.style.backgroundImage = "url(\"".concat(bgImg, "\")");
    face.style.backgroundPosition = 'center';
    face.style.backgroundSize = '100%';
    face.style.backgroundRepeat = 'repeat';
  }
}
function _rollNumber() {
  var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var canZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  // Throw an error if the value is not a valid number
  if (typeof max !== 'number' || Number.isNaN(max)) {
    throw new Error("Invalid die max value: ".concat(max, ". All values must be positive numbers."));
  }
  // Valid number
  if (max > 0) {
    var maxValue = max;
    var finalValue = 1;
    if (canZero) {
      maxValue++;
      finalValue--;
    }
    return Math.floor(Math.random() * maxValue) + finalValue;
  } else return 0;
}
function _insertCreateCube() {
  var tinyDice = this;
  /** @type {function(number, number, boolean=, boolean=): CubeResult} */
  _classPrivateFieldSet(_createCube, this, function (result, max) {
    var canZero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var rollInfinity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    // Container
    /** @type {DiceElement} */
    var diceElements = {
      faces: [],
      container: null,
      wrapper: null
    };
    var container = document.createElement('div');
    container.className = 'dice-container';
    container.style.zIndex = String(1000 + tinyDice.addCubeId()); // each dice with higher priority
    diceElements.container = container;
    // Wrapper
    var wrapper = document.createElement('div');
    wrapper.className = "cube-wrapper".concat(rollInfinity ? " spin-infinite" : '');
    diceElements.wrapper = wrapper;
    // Get rot
    var rotX = 360 * (3 + Math.floor(Math.random() * 5));
    var rotY = 360 * (3 + Math.floor(Math.random() * 5));
    // Wrapper animation
    wrapper.style.animation = "tinyDiceSpinCubeCustom 2s ease-in-out forwards";
    wrapper.style.setProperty('--rotX', "".concat(rotX, "deg"));
    wrapper.style.setProperty('--rotY', "".concat(rotY, "deg"));
    // Create the cube
    var sequence = [];
    var countSeq = new Set();
    var min = !canZero ? 0 : -1;
    for (var i = 1; i <= 6; i++) {
      // Element
      var face = document.createElement('div');
      face.className = "face face".concat(i);
      _assertClassBrand(_TinyDices_brand, tinyDice, _updateDiceFaceSkin).call(tinyDice, face);
      // Ignored results
      if (i !== 1) {
        var roll = void 0;
        // Normal max
        if (max > min) {
          var extraValue = min;
          var usingExtra = false;
          do {
            roll = !usingExtra ? _assertClassBrand(_TinyDices_brand, tinyDice, _rollNumber).call(tinyDice, max, canZero) : extraValue;
            if (usingExtra || sequence.length >= max) {
              if (extraValue >= max) {
                extraValue = min;
                countSeq.clear();
              }
              extraValue++;
              usingExtra = true;
            }
          } while (countSeq.has(roll));
        }
        // 0 or negative max
        else roll = max;
        // Insert sequence
        if (roll < 1) roll = 0;
        sequence.push(roll);
        countSeq.add(roll);
        face.textContent = String(roll);
      }
      // The result!
      else {
        face.textContent = String(result);
        sequence.push(result);
        countSeq.add(result);
      }
      // Side added
      wrapper.appendChild(face);
      diceElements.faces.push(face);
    }
    // Stop cube animation
    if (!rollInfinity) {
      setTimeout(function () {
        if (wrapper) wrapper.classList.add('stopped');
      }, 2000);
    }
    // Insert the cube
    container.appendChild(wrapper);
    _assertClassBrand(_TinyDices_brand, tinyDice, _addElement).call(tinyDice, diceElements);
    return {
      cube: container,
      sequence: sequence
    };
  });
}
var _default = exports["default"] = TinyDices;

},{"tiny-essentials":142,"validate-color":177}],134:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"dup":112}],135:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],136:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"dup":114}],137:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],138:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],139:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"buffer":62,"dup":119}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatBytes = formatBytes;
exports.getAge = getAge;
exports.getSimplePerc = getSimplePerc;
exports.ruleOfThree = ruleOfThree;
/**
 * Executes a Rule of Three calculation.
 *
 * @param {number} val1 - The first reference value (numerator in direct proportion, denominator in inverse).
 * @param {number} val2 - The second reference value (denominator in direct proportion, numerator in inverse).
 * @param {number} val3 - The third value (numerator in direct proportion, denominator in inverse).
 * @param {boolean} [inverse] - Whether the calculation should use inverse proportion (true for inverse, false for direct).
 * @returns {number} The result of the Rule of Three operation.
 *
 * Rule of Three Formula (Direct Proportion):
 *      val1 / val2 = val3 / result
 *
 * For Inverse Proportion:
 *      val1 / val3 = val2 / result
 *
 * Visual Representation:
 *
 * For Direct Proportion:
 *      val1      val2
 *      -----  =  ------
 *      val3      result
 *
 * For Inverse Proportion:
 *      val1      val2
 *      -----  =  ------
 *      val3      result
 *
 * @example
 * // Direct proportion:
 * ruleOfThree.execute(2, 6, 3, false); // → 9
 *
 * @example
 * // Inverse proportion:
 * ruleOfThree.execute(2, 6, 3, true); // → 4
 */
function ruleOfThree(val1, val2, val3) {
  var inverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return inverse ? Number(val1 * val2) / val3 : Number(val3 * val2) / val1;
}
/**
 * Calculates a percentage of a given base value.
 * @param {number} price - The base value.
 * @param {number} percentage - The percentage to apply.
 * @returns {number} The result of the percentage calculation.
 *
 * @example
 * getSimplePerc(200, 15); // 30
 */
function getSimplePerc(price, percentage) {
  return price * (percentage / 100);
}
/**
 * Calculates the age based on the given date.
 *
 * @param {number|string|Date} timeData - The birth date (can be a timestamp, ISO string, or Date object).
 * @param {Date|null} [now=null] - The Date object representing the current date. Defaults to the current date and time if not provided.
 * @returns {number|null} The age in years, or null if `timeData` is not provided or invalid.
 */
function getAge() {
  var timeData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (typeof timeData !== 'undefined' && timeData !== null && timeData !== 0) {
    var birthDate = new Date(timeData);
    if (Number.isNaN(birthDate.getTime())) return null;
    var currentDate = now instanceof Date ? now : new Date();
    var age = currentDate.getFullYear() - birthDate.getFullYear();
    var currentMonth = currentDate.getMonth();
    var birthMonth = birthDate.getMonth();
    var currentDay = currentDate.getDate();
    var birthDay = birthDate.getDate();
    // Adjust if birthday hasn't occurred yet this year
    if (currentMonth < birthMonth || currentMonth === birthMonth && currentDay < birthDay) age--;
    return Math.abs(age);
  }
  return null;
}
/**
 * @typedef {Object} FormattedByteResult
 * @property {string|null} unit - The resulting unit (e.g., 'MB', 'GB') or null if input is invalid.
 * @property {number|null} value - The numerical value in the chosen unit, or null if input is invalid.
 */
/**
 * Converts a byte value into a human-readable format with unit and value separated.
 *
 * @param {number} bytes - The number of bytes to format. Must be a non-negative number.
 * @param {number|null} [decimals=null] - The number of decimal places to include in the result. Defaults to null. If negative, it will be treated as 0. If null, no rounding is applied.
 * @param {string|null} [maxUnit=null] - Optional unit limit. If provided, restricts conversion to this unit at most (e.g., 'MB' prevents conversion to 'GB' or higher). Must be one of: 'Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'.
 * @returns {FormattedByteResult} An object with the converted value and its corresponding unit. Returns nulls if input is invalid.
 *
 * @example
 * formatBytes(123456789);
 * // → { unit: 'MB', value: 117.74 }
 *
 * @example
 * formatBytes(1073741824, 2, 'MB');
 * // → { unit: 'MB', value: 1024 }
 */
function formatBytes(bytes) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var maxUnit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (typeof bytes !== 'number' || bytes < 0) return {
    unit: null,
    value: null
  };
  if (bytes === 0) return {
    unit: 'Bytes',
    value: 0
  };
  var k = 1024;
  var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  var maxIndex = maxUnit && sizes.includes(maxUnit) ? sizes.indexOf(maxUnit) : sizes.length - 1;
  var i = Math.min(Math.floor(Math.log(bytes) / Math.log(k)), maxIndex);
  var value = bytes / Math.pow(k, i);
  if (decimals !== null) {
    var dm = decimals < 0 ? 0 : decimals;
    value = parseFloat(value.toFixed(dm));
  }
  var unit = sizes[i];
  return {
    unit: unit,
    value: value
  };
}

},{}],141:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"dup":121}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ColorSafeStringify", {
  enumerable: true,
  get: function get() {
    return _ColorSafeStringify["default"];
  }
});
Object.defineProperty(exports, "TinyLevelUp", {
  enumerable: true,
  get: function get() {
    return _userLevel["default"];
  }
});
Object.defineProperty(exports, "TinyPromiseQueue", {
  enumerable: true,
  get: function get() {
    return _TinyPromiseQueue["default"];
  }
});
Object.defineProperty(exports, "TinyRateLimiter", {
  enumerable: true,
  get: function get() {
    return _TinyRateLimiter["default"];
  }
});
Object.defineProperty(exports, "addAiMarkerShortcut", {
  enumerable: true,
  get: function get() {
    return _text.addAiMarkerShortcut;
  }
});
Object.defineProperty(exports, "arraySortPositions", {
  enumerable: true,
  get: function get() {
    return _arraySortPositions["default"];
  }
});
Object.defineProperty(exports, "asyncReplace", {
  enumerable: true,
  get: function get() {
    return _replaceAsync["default"];
  }
});
Object.defineProperty(exports, "checkObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.checkObj;
  }
});
Object.defineProperty(exports, "cloneObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.cloneObjTypeOrder;
  }
});
Object.defineProperty(exports, "countObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.countObj;
  }
});
Object.defineProperty(exports, "extendObjType", {
  enumerable: true,
  get: function get() {
    return _objFilter.extendObjType;
  }
});
Object.defineProperty(exports, "formatBytes", {
  enumerable: true,
  get: function get() {
    return _simpleMath.formatBytes;
  }
});
Object.defineProperty(exports, "formatCustomTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatCustomTimer;
  }
});
Object.defineProperty(exports, "formatDayTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatDayTimer;
  }
});
Object.defineProperty(exports, "formatTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatTimer;
  }
});
Object.defineProperty(exports, "getAge", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getAge;
  }
});
Object.defineProperty(exports, "getSimplePerc", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getSimplePerc;
  }
});
Object.defineProperty(exports, "getTimeDuration", {
  enumerable: true,
  get: function get() {
    return _clock.getTimeDuration;
  }
});
Object.defineProperty(exports, "isJsonObject", {
  enumerable: true,
  get: function get() {
    return _objFilter.isJsonObject;
  }
});
Object.defineProperty(exports, "objType", {
  enumerable: true,
  get: function get() {
    return _objFilter.objType;
  }
});
Object.defineProperty(exports, "reorderObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.reorderObjTypeOrder;
  }
});
Object.defineProperty(exports, "ruleOfThree", {
  enumerable: true,
  get: function get() {
    return _simpleMath.ruleOfThree;
  }
});
Object.defineProperty(exports, "shuffleArray", {
  enumerable: true,
  get: function get() {
    return _array.shuffleArray;
  }
});
Object.defineProperty(exports, "toTitleCase", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCase;
  }
});
Object.defineProperty(exports, "toTitleCaseLowerFirst", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCaseLowerFirst;
  }
});
var _replaceAsync = _interopRequireDefault(require("../legacy/libs/replaceAsync.mjs"));
var _userLevel = _interopRequireDefault(require("../legacy/libs/userLevel.mjs"));
var _arraySortPositions = _interopRequireDefault(require("../legacy/libs/arraySortPositions.mjs"));
var _array = require("./basics/array.mjs");
var _clock = require("./basics/clock.mjs");
var _objFilter = require("./basics/objFilter.mjs");
var _simpleMath = require("./basics/simpleMath.mjs");
var _text = require("./basics/text.mjs");
var _ColorSafeStringify = _interopRequireDefault(require("./libs/ColorSafeStringify.mjs"));
var _TinyPromiseQueue = _interopRequireDefault(require("./libs/TinyPromiseQueue.mjs"));
var _TinyRateLimiter = _interopRequireDefault(require("./libs/TinyRateLimiter.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"../legacy/libs/arraySortPositions.mjs":134,"../legacy/libs/replaceAsync.mjs":135,"../legacy/libs/userLevel.mjs":136,"./basics/array.mjs":137,"./basics/clock.mjs":138,"./basics/objFilter.mjs":139,"./basics/simpleMath.mjs":140,"./basics/text.mjs":141,"./libs/ColorSafeStringify.mjs":143,"./libs/TinyPromiseQueue.mjs":144,"./libs/TinyRateLimiter.mjs":145}],143:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"dup":125}],144:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"dup":130}],145:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"_process":97,"dup":131}],146:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"dup":112}],147:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],148:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"dup":114}],149:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"dup":115}],150:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areElsPerfColliding = exports.areElsColliding = exports.areElsCollTop = exports.areElsCollRight = exports.areElsCollPerfTop = exports.areElsCollPerfRight = exports.areElsCollPerfLeft = exports.areElsCollPerfBottom = exports.areElsCollLeft = exports.areElsCollBottom = void 0;
exports.getElsCollDetails = getElsCollDetails;
exports.getElsCollDirDepth = getElsCollDirDepth;
exports.getElsPerfColliding = exports.getElsColliding = exports.getElsCollOverlapPos = exports.getElsCollOverlap = void 0;
exports.getElsRelativeCenterOffset = getElsRelativeCenterOffset;
exports.getRectCenter = void 0;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/**
 * A direction relative to a rectangle.
 *
 * Represents one of the four cardinal directions from the perspective of the element.
 *
 * @typedef {'top' | 'bottom' | 'left' | 'right'} Dirs
 */
/**
 * Represents all directional aspects of a collision.
 *
 * @typedef {Object} CollDirs
 * @property {Dirs | 'center' | null} in - The dominant direction of entry. `'center'` if all sides are equally overlapped. `null` if no collision.
 * @property {Dirs | null} x - The horizontal direction (`'left'` or `'right'`) the collision is biased toward, or `null`.
 * @property {Dirs | null} y - The vertical direction (`'top'` or `'bottom'`) the collision is biased toward, or `null`.
 */
/**
 * Indicates if a collision is in the negative direction (rect2 is outside rect1).
 *
 * @typedef {Object} NegCollDirs
 * @property {Dirs | null} x - Horizontal direction of negative overlap, if any.
 * @property {Dirs | null} y - Vertical direction of negative overlap, if any.
 */
/**
 * Collision depth values from each side of rect2 inside rect1.
 *
 * Positive values indicate penetration; negative values indicate gaps.
 *
 * @typedef {Object} CollData
 * @property {number} top - Depth from rect2's top into rect1.
 * @property {number} bottom - Depth from rect2's bottom into rect1.
 * @property {number} left - Depth from rect2's left into rect1.
 * @property {number} right - Depth from rect2's right into rect1.
 */
/**
 * X and Y offset representing center difference between two rectangles.
 *
 * Useful to measure how far one element's center is from another.
 *
 * @typedef {Object} CollCenter
 * @property {number} x - Horizontal distance in pixels from rect1's center to rect2's center.
 * @property {number} y - Vertical distance in pixels from rect1's center to rect2's center.
 */
/**
 * Represents a rectangular area in absolute pixel values.
 *
 * Similar to `DOMRect`, this object describes the dimensions and position of a box
 * in the 2D plane, typically representing an element's bounding box.
 *
 * @typedef {Object} ObjRect
 * @property {number} height - The total height of the rectangle in pixels.
 * @property {number} width - The total width of the rectangle in pixels.
 * @property {number} top - The Y-coordinate of the top edge of the rectangle.
 * @property {number} bottom - The Y-coordinate of the bottom edge of the rectangle.
 * @property {number} left - The X-coordinate of the left edge of the rectangle.
 * @property {number} right - The X-coordinate of the right edge of the rectangle.
 */
// Normal collision checks (loose overlap detection)
/**
 * Checks if rect1 is completely above rect2 (no vertical overlap).
 *
 * @param {ObjRect} rect1 - The bounding rectangle of the first element.
 * @param {ObjRect} rect2 - The bounding rectangle of the second element.
 * @returns {boolean} True if rect1 is entirely above rect2.
 */
var areElsCollTop = exports.areElsCollTop = function areElsCollTop(rect1, rect2) {
  return rect1.bottom < rect2.top;
};
/**
 * Checks if rect1 is completely below rect2 (no vertical overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is entirely below rect2.
 */
var areElsCollBottom = exports.areElsCollBottom = function areElsCollBottom(rect1, rect2) {
  return rect1.top > rect2.bottom;
};
/**
 * Checks if rect1 is completely to the left of rect2 (no horizontal overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is entirely to the left of rect2.
 */
var areElsCollLeft = exports.areElsCollLeft = function areElsCollLeft(rect1, rect2) {
  return rect1.right < rect2.left;
};
/**
 * Checks if rect1 is completely to the right of rect2 (no horizontal overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is entirely to the right of rect2.
 */
var areElsCollRight = exports.areElsCollRight = function areElsCollRight(rect1, rect2) {
  return rect1.left > rect2.right;
};
// Perfect collision checks (touch included)
/**
 * Checks if rect1 is perfectly above rect2 (no vertical touch or overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is fully above or touching rect2's top.
 */
var areElsCollPerfTop = exports.areElsCollPerfTop = function areElsCollPerfTop(rect1, rect2) {
  return rect1.bottom <= rect2.top;
};
/**
 * Checks if rect1 is perfectly below rect2 (no vertical touch or overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is fully below or touching rect2's bottom.
 */
var areElsCollPerfBottom = exports.areElsCollPerfBottom = function areElsCollPerfBottom(rect1, rect2) {
  return rect1.top >= rect2.bottom;
};
/**
 * Checks if rect1 is perfectly to the left of rect2 (no horizontal touch or overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is fully left or touching rect2's left.
 */
var areElsCollPerfLeft = exports.areElsCollPerfLeft = function areElsCollPerfLeft(rect1, rect2) {
  return rect1.right <= rect2.left;
};
/**
 * Checks if rect1 is perfectly to the right of rect2 (no horizontal touch or overlap).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if rect1 is fully right or touching rect2's right.
 */
var areElsCollPerfRight = exports.areElsCollPerfRight = function areElsCollPerfRight(rect1, rect2) {
  return rect1.left >= rect2.right;
};
// Main collision check
/**
 * Returns true if rect1 and rect2 are colliding (partially or fully overlapping).
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if there's any collision between rect1 and rect2.
 */
var areElsColliding = exports.areElsColliding = function areElsColliding(rect1, rect2) {
  return !(areElsCollLeft(rect1, rect2) || areElsCollRight(rect1, rect2) || areElsCollTop(rect1, rect2) || areElsCollBottom(rect1, rect2));
};
/**
 * Returns true if rect1 and rect2 are colliding or perfectly touching.
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {boolean} True if there's any contact or overlap.
 */
var areElsPerfColliding = exports.areElsPerfColliding = function areElsPerfColliding(rect1, rect2) {
  return !(areElsCollPerfLeft(rect1, rect2) || areElsCollPerfRight(rect1, rect2) || areElsCollPerfTop(rect1, rect2) || areElsCollPerfBottom(rect1, rect2));
};
// Collision direction guess (loose and perfect)
/**
 * Attempts to determine the direction rect1 entered rect2 based on loose overlap rules.
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {string|null} 'top' | 'bottom' | 'left' | 'right' | null
 */
var getElsColliding = exports.getElsColliding = function getElsColliding(rect1, rect2) {
  if (areElsCollLeft(rect1, rect2)) return 'left';else if (areElsCollRight(rect1, rect2)) return 'right';else if (areElsCollTop(rect1, rect2)) return 'top';else if (areElsCollBottom(rect1, rect2)) return 'bottom';
  return null;
};
/**
 * Attempts to determine the direction rect1 touched or entered rect2 using perfect mode.
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {'top' | 'bottom' | 'left' | 'right' | null}
 */
var getElsPerfColliding = exports.getElsPerfColliding = function getElsPerfColliding(rect1, rect2) {
  if (areElsCollPerfLeft(rect1, rect2)) return 'left';else if (areElsCollPerfRight(rect1, rect2)) return 'right';else if (areElsCollPerfTop(rect1, rect2)) return 'top';else if (areElsCollPerfBottom(rect1, rect2)) return 'bottom';
  return null;
};
// Overlap Calculation
/**
 * Calculates overlap values between rect1 and rect2 in all directions.
 *
 * @param {ObjRect} rect1
 * @param {ObjRect} rect2
 * @returns {{
 *   overlapLeft: number,
 *   overlapRight: number,
 *   overlapTop: number,
 *   overlapBottom: number
 * }} Distance of overlap from each direction (can be negative).
 */
var getElsCollOverlap = exports.getElsCollOverlap = function getElsCollOverlap(rect1, rect2) {
  return {
    overlapLeft: rect2.right - rect1.left,
    overlapRight: rect1.right - rect2.left,
    overlapTop: rect2.bottom - rect1.top,
    overlapBottom: rect1.bottom - rect2.top
  };
};
/**
 * Determines directional collision based on overlap depth.
 *
 * @param {Object} [settings={}]
 * @param {number} [settings.overlapLeft]
 * @param {number} [settings.overlapRight]
 * @param {number} [settings.overlapTop]
 * @param {number} [settings.overlapBottom]
 * @returns {{ dirX: Dirs, dirY: Dirs }} Direction of strongest X/Y overlap.
 */
var getElsCollOverlapPos = exports.getElsCollOverlapPos = function getElsCollOverlapPos() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$overlapLeft = _ref.overlapLeft,
    overlapLeft = _ref$overlapLeft === void 0 ? -1 : _ref$overlapLeft,
    _ref$overlapRight = _ref.overlapRight,
    overlapRight = _ref$overlapRight === void 0 ? -1 : _ref$overlapRight,
    _ref$overlapTop = _ref.overlapTop,
    overlapTop = _ref$overlapTop === void 0 ? -1 : _ref$overlapTop,
    _ref$overlapBottom = _ref.overlapBottom,
    overlapBottom = _ref$overlapBottom === void 0 ? -1 : _ref$overlapBottom;
  return {
    dirX: overlapLeft < overlapRight ? 'right' : 'left',
    dirY: overlapTop < overlapBottom ? 'bottom' : 'top'
  };
};
// Center utils
/**
 * Calculates the center point (X and Y) of a given Rect.
 *
 * @param {ObjRect} rect - The bounding rectangle of the element.
 * @returns {{ x: number, y: number }} An object with the `x` and `y` coordinates of the center.
 */
var getRectCenter = exports.getRectCenter = function getRectCenter(rect) {
  return {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
  };
};
/**
 * Calculates the offset between the center of rect2 and the center of rect1.
 *
 * The values will be 0 when rect1 is perfectly centered over rect2.
 *
 * @param {ObjRect} rect1 - The bounding rectangle of the reference element.
 * @param {ObjRect} rect2 - The bounding rectangle of the element being compared.
 * @returns {{
 *   x: number,
 *   y: number
 * }} An object with the X and Y offset in pixels from rect1's center to rect2's center.
 */
function getElsRelativeCenterOffset(rect1, rect2) {
  var center1X = rect1.left + rect1.width / 2;
  var center1Y = rect1.top + rect1.height / 2;
  var center2X = rect2.left + rect2.width / 2;
  var center2Y = rect2.top + rect2.height / 2;
  return {
    x: center2X - center1X,
    y: center2Y - center1Y
  };
}
// Direction & Depth detection
/**
 * Detects the direction of the dominant collision between two elements
 * and calculates how deep the overlap is in both x and y axes.
 *
 * @param {ObjRect} rect1 - The bounding rectangle of the first element.
 * @param {ObjRect} rect2 - The bounding rectangle of the second element.
 * @returns {{
 *   inDir: Dirs | null;
 *   dirX: Dirs | null;
 *   dirY: Dirs | null;
 *   depthX: number;
 *   depthY: number;
 * }} An object containing the collision direction and how deep the overlap is.
 */
function getElsCollDirDepth(rect1, rect2) {
  if (!areElsPerfColliding(rect1, rect2)) return {
    inDir: null,
    dirX: null,
    dirY: null,
    depthX: 0,
    depthY: 0
  };
  var _getElsCollOverlap = getElsCollOverlap(rect1, rect2),
    overlapLeft = _getElsCollOverlap.overlapLeft,
    overlapRight = _getElsCollOverlap.overlapRight,
    overlapTop = _getElsCollOverlap.overlapTop,
    overlapBottom = _getElsCollOverlap.overlapBottom;
  var _getElsCollOverlapPos = getElsCollOverlapPos({
      overlapLeft: overlapLeft,
      overlapRight: overlapRight,
      overlapTop: overlapTop,
      overlapBottom: overlapBottom
    }),
    dirX = _getElsCollOverlapPos.dirX,
    dirY = _getElsCollOverlapPos.dirY;
  var depthX = Math.min(overlapLeft, overlapRight);
  var depthY = Math.min(overlapTop, overlapBottom);
  /** @type {Dirs} */
  var inDir;
  if (depthX < depthY) inDir = dirX;else inDir = dirY;
  return {
    inDir: inDir,
    dirX: dirX,
    dirY: dirY,
    depthX: depthX,
    depthY: depthY
  };
}
// Full detail report
/**
 * Detects the collision direction and depth between two DOMRects.
 *
 * @param {ObjRect} rect1 - The bounding rectangle of the first element.
 * @param {ObjRect} rect2 - The bounding rectangle of the second element.
 * @returns {{ depth: CollData; dirs: CollDirs; isNeg: NegCollDirs; }} Collision info or null if no collision is detected.
 */
function getElsCollDetails(rect1, rect2) {
  var isColliding = areElsPerfColliding(rect1, rect2);
  /** @type {CollDirs} */
  var dirs = {
    "in": null,
    x: null,
    y: null
  };
  /** @type {NegCollDirs} */
  var isNeg = {
    y: null,
    x: null
  };
  /** @type {Record<Dirs, number>} */
  var depth = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  };
  // Depth
  // Yes, it's actually reversed the values orders
  var _getElsCollOverlap2 = getElsCollOverlap(rect2, rect1),
    overlapLeft = _getElsCollOverlap2.overlapLeft,
    overlapRight = _getElsCollOverlap2.overlapRight,
    overlapTop = _getElsCollOverlap2.overlapTop,
    overlapBottom = _getElsCollOverlap2.overlapBottom;
  depth.top = overlapTop;
  depth.bottom = overlapBottom;
  depth.left = overlapLeft;
  depth.right = overlapRight;
  // Dirs
  /**
   * Detect the direction with the smallest positive overlap (entry point)
   * @type {[Dirs, number][]}
   */
  // @ts-ignore
  var entries = Object.entries(depth).filter(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      val = _ref3[1];
    return val > 0;
  }).sort(function (a, b) {
    return a[1] - b[1];
  });
  // Yes, it's actually reversed the values orders here too
  var _getElsCollOverlapPos2 = getElsCollOverlapPos({
      overlapLeft: overlapRight,
      overlapRight: overlapLeft,
      overlapTop: overlapBottom,
      overlapBottom: overlapTop
    }),
    dirX = _getElsCollOverlapPos2.dirX,
    dirY = _getElsCollOverlapPos2.dirY;
  dirs.y = dirY;
  dirs.x = dirX;
  // isNeg
  if (depth.bottom < 0) isNeg.y = 'bottom';else if (depth.top < 0) isNeg.y = 'top';
  if (depth.left < 0) isNeg.x = 'left';else if (depth.right < 0) isNeg.x = 'right';
  // Inside Dir
  dirs["in"] = isColliding ? depth.top === depth.bottom && depth.bottom === depth.left && depth.left === depth.right ? 'center' : entries.length ? entries[0][0] : 'top' : null; // fallback in case of exact match
  // Complete
  return {
    dirs: dirs,
    depth: depth,
    isNeg: isNeg
  };
}

},{}],152:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"dup":117}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchBlob = fetchBlob;
exports.fetchJson = fetchJson;
exports.installWindowHiddenScript = installWindowHiddenScript;
exports.readBase64Blob = readBase64Blob;
exports.readFileBlob = readFileBlob;
exports.readJsonBlob = readJsonBlob;
exports.saveJsonFile = saveJsonFile;
var _objFilter = require("./objFilter.mjs");
function _regeneratorValues(e) { if (null != e) { var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) return { next: function next() { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }; } }; } throw new TypeError(_typeof(e) + " is not iterable"); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/////////////////////////////////////////////////////////////////
/**
 * Reads the contents of a file using the specified FileReader method.
 *
 * @param {File} file - The file to be read.
 * @param {'readAsArrayBuffer'|'readAsDataURL'|'readAsText'|'readAsBinaryString'} method -
 *   The FileReader method to use for reading the file.
 * @returns {Promise<any>} - A promise that resolves with the file content, according to the chosen method.
 * @throws {Error} - If an unexpected error occurs while handling the result.
 * @throws {DOMException} - If the FileReader encounters an error while reading the file.
 */
function readFileBlob(file, method) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();
    reader.onload = function () {
      try {
        resolve(reader.result);
      } catch (error) {
        reject(error);
      }
    };
    reader.onerror = function () {
      reject(reader.error);
    };
    reader[method](file);
  });
}
/**
 * Reads a file as a Base64 string using FileReader, and optionally formats it as a full data URL.
 *
 * Performs strict validation to ensure the result is a valid Base64 string or a proper data URL.
 *
 * @param {File} file - The file to be read.
 * @param {boolean|string} [isDataUrl=false] - If true, returns a full data URL; if false, returns only the Base64 string;
 *   if a string is passed, it is used as the MIME type in the data URL.
 * @returns {Promise<string>} - A promise that resolves with the Base64 string or data URL.
 *
 * @throws {TypeError} - If the result is not a string or if `isDataUrl` is not a valid type.
 * @throws {Error} - If the result does not match the expected data URL format or Base64 structure.
 * @throws {DOMException} - If the FileReader fails to read the file.
 */
function readBase64Blob(file) {
  var isDataUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return new Promise(function (resolve, reject) {
    if (typeof isDataUrl !== 'string' && typeof isDataUrl !== 'boolean') reject(new TypeError('The isDataUrl parameter must be a boolean or a string.'));
    readFileBlob(file, 'readAsDataURL').then(
    /**
     * Ensure that the URL format is correct in the required pattern
     * @param {string} base64Data
     */
    function (base64Data) {
      if (typeof base64Data !== 'string') throw new TypeError('Expected file content to be a string.');
      var match = base64Data.match(/^data:(.+);base64,(.*)$/);
      if (!match || !match[2]) throw new Error('Invalid data URL format or missing Base64 content.');
      var _match = _slicedToArray(match, 3),
        mimeType = _match[1],
        base64 = _match[2];
      if (!/^[\w/+]+=*$/.test(base64)) throw new Error('Base64 content is malformed.');
      if (typeof isDataUrl === 'boolean') return resolve(isDataUrl ? base64Data : base64);
      if (!/^[\w-]+\/[\w.+-]+$/.test(isDataUrl)) throw new Error("Invalid MIME type string: ".concat(isDataUrl));
      return resolve("data:".concat(isDataUrl, ";base64,").concat(base64));
    })["catch"](reject);
  });
}
/**
 * Reads a file and strictly validates its content as proper JSON using FileReader.
 *
 * Performs several checks to ensure the file contains valid, parsable JSON data.
 *
 * @param {File} file - The file to be read. It must contain valid JSON as plain text.
 * @returns {Promise<Record<string|number|symbol, any>|any[]>} - A promise that resolves with the parsed JSON object.
 *
 * @throws {SyntaxError} - If the file content is not valid JSON syntax.
 * @throws {TypeError} - If the result is not a string or does not represent a JSON value.
 * @throws {Error} - If the result is empty or structurally invalid as JSON.
 * @throws {DOMException} - If the FileReader fails to read the file.
 */
function readJsonBlob(file) {
  return new Promise(function (resolve, reject) {
    return readFileBlob(file, 'readAsText').then(function (data) {
      if (typeof data !== 'string') throw new TypeError('Expected file content to be a string.');
      var trimmed = data.trim();
      if (trimmed.length === 0) throw new Error('File is empty or contains only whitespace.');
      var parsed = JSON.parse(trimmed);
      if (_typeof(parsed) !== 'object' || parsed === null) throw new Error('Parsed content is not a valid JSON object or array.');
      resolve(parsed);
    })["catch"](reject);
  });
}
/**
 * Saves a JSON object as a downloadable file.
 * @param {string} filename
 * @param {any} data
 * @param {number} [spaces=2]
 */
function saveJsonFile(filename, data) {
  var spaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var json = JSON.stringify(data, null, spaces);
  var blob = new Blob([json], {
    type: 'application/json'
  });
  var url = URL.createObjectURL(blob);
  var link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
/**
 * @typedef {Object} FetchTemplateOptions
 * @property {string} [method="GET"] - HTTP method to use (GET, POST, etc.).
 * @property {any} [body] - Request body (only for methods like POST, PUT).
 * @property {number} [timeout=0] - Timeout in milliseconds (ignored if signal is provided).
 * @property {number} [retries=0] - Number of retry attempts (ignored if signal is provided).
 * @property {Headers|Record<string, *>} [headers={}] - Additional headers.
 * @property {AbortSignal|null} [signal] - External AbortSignal; disables timeout and retries.
 */
/**
 * @param {string} url - The full URL to fetch data from.
 * @param {FetchTemplateOptions} [options] - Optional settings.
 * @returns {Promise<Response>} Result data.
 * @throws {Error} Throws if fetch fails, times out.
 */
function fetchTemplate(_x) {
  return _fetchTemplate.apply(this, arguments);
}
/**
 * Loads and parses a JSON from a remote URL using Fetch API.
 *
 * @param {string} url - The full URL to fetch JSON from.
 * @param {Object} [options] - Optional settings.
 * @returns {Promise<any[] | Record<string | number | symbol, unknown>>} Parsed JSON object.
 * @throws {Error} Throws if fetch fails, times out, or returns invalid JSON.
 */
function _fetchTemplate() {
  _fetchTemplate = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(url) {
    var _ref2,
      _ref2$method,
      method,
      body,
      _ref2$timeout,
      timeout,
      _ref2$retries,
      retries,
      _ref2$headers,
      headers,
      _ref2$signal,
      signal,
      attempts,
      lastError,
      _loop,
      _ret,
      attempt,
      _args2 = arguments;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          _ref2 = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, _ref2$method = _ref2.method, method = _ref2$method === void 0 ? 'GET' : _ref2$method, body = _ref2.body, _ref2$timeout = _ref2.timeout, timeout = _ref2$timeout === void 0 ? 0 : _ref2$timeout, _ref2$retries = _ref2.retries, retries = _ref2$retries === void 0 ? 0 : _ref2$retries, _ref2$headers = _ref2.headers, headers = _ref2$headers === void 0 ? {} : _ref2$headers, _ref2$signal = _ref2.signal, signal = _ref2$signal === void 0 ? null : _ref2$signal;
          if (!(typeof url !== 'string' || !url.startsWith('../') && !url.startsWith('./') && !url.startsWith('/') && !url.startsWith('https://') && !url.startsWith('http://'))) {
            _context2.n = 1;
            break;
          }
          throw new Error('Invalid URL: must be a valid http or https address.');
        case 1:
          if (!(typeof method !== 'string' || !method.trim())) {
            _context2.n = 2;
            break;
          }
          throw new Error('Invalid method: must be a non-empty string.');
        case 2:
          if (signal) {
            _context2.n = 4;
            break;
          }
          if (!(typeof timeout !== 'number' || !Number.isFinite(timeout) || Number.isNaN(timeout) || timeout < 0)) {
            _context2.n = 3;
            break;
          }
          throw new Error('Invalid timeout: must be a positive number.');
        case 3:
          if (!(typeof retries !== 'number' || !Number.isFinite(retries) || Number.isNaN(retries) || retries < 0)) {
            _context2.n = 4;
            break;
          }
          throw new Error('Invalid retries: must be a positive number.');
        case 4:
          attempts = signal ? 1 : retries + 1;
          /** @type {Error|null} */
          lastError = null;
          _loop = /*#__PURE__*/_regenerator().m(function _loop(attempt) {
            var _controller$signal;
            var controller, localSignal, timer, response, _t;
            return _regenerator().w(function (_context) {
              while (1) switch (_context.n) {
                case 0:
                  controller = signal ? null : new AbortController();
                  localSignal = signal || ((_controller$signal = controller === null || controller === void 0 ? void 0 : controller.signal) !== null && _controller$signal !== void 0 ? _controller$signal : null);
                  timer = !signal && timeout && controller ? setTimeout(function () {
                    return controller.abort();
                  }, timeout) : null;
                  _context.p = 1;
                  _context.n = 2;
                  return fetch(url, {
                    method: method.toUpperCase(),
                    headers: _objectSpread({
                      Accept: 'application/json'
                    }, headers),
                    body: body !== undefined ? (0, _objFilter.isJsonObject)(body) ? JSON.stringify(body) : body : undefined,
                    signal: localSignal
                  });
                case 2:
                  response = _context.v;
                  if (timer) clearTimeout(timer);
                  if (response.ok) {
                    _context.n = 3;
                    break;
                  }
                  throw new Error("HTTP error: ".concat(response.status, " ").concat(response.statusText));
                case 3:
                  return _context.a(2, {
                    v: response
                  });
                case 4:
                  _context.p = 4;
                  _t = _context.v;
                  lastError = /** @type {Error} */_t;
                  if (!signal) {
                    _context.n = 5;
                    break;
                  }
                  return _context.a(2, 0);
                case 5:
                  if (!(attempt < retries)) {
                    _context.n = 6;
                    break;
                  }
                  _context.n = 6;
                  return new Promise(function (resolve) {
                    return setTimeout(resolve, 300 * (attempt + 1));
                  });
                case 6:
                  return _context.a(2);
              }
            }, _loop, null, [[1, 4]]);
          });
          attempt = 0;
        case 5:
          if (!(attempt < attempts)) {
            _context2.n = 9;
            break;
          }
          return _context2.d(_regeneratorValues(_loop(attempt)), 6);
        case 6:
          _ret = _context2.v;
          if (!(_ret === 0)) {
            _context2.n = 7;
            break;
          }
          return _context2.a(3, 9);
        case 7:
          if (!_ret) {
            _context2.n = 8;
            break;
          }
          return _context2.a(2, _ret.v);
        case 8:
          attempt++;
          _context2.n = 5;
          break;
        case 9:
          throw new Error("Failed to fetch JSON from \"".concat(url, "\"").concat(lastError ? ": ".concat(lastError.message) : '.'));
        case 10:
          return _context2.a(2);
      }
    }, _callee);
  }));
  return _fetchTemplate.apply(this, arguments);
}
function fetchJson(_x2, _x3) {
  return _fetchJson.apply(this, arguments);
}
/**
 * Loads a remote file as a Blob using Fetch API.
 *
 * @param {string} url - The full URL to fetch the file from.
 * @param {Object} [options] - Optional fetch options.
 * @param {string[]} [allowedMimeTypes] - Optional list of accepted MIME types (e.g., ['image/jpeg']).
 * @returns {Promise<Blob>} - The fetched file as a Blob.
 * @throws {Error} Throws if fetch fails, response is not ok, or MIME type is not allowed.
 */
function _fetchJson() {
  _fetchJson = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(url, options) {
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          return _context4.a(2, new Promise(function (resolve, reject) {
            fetchTemplate(url, options).then(/*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(res) {
                var contentType, data;
                return _regenerator().w(function (_context3) {
                  while (1) switch (_context3.n) {
                    case 0:
                      contentType = res.headers.get('content-type') || '';
                      if (contentType.includes('application/json')) {
                        _context3.n = 1;
                        break;
                      }
                      throw new Error("Unexpected content-type: ".concat(contentType));
                    case 1:
                      _context3.n = 2;
                      return res.json();
                    case 2:
                      data = _context3.v;
                      if (!(!Array.isArray(data) && !(0, _objFilter.isJsonObject)(data))) {
                        _context3.n = 3;
                        break;
                      }
                      throw new Error('Received invalid data instead of valid JSON.');
                    case 3:
                      return _context3.a(2, resolve(data));
                  }
                }, _callee2);
              }));
              return function (_x7) {
                return _ref3.apply(this, arguments);
              };
            }())["catch"](reject);
          }));
      }
    }, _callee3);
  }));
  return _fetchJson.apply(this, arguments);
}
function fetchBlob(_x4, _x5, _x6) {
  return _fetchBlob.apply(this, arguments);
} ///////////////////////////////////////////////////////////////////////////////
/**
 * Installs a script that toggles CSS classes on a given element
 * based on the page's visibility or focus state, and optionally
 * triggers callbacks on visibility changes.
 *
 * @param {Object} [settings={}]
 * @param {Element} [settings.element=document.body] - The element to receive visibility classes.
 * @param {string} [settings.hiddenClass='windowHidden'] - CSS class applied when the page is hidden.
 * @param {string} [settings.visibleClass='windowVisible'] - CSS class applied when the page is visible.
 * @param {() => void} [settings.onVisible] - Callback called when page becomes visible.
 * @param {() => void} [settings.onHidden] - Callback called when page becomes hidden.
 * @returns {() => void} Function that removes all installed event listeners.
 * @throws {TypeError} If any provided setting is invalid.
 */
function _fetchBlob() {
  _fetchBlob = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(url, allowedMimeTypes, options) {
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          return _context6.a(2, new Promise(function (resolve, reject) {
            fetchTemplate(url, options).then(/*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(res) {
                var contentType, data;
                return _regenerator().w(function (_context5) {
                  while (1) switch (_context5.n) {
                    case 0:
                      contentType = res.headers.get('content-type') || '';
                      if (!(Array.isArray(allowedMimeTypes) && allowedMimeTypes.length > 0 && !allowedMimeTypes.some(function (type) {
                        return contentType.includes(type);
                      }))) {
                        _context5.n = 1;
                        break;
                      }
                      throw new Error("Blocked MIME type: ".concat(contentType));
                    case 1:
                      _context5.n = 2;
                      return res.blob();
                    case 2:
                      data = _context5.v;
                      return _context5.a(2, resolve(data));
                  }
                }, _callee4);
              }));
              return function (_x8) {
                return _ref4.apply(this, arguments);
              };
            }())["catch"](reject);
          }));
      }
    }, _callee5);
  }));
  return _fetchBlob.apply(this, arguments);
}
function installWindowHiddenScript() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$element = _ref.element,
    element = _ref$element === void 0 ? document.body : _ref$element,
    _ref$hiddenClass = _ref.hiddenClass,
    hiddenClass = _ref$hiddenClass === void 0 ? 'windowHidden' : _ref$hiddenClass,
    _ref$visibleClass = _ref.visibleClass,
    visibleClass = _ref$visibleClass === void 0 ? 'windowVisible' : _ref$visibleClass,
    onVisible = _ref.onVisible,
    onHidden = _ref.onHidden;
  if (!(element instanceof Element)) throw new TypeError("\"element\" must be an instance of Element.");
  if (typeof hiddenClass !== 'string') throw new TypeError("\"hiddenClass\" must be a string.");
  if (typeof visibleClass !== 'string') throw new TypeError("\"visibleClass\" must be a string.");
  if (onVisible !== undefined && typeof onVisible !== 'function') throw new TypeError("\"onVisible\" must be a function if provided.");
  if (onHidden !== undefined && typeof onHidden !== 'function') throw new TypeError("\"onHidden\" must be a function if provided.");
  var removeClass = function removeClass() {
    element.classList.remove(hiddenClass);
    element.classList.remove(visibleClass);
  };
  /** @type {string|null} */
  var hiddenProp = null;
  var visibilityEvents = ['visibilitychange', 'mozvisibilitychange', 'webkitvisibilitychange', 'msvisibilitychange'];
  var visibilityProps = ['hidden', 'mozHidden', 'webkitHidden', 'msHidden'];
  for (var i = 0; i < visibilityProps.length; i++) {
    if (visibilityProps[i] in document) {
      hiddenProp = visibilityProps[i];
      break;
    }
  }
  /** @type {(this: any, evt: Event) => void} */
  var handler = function handler(evt) {
    removeClass();
    var type = evt === null || evt === void 0 ? void 0 : evt.type;
    // @ts-ignore
    var isHidden = hiddenProp && document[hiddenProp];
    var visibleEvents = ['focus', 'focusin', 'pageshow'];
    var hiddenEvents = ['blur', 'focusout', 'pagehide'];
    if (visibleEvents.includes(type)) {
      element.classList.add(visibleClass);
      onVisible === null || onVisible === void 0 || onVisible();
    } else if (hiddenEvents.includes(type)) {
      element.classList.add(hiddenClass);
      onHidden === null || onHidden === void 0 || onHidden();
    } else {
      if (isHidden) {
        element.classList.add(hiddenClass);
        onHidden === null || onHidden === void 0 || onHidden();
      } else {
        element.classList.add(visibleClass);
        onVisible === null || onVisible === void 0 || onVisible();
      }
    }
  };
  /** @type {() => void} */
  var uninstall = function uninstall() {};
  if (hiddenProp) {
    var eventType = visibilityEvents[visibilityProps.indexOf(hiddenProp)];
    document.addEventListener(eventType, handler);
    window.addEventListener('focus', handler);
    window.addEventListener('blur', handler);
    uninstall = function uninstall() {
      document.removeEventListener(eventType, handler);
      window.removeEventListener('focus', handler);
      window.removeEventListener('blur', handler);
      removeClass();
    };
  } else if ('onfocusin' in document) {
    // Fallback for IE9 and older
    // @ts-ignore
    document.onfocusin = document.onfocusout = handler;
    uninstall = function uninstall() {
      // @ts-ignore
      document.onfocusin = document.onfocusout = null;
      removeClass();
    };
  } else {
    // Last resort fallback
    window.onpageshow = window.onpagehide = window.onfocus = window.onblur = handler;
    uninstall = function uninstall() {
      window.onpageshow = window.onpagehide = window.onfocus = window.onblur = null;
      removeClass();
    };
  }
  // Trigger initial state
  // @ts-ignore
  var simulatedEvent = new Event(hiddenProp && document[hiddenProp] ? 'blur' : 'focus');
  handler(simulatedEvent);
  return uninstall;
}

},{"./objFilter.mjs":155}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areHtmlElsColliding = areHtmlElsColliding;
exports.areHtmlElsPerfColliding = areHtmlElsPerfColliding;
exports.getHtmlElPadding = exports.getHtmlElMargin = exports.getHtmlElBordersWidth = exports.getHtmlElBorders = void 0;
exports.isInViewport = isInViewport;
exports.isScrolledIntoView = isScrolledIntoView;
var _TinyHtml = _interopRequireDefault(require("../libs/TinyHtml.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Checks if two DOM elements are colliding on the screen.
 *
 * @param {Element} elem1 - First DOM element.
 * @param {Element} elem2 - Second DOM element.
 * @returns {boolean} - Returns true if the elements are colliding.
 * @deprecated - Use TinyHtml.isCollWith instead.
 */
function areHtmlElsColliding(elem1, elem2) {
  return _TinyHtml["default"].isCollWith(elem1, elem2);
}
/**
 * Checks if two DOM elements are colliding on the screen.
 *
 * @param {Element} elem1 - First DOM element.
 * @param {Element} elem2 - Second DOM element.
 * @returns {boolean} - Returns true if the elements are colliding.
 * @deprecated - Use TinyHtml.isCollPerfWith instead.
 */
function areHtmlElsPerfColliding(elem1, elem2) {
  return _TinyHtml["default"].isCollPerfWith(elem1, elem2);
}
///////////////////////////////////////////////////////////////////////////
/**
 * @typedef {import('../libs/TinyHtml.mjs').HtmlElBoxSides} HtmlElBoxSides
 */
/**
 * Returns the total border width and individual sides from `border{Side}Width` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border widths, and each side individually.
 * @deprecated - Use TinyHtml.borderWidth instead.
 */
var getHtmlElBordersWidth = exports.getHtmlElBordersWidth = function getHtmlElBordersWidth(el) {
  return _TinyHtml["default"].borderWidth(el);
};
/**
 * Returns the total border size and individual sides from `border{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border sizes, and each side individually.
 * @deprecated - Use TinyHtml.border instead.
 */
var getHtmlElBorders = exports.getHtmlElBorders = function getHtmlElBorders(el) {
  return _TinyHtml["default"].border(el);
};
/**
 * Returns the total margin and individual sides from `margin{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) margins, and each side individually.
 * @deprecated - Use TinyHtml.margin instead.
 */
var getHtmlElMargin = exports.getHtmlElMargin = function getHtmlElMargin(el) {
  return _TinyHtml["default"].margin(el);
};
/**
 * Returns the total padding and individual sides from `padding{Side}` CSS properties.
 *
 * @param {Element} el - The target DOM element.
 * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) paddings, and each side individually.
 * @deprecated - Use TinyHtml.padding instead.
 */
var getHtmlElPadding = exports.getHtmlElPadding = function getHtmlElPadding(el) {
  return _TinyHtml["default"].padding(el);
};
/////////////////////////////////////////////////////////////
// The new version will receive great modifications, the deprecated code has been preserved for non-glitch designs that are using the original code.
/**
 * Checks if the given element is at least partially visible in the viewport.
 *
 * @param {HTMLElement} element - The DOM element to check.
 * @returns {boolean} True if the element is partially in the viewport, false otherwise.
 * @deprecated - Use TinyHtml.isInViewport instead.
 */
function isInViewport(element) {
  var elementTop = element.offsetTop;
  var elementBottom = elementTop + element.offsetHeight;
  var viewportTop = window.scrollY;
  var viewportBottom = viewportTop + window.innerHeight;
  return elementBottom > viewportTop && elementTop < viewportBottom;
}
/**
 * Checks if the given element is fully visible in the viewport (top and bottom).
 *
 * @param {HTMLElement} element - The DOM element to check.
 * @returns {boolean} True if the element is fully visible in the viewport, false otherwise.
 * @deprecated - Use TinyHtml.isScrolledIntoView instead.
 */
function isScrolledIntoView(element) {
  var viewportTop = window.scrollY;
  var viewportBottom = viewportTop + window.innerHeight;
  var elemTop = element.offsetTop;
  var elemBottom = elemTop + element.offsetHeight;
  return elemBottom <= viewportBottom && elemTop >= viewportTop;
}

},{"../libs/TinyHtml.mjs":167}],155:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"buffer":62,"dup":119}],156:[function(require,module,exports){
arguments[4][120][0].apply(exports,arguments)
},{"dup":120}],157:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAiMarkerShortcut = addAiMarkerShortcut;
exports.safeTextTrim = safeTextTrim;
exports.toTitleCase = toTitleCase;
exports.toTitleCaseLowerFirst = toTitleCaseLowerFirst;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Converts a string to title case where the first letter of each word is capitalized.
 * All other letters are converted to lowercase.
 *
 * Example: "hello world" -> "Hello World"
 *
 * @param {string} str - The string to be converted to title case.
 * @returns {string} The string converted to title case.
 */
function toTitleCase(str) {
  return str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}
/**
 * Converts a string to title case where the first letter of each word is capitalized,
 * but the first letter of the entire string is left lowercase.
 *
 * Example: "hello world" -> "hello World"
 *
 * @param {string} str - The string to be converted to title case with the first letter in lowercase.
 * @returns {string} The string converted to title case with the first letter in lowercase.
 */
function toTitleCaseLowerFirst(str) {
  var titleCased = str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
  return titleCased.charAt(0).toLowerCase() + titleCased.slice(1);
}
/**
 * Enables a keyboard shortcut to toggle a CSS class on the document body.
 *
 * This function listens for a specific key combination: `Ctrl + Alt + [key]`.
 * When triggered, it prevents the default behavior and toggles the
 * `detect-made-by-ai` class on the `<body>`, which can be used to apply visual
 * indicators or filters on AI-generated content.
 *
 * If executed outside of a browser environment (e.g., in Node.js), the function logs an error and exits.
 * If the `<body>` is not available at the moment the shortcut is triggered, a warning is logged.
 *
 * @param {string} [key='a'] - The lowercase character key to be used in combination with Ctrl and Alt.
 */
function addAiMarkerShortcut() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'a';
  if (typeof HTMLElement === 'undefined') {
    console.error('[AiMarkerShortcut] Environment does not support the DOM. This function must be run in a browser.');
    return;
  }
  document.addEventListener('keydown', function (event) {
    if (event.ctrlKey && event.altKey && event.key.toLowerCase() === key) {
      event.preventDefault(); // Prevent any default behavior
      if (!document.body) {
        console.warn('[AiMarkerShortcut] <body> element not found. Cannot toggle class. Ensure the DOM is fully loaded when using the shortcut.');
        return;
      }
      document.body.classList.toggle('detect-made-by-ai');
    }
  });
}
/**
 * Trims a text string to a specified character limit, attempting to avoid cutting words in half.
 * If a space is found before the limit and it's not too far from the limit (at least 60%),
 * the cut is made at that space; otherwise, the text is hard-cut at the limit.
 * If the input is shorter than the limit, it is returned unchanged.
 *
 * @param {string} text - The input text to be trimmed.
 * @param {number} limit - The maximum number of characters allowed.
 * @param {number} [safeCutZone=0.6] - A decimal between 0 and 1 representing the minimal acceptable position
 *                                     (as a fraction of `limit`) to cut at a space. Defaults to 0.6.
 * @returns {string} - The trimmed text, possibly ending with an ellipsis ("...").
 * @throws {TypeError} - Throws if `text` is not a string.
 * @throws {TypeError} - Throws if `limit` is not a positive integer.
 * @throws {TypeError} - Throws if `safeCutZone` is not a number between 0 and 1 (inclusive).
 */
function safeTextTrim(text, limit) {
  var safeCutZone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.6;
  if (typeof text !== 'string') throw new TypeError("Expected a string for 'text', but received ".concat(_typeof(text)));
  if (!Number.isInteger(limit) || limit <= 0) throw new TypeError("Expected 'limit' to be a positive integer, but received ".concat(limit));
  if (typeof safeCutZone !== 'number' || safeCutZone < 0 || safeCutZone > 1) throw new TypeError("Expected 'safeCutZone' to be a number between 0 and 1, but received ".concat(safeCutZone));
  var result = text.trim();
  if (result.length > limit) {
    // Try to cut the string into a space before the limit
    var safeCut = result.lastIndexOf(' ', limit);
    if (safeCut > 0 && safeCut >= limit * safeCutZone) {
      // Only cuts where there is a space, and if the cut is not too early
      return "".concat(result.substring(0, safeCut).trim(), "...");
    } else {
      // Emergency: Cuts straight to the limit and adds "...".
      return "".concat(result.substring(0, limit).trim(), "...");
    }
  }
  return result;
}
/*
import { useEffect } from "react";

function KeyPressHandler() {
    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.ctrlKey && event.altKey && event.key.toLowerCase() === "a") {
                event.preventDefault();
                document.body.classList.toggle("detect-made-by-ai");
            }
        };
        
        document.addEventListener("keydown", handleKeyDown);
        return () => {
            document.removeEventListener("keydown", handleKeyDown);
        };
    }, []);

    return null;
}

export default KeyPressHandler;
*/

},{}],158:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./normalFuncs.mjs":159,"dup":122,"fs":61,"fs/promises":61,"path":94}],159:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"../basics/text.mjs":157,"dup":123,"fs":61,"path":94}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ColorSafeStringify", {
  enumerable: true,
  get: function get() {
    return _ColorSafeStringify["default"];
  }
});
Object.defineProperty(exports, "TinyAfterScrollWatcher", {
  enumerable: true,
  get: function get() {
    return _TinyAfterScrollWatcher["default"];
  }
});
Object.defineProperty(exports, "TinyClipboard", {
  enumerable: true,
  get: function get() {
    return _TinyClipboard["default"];
  }
});
Object.defineProperty(exports, "TinyDomReadyManager", {
  enumerable: true,
  get: function get() {
    return _TinyDomReadyManager["default"];
  }
});
Object.defineProperty(exports, "TinyDragDropDetector", {
  enumerable: true,
  get: function get() {
    return _TinyDragDropDetector["default"];
  }
});
Object.defineProperty(exports, "TinyDragger", {
  enumerable: true,
  get: function get() {
    return _TinyDragger["default"];
  }
});
Object.defineProperty(exports, "TinyHtml", {
  enumerable: true,
  get: function get() {
    return _TinyHtml["default"];
  }
});
Object.defineProperty(exports, "TinyLevelUp", {
  enumerable: true,
  get: function get() {
    return _userLevel["default"];
  }
});
Object.defineProperty(exports, "TinyNotifications", {
  enumerable: true,
  get: function get() {
    return _TinyNotifications["default"];
  }
});
Object.defineProperty(exports, "TinyNotifyCenter", {
  enumerable: true,
  get: function get() {
    return _TinyNotifyCenter["default"];
  }
});
Object.defineProperty(exports, "TinyPromiseQueue", {
  enumerable: true,
  get: function get() {
    return _TinyPromiseQueue["default"];
  }
});
Object.defineProperty(exports, "TinyRateLimiter", {
  enumerable: true,
  get: function get() {
    return _TinyRateLimiter["default"];
  }
});
Object.defineProperty(exports, "TinySmartScroller", {
  enumerable: true,
  get: function get() {
    return _TinySmartScroller["default"];
  }
});
Object.defineProperty(exports, "TinyTextRangeEditor", {
  enumerable: true,
  get: function get() {
    return _TinyTextRangeEditor["default"];
  }
});
Object.defineProperty(exports, "TinyToastNotify", {
  enumerable: true,
  get: function get() {
    return _TinyToastNotify["default"];
  }
});
Object.defineProperty(exports, "UltraRandomMsgGen", {
  enumerable: true,
  get: function get() {
    return _UltraRandomMsgGen["default"];
  }
});
Object.defineProperty(exports, "addAiMarkerShortcut", {
  enumerable: true,
  get: function get() {
    return _text.addAiMarkerShortcut;
  }
});
Object.defineProperty(exports, "areElsCollBottom", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollBottom;
  }
});
Object.defineProperty(exports, "areElsCollLeft", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollLeft;
  }
});
Object.defineProperty(exports, "areElsCollPerfBottom", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollPerfBottom;
  }
});
Object.defineProperty(exports, "areElsCollPerfLeft", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollPerfLeft;
  }
});
Object.defineProperty(exports, "areElsCollPerfRight", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollPerfRight;
  }
});
Object.defineProperty(exports, "areElsCollPerfTop", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollPerfTop;
  }
});
Object.defineProperty(exports, "areElsCollRight", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollRight;
  }
});
Object.defineProperty(exports, "areElsCollTop", {
  enumerable: true,
  get: function get() {
    return _collision.areElsCollTop;
  }
});
Object.defineProperty(exports, "areElsColliding", {
  enumerable: true,
  get: function get() {
    return _collision.areElsColliding;
  }
});
Object.defineProperty(exports, "areElsPerfColliding", {
  enumerable: true,
  get: function get() {
    return _collision.areElsPerfColliding;
  }
});
Object.defineProperty(exports, "areHtmlElsColliding", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.areHtmlElsColliding;
  }
});
Object.defineProperty(exports, "arraySortPositions", {
  enumerable: true,
  get: function get() {
    return _arraySortPositions["default"];
  }
});
Object.defineProperty(exports, "asyncReplace", {
  enumerable: true,
  get: function get() {
    return _replaceAsync["default"];
  }
});
Object.defineProperty(exports, "backupFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.backupFile;
  }
});
Object.defineProperty(exports, "checkObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.checkObj;
  }
});
Object.defineProperty(exports, "clearDirectory", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.clearDirectory;
  }
});
Object.defineProperty(exports, "clearDirectoryAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.clearDirectoryAsync;
  }
});
Object.defineProperty(exports, "cloneObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.cloneObjTypeOrder;
  }
});
Object.defineProperty(exports, "countObj", {
  enumerable: true,
  get: function get() {
    return _objFilter.countObj;
  }
});
Object.defineProperty(exports, "dirExists", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.dirExists;
  }
});
Object.defineProperty(exports, "dirSize", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.dirSize;
  }
});
Object.defineProperty(exports, "dirSizeAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.dirSizeAsync;
  }
});
Object.defineProperty(exports, "documentIsFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.documentIsFullScreen;
  }
});
Object.defineProperty(exports, "ensureCopyFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.ensureCopyFile;
  }
});
Object.defineProperty(exports, "ensureDirectory", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.ensureDirectory;
  }
});
Object.defineProperty(exports, "exitFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.exitFullScreen;
  }
});
Object.defineProperty(exports, "extendObjType", {
  enumerable: true,
  get: function get() {
    return _objFilter.extendObjType;
  }
});
Object.defineProperty(exports, "fetchJson", {
  enumerable: true,
  get: function get() {
    return _html.fetchJson;
  }
});
Object.defineProperty(exports, "fileExists", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.fileExists;
  }
});
Object.defineProperty(exports, "fileSize", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.fileSize;
  }
});
Object.defineProperty(exports, "fileSizeAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.fileSizeAsync;
  }
});
Object.defineProperty(exports, "formatBytes", {
  enumerable: true,
  get: function get() {
    return _simpleMath.formatBytes;
  }
});
Object.defineProperty(exports, "formatCustomTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatCustomTimer;
  }
});
Object.defineProperty(exports, "formatDayTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatDayTimer;
  }
});
Object.defineProperty(exports, "formatTimer", {
  enumerable: true,
  get: function get() {
    return _clock.formatTimer;
  }
});
Object.defineProperty(exports, "genFibonacciSeq", {
  enumerable: true,
  get: function get() {
    return _simpleMath.genFibonacciSeq;
  }
});
Object.defineProperty(exports, "getAge", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getAge;
  }
});
Object.defineProperty(exports, "getElsCollDetails", {
  enumerable: true,
  get: function get() {
    return _collision.getElsCollDetails;
  }
});
Object.defineProperty(exports, "getElsCollDirDepth", {
  enumerable: true,
  get: function get() {
    return _collision.getElsCollDirDepth;
  }
});
Object.defineProperty(exports, "getElsCollOverlap", {
  enumerable: true,
  get: function get() {
    return _collision.getElsCollOverlap;
  }
});
Object.defineProperty(exports, "getElsCollOverlapPos", {
  enumerable: true,
  get: function get() {
    return _collision.getElsCollOverlapPos;
  }
});
Object.defineProperty(exports, "getElsColliding", {
  enumerable: true,
  get: function get() {
    return _collision.getElsColliding;
  }
});
Object.defineProperty(exports, "getElsPerfColliding", {
  enumerable: true,
  get: function get() {
    return _collision.getElsPerfColliding;
  }
});
Object.defineProperty(exports, "getElsRelativeCenterOffset", {
  enumerable: true,
  get: function get() {
    return _collision.getElsRelativeCenterOffset;
  }
});
Object.defineProperty(exports, "getHtmlElBorders", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.getHtmlElBorders;
  }
});
Object.defineProperty(exports, "getHtmlElBordersWidth", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.getHtmlElBordersWidth;
  }
});
Object.defineProperty(exports, "getHtmlElMargin", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.getHtmlElMargin;
  }
});
Object.defineProperty(exports, "getHtmlElPadding", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.getHtmlElPadding;
  }
});
Object.defineProperty(exports, "getLatestBackupPath", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.getLatestBackupPath;
  }
});
Object.defineProperty(exports, "getRectCenter", {
  enumerable: true,
  get: function get() {
    return _collision.getRectCenter;
  }
});
Object.defineProperty(exports, "getSimplePerc", {
  enumerable: true,
  get: function get() {
    return _simpleMath.getSimplePerc;
  }
});
Object.defineProperty(exports, "getTimeDuration", {
  enumerable: true,
  get: function get() {
    return _clock.getTimeDuration;
  }
});
Object.defineProperty(exports, "installWindowHiddenScript", {
  enumerable: true,
  get: function get() {
    return _html.installWindowHiddenScript;
  }
});
Object.defineProperty(exports, "isDirEmpty", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.isDirEmpty;
  }
});
Object.defineProperty(exports, "isDirEmptyAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.isDirEmptyAsync;
  }
});
Object.defineProperty(exports, "isFullScreenMode", {
  enumerable: true,
  get: function get() {
    return _fullScreen.isFullScreenMode;
  }
});
Object.defineProperty(exports, "isInViewport", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.isInViewport;
  }
});
Object.defineProperty(exports, "isJsonObject", {
  enumerable: true,
  get: function get() {
    return _objFilter.isJsonObject;
  }
});
Object.defineProperty(exports, "isScreenFilled", {
  enumerable: true,
  get: function get() {
    return _fullScreen.isScreenFilled;
  }
});
Object.defineProperty(exports, "isScrolledIntoView", {
  enumerable: true,
  get: function get() {
    return _html_deprecated.isScrolledIntoView;
  }
});
Object.defineProperty(exports, "listDirs", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.listDirs;
  }
});
Object.defineProperty(exports, "listDirsAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.listDirsAsync;
  }
});
Object.defineProperty(exports, "listFiles", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.listFiles;
  }
});
Object.defineProperty(exports, "listFilesAsync", {
  enumerable: true,
  get: function get() {
    return _asyncFuncs.listFilesAsync;
  }
});
Object.defineProperty(exports, "objType", {
  enumerable: true,
  get: function get() {
    return _objFilter.objType;
  }
});
Object.defineProperty(exports, "offFullScreenChange", {
  enumerable: true,
  get: function get() {
    return _fullScreen.offFullScreenChange;
  }
});
Object.defineProperty(exports, "onFullScreenChange", {
  enumerable: true,
  get: function get() {
    return _fullScreen.onFullScreenChange;
  }
});
Object.defineProperty(exports, "readBase64Blob", {
  enumerable: true,
  get: function get() {
    return _html.readBase64Blob;
  }
});
Object.defineProperty(exports, "readFileBlob", {
  enumerable: true,
  get: function get() {
    return _html.readFileBlob;
  }
});
Object.defineProperty(exports, "readJsonBlob", {
  enumerable: true,
  get: function get() {
    return _html.readJsonBlob;
  }
});
Object.defineProperty(exports, "readJsonFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.readJsonFile;
  }
});
Object.defineProperty(exports, "renameFileAddPrefixSuffix", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileAddPrefixSuffix;
  }
});
Object.defineProperty(exports, "renameFileBatch", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileBatch;
  }
});
Object.defineProperty(exports, "renameFileNormalizeCase", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileNormalizeCase;
  }
});
Object.defineProperty(exports, "renameFilePadNumbers", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFilePadNumbers;
  }
});
Object.defineProperty(exports, "renameFileRegex", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.renameFileRegex;
  }
});
Object.defineProperty(exports, "reorderObjTypeOrder", {
  enumerable: true,
  get: function get() {
    return _objFilter.reorderObjTypeOrder;
  }
});
Object.defineProperty(exports, "requestFullScreen", {
  enumerable: true,
  get: function get() {
    return _fullScreen.requestFullScreen;
  }
});
Object.defineProperty(exports, "restoreLatestBackup", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.restoreLatestBackup;
  }
});
Object.defineProperty(exports, "ruleOfThree", {
  enumerable: true,
  get: function get() {
    return _simpleMath.ruleOfThree;
  }
});
Object.defineProperty(exports, "safeTextTrim", {
  enumerable: true,
  get: function get() {
    return _text.safeTextTrim;
  }
});
Object.defineProperty(exports, "saveJsonFile", {
  enumerable: true,
  get: function get() {
    return _html.saveJsonFile;
  }
});
Object.defineProperty(exports, "shuffleArray", {
  enumerable: true,
  get: function get() {
    return _array.shuffleArray;
  }
});
Object.defineProperty(exports, "toTitleCase", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCase;
  }
});
Object.defineProperty(exports, "toTitleCaseLowerFirst", {
  enumerable: true,
  get: function get() {
    return _text.toTitleCaseLowerFirst;
  }
});
Object.defineProperty(exports, "tryDeleteFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.tryDeleteFile;
  }
});
Object.defineProperty(exports, "writeJsonFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.writeJsonFile;
  }
});
Object.defineProperty(exports, "writeTextFile", {
  enumerable: true,
  get: function get() {
    return _normalFuncs.writeTextFile;
  }
});
var _replaceAsync = _interopRequireDefault(require("../legacy/libs/replaceAsync.mjs"));
var _userLevel = _interopRequireDefault(require("../legacy/libs/userLevel.mjs"));
var _arraySortPositions = _interopRequireDefault(require("../legacy/libs/arraySortPositions.mjs"));
var _array = require("./basics/array.mjs");
var _clock = require("./basics/clock.mjs");
var _objFilter = require("./basics/objFilter.mjs");
var _fullScreen = require("./basics/fullScreen.mjs");
var _simpleMath = require("./basics/simpleMath.mjs");
var _text = require("./basics/text.mjs");
var _ColorSafeStringify = _interopRequireDefault(require("./libs/ColorSafeStringify.mjs"));
var _TinyPromiseQueue = _interopRequireDefault(require("./libs/TinyPromiseQueue.mjs"));
var _TinyRateLimiter = _interopRequireDefault(require("./libs/TinyRateLimiter.mjs"));
var _TinyNotifyCenter = _interopRequireDefault(require("./libs/TinyNotifyCenter.mjs"));
var _TinyToastNotify = _interopRequireDefault(require("./libs/TinyToastNotify.mjs"));
var _html = require("./basics/html.mjs");
var _html_deprecated = require("./basics/html_deprecated.mjs");
var _TinyDragDropDetector = _interopRequireDefault(require("./libs/TinyDragDropDetector.mjs"));
var _normalFuncs = require("./fileManager/normalFuncs.mjs");
var _asyncFuncs = require("./fileManager/asyncFuncs.mjs");
var _TinyDragger = _interopRequireDefault(require("./libs/TinyDragger.mjs"));
var _TinyDomReadyManager = _interopRequireDefault(require("./libs/TinyDomReadyManager.mjs"));
var _TinyNotifications = _interopRequireDefault(require("./libs/TinyNotifications.mjs"));
var _collision = require("./basics/collision.mjs");
var _TinyHtml = _interopRequireDefault(require("./libs/TinyHtml.mjs"));
var _TinyAfterScrollWatcher = _interopRequireDefault(require("./libs/TinyAfterScrollWatcher.mjs"));
var _UltraRandomMsgGen = _interopRequireDefault(require("./libs/UltraRandomMsgGen.mjs"));
var _TinySmartScroller = _interopRequireDefault(require("./libs/TinySmartScroller.mjs"));
var _TinyTextRangeEditor = _interopRequireDefault(require("./libs/TinyTextRangeEditor.mjs"));
var _TinyClipboard = _interopRequireDefault(require("./libs/TinyClipboard.mjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }

},{"../legacy/libs/arraySortPositions.mjs":146,"../legacy/libs/replaceAsync.mjs":147,"../legacy/libs/userLevel.mjs":148,"./basics/array.mjs":149,"./basics/clock.mjs":150,"./basics/collision.mjs":151,"./basics/fullScreen.mjs":152,"./basics/html.mjs":153,"./basics/html_deprecated.mjs":154,"./basics/objFilter.mjs":155,"./basics/simpleMath.mjs":156,"./basics/text.mjs":157,"./fileManager/asyncFuncs.mjs":158,"./fileManager/normalFuncs.mjs":159,"./libs/ColorSafeStringify.mjs":161,"./libs/TinyAfterScrollWatcher.mjs":162,"./libs/TinyClipboard.mjs":163,"./libs/TinyDomReadyManager.mjs":164,"./libs/TinyDragDropDetector.mjs":165,"./libs/TinyDragger.mjs":166,"./libs/TinyHtml.mjs":167,"./libs/TinyNotifications.mjs":168,"./libs/TinyNotifyCenter.mjs":169,"./libs/TinyPromiseQueue.mjs":170,"./libs/TinyRateLimiter.mjs":171,"./libs/TinySmartScroller.mjs":172,"./libs/TinyTextRangeEditor.mjs":173,"./libs/TinyToastNotify.mjs":174,"./libs/UltraRandomMsgGen.mjs":175}],161:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"dup":125}],162:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _scrollTarget = /*#__PURE__*/new WeakMap();
var _lastScrollTime = /*#__PURE__*/new WeakMap();
var _afterScrollQueue = /*#__PURE__*/new WeakMap();
var _inactivityTime = /*#__PURE__*/new WeakMap();
var _externalScrollListeners = /*#__PURE__*/new WeakMap();
var _onStopListeners = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _TinyAfterScrollWatcher_brand = /*#__PURE__*/new WeakSet();
/**
 * @typedef {(() => void)} FnData - Function with no arguments and no return value
 */
/**
 * A function that handles a scroll event.
 * It receives a standard `Event` object when a scroll occurs.
 *
 * @typedef {(ev: Event) => void} OnScrollFunc
 */
/**
 * A scroll tracker that queues functions to be executed
 * after the user stops scrolling a specific element or the window.
 */
var TinyAfterScrollWatcher = /*#__PURE__*/function () {
  /**
   * @param {Element|Window} scrollTarget - The element or window to track scrolling on
   * @param {number} [inactivityTime=100] - Time in milliseconds to wait after scroll ends before executing the queue
   * @throws {TypeError} If scrollTarget is not a valid Element or Window
   * @throws {TypeError} If inactivityTime is not a positive number
   */
  function TinyAfterScrollWatcher() {
    var _this = this;
    var scrollTarget = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var inactivityTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    _classCallCheck(this, TinyAfterScrollWatcher);
    /**
     * Continuously checks whether the user has stopped scrolling,
     * and if so, runs all queued functions.
     */
    _classPrivateMethodInitSpec(this, _TinyAfterScrollWatcher_brand);
    /** @type {Element|Window} */
    _classPrivateFieldInitSpec(this, _scrollTarget, void 0);
    /** @type {null|NodeJS.Timeout} */
    _classPrivateFieldInitSpec(this, _lastScrollTime, null);
    /** @type {FnData[]} */
    _classPrivateFieldInitSpec(this, _afterScrollQueue, []);
    /** @type {number} */
    _classPrivateFieldInitSpec(this, _inactivityTime, 100);
    /** @type {Set<OnScrollFunc>} */
    _classPrivateFieldInitSpec(this, _externalScrollListeners, new Set());
    /** @type {Set<FnData>} */
    _classPrivateFieldInitSpec(this, _onStopListeners, new Set());
    /** @type {boolean} */
    _classPrivateFieldInitSpec(this, _destroyed, false);
    _defineProperty(this, "_checkTimer", function () {
      if (_classPrivateFieldGet(_lastScrollTime, _this)) clearTimeout(_classPrivateFieldGet(_lastScrollTime, _this));
      _classPrivateFieldSet(_lastScrollTime, _this, setTimeout(function () {
        _classPrivateFieldSet(_lastScrollTime, _this, null);
        _assertClassBrand(_TinyAfterScrollWatcher_brand, _this, _checkQueue).call(_this);
      }, _classPrivateFieldGet(_inactivityTime, _this)));
    });
    if (!(scrollTarget instanceof Element) && !(scrollTarget instanceof Window)) throw new TypeError('scrollTarget must be an Element or the Window object.');
    _classPrivateFieldSet(_scrollTarget, this, scrollTarget);
    this._checkTimer = this._checkTimer.bind(this);
    _classPrivateFieldGet(_scrollTarget, this).addEventListener('scroll', this._checkTimer);
    _classPrivateFieldSet(_inactivityTime, this, inactivityTime);
  }
  return _createClass(TinyAfterScrollWatcher, [{
    key: "inactivityTime",
    get:
    /**
     * Gets the current inactivity time in milliseconds.
     * @returns {number}
     */
    function get() {
      return _classPrivateFieldGet(_inactivityTime, this);
    }
    /**
     * Sets a new inactivity time.
     * Must be a positive number (in milliseconds).
     * @param {number} value
     * @throws {Error} If value is not a positive number
     */,
    set: function set(value) {
      if (typeof value !== 'number' || value <= 0 || !Number.isFinite(value)) throw new Error('inactivityTime must be a positive number in milliseconds.');
      _classPrivateFieldSet(_inactivityTime, this, value);
    }
  }, {
    key: "doAfterScroll",
    value:
    /**
     * Adds a function to be executed after scroll has stopped.
     * The scroll is considered "stopped" after the configured inactivity time.
     *
     * @param {() => void} fn - A function to execute once scrolling has stopped.
     * @throws {TypeError} If the argument is not a function.
     */
    function doAfterScroll(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      this.lastScrollTime = Date.now();
      _classPrivateFieldGet(_afterScrollQueue, this).push(fn);
    }
    /**
     * Registers a function to run once after scrolling has stopped,
     * before any afterScrollQueue functions.
     *
     * @param {FnData} fn - A function to execute after scroll stop.
     * @throws {TypeError} If the argument is not a function.
     */
  }, {
    key: "onStop",
    value: function onStop(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      _classPrivateFieldGet(_onStopListeners, this).add(fn);
    }
    /**
     * Removes a previously registered onStop function.
     *
     * @param {FnData} fn - The function to remove.
     * @throws {TypeError} If the argument is not a function.
     */
  }, {
    key: "offStop",
    value: function offStop(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      _classPrivateFieldGet(_onStopListeners, this)["delete"](fn);
    }
    /**
     * Registers an external scroll listener on the tracked element.
     *
     * @param {OnScrollFunc} fn - The scroll listener to add
     * @throws {TypeError} If the argument is not a function.
     */
  }, {
    key: "onScroll",
    value: function onScroll(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      _classPrivateFieldGet(_scrollTarget, this).addEventListener('scroll', fn);
      _classPrivateFieldGet(_externalScrollListeners, this).add(fn);
    }
    /**
     * Removes a previously registered scroll listener from the tracked element.
     *
     * @param {OnScrollFunc} fn - The scroll listener to remove
     * @throws {TypeError} If the argument is not a function.
     */
  }, {
    key: "offScroll",
    value: function offScroll(fn) {
      if (typeof fn !== 'function') throw new TypeError('Argument must be a function.');
      if (_classPrivateFieldGet(_externalScrollListeners, this).has(fn)) {
        _classPrivateFieldGet(_scrollTarget, this).removeEventListener('scroll', fn);
        _classPrivateFieldGet(_externalScrollListeners, this)["delete"](fn);
      }
    }
    /**
     * Destroys the watcher by removing internal listeners and clearing data.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      _classPrivateFieldSet(_destroyed, this, true);
      _classPrivateFieldGet(_scrollTarget, this).removeEventListener('scroll', this._checkTimer);
      var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(_externalScrollListeners, this)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var fn = _step.value;
          _classPrivateFieldGet(_scrollTarget, this).removeEventListener('scroll', fn);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      _classPrivateFieldGet(_externalScrollListeners, this).clear();
      _classPrivateFieldGet(_onStopListeners, this).clear();
    }
  }]);
}();
function _checkQueue() {
  if (_classPrivateFieldGet(_destroyed, this)) return;
  // Runs all onStop first listeners
  var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(_onStopListeners, this)),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _fn = _step2.value;
      if (typeof _fn === 'function') _fn();
    }
    // Then execute the queue afterScrollQueue
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  while (_classPrivateFieldGet(_afterScrollQueue, this).length) {
    var fn = _classPrivateFieldGet(_afterScrollQueue, this).pop();
    if (typeof fn === 'function') fn();
  }
}
var _default = exports["default"] = TinyAfterScrollWatcher;

},{}],163:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _existExecCommand = /*#__PURE__*/new WeakMap();
var _existNavigator = /*#__PURE__*/new WeakMap();
var _copyText = /*#__PURE__*/new WeakMap();
var _copyBlob = /*#__PURE__*/new WeakMap();
/**
 * Utility class to handle clipboard operations for text and blob data.
 * Supports modern Clipboard API, custom platform, and legacy execCommand fallback.
 */
var TinyClipboard = /*#__PURE__*/function () {
  /**
   * Constructs a new TinyClipboard instance.
   * Automatically detects and configures available clipboard APIs.
   */
  function TinyClipboard() {
    _classCallCheck(this, TinyClipboard);
    /**
     * Indicates whether the legacy `document.execCommand()` API is available.
     * Used as a fallback for clipboard operations when modern APIs are not supported.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _existExecCommand, false);
    /**
     * Indicates whether the modern Clipboard API (`navigator.clipboard`) is available.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _existNavigator, false);
    /**
     * Function used to copy plain text to the clipboard.
     * Can be overridden using `setCopyText()`.
     *
     * @type {((text: string) => Promise<void>) | null}
     */
    _classPrivateFieldInitSpec(this, _copyText, null);
    /**
     * Function used to copy a Blob (binary data) to the clipboard.
     * Can be overridden using `setCopyBlob()`.
     *
     * @type {((blob: Blob) => Promise<void>) | null}
     */
    _classPrivateFieldInitSpec(this, _copyBlob, null);
    // Whether the Clipboard API is available.
    if (typeof navigator.clipboard !== 'undefined' && navigator.clipboard !== null) {
      _classPrivateFieldSet(_existNavigator, this, true);
      _classPrivateFieldSet(_copyText, this, function (text) {
        return navigator.clipboard.writeText(text);
      });
      _classPrivateFieldSet(_copyBlob, this, function (blob) {
        return navigator.clipboard.write([new ClipboardItem(_defineProperty({}, blob.type, blob))]);
      });
    }
    /**
     * @type {boolean}
     * Whether the legacy execCommand API is available.
     */
    _classPrivateFieldSet(_existExecCommand, this, typeof document.execCommand !== 'undefined' && document.execCommand !== null);
  }
  /**
   * Override the default text copy behavior.
   * This allows you to provide your own clipboard implementation or
   * integrate with external systems like Capacitor or Electron.
   *
   * @param {(text: string) => Promise<void>} callback - The function to use for copying text.
   * @throws {TypeError} If the callback is not a function.
   */
  return _createClass(TinyClipboard, [{
    key: "setCopyText",
    value: function setCopyText(callback) {
      if (typeof callback !== 'function') throw new TypeError('setCopyText expected a function that returns Promise<void>.');
      _classPrivateFieldSet(_copyText, this, callback);
    }
    /**
     * Override the default blob copy behavior.
     * This allows you to provide a custom clipboard handling method for blob data.
     *
     * @param {(blob: Blob) => Promise<void>} callback - The function to use for copying blob data.
     * @throws {TypeError} If the callback is not a function.
     */
  }, {
    key: "setCopyBlob",
    value: function setCopyBlob(callback) {
      if (typeof callback !== 'function') throw new TypeError('setCopyBlob expected a function that returns Promise<void>.');
      _classPrivateFieldSet(_copyBlob, this, callback);
    }
    /**
     * Copy a plain text string to the clipboard.
     * Uses modern or legacy fallback.
     *
     * @param {string} text - The text string to be copied.
     * @returns {Promise<void>} A promise resolving when the text is copied or boolean for legacy.
     */
  }, {
    key: "copyText",
    value: function copyText(text) {
      if (typeof text !== 'string') throw new TypeError('copyText expected a string.');
      // Clipboard API
      if (_classPrivateFieldGet(_copyText, this)) return _classPrivateFieldGet(_copyText, this).call(this, text);
      // Classic API
      else if (_classPrivateFieldGet(_existExecCommand, this)) {
        var host = document.body;
        var copyInput = document.createElement('input');
        copyInput.style.position = 'fixed';
        copyInput.style.opacity = '0';
        copyInput.value = text;
        host.append(copyInput);
        copyInput.select();
        copyInput.setSelectionRange(0, 99999);
        document.execCommand('Copy');
        copyInput.remove();
        return new Promise(function (resolve) {
          return resolve(undefined);
        });
      }
      throw new Error('Clipboard API not found!');
    }
    /**
     * Copy a Blob (binary data) to the clipboard.
     *
     * @param {Blob} blob - The blob object to copy.
     * @returns {Promise<void>} A promise that resolves when the blob is copied or null on fallback.
     */
  }, {
    key: "copyBlob",
    value: function copyBlob(blob) {
      var _this = this;
      if (!(blob instanceof Blob)) throw new TypeError('copyBlob expected a Blob instance.');
      return new Promise(function (resolve, reject) {
        if (_classPrivateFieldGet(_copyBlob, _this)) {
          return _classPrivateFieldGet(_copyBlob, _this).call(_this, blob).then(resolve)["catch"](reject);
        }
        throw new Error('Clipboard API not found!');
      });
    }
    /**
     * Internal: Handle getting blob data from a clipboard item.
     *
     * @private
     * @param {string} type - The MIME type to fetch.
     * @param {ClipboardItem} clipboardItem - Clipboard item instance.
     * @returns {Promise<Blob>} A promise that resolves with the Blob.
     */
  }, {
    key: "_handleBlob",
    value: function _handleBlob(type, clipboardItem) {
      return clipboardItem.getType(type);
    }
    /**
     * Internal: Handle getting plain text from a clipboard item.
     *
     * @private
     * @param {string} type - The MIME type (should be 'text/plain').
     * @param {ClipboardItem} clipboardItem - Clipboard item instance.
     * @returns {Promise<string>} A promise that resolves with the text content.
     */
  }, {
    key: "_handleText",
    value: function _handleText(type, clipboardItem) {
      return this._handleBlob(type, clipboardItem).then(function (blob) {
        return blob.text();
      });
    }
    /**
     * Read clipboard data based on filters like type, mime, index.
     *
     * @param {number|null} [index=0] - Item index or null for all.
     * @param {'text'|'custom'|null} [type=null] - Data type to filter.
     * @param {string|null} [mimeFormat=null] - MIME type or prefix.
     * @param {boolean} [fixValue=false] - If true, exact match on MIME type.
     * @returns {Promise<Blob|string|Array<Blob|string>|null>} A promise resolving with matching data.
     */
  }, {
    key: "_readData",
    value: function _readData() {
      var _this2 = this;
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var mimeFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var fixValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      return new Promise(function (resolve, reject) {
        _this2._read(index).then(function (items) {
          if (!items) return resolve(null);
          /** @type {Array<Blob|string>} */
          var finalResult = [];
          // Complete task
          var continueLoop = true;
          /**
           * @param {string} mimeType
           * @param {ClipboardItem} item
           */
          var completeTask = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(mimeType, item) {
              var result, _result, _result2;
              return _regenerator().w(function (_context) {
                while (1) switch (_context.n) {
                  case 0:
                    if (continueLoop) {
                      _context.n = 1;
                      break;
                    }
                    return _context.a(2);
                  case 1:
                    if (!((type === null || type === 'custom') && typeof mimeFormat === 'string' && (!fixValue && mimeType.startsWith(mimeFormat) || fixValue && mimeType === mimeFormat))) {
                      _context.n = 3;
                      break;
                    }
                    continueLoop = false;
                    _context.n = 2;
                    return _this2._handleBlob(mimeType, item);
                  case 2:
                    result = _context.v;
                    if (result) finalResult.push(result);
                    _context.n = 7;
                    break;
                  case 3:
                    if (!((type === null || type === 'text') && mimeType === 'text/plain')) {
                      _context.n = 5;
                      break;
                    }
                    continueLoop = false;
                    _context.n = 4;
                    return _this2._handleText(mimeType, item);
                  case 4:
                    _result = _context.v;
                    if (_result) finalResult.push(_result);
                    _context.n = 7;
                    break;
                  case 5:
                    if (!(type === null)) {
                      _context.n = 7;
                      break;
                    }
                    continueLoop = false;
                    _context.n = 6;
                    return _this2._handleBlob(mimeType, item);
                  case 6:
                    _result2 = _context.v;
                    if (_result2) finalResult.push(_result2);
                  case 7:
                    return _context.a(2);
                }
              }, _callee);
            }));
            return function completeTask(_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }();
          /** @type {Promise<void>[]} */
          var promises = [];
          /**
           * Read Item
           * @param {ClipboardItem | ClipboardItems} item
           */
          var readItem = function readItem(item) {
            if (!(item instanceof ClipboardItem)) throw new Error('Expected ClipboardItem when reading data.');
            for (var tIndex in item.types) promises.push(completeTask(item.types[tIndex], item));
          };
          // Specific Item
          if (typeof index === 'number' && !Number.isNaN(index) && Number.isFinite(index) && index > -1) {
            readItem(items);
            Promise.all(promises).then(function () {
              if (finalResult[0]) resolve(finalResult[0]);else resolve(null);
            })["catch"](reject);
          }
          // All
          else if (Array.isArray(items)) {
            for (var tIndex in items) readItem(items[tIndex]);
            Promise.all(promises).then(function () {
              return resolve(finalResult);
            })["catch"](reject);
          }
        })
        // Fail
        ["catch"](reject);
      });
    }
    /**
     * Read plain text from the clipboard (single item by index).
     *
     * @param {number} [index=0] - The index of the clipboard item to read.
     * @returns {Promise<string|null>} A promise that resolves to the clipboard text or null.
     */
  }, {
    key: "readText",
    value: (function () {
      var _readText = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var index,
          value,
          _args2 = arguments;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              index = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 0;
              _context2.n = 1;
              return this._readData(index, 'text');
            case 1:
              value = _context2.v;
              if (!(typeof value !== 'string')) {
                _context2.n = 2;
                break;
              }
              throw new Error('Failed to read text: expected string result.');
            case 2:
              return _context2.a(2, value);
          }
        }, _callee2, this);
      }));
      function readText() {
        return _readText.apply(this, arguments);
      }
      return readText;
    }()
    /**
     * Read custom clipboard data based on MIME type from a specific index.
     *
     * @param {string|null} [mimeFormat=null] - MIME prefix to match (e.g., "image/").
     * @param {boolean} [fixValue=false] - If true, matches exact MIME instead of prefix.
     * @param {number} [index=0] - Clipboard item index.
     * @returns {Promise<Blob|null>} A promise resolving with a blob or null.
     */
    )
  }, {
    key: "readCustom",
    value: (function () {
      var _readCustom = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
        var mimeFormat,
          fixValue,
          index,
          value,
          _args3 = arguments;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              mimeFormat = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : null;
              fixValue = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;
              index = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : 0;
              _context3.n = 1;
              return this._readData(index, 'custom', mimeFormat, fixValue);
            case 1:
              value = _context3.v;
              if (value instanceof Blob) {
                _context3.n = 2;
                break;
              }
              throw new Error('Failed to read custom data: expected Blob.');
            case 2:
              return _context3.a(2, value);
          }
        }, _callee3, this);
      }));
      function readCustom() {
        return _readCustom.apply(this, arguments);
      }
      return readCustom;
    }()
    /**
     * Read all available plain text entries from the clipboard.
     *
     * @returns {Promise<string[]>} A promise resolving to an array of strings or null.
     */
    )
  }, {
    key: "readAllTexts",
    value: (function () {
      var _readAllTexts = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4() {
        var values;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return this._readData(null, 'text');
            case 1:
              values = _context4.v;
              if (Array.isArray(values)) {
                _context4.n = 2;
                break;
              }
              throw new Error('Expected array of strings when reading all texts.');
            case 2:
              if (values.every(function (value) {
                return typeof value === 'string';
              })) {
                _context4.n = 3;
                break;
              }
              throw new Error('Some values returned were not strings.');
            case 3:
              return _context4.a(2, values);
          }
        }, _callee4, this);
      }));
      function readAllTexts() {
        return _readAllTexts.apply(this, arguments);
      }
      return readAllTexts;
    }()
    /**
     * Read all clipboard data matching a specific custom MIME type.
     *
     * @param {string|null} [mimeFormat=null] - MIME prefix or exact type.
     * @param {boolean} [fixValue=false] - Match prefix or exact MIME.
     * @returns {Promise<Blob[]>} A promise resolving with array of Blobs or null.
     */
    )
  }, {
    key: "readAllCustom",
    value: (function () {
      var _readAllCustom = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5() {
        var mimeFormat,
          fixValue,
          values,
          _args5 = arguments;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              mimeFormat = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : null;
              fixValue = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : false;
              _context5.n = 1;
              return this._readData(null, 'custom', mimeFormat, fixValue);
            case 1:
              values = _context5.v;
              if (Array.isArray(values)) {
                _context5.n = 2;
                break;
              }
              throw new Error('Expected array of blobs when reading all custom items.');
            case 2:
              if (values.every(function (value) {
                return value instanceof Blob;
              })) {
                _context5.n = 3;
                break;
              }
              throw new Error('Some values returned were not Blob instances.');
            case 3:
              return _context5.a(2, values);
          }
        }, _callee5, this);
      }));
      function readAllCustom() {
        return _readAllCustom.apply(this, arguments);
      }
      return readAllCustom;
    }()
    /**
     * Read all clipboard data as Blob or text depending on type.
     *
     * @param {'text'|'custom'|null} [type=null] - The type of data to retrieve.
     * @param {string|null} [mimeFormat=null] - The MIME type or prefix to match.
     * @returns {Promise<Array<Blob|string>>} A promise resolving with matching data array.
     */
    )
  }, {
    key: "readAllData",
    value: (function () {
      var _readAllData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6() {
        var type,
          mimeFormat,
          value,
          _args6 = arguments;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              type = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : null;
              mimeFormat = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : null;
              _context6.n = 1;
              return this._readData(null, type, mimeFormat);
            case 1:
              value = _context6.v;
              if (Array.isArray(value)) {
                _context6.n = 2;
                break;
              }
              throw new Error('Expected array result when reading all data.');
            case 2:
              return _context6.a(2, value);
          }
        }, _callee6, this);
      }));
      function readAllData() {
        return _readAllData.apply(this, arguments);
      }
      return readAllData;
    }()
    /**
     * Read clipboard data at a specific index or all if null.
     *
     * @param {number|null} index - Index of the item to retrieve or null to get all.
     * @returns {Promise<ClipboardItem|ClipboardItems|null>} A promise resolving with a clipboard item or array of items.
     */
    )
  }, {
    key: "_read",
    value: function _read(index) {
      var _this3 = this;
      return new Promise(function (resolve, reject) {
        if (!_classPrivateFieldGet(_existNavigator, _this3)) reject(new Error('Clipboard API not found!'));
        navigator.clipboard.read().then(function (items) {
          // Index is number
          if (typeof index === 'number') {
            if (Number.isNaN(index) || !Number.isFinite(index) || index < 0) throw new Error("Invalid index value: ".concat(index));
            if (items[index]) resolve(items[index]);
            // Not found
            else resolve(null);
          }
          // Get All
          resolve(items);
        })["catch"](reject);
      });
    }
    /**
     * Read clipboard data at a specific index.
     *
     * @param {number} index - Index of the item to retrieve
     * @returns {Promise<ClipboardItem|null>} A promise resolving with a clipboard item.
     */
  }, {
    key: "readIndex",
    value: (function () {
      var _readIndex = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(index) {
        var value;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              _context7.n = 1;
              return this._read(index);
            case 1:
              value = _context7.v;
              if (!(value !== null && !(value instanceof ClipboardItem))) {
                _context7.n = 2;
                break;
              }
              throw new Error("Value at index ".concat(index, " is not a ClipboardItem."));
            case 2:
              return _context7.a(2, value);
          }
        }, _callee7, this);
      }));
      function readIndex(_x3) {
        return _readIndex.apply(this, arguments);
      }
      return readIndex;
    }()
    /**
     * Read all clipboard content without any filters.
     *
     * @returns {Promise<ClipboardItems>} A promise resolving with all clipboard items.
     */
    )
  }, {
    key: "readAll",
    value: (function () {
      var _readAll = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8() {
        var value, _iterator, _step, item, _t;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              _context8.n = 1;
              return this._read(null);
            case 1:
              value = _context8.v;
              if (Array.isArray(value)) {
                _context8.n = 2;
                break;
              }
              throw new Error('Expected array result from clipboard read.');
            case 2:
              _iterator = _createForOfIteratorHelper(value);
              _context8.p = 3;
              _iterator.s();
            case 4:
              if ((_step = _iterator.n()).done) {
                _context8.n = 6;
                break;
              }
              item = _step.value;
              if (item instanceof ClipboardItem) {
                _context8.n = 5;
                break;
              }
              throw new Error('Invalid item type found in clipboard result.');
            case 5:
              _context8.n = 4;
              break;
            case 6:
              _context8.n = 8;
              break;
            case 7:
              _context8.p = 7;
              _t = _context8.v;
              _iterator.e(_t);
            case 8:
              _context8.p = 8;
              _iterator.f();
              return _context8.f(8);
            case 9:
              return _context8.a(2, value);
          }
        }, _callee8, this, [[3, 7, 8, 9]]);
      }));
      function readAll() {
        return _readAll.apply(this, arguments);
      }
      return readAll;
    }()
    /**
     * Returns whether the legacy `document.execCommand()` API is available.
     * This can be used to determine if a fallback clipboard method is usable.
     *
     * @returns {boolean} True if `document.execCommand` is available.
     */
    )
  }, {
    key: "isExecCommandAvailable",
    value: function isExecCommandAvailable() {
      return _classPrivateFieldGet(_existExecCommand, this);
    }
    /**
     * Returns whether the modern Clipboard API (`navigator.clipboard`) is available.
     * Useful to know if full clipboard features can be accessed.
     *
     * @returns {boolean} True if `navigator.clipboard` is available.
     */
  }, {
    key: "isNavigatorClipboardAvailable",
    value: function isNavigatorClipboardAvailable() {
      return _classPrivateFieldGet(_existNavigator, this);
    }
    /**
     * Returns the function used to copy plain text to the clipboard.
     * This function may be built-in or set manually via `setCopyText`.
     *
     * @returns {((text: string) => Promise<void>) | null} The current text copy function or null if unavailable.
     */
  }, {
    key: "getCopyTextFunc",
    value: function getCopyTextFunc() {
      return _classPrivateFieldGet(_copyText, this);
    }
    /**
     * Returns the function used to copy Blob (binary data) to the clipboard.
     * This function may be built-in or set manually via `setCopyBlob`.
     *
     * @returns {((blob: Blob) => Promise<void>) | null} The current blob copy function or null if unavailable.
     */
  }, {
    key: "getCopyBlobFunc",
    value: function getCopyBlobFunc() {
      return _classPrivateFieldGet(_copyBlob, this);
    }
  }]);
}();
var _default = exports["default"] = TinyClipboard;

},{}],164:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],165:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"dup":127}],166:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _TinyHtml = _interopRequireDefault(require("./TinyHtml.mjs"));
var TinyCollision = _interopRequireWildcard(require("../basics/collision.mjs"));
var _objFilter = require("../basics/objFilter.mjs");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @typedef {Object} VibrationPatterns
 * @property {number[]|false} start - Pattern to vibrate on start
 * @property {number[]|false} end - Pattern to vibrate on end
 * @property {number[]|false} collide - Pattern to vibrate on collision
 * @property {number[]|false} move - Pattern to vibrate while moving
 */
/**
 * TinyDragger enables drag-and-drop functionality for a DOM element.
 * It supports jail boundaries, optional collision detection, vibration feedback,
 * automatic reverting, proxy dragging, and event dispatching.
 */
var _enabled = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _offsetY = /*#__PURE__*/new WeakMap();
var _offsetX = /*#__PURE__*/new WeakMap();
var _mirrorElem = /*#__PURE__*/new WeakMap();
var _multiCollision = /*#__PURE__*/new WeakMap();
var _lockInsideJail = /*#__PURE__*/new WeakMap();
var _revertOnDrop = /*#__PURE__*/new WeakMap();
var _dragging = /*#__PURE__*/new WeakMap();
var _collisionByMouse = /*#__PURE__*/new WeakMap();
var _dropInJailOnly = /*#__PURE__*/new WeakMap();
var _lastCollision = /*#__PURE__*/new WeakMap();
var _collidables = /*#__PURE__*/new WeakMap();
var _dragProxy = /*#__PURE__*/new WeakMap();
var _vibration = /*#__PURE__*/new WeakMap();
var _jail = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _dragHiddenClass = /*#__PURE__*/new WeakMap();
var _classDragging = /*#__PURE__*/new WeakMap();
var _classBodyDragging = /*#__PURE__*/new WeakMap();
var _classJailDragging = /*#__PURE__*/new WeakMap();
var _classJailDragDisabled = /*#__PURE__*/new WeakMap();
var _classDragCollision = /*#__PURE__*/new WeakMap();
var _defaultZIndex = /*#__PURE__*/new WeakMap();
var _TinyDragger_brand = /*#__PURE__*/new WeakSet();
var _collisionsMarked = /*#__PURE__*/new WeakMap();
var TinyDragger = /*#__PURE__*/function () {
  /** @typedef {(event: TouchEvent) => void} TouchDragEvent */
  /**
   * @param {HTMLElement|TinyHtml} targetElement - The element to make draggable.
   * @param {Object} [options={}] - Configuration options.
   * @param {HTMLElement} [options.jail] - Optional container to restrict dragging within.
   * @param {boolean} [options.mirrorElem=true] - Use a visual clone instead of dragging the original element.
   * @param {number} [options.defaultZIndex] - Sets the z-index value applied when dragging starts.
   * @param {boolean} [options.collisionByMouse=false] - Use mouse position for collision instead of element rect.
   * @param {string} [options.classDragging='dragging'] - CSS class applied to the clone during dragging.
   * @param {string} [options.classBodyDragging='drag-active'] - CSS class applied to <body> during dragging.
   * @param {string} [options.classJailDragging='jail-drag-active'] - CSS class applied to jail element during drag.
   * @param {string} [options.classJailDragDisabled='jail-drag-disabled'] - CSS class applied to jail element disabled.
   * @param {string} [options.classDragCollision='dragging-collision'] - CSS class applied to collision element.
   * @param {boolean} [options.lockInsideJail=false] - Restrict movement within the jail container.
   * @param {boolean} [options.dropInJailOnly=false] - Restrict drop within the jail container.
   * @param {boolean} [options.multiCollision=false] - Enables returning multiple collided elements.
   * @param {VibrationPatterns|false} [options.vibration=false] - Vibration feedback configuration.
   * @param {boolean} [options.revertOnDrop=false] - Whether to return to original position on drop.
   * @param {string} [options.classHidden='drag-hidden'] - CSS class to hide original element during dragging.
   * @throws {Error} If any option has an invalid type.
   */
  function TinyDragger(targetElement) {
    var _this = this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, TinyDragger);
    /**
     * Handles the start of a drag event.
     * @param {MouseEvent|Touch} event - The initiating event.
     */
    _classPrivateMethodInitSpec(this, _TinyDragger_brand);
    _classPrivateFieldInitSpec(this, _enabled, true);
    _classPrivateFieldInitSpec(this, _destroyed, false);
    _classPrivateFieldInitSpec(this, _offsetY, 0);
    _classPrivateFieldInitSpec(this, _offsetX, 0);
    _classPrivateFieldInitSpec(this, _mirrorElem, true);
    _classPrivateFieldInitSpec(this, _multiCollision, false);
    _classPrivateFieldInitSpec(this, _lockInsideJail, false);
    _classPrivateFieldInitSpec(this, _revertOnDrop, false);
    _classPrivateFieldInitSpec(this, _dragging, false);
    _classPrivateFieldInitSpec(this, _collisionByMouse, false);
    _classPrivateFieldInitSpec(this, _dropInJailOnly, false);
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _lastCollision, null);
    /** @type {HTMLElement[]} */
    _classPrivateFieldInitSpec(this, _collidables, []);
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _dragProxy, null);
    /** @type {VibrationPatterns} */
    _classPrivateFieldInitSpec(this, _vibration, {
      start: false,
      end: false,
      collide: false,
      move: false
    });
    /** @type {HTMLElement|null} */
    _classPrivateFieldInitSpec(this, _jail, null);
    /** @type {HTMLElement} */
    _classPrivateFieldInitSpec(this, _target, void 0);
    _classPrivateFieldInitSpec(this, _dragHiddenClass, 'drag-hidden');
    _classPrivateFieldInitSpec(this, _classDragging, 'dragging');
    _classPrivateFieldInitSpec(this, _classBodyDragging, 'drag-active');
    _classPrivateFieldInitSpec(this, _classJailDragging, 'jail-drag-active');
    _classPrivateFieldInitSpec(this, _classJailDragDisabled, 'jail-drag-disabled');
    _classPrivateFieldInitSpec(this, _classDragCollision, 'dragging-collision');
    _classPrivateFieldInitSpec(this, _defaultZIndex, 9999);
    /** @type {HTMLElement[]} */
    _classPrivateFieldInitSpec(this, _collisionsMarked, []);
    var targetElem = !(targetElement instanceof _TinyHtml["default"]) ? targetElement : targetElement.get();
    if (!(targetElem instanceof HTMLElement)) throw new Error('TinyDragger requires a valid target HTMLElement to initialize.');
    _classPrivateFieldSet(_target, this, targetElem);
    // === Validations ===
    if (options.jail !== undefined && !(options.jail instanceof HTMLElement)) throw new Error('The "jail" option must be an HTMLElement if provided.');
    if (options.defaultZIndex !== undefined) this.setDefaultZIndex(options.defaultZIndex);
    if (options.vibration !== undefined && options.vibration !== false && !(0, _objFilter.isJsonObject)(options.vibration)) throw new Error('The "vibration" option must be an object or false.');
    /**
     * @param {any} val
     * @param {string} name
     */
    var validateBoolean = function validateBoolean(val, name) {
      if (val !== undefined && typeof val !== 'boolean') {
        throw new Error("The \"".concat(name, "\" option must be a boolean."));
      }
    };
    /**
     * @param {any} val
     * @param {string} name
     */
    var validateString = function validateString(val, name) {
      if (val !== undefined && typeof val !== 'string') {
        throw new Error("The \"".concat(name, "\" option must be a string."));
      }
    };
    validateBoolean(options.mirrorElem, 'mirrorElem');
    validateBoolean(options.collisionByMouse, 'collisionByMouse');
    validateBoolean(options.lockInsideJail, 'lockInsideJail');
    validateBoolean(options.dropInJailOnly, 'dropInJailOnly');
    validateBoolean(options.revertOnDrop, 'revertOnDrop');
    validateBoolean(options.multiCollision, 'multiCollision');
    validateString(options.classDragging, 'classDragging');
    validateString(options.classBodyDragging, 'classBodyDragging');
    validateString(options.classJailDragging, 'classJailDragging');
    validateString(options.classJailDragDisabled, 'classJailDragDisabled');
    validateString(options.classDragCollision, 'classDragCollision');
    validateString(options.classHidden, 'classHidden');
    if (options.jail instanceof HTMLElement) _classPrivateFieldSet(_jail, this, options.jail);
    /** @type {VibrationPatterns} */
    var vibrationTemplate = {
      start: false,
      end: false,
      collide: false,
      move: false
    };
    _classPrivateFieldSet(_vibration, this, Object.assign(vibrationTemplate, (0, _objFilter.isJsonObject)(options.vibration) ? options.vibration : {}));
    if (typeof options.classDragging === 'string') _classPrivateFieldSet(_classDragging, this, options.classDragging);
    if (typeof options.classBodyDragging === 'string') _classPrivateFieldSet(_classBodyDragging, this, options.classBodyDragging);
    if (typeof options.classJailDragging === 'string') _classPrivateFieldSet(_classJailDragging, this, options.classJailDragging);
    if (typeof options.classJailDragDisabled === 'string') _classPrivateFieldSet(_classJailDragDisabled, this, options.classJailDragDisabled);
    if (typeof options.classHidden === 'string') _classPrivateFieldSet(_dragHiddenClass, this, options.classHidden);
    if (typeof options.classDragCollision === 'string') _classPrivateFieldSet(_classDragCollision, this, options.classDragCollision);
    if (typeof options.collisionByMouse === 'boolean') _classPrivateFieldSet(_collisionByMouse, this, options.collisionByMouse);
    if (typeof options.mirrorElem === 'boolean') _classPrivateFieldSet(_mirrorElem, this, options.mirrorElem);
    if (typeof options.revertOnDrop === 'boolean') _classPrivateFieldSet(_revertOnDrop, this, options.revertOnDrop);
    if (typeof options.lockInsideJail === 'boolean') _classPrivateFieldSet(_lockInsideJail, this, options.lockInsideJail);
    if (typeof options.dropInJailOnly === 'boolean') _classPrivateFieldSet(_dropInJailOnly, this, options.dropInJailOnly);
    if (typeof options.multiCollision === 'boolean') _classPrivateFieldSet(_multiCollision, this, options.multiCollision);
    /** @private */
    this._onMouseDown = _assertClassBrand(_TinyDragger_brand, this, _startDrag).bind(this);
    /** @private */
    this._onMouseMove = _assertClassBrand(_TinyDragger_brand, this, _drag).bind(this);
    /** @private */
    this._onMouseUp = _assertClassBrand(_TinyDragger_brand, this, _endDrag).bind(this);
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchStart = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _startDrag).call(_this, e.touches[0]);
    };
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchMove = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _drag).call(_this, e.touches[0]);
    };
    /**
     * @type {TouchDragEvent}
     * @private
     */
    this._onTouchEnd = function (e) {
      return _assertClassBrand(_TinyDragger_brand, _this, _endDrag).call(_this, e.changedTouches[0]);
    };
    _classPrivateFieldGet(_target, this).addEventListener('mousedown', this._onMouseDown);
    _classPrivateFieldGet(_target, this).addEventListener('touchstart', this._onTouchStart, {
      passive: false
    });
  }
  /**
   * Enables the drag functionality.
   */
  return _createClass(TinyDragger, [{
    key: "enable",
    value: function enable() {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.add(_classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_enabled, this, true);
    }
    /**
     * Disables the drag functionality.
     */
  }, {
    key: "disable",
    value: function disable() {
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_enabled, this, false);
    }
    /**
     * Adds an element to be considered for collision detection.
     * @param {HTMLElement} element - The element to track collisions with.
     * @throws {Error} If the element is not a valid HTMLElement.
     */
  }, {
    key: "addCollidable",
    value: function addCollidable(element) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(element instanceof HTMLElement)) throw new Error('addCollidable expects an HTMLElement as argument.');
      if (!_classPrivateFieldGet(_collidables, this).includes(element)) _classPrivateFieldGet(_collidables, this).push(element);
    }
    /**
     * Removes a collidable element from the tracking list.
     * @param {HTMLElement} element - The element to remove.
     * @throws {Error} If the element is not a valid HTMLElement.
     */
  }, {
    key: "removeCollidable",
    value: function removeCollidable(element) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(element instanceof HTMLElement)) throw new Error('removeCollidable expects an HTMLElement as argument.');
      _classPrivateFieldSet(_collidables, this, _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return el !== element;
      }));
    }
    /**
     * Sets vibration patterns for drag events.
     * @param {Object} [param0={}] - Vibration pattern configuration.
     * @param {number[]|false} [param0.startPattern=false] - Vibration on drag start.
     * @param {number[]|false} [param0.endPattern=false] - Vibration on drag end.
     * @param {number[]|false} [param0.collidePattern=false] - Vibration on collision.
     * @param {number[]|false} [param0.movePattern=false] - Vibration during movement.
     * @throws {Error} If any pattern is not false or an array of numbers.
     */
  }, {
    key: "setVibrationPattern",
    value: function setVibrationPattern() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$startPattern = _ref.startPattern,
        startPattern = _ref$startPattern === void 0 ? false : _ref$startPattern,
        _ref$endPattern = _ref.endPattern,
        endPattern = _ref$endPattern === void 0 ? false : _ref$endPattern,
        _ref$collidePattern = _ref.collidePattern,
        collidePattern = _ref$collidePattern === void 0 ? false : _ref$collidePattern,
        _ref$movePattern = _ref.movePattern,
        movePattern = _ref$movePattern === void 0 ? false : _ref$movePattern;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      /** @param {any} value */
      var isValidPattern = function isValidPattern(value) {
        return value === false || Array.isArray(value) && value.every(function (n) {
          return typeof n === 'number';
        });
      };
      if (!isValidPattern(startPattern)) throw new Error('Invalid "startPattern": must be false or an array of numbers.');
      if (!isValidPattern(endPattern)) throw new Error('Invalid "endPattern": must be false or an array of numbers.');
      if (!isValidPattern(collidePattern)) throw new Error('Invalid "collidePattern": must be false or an array of numbers.');
      if (!isValidPattern(movePattern)) throw new Error('Invalid "movePattern": must be false or an array of numbers.');
      _classPrivateFieldSet(_vibration, this, {
        start: startPattern,
        end: endPattern,
        collide: collidePattern,
        move: movePattern
      });
    }
    /**
     * Disables all vibration feedback.
     */
  }, {
    key: "disableVibration",
    value: function disableVibration() {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      _classPrivateFieldSet(_vibration, this, {
        start: false,
        end: false,
        collide: false,
        move: false
      });
    }
    /**
     * Calculates the cursor offset relative to the top-left of the target element.
     * @param {MouseEvent|Touch} event - The mouse or touch event.
     * @returns {{x: number, y: number}} The offset in pixels.
     * @throws {Error} If event is not a MouseEvent or Touch with clientX/clientY.
     */
  }, {
    key: "getOffset",
    value: function getOffset(event) {
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(event instanceof MouseEvent) && !(event instanceof Touch) || typeof event.clientX !== 'number' || typeof event.clientY !== 'number') throw new Error('getOffset expects an event with valid clientX and clientY coordinates.');
      var targetRect = _classPrivateFieldGet(_target, this).getBoundingClientRect();
      var _TinyHtml$borderWidth = _TinyHtml["default"].borderWidth(_classPrivateFieldGet(_target, this)),
        borderLeft = _TinyHtml$borderWidth.left,
        borderTop = _TinyHtml$borderWidth.top;
      return {
        x: event.clientX - targetRect.left + borderLeft,
        y: event.clientY - targetRect.top + borderTop
      };
    }
  }, {
    key: "checkDragCollision",
    value:
    /**
     * Handles dragging collision.
     * @param {MouseEvent|Touch} event - The drag event.
     */
    function checkDragCollision(event) {
      var _this2 = this;
      var _this$execCollision = this.execCollision(event),
        collidedElements = _this$execCollision.collidedElements;
      var first = collidedElements[0] || null;
      // Removes old marking if necessary
      if (_classPrivateFieldGet(_lastCollision, this) && !collidedElements.includes(_classPrivateFieldGet(_lastCollision, this))) {
        _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
      }
      // Adds Marking for All Colluded
      collidedElements.forEach(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this2, _addCollision).call(_this2, el);
      });
      // Removes markings from who no longer collided
      _classPrivateFieldGet(_collidables, this).forEach(function (el) {
        if (!collidedElements.includes(el)) {
          el.classList.remove(_classPrivateFieldGet(_classDragCollision, _this2));
        }
      });
      if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).collide) && collidedElements.length > 0) {
        navigator.vibrate(_classPrivateFieldGet(_vibration, this).collide);
      }
      _classPrivateFieldSet(_lastCollision, this, first);
    }
    /**
     * Handles dragging movement.
     * @param {MouseEvent|Touch} event - The drag event.
     */
  }, {
    key: "execCollision",
    value:
    /**
     * Handles the collision of a drag.
     * @param {MouseEvent|Touch} event - The release event.
     * @returns {{ inJail: boolean; collidedElements: (HTMLElement | null)[] }}
     */
    function execCollision(event) {
      var _classPrivateFieldGet2;
      if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragProxy, this)) return {
        inJail: false,
        collidedElements: []
      };
      var collidedElements = [];
      var inJail = true;
      var jailRect = (_classPrivateFieldGet2 = _classPrivateFieldGet(_jail, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.getBoundingClientRect();
      if (_classPrivateFieldGet(_collisionByMouse, this)) {
        var x = event.clientX;
        var y = event.clientY;
        if (_classPrivateFieldGet(_dropInJailOnly, this) && _classPrivateFieldGet(_jail, this) && jailRect) {
          inJail = x >= jailRect.left && x <= jailRect.right && y >= jailRect.top && y <= jailRect.bottom;
        }
        collidedElements = inJail ? _classPrivateFieldGet(_multiCollision, this) ? this.getAllCollidedElements(x, y) : [this.getCollidedElement(x, y)].filter(Boolean) : [];
      } else {
        var rect = _classPrivateFieldGet(_dragProxy, this).getBoundingClientRect();
        if (_classPrivateFieldGet(_dropInJailOnly, this) && _classPrivateFieldGet(_jail, this) && jailRect) {
          inJail = rect.left >= jailRect.left && rect.right <= jailRect.right && rect.top >= jailRect.top && rect.bottom <= jailRect.bottom;
        }
        collidedElements = inJail ? _classPrivateFieldGet(_multiCollision, this) ? this.getAllCollidedElementsByRect(rect) : [this.getCollidedElementByRect(rect)].filter(Boolean) : [];
      }
      return {
        inJail: inJail,
        collidedElements: collidedElements
      };
    }
    /**
     * Handles the end of a drag.
     * @param {MouseEvent|Touch} event - The release event.
     */
  }, {
    key: "getAllCollidedElementsByRect",
    value:
    /**
     * Returns all elements currently colliding with the given rectangle.
     *
     * @param {DOMRect} rect - Bounding rectangle of the dragged proxy.
     * @returns {HTMLElement[]} A list of all collided elements.
     * @throws {Error} If the input is not a valid DOMRect with numeric bounds.
     */
    function getAllCollidedElementsByRect(rect) {
      var _this3 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(rect instanceof DOMRect) || typeof rect.left !== 'number' || typeof rect.right !== 'number' || typeof rect.top !== 'number' || typeof rect.bottom !== 'number') throw new Error('getCollidedElementByRect expects a valid DOMRect object.');
      return _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this3, _getCollidedElementByRect).call(_this3, el, rect);
      });
    }
    /**
     * Detects collision based on rectangle intersection.
     * @param {DOMRect} rect - Bounding rectangle of the dragged proxy.
     * @returns {HTMLElement|null} The collided element or null.
     * @throws {Error} If rect is not a DOMRect with valid numeric properties.
     */
  }, {
    key: "getCollidedElementByRect",
    value: function getCollidedElementByRect(rect) {
      var _this4 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (!(rect instanceof DOMRect) || typeof rect.left !== 'number' || typeof rect.right !== 'number' || typeof rect.top !== 'number' || typeof rect.bottom !== 'number') throw new Error('getCollidedElementByRect expects a valid DOMRect object.');
      return _classPrivateFieldGet(_collidables, this).find(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this4, _getCollidedElementByRect).call(_this4, el, rect);
      }) || null;
    }
    /**
     * Checks whether a given (x, y) coordinate is inside the bounding rectangle of an element.
     *
     * @param {HTMLElement} el - The element to test for collision.
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {boolean} True if the point is within the element's bounds.
     */
  }, {
    key: "getAllCollidedElements",
    value:
    /**
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {HTMLElement[]} The collided element or null.
     */
    function getAllCollidedElements(x, y) {
      var _this5 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (typeof x !== 'number' || typeof y !== 'number') throw new Error('getCollidedElement expects numeric x and y coordinates.');
      return _classPrivateFieldGet(_collidables, this).filter(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this5, _getCollidedElement).call(_this5, el, x, y);
      });
    }
    /**
     * Detects collision with a point using element bounding rectangles.
     * @param {number} x - Horizontal screen coordinate.
     * @param {number} y - Vertical screen coordinate.
     * @returns {HTMLElement|null} The collided element or null.
     */
  }, {
    key: "getCollidedElement",
    value: function getCollidedElement(x, y) {
      var _this6 = this;
      _assertClassBrand(_TinyDragger_brand, this, _checkDestroy).call(this);
      if (typeof x !== 'number' || typeof y !== 'number') throw new Error('getCollidedElement expects numeric x and y coordinates.');
      return _classPrivateFieldGet(_collidables, this).find(function (el) {
        return _assertClassBrand(_TinyDragger_brand, _this6, _getCollidedElement).call(_this6, el, x, y);
      }) || null;
    }
    /**
     * Dispatches a custom event from the target element.
     * @param {string} type - The event name.
     */
  }, {
    key: "getDragging",
    value:
    /**
     * Gets whether dragging is currently active.
     * @returns {boolean}
     */
    function getDragging() {
      return _classPrivateFieldGet(_dragging, this);
    }
    /**
     * Gets whether movement is restricted inside the jail container.
     * @returns {boolean}
     */
  }, {
    key: "getLockInsideJail",
    value: function getLockInsideJail() {
      return _classPrivateFieldGet(_lockInsideJail, this);
    }
    /**
     * Sets whether movement is restricted inside the jail container.
     * @param {boolean} value
     */
  }, {
    key: "setLockInsideJail",
    value: function setLockInsideJail(value) {
      if (typeof value !== 'boolean') throw new Error('lockInsideJail must be a boolean.');
      _classPrivateFieldSet(_lockInsideJail, this, value);
    }
    /**
     * Gets whether the element should revert to original position on drop.
     * @returns {boolean}
     */
  }, {
    key: "getRevertOnDrop",
    value: function getRevertOnDrop() {
      return _classPrivateFieldGet(_revertOnDrop, this);
    }
    /**
     * Sets whether the element should revert to original position on drop.
     * @param {boolean} value
     */
  }, {
    key: "setRevertOnDrop",
    value: function setRevertOnDrop(value) {
      if (typeof value !== 'boolean') throw new Error('revertOnDrop must be a boolean.');
      _classPrivateFieldSet(_revertOnDrop, this, value);
    }
    /**
     * Gets whether collision detection uses mouse position.
     * @returns {boolean}
     */
  }, {
    key: "getCollisionByMouse",
    value: function getCollisionByMouse() {
      return _classPrivateFieldGet(_collisionByMouse, this);
    }
    /**
     * Sets whether collision detection uses mouse position.
     * @param {boolean} value
     */
  }, {
    key: "setCollisionByMouse",
    value: function setCollisionByMouse(value) {
      if (typeof value !== 'boolean') throw new Error('collisionByMouse must be a boolean.');
      _classPrivateFieldSet(_collisionByMouse, this, value);
    }
    /**
     * Gets whether dropping is restricted inside the jail container.
     * @returns {boolean}
     */
  }, {
    key: "getDropInJailOnly",
    value: function getDropInJailOnly() {
      return _classPrivateFieldGet(_dropInJailOnly, this);
    }
    /**
     * Sets whether dropping is restricted inside the jail container.
     * @param {boolean} value
     */
  }, {
    key: "setDropInJailOnly",
    value: function setDropInJailOnly(value) {
      if (typeof value !== 'boolean') throw new Error('dropInJailOnly must be a boolean.');
      _classPrivateFieldSet(_dropInJailOnly, this, value);
    }
    /**
     * Returns the current default z-index used for draggable items.
     * @returns {number}
     */
  }, {
    key: "getDefaultZIndex",
    value: function getDefaultZIndex() {
      return _classPrivateFieldGet(_defaultZIndex, this);
    }
    /**
     * Sets a new default z-index for draggable items.
     * @param {number} newZIndex
     */
  }, {
    key: "setDefaultZIndex",
    value: function setDefaultZIndex(newZIndex) {
      if (typeof newZIndex !== 'number' || !Number.isFinite(newZIndex)) throw new TypeError('Z-index must be a finite number.');
      _classPrivateFieldSet(_defaultZIndex, this, newZIndex);
    }
    /**
     * Returns whether the draggable element is mirrored or the original.
     * @returns {boolean}
     */
  }, {
    key: "isMirrorEnabled",
    value: function isMirrorEnabled() {
      return _classPrivateFieldGet(_mirrorElem, this);
    }
    /**
     * Sets whether the draggable element should be a mirror or the original.
     * @param {boolean} useMirror
     */
  }, {
    key: "setMirrorEnabled",
    value: function setMirrorEnabled(useMirror) {
      if (typeof useMirror !== 'boolean') throw new TypeError('Mirror setting must be a boolean.');
      _classPrivateFieldSet(_mirrorElem, this, useMirror);
    }
    /**
     * Returns the original target element being dragged.
     * @returns {HTMLElement}
     */
  }, {
    key: "getTarget",
    value: function getTarget() {
      return _classPrivateFieldGet(_target, this);
    }
    /**
     * Returns the current jail container (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getJail",
    value: function getJail() {
      return _classPrivateFieldGet(_jail, this);
    }
    /**
     * Returns the current proxy element being dragged (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getDragProxy",
    value: function getDragProxy() {
      return _classPrivateFieldGet(_dragProxy, this);
    }
    /**
     * Returns the last collided element (if any).
     * @returns {HTMLElement|null}
     */
  }, {
    key: "getLastCollision",
    value: function getLastCollision() {
      return _classPrivateFieldGet(_lastCollision, this);
    }
    /**
     * Returns all registered collidable elements.
     * @returns {HTMLElement[]}
     */
  }, {
    key: "getCollidables",
    value: function getCollidables() {
      return _toConsumableArray(_classPrivateFieldGet(_collidables, this));
    }
    /**
     * Returns the CSS class used to hide the target during drag.
     * @returns {string}
     */
  }, {
    key: "getDragHiddenClass",
    value: function getDragHiddenClass() {
      return _classPrivateFieldGet(_dragHiddenClass, this);
    }
    /**
     * Returns the CSS class applied to the clone during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassDragging",
    value: function getClassDragging() {
      return _classPrivateFieldGet(_classDragging, this);
    }
    /**
     * Returns the CSS class applied to <body> during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassBodyDragging",
    value: function getClassBodyDragging() {
      return _classPrivateFieldGet(_classBodyDragging, this);
    }
    /**
     * Returns the CSS class applied to the jail during dragging.
     * @returns {string}
     */
  }, {
    key: "getClassJailDragging",
    value: function getClassJailDragging() {
      return _classPrivateFieldGet(_classJailDragging, this);
    }
    /**
     * Returns the CSS class applied to the jail when dragging is disabled.
     * @returns {string}
     */
  }, {
    key: "getClassJailDragDisabled",
    value: function getClassJailDragDisabled() {
      return _classPrivateFieldGet(_classJailDragDisabled, this);
    }
    /**
     * Returns the CSS class applied to a collided element.
     * @returns {string}
     */
  }, {
    key: "getClassDragCollision",
    value: function getClassDragCollision() {
      return _classPrivateFieldGet(_classDragCollision, this);
    }
    /**
     * Returns the full vibration configuration.
     * @returns {VibrationPatterns}
     */
  }, {
    key: "getVibrations",
    value: function getVibrations() {
      return _objectSpread({}, _classPrivateFieldGet(_vibration, this));
    }
    /**
     * Returns the vibration pattern for drag start.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getStartVibration",
    value: function getStartVibration() {
      return _classPrivateFieldGet(_vibration, this).start;
    }
    /**
     * Returns the vibration pattern for drag end.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getEndVibration",
    value: function getEndVibration() {
      return _classPrivateFieldGet(_vibration, this).end;
    }
    /**
     * Returns the vibration pattern for collisions.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getCollideVibration",
    value: function getCollideVibration() {
      return _classPrivateFieldGet(_vibration, this).collide;
    }
    /**
     * Returns the vibration pattern during movement.
     * @returns {number[]|boolean}
     */
  }, {
    key: "getMoveVibration",
    value: function getMoveVibration() {
      return _classPrivateFieldGet(_vibration, this).move;
    }
    /**
     * Returns whether the dragger is currently enabled.
     * @returns {boolean}
     */
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return _classPrivateFieldGet(_enabled, this);
    }
    /**
     * Internal method to verify if the instance has been destroyed.
     * Throws an error if any operation is attempted after destruction.
     */
  }, {
    key: "destroy",
    value:
    /**
     * Completely disables drag-and-drop and cleans up all event listeners.
     * Does NOT remove the original HTML element.
     */
    function destroy() {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      this.disable();
      _classPrivateFieldGet(_target, this).removeEventListener('mousedown', this._onMouseDown);
      _classPrivateFieldGet(_target, this).removeEventListener('touchstart', this._onTouchStart);
      document.removeEventListener('mousemove', this._onMouseMove);
      document.removeEventListener('mouseup', this._onMouseUp);
      document.removeEventListener('touchmove', this._onTouchMove);
      document.removeEventListener('touchend', this._onTouchEnd);
      if (_classPrivateFieldGet(_lastCollision, this)) _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
      if (_classPrivateFieldGet(_dragProxy, this)) {
        if (_classPrivateFieldGet(_mirrorElem, this)) _classPrivateFieldGet(_dragProxy, this).remove();else Object.assign(_classPrivateFieldGet(_dragProxy, this).style, {
          position: '',
          pointerEvents: '',
          left: '',
          top: '',
          width: '',
          height: '',
          zIndex: ''
        });
        _classPrivateFieldSet(_dragProxy, this, null);
      }
      _classPrivateFieldSet(_collidables, this, []);
      _classPrivateFieldSet(_dragging, this, false);
      _classPrivateFieldSet(_lastCollision, this, null);
      if (_classPrivateFieldGet(_mirrorElem, this)) _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_dragHiddenClass, this));
      _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_classDragging, this));
      document.body.classList.remove(_classPrivateFieldGet(_classBodyDragging, this));
      if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragging, this), _classPrivateFieldGet(_classJailDragDisabled, this));
      _classPrivateFieldSet(_destroyed, this, true);
    }
  }]);
}();
function _startDrag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_enabled, this) || !_classPrivateFieldGet(_target, this).parentElement) return;
  if (_classPrivateFieldGet(_mirrorElem, this)) {
    var dragProxy = _classPrivateFieldGet(_target, this).cloneNode(true);
    if (!(dragProxy instanceof HTMLElement)) throw new Error('[TinyDragger] INVALID DRAG ELEMENT!');
    _classPrivateFieldSet(_dragProxy, this, dragProxy);
  } else _classPrivateFieldSet(_dragProxy, this, _classPrivateFieldGet(_target, this));
  _classPrivateFieldSet(_dragging, this, true);
  var rect = _classPrivateFieldGet(_target, this).getBoundingClientRect();
  Object.assign(_classPrivateFieldGet(_dragProxy, this).style, {
    position: 'absolute',
    pointerEvents: 'none',
    left: "".concat(_classPrivateFieldGet(_target, this).offsetLeft, "px"),
    top: "".concat(_classPrivateFieldGet(_target, this).offsetTop, "px"),
    width: "".concat(rect.width, "px"),
    height: "".concat(rect.height, "px"),
    zIndex: _classPrivateFieldGet(_defaultZIndex, this)
  });
  if (_classPrivateFieldGet(_mirrorElem, this)) {
    _classPrivateFieldGet(_target, this).classList.add(_classPrivateFieldGet(_dragHiddenClass, this));
    _classPrivateFieldGet(_target, this).parentElement.appendChild(_classPrivateFieldGet(_dragProxy, this));
  }
  var _this$getOffset = this.getOffset(event),
    offsetX = _this$getOffset.x,
    offsetY = _this$getOffset.y;
  _classPrivateFieldSet(_offsetX, this, offsetX);
  _classPrivateFieldSet(_offsetY, this, offsetY);
  _classPrivateFieldGet(_dragProxy, this).classList.add(_classPrivateFieldGet(_classDragging, this));
  document.body.classList.add(_classPrivateFieldGet(_classBodyDragging, this));
  if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.add(_classPrivateFieldGet(_classJailDragging, this));
  document.addEventListener('mousemove', this._onMouseMove);
  document.addEventListener('mouseup', this._onMouseUp);
  document.addEventListener('touchmove', this._onTouchMove, {
    passive: false
  });
  document.addEventListener('touchend', this._onTouchEnd);
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).start)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).start);
  }
  this.checkDragCollision(event);
  _assertClassBrand(_TinyDragger_brand, this, _dispatchEvent).call(this, 'drag');
}
/**
 * Marks an element as currently collided by adding the collision CSS class.
 * The element is stored in an internal list for easy removal later.
 *
 * @param {HTMLElement|null} el - The element to mark as collided.
 */
function _addCollision(el) {
  if (!el) return;
  el.classList.add(_classPrivateFieldGet(_classDragCollision, this));
  _classPrivateFieldGet(_collisionsMarked, this).push(el);
}
/**
 * Removes the collision CSS class from all previously marked elements.
 * Also clears the last single collision element, if set.
 *
 */
function _removeCollision() {
  while (_classPrivateFieldGet(_collisionsMarked, this).length > 0) {
    var el = _classPrivateFieldGet(_collisionsMarked, this).shift();
    if (el) el.classList.remove(_classPrivateFieldGet(_classDragCollision, this));
  }
  if (!_classPrivateFieldGet(_lastCollision, this)) return;
  _classPrivateFieldGet(_lastCollision, this).classList.remove(_classPrivateFieldGet(_classDragCollision, this));
}
function _drag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragging, this) || !_classPrivateFieldGet(_enabled, this) || !_classPrivateFieldGet(_dragProxy, this)) return;
  var parent = _classPrivateFieldGet(_dragProxy, this).offsetParent || document.body;
  var parentRect = parent.getBoundingClientRect();
  var x = event.clientX - parentRect.left - _classPrivateFieldGet(_offsetX, this);
  var y = event.clientY - parentRect.top - _classPrivateFieldGet(_offsetY, this);
  if (_classPrivateFieldGet(_lockInsideJail, this) && _classPrivateFieldGet(_jail, this)) {
    var jailRect = _classPrivateFieldGet(_jail, this).getBoundingClientRect();
    var targetRect = _classPrivateFieldGet(_dragProxy, this).getBoundingClientRect();
    var jailLeft = jailRect.left - parentRect.left;
    var jailTop = jailRect.top - parentRect.top;
    var _TinyHtml$borderWidth2 = _TinyHtml["default"].borderWidth(_classPrivateFieldGet(_jail, this)),
      borderX = _TinyHtml$borderWidth2.x,
      borderY = _TinyHtml$borderWidth2.y;
    var maxX = jailLeft + jailRect.width - targetRect.width - borderY;
    var maxY = jailTop + jailRect.height - targetRect.height - borderX;
    x = Math.max(jailLeft, Math.min(x, maxX));
    y = Math.max(jailTop, Math.min(y, maxY));
  }
  _classPrivateFieldGet(_dragProxy, this).style.position = 'absolute';
  _classPrivateFieldGet(_dragProxy, this).style.left = "".concat(x, "px");
  _classPrivateFieldGet(_dragProxy, this).style.top = "".concat(y, "px");
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).move)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).move);
  }
  this.checkDragCollision(event);
  _assertClassBrand(_TinyDragger_brand, this, _dispatchEvent).call(this, 'dragging');
}
function _endDrag(event) {
  if (event instanceof MouseEvent) event.preventDefault();
  if (_classPrivateFieldGet(_destroyed, this) || !_classPrivateFieldGet(_dragging, this)) return;
  _classPrivateFieldSet(_dragging, this, false);
  if (!_classPrivateFieldGet(_dragProxy, this)) return;
  _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_classDragging, this));
  document.body.classList.remove(_classPrivateFieldGet(_classBodyDragging, this));
  if (_classPrivateFieldGet(_jail, this)) _classPrivateFieldGet(_jail, this).classList.remove(_classPrivateFieldGet(_classJailDragging, this));
  document.removeEventListener('mousemove', this._onMouseMove);
  document.removeEventListener('mouseup', this._onMouseUp);
  document.removeEventListener('touchmove', this._onTouchMove);
  document.removeEventListener('touchend', this._onTouchEnd);
  var _this$execCollision2 = this.execCollision(event),
    collidedElements = _this$execCollision2.collidedElements;
  if (navigator.vibrate && Array.isArray(_classPrivateFieldGet(_vibration, this).end)) {
    navigator.vibrate(_classPrivateFieldGet(_vibration, this).end);
  }
  var newX = _classPrivateFieldGet(_dragProxy, this).style.left;
  var newY = _classPrivateFieldGet(_dragProxy, this).style.top;
  if (_classPrivateFieldGet(_dragProxy, this)) {
    if (_classPrivateFieldGet(_mirrorElem, this)) _classPrivateFieldGet(_dragProxy, this).remove();else Object.assign(_classPrivateFieldGet(_dragProxy, this).style, {
      position: '',
      pointerEvents: '',
      left: '',
      top: '',
      width: '',
      height: '',
      zIndex: ''
    });
    _classPrivateFieldSet(_dragProxy, this, null);
  }
  if (_classPrivateFieldGet(_lastCollision, this)) _assertClassBrand(_TinyDragger_brand, this, _removeCollision).call(this);
  _classPrivateFieldSet(_lastCollision, this, null);
  if (_classPrivateFieldGet(_mirrorElem, this)) _classPrivateFieldGet(_target, this).classList.remove(_classPrivateFieldGet(_dragHiddenClass, this));
  if (!_classPrivateFieldGet(_revertOnDrop, this)) {
    _classPrivateFieldGet(_target, this).style.left = newX;
    _classPrivateFieldGet(_target, this).style.top = newY;
  }
  var dropEvent = new CustomEvent('drop', {
    detail: {
      targets: collidedElements,
      first: collidedElements[0] || null
    }
  });
  _classPrivateFieldGet(_target, this).dispatchEvent(dropEvent);
}
/**
 * Checks if the provided element intersects with the given bounding rectangle.
 *
 * @param {HTMLElement} el - The element to test for collision.
 * @param {DOMRect} rect - The bounding rectangle to check against.
 * @returns {boolean} True if the element intersects with the rectangle.
 */
function _getCollidedElementByRect(el, rect) {
  var elRect = el.getBoundingClientRect();
  return !(rect.right < elRect.left || rect.left > elRect.right || rect.bottom < elRect.top || rect.top > elRect.bottom);
}
function _getCollidedElement(el, x, y) {
  var rect = el.getBoundingClientRect();
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}
function _dispatchEvent(type) {
  var event = new CustomEvent(type);
  _classPrivateFieldGet(_target, this).dispatchEvent(event);
}
function _checkDestroy() {
  if (_classPrivateFieldGet(_destroyed, this)) throw new Error('This TinyDragger instance has been destroyed and can no longer be used.');
}
_defineProperty(TinyDragger, "Utils", _objectSpread(_objectSpread({}, TinyCollision), {}, {
  TinyHtml: _TinyHtml["default"]
}));
var _default = exports["default"] = TinyDragger;

},{"../basics/collision.mjs":151,"../basics/objFilter.mjs":155,"./TinyHtml.mjs":167}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var TinyCollision = _interopRequireWildcard(require("../basics/collision.mjs"));
var _TinyHtml;
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var areElsColliding = TinyCollision.areElsColliding,
  areElsPerfColliding = TinyCollision.areElsPerfColliding,
  areElsCollTop = TinyCollision.areElsCollTop,
  areElsCollBottom = TinyCollision.areElsCollBottom,
  areElsCollLeft = TinyCollision.areElsCollLeft,
  areElsCollRight = TinyCollision.areElsCollRight;
/**
 * Callback invoked on each animation frame with the current scroll position,
 * normalized animation time (`0` to `1`), and a completion flag.
 *
 * @typedef {(progress: { x: number, y: number, isComplete: boolean, time: number }) => void} OnScrollAnimation
 */
/**
 * A list of supported easing function names for smooth animations.
 *
 * @typedef {'linear' | 'easeInQuad' | 'easeOutQuad' | 'easeInOutQuad' | 'easeInCubic' | 'easeOutCubic' | 'easeInOutCubic'} Easings
 */
/**
 * Represents a raw Node element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {Node|TinyHtml|null} TinyNode
 */
/**
 * Represents a raw DOM element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {Element|TinyHtml} TinyElement
 */
/**
 * Represents a raw DOM html element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {HTMLElement|TinyHtml} TinyHtmlElement
 */
/**
 * Represents a raw DOM event target element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {EventTarget|TinyHtml} TinyEventTarget
 */
/**
 * Represents a raw DOM input element or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {InputElement|TinyHtml} TinyInputElement
 */
/**
 * Represents a raw DOM element/window or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {ElementAndWindow|TinyHtml} TinyElementAndWindow
 */
/**
 * Represents a value that can be either a DOM Element or the global Window object.
 * Useful for functions that operate generically on scrollable or measurable targets.
 *
 * @typedef {Element|Window} ElementAndWindow
 */
/**
 * Represents a raw DOM element/window/document or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {ElementAndWinAndDoc|TinyHtml} TinyElementAndWinAndDoc
 */
/**
 * Represents a value that can be either a DOM Element, or the global Window object, or the document object.
 * Useful for functions that operate generically on scrollable or measurable targets.
 *
 * @typedef {Element|Window|Document} ElementAndWinAndDoc
 */
/**
 * Represents a raw DOM element with document or an instance of TinyHtml.
 * This type is used to abstract interactions with both plain elements
 * and wrapped elements via the TinyHtml class.
 *
 * @typedef {ElementWithDoc|TinyHtml} TinyElementWithDoc
 */
/**
 * Represents a value that can be either a DOM Element, or the document object.
 * Useful for functions that operate generically on measurable targets.
 *
 * @typedef {Element|Document} ElementWithDoc
 */
/**
 * A parameter type used for filtering or matching elements.
 * It can be:
 * - A string (CSS selector),
 * - A raw DOM element,
 * - An array of raw DOM elements,
 * - A filtering function that receives an index and element,
 *   and returns true if it matches.
 *
 * @typedef {string|Element|Element[]|((index: number, el: Element) => boolean)} WinnowRequest
 */
/**
 * Elements accepted as constructor values for TinyHtml.
 * These include common DOM elements and root containers.
 *
 * @typedef {Window|Element|Document|Text} ConstructorElValues
 */
/**
 * Options passed to `addEventListener` or `removeEventListener`.
 * Can be a boolean or an object of type `AddEventListenerOptions`.
 *
 * @typedef {boolean|AddEventListenerOptions} EventRegistryOptions
 */
/**
 * Structure describing a registered event callback and its options.
 *
 * @typedef {Object} EventRegistryItem
 * @property {EventListenerOrEventListenerObject|null} handler - The function to be executed when the event is triggered.
 * @property {EventRegistryOptions} [options] - Optional configuration passed to the listener.
 */
/**
 * Maps event names (e.g., `"click"`, `"keydown"`) to a list of registered handlers and options.
 *
 * @typedef {Record<string, EventRegistryItem[]>} EventRegistryList
 */
/**
 * WeakMap storing all event listeners per element.
 * Each element has a registry mapping event names to their handler lists.
 *
 * @type {WeakMap<ConstructorElValues|EventTarget, EventRegistryList>}
 */
var __eventRegistry = new WeakMap();
/**
 * A key-value store associated with a specific DOM element.
 * Keys are strings, and values can be of any type.
 *
 * @typedef {Record<string, *>} ElementDataStore
 */
/**
 * WeakMap to hold private data for elements
 *
 * @type {WeakMap<ConstructorElValues, ElementDataStore>}
 */
var __elementDataMap = new WeakMap();
/**
 * Stores directional collision locks separately.
 * Each direction has its own WeakMap to allow independent locking.
 *
 * @type {{
 *   top: WeakMap<Element, true>,
 *   bottom: WeakMap<Element, true>,
 *   left: WeakMap<Element, true>,
 *   right: WeakMap<Element, true>
 * }}
 */
var __elemCollision = {
  top: new WeakMap(),
  bottom: new WeakMap(),
  left: new WeakMap(),
  right: new WeakMap()
};
/**
 * Possible directions from which a collision was detected and locked.
 *
 * @typedef {'top'|'bottom'|'left'|'right'} CollisionDirLock
 */
/**
 * @typedef {Object} HtmlElBoxSides
 * @property {number} x - Total horizontal size (left + right)
 * @property {number} y - Total vertical size (top + bottom)
 * @property {number} left
 * @property {number} right
 * @property {number} top
 * @property {number} bottom
 */
/**
 * @typedef {string | number | Date | boolean | null} SetValueBase - Primitive types accepted as input values.
 */
/**
 * @typedef {'string' | 'date' | 'number'} GetValueTypes
 * Types of value extractors supported by TinyHtml._valTypes.
 */
/**
 * @typedef {SetValueBase|SetValueBase[]} SetValueList - A single value or an array of values to be assigned to the input element.
 */
/**
 * A list of HTML form elements that can have a `.value` property used by TinyHtml.
 * Includes common input types used in forms.
 *
 * @typedef {HTMLInputElement|HTMLSelectElement|HTMLTextAreaElement|HTMLOptionElement} InputElement
 */
/**
 * TinyHtml is a utility class that provides static and instance-level methods
 * for precise dimension and position computations on HTML elements.
 * It mimics some jQuery functionalities while using native browser APIs.
 *
 * Inspired by the jQuery project's open source implementations of element dimension
 * and offset utilities. This class serves as a lightweight alternative using modern DOM APIs.
 *
 * @class
 */
var _el = /*#__PURE__*/new WeakMap();
var TinyHtml = /*#__PURE__*/function () {
  /**
   * Creates an instance of TinyHtml for a specific Element.
   * Useful when you want to operate repeatedly on the same element using instance methods.
   * @param {ConstructorElValues} el - The element to wrap and manipulate.
   */
  function TinyHtml(el) {
    _classCallCheck(this, TinyHtml);
    //////////////////////////////////////////////////////////////////
    /** @type {ElementDataStore} */
    _defineProperty(this, "_data", {});
    //////////////////////////////////////////////////////
    /**
     * The target HTML element for instance-level operations.
     * @type {ConstructorElValues}
     */
    _classPrivateFieldInitSpec(this, _el, void 0);
    if (el instanceof TinyHtml) throw new Error("[TinyHtml] You are trying to put a TinyHtml inside another TinyHtml in constructor.");
    if (!(el instanceof Element) && !(el instanceof Window) && !(el instanceof Document) && !(el instanceof Text)) throw new Error("[TinyHtml] Invalid Target in constructor.");
    _classPrivateFieldSet(_el, this, el);
  }
  /**
   * Checks whether the given object is a window.
   * @param {*} obj - The object to test.
   * @returns {obj is Window} - True if it's a Window.
   */
  return _createClass(TinyHtml, [{
    key: "querySelector",
    value:
    /**
     * Queries the element for the first element matching the CSS selector and wraps it in a TinyHtml instance.
     *
     * @param {string} selector - A valid CSS selector string.
     * @returns {TinyHtml|null} A TinyHtml instance wrapping the matched element.
     */
    function querySelector(selector) {
      return TinyHtml.query(selector, TinyHtml._preElem(this, 'query'));
    }
    /**
     * Queries the document for all elements matching the CSS selector and wraps them in TinyHtml instances.
     *
     * @param {string} selector - A valid CSS selector string.
     * @param {Document|Element} elem - Target element.
     * @returns {TinyHtml[]} An array of TinyHtml instances wrapping the matched elements.
     */
  }, {
    key: "querySelectorAll",
    value:
    /**
     * Queries the element for all elements matching the CSS selector and wraps them in TinyHtml instances.
     *
     * @param {string} selector - A valid CSS selector string.
     * @returns {TinyHtml[]} An array of TinyHtml instances wrapping the matched elements.
     */
    function querySelectorAll(selector) {
      return TinyHtml.queryAll(selector, TinyHtml._preElem(this, 'queryAll'));
    }
    /**
     * Retrieves an element by its ID and wraps it in a TinyHtml instance.
     *
     * @param {string} selector - The ID of the element to retrieve.
     * @returns {TinyHtml|null} A TinyHtml instance wrapping the found element.
     */
  }, {
    key: "getElementsByClassName",
    value:
    /**
     * Retrieves all elements with the specified class name and wraps them in TinyHtml instances.
     *
     * @param {string} selector - The class name to search for.
     * @returns {TinyHtml[]} An array of TinyHtml instances wrapping the found elements.
     */
    function getElementsByClassName(selector) {
      return TinyHtml.getByClassName(selector, TinyHtml._preElem(this, 'getByClassName'));
    }
    /**
     * Retrieves all elements with the specified name attribute and wraps them in TinyHtml instances.
     *
     * @param {string} selector - The name attribute to search for.
     * @returns {TinyHtml[]} An array of TinyHtml instances wrapping the found elements.
     */
  }, {
    key: "getElementsByTagNameNS",
    value:
    /**
     * Retrieves all elements with the specified local tag name within the given namespace URI,
     * and wraps them in TinyHtml instances.
     *
     * @param {string} localName - The local name (tag) of the elements to search for.
     * @param {string|null} [namespaceURI='http://www.w3.org/1999/xhtml'] - The namespace URI to search within.
     * @returns {TinyHtml[]} An array of TinyHtml instances wrapping the found elements.
     */
    function getElementsByTagNameNS(localName) {
      var namespaceURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http://www.w3.org/1999/xhtml';
      return TinyHtml.getByTagNameNS(localName, namespaceURI, TinyHtml._preElem(this, 'getByTagNameNS'));
    }
    //////////////////////////////////////////////////////////////////
    /**
     * Returns the current target held by this instance.
     *
     * @returns {ConstructorElValues} - The instance's target element.
     */
  }, {
    key: "get",
    value: function get() {
      return _classPrivateFieldGet(_el, this);
    }
    /**
     * Returns the current Element held by this instance.
     *
     * @param {string} where - The method name or context calling this.
     * @returns {ConstructorElValues} - The instance's element.
     * @readonly
     */
  }, {
    key: "_getElement",
    value: function _getElement(where) {
      if (!(_classPrivateFieldGet(_el, this) instanceof Element) && !(_classPrivateFieldGet(_el, this) instanceof Window) && !(_classPrivateFieldGet(_el, this) instanceof Document)) throw new Error("[TinyHtml] Invalid Element in ".concat(where, "()."));
      return _classPrivateFieldGet(_el, this);
    }
    //////////////////////////////////////////////////////
    /**
     * @param {TinyElement|EventTarget|null|(TinyElement|EventTarget|null)[]} elems
     * @param {string} where
     * @param {any[]} TheTinyElements
     * @param {string[]} elemName
     * @returns {any[]}
     * @readonly
     */
  }, {
    key: "not",
    value:
    /**
     * Returns only the elements **not** matching the given selector or function.
     *
     * @param {WinnowRequest} selector
     * @returns {Element[]}
     */
    function not(selector) {
      return TinyHtml.not(this, selector);
    }
    /**
     * Finds elements matching a selector within a context.
     *
     * @param {TinyElement|TinyElement[]} context
     * @param {string} selector
     * @returns {Element[]}
     */
  }, {
    key: "find",
    value:
    /**
     * Finds elements in your element matching a selector within a context.
     *
     * @param {string} selector
     * @returns {Element[]}
     */
    function find(selector) {
      return TinyHtml.find(this, selector);
    }
    /**
     * Checks if at least one element matches the selector.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {WinnowRequest} selector
     * @returns {boolean}
     */
  }, {
    key: "is",
    value:
    /**
     * Checks if the element matches the selector.
     *
     * @param {WinnowRequest} selector
     * @returns {boolean}
     */
    function is(selector) {
      return TinyHtml.is(this, selector);
    }
    /**
     * Returns elements from the current list that contain the given target(s).
     * @param {TinyElement|TinyElement[]} roots - A single element or an array of elements (DOM or TinyHtml).
     * @param {string|TinyElement|TinyElement[]} target - Selector or DOM element(s).
     * @returns {Element[]} Elements that contain the target.
     */
  }, {
    key: "has",
    value:
    /**
     * Return if the element has the target(s).
     * @param {string|TinyElement|TinyElement[]} target - Selector or DOM element(s).
     * @returns {boolean} Elements that contain the target.
     */
    function has(target) {
      return TinyHtml.has(this, target).length > 0;
    }
    /**
     * Finds the closest ancestor (including self) that matches the selector.
     *
     * @param {TinyElement|TinyElement[]} els - A single element or an array of elements (DOM or TinyHtml).
     * @param {string|Element} selector - A selector string or DOM element to match.
     * @param {Element|null} [context] - An optional context to stop searching.
     * @returns {Element[]}
     */
  }, {
    key: "closest",
    value:
    /**
     * Finds the closest ancestor (including self) that matches the selector.
     *
     * @param {string|Element} selector - A selector string or DOM element to match.
     * @param {Element|null} [context] - An optional context to stop searching.
     * @returns {Element[]}
     */
    function closest(selector, context) {
      return TinyHtml.closest(this, selector, context);
    }
    /**
     * Compares two DOM elements to determine if they refer to the same node in the document.
     *
     * This performs a strict equality check (`===`) between the two elements.
     *
     * @param {TinyNode} elem - The first DOM element to compare.
     * @param {TinyNode} otherElem - The second DOM element to compare.
     * @returns {boolean} `true` if both elements are the same DOM node; otherwise, `false`.
     */
  }, {
    key: "isSameDom",
    value:
    /**
     * Compares two DOM elements to determine if they refer to the same node in the document.
     *
     * This performs a strict equality check (`===`) between the two elements.
     *
     * @param {TinyNode} elem - The DOM element to compare.
     * @returns {boolean} `true` if both elements are the same DOM node; otherwise, `false`.
     */
    function isSameDom(elem) {
      return TinyHtml.isSameDom(this, elem);
    }
  }, {
    key: "data",
    value:
    /**
     * Retrieves data associated with a DOM element.
     *
     * If a `key` is provided, the corresponding value is returned.
     * If no `key` is given, a shallow copy of all stored data is returned.
     *
     * @param {string} [key] - The specific key to retrieve from the data store.
     * @param {boolean} [isPrivate=false] - Whether to access the private data store.
     * @returns {ElementDataStore|undefined|any} - The stored value, all data, or undefined if the key doesn't exist.
     */
    function data(key, isPrivate) {
      return TinyHtml.data(this, key, isPrivate);
    }
    /**
     * Stores a value associated with a specific key for a DOM element.
     *
     * @param {TinyElement} el - The DOM element.
     * @param {string} key - The key under which the data will be stored.
     * @param {any} value - The value to store.
     * @param {boolean} [isPrivate=false] - Whether to store the data in the private store.
     * @returns {TinyElement}
     */
  }, {
    key: "setData",
    value:
    /**
     * Stores a value associated with a specific key for a DOM element.
     *
     * @param {string} key - The key under which the data will be stored.
     * @param {any} value - The value to store.
     * @param {boolean} [isPrivate=false] - Whether to store the data in the private store.
     * @returns {TinyElement}
     */
    function setData(key, value) {
      var isPrivate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return TinyHtml.setData(this, key, value, isPrivate);
    }
    //////////////////////////////////////////////////////
    /**
     * Get the sibling element in a given direction.
     *
     * @param {TinyNode} el
     * @param {"previousSibling"|"nextSibling"} direction
     * @param {string} where
     * @returns {ChildNode|null}
     * @readonly
     */
  }, {
    key: "parent",
    value:
    /**
     * Returns the direct parent node of the given element, excluding document fragments.
     *
     * @returns {ParentNode|null} The parent node or null if not found.
     */
    function parent() {
      return TinyHtml.parent(this);
    }
    /**
     * Returns all ancestor nodes of the given element, optionally stopping before a specific ancestor.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of ancestor nodes.
     */
  }, {
    key: "parents",
    value:
    /**
     * Returns all ancestor nodes of the given element, optionally stopping before a specific ancestor.
     *
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of ancestor nodes.
     */
    function parents(until) {
      return TinyHtml.parents(this, until);
    }
    /**
     * Returns the next sibling of the given element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @returns {ChildNode|null} The next sibling or null if none found.
     */
  }, {
    key: "next",
    value:
    /**
     * Returns the next sibling of the given element.
     *
     * @returns {ChildNode|null} The next sibling or null if none found.
     */
    function next() {
      return TinyHtml.next(this);
    }
    /**
     * Returns the previous sibling of the given element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @returns {ChildNode|null} The previous sibling or null if none found.
     */
  }, {
    key: "prev",
    value:
    /**
     * Returns the previous sibling of the given element.
     *
     * @returns {ChildNode|null} The previous sibling or null if none found.
     */
    function prev() {
      return TinyHtml.prev(this);
    }
    /**
     * Returns all next sibling nodes after the given element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @returns {ChildNode[]} An array of next sibling nodes.
     */
  }, {
    key: "nextAll",
    value:
    /**
     * Returns all next sibling nodes after the given element.
     *
     * @returns {ChildNode[]} An array of next sibling nodes.
     */
    function nextAll() {
      return TinyHtml.nextAll(this);
    }
    /**
     * Returns all previous sibling nodes before the given element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @returns {ChildNode[]} An array of previous sibling nodes.
     */
  }, {
    key: "prevAll",
    value:
    /**
     * Returns all previous sibling nodes before the given element.
     *
     * @returns {ChildNode[]} An array of previous sibling nodes.
     */
    function prevAll() {
      return TinyHtml.prevAll(this);
    }
    /**
     * Returns all next sibling nodes up to (but not including) the node matched by a selector or element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of next sibling nodes.
     */
  }, {
    key: "nextUntil",
    value:
    /**
     * Returns all next sibling nodes up to (but not including) the node matched by a selector or element.
     *
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of next sibling nodes.
     */
    function nextUntil(until) {
      return TinyHtml.nextUntil(this, until);
    }
    /**
     * Returns all previous sibling nodes up to (but not including) the node matched by a selector or element.
     *
     * @param {TinyNode} el - The DOM node to start from.
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of previous sibling nodes.
     */
  }, {
    key: "prevUntil",
    value:
    /**
     * Returns all previous sibling nodes up to (but not including) the node matched by a selector or element.
     *
     * @param {TinyNode|string} [until] - A node or selector to stop before.
     * @returns {ChildNode[]} An array of previous sibling nodes.
     */
    function prevUntil(until) {
      return TinyHtml.prevUntil(this, until);
    }
    /**
     * Returns all sibling nodes of the given element, excluding itself.
     *
     * @param {TinyNode} el - The DOM node to find siblings of.
     * @returns {ChildNode[]} An array of sibling nodes.
     */
  }, {
    key: "siblings",
    value:
    /**
     * Returns all sibling nodes of the given element, excluding itself.
     *
     * @returns {ChildNode[]} An array of sibling nodes.
     */
    function siblings() {
      return TinyHtml.siblings(this);
    }
    /**
     * Returns all child nodes of the given element.
     *
     * @param {TinyNode} el - The DOM node to get children from.
     * @returns {ChildNode[]} An array of child nodes.
     */
  }, {
    key: "children",
    value:
    /**
     * Returns all child nodes of the given element.
     *
     * @returns {ChildNode[]} An array of child nodes.
     */
    function children() {
      return TinyHtml.children(this);
    }
    /**
     * Returns the contents of the given node. For `<template>` it returns its content; for `<iframe>`, the document.
     *
     * @param {TinyNode} el - The DOM node to get contents from.
     * @returns {(ChildNode|DocumentFragment)[]|Document[]} An array of child nodes or the content document of an iframe.
     */
  }, {
    key: "contents",
    value:
    /**
     * Returns the contents of the given node. For `<template>` it returns its content; for `<iframe>`, the document.
     *
     * @returns {(ChildNode|DocumentFragment)[]|Document[]} An array of child nodes or the content document of an iframe.
     */
    function contents() {
      return TinyHtml.contents(this);
    }
    /**
     * Clone each element.
     * @param {TinyNode|TinyNode[]} el
     * @param {boolean} [deep=true]
     * @returns {Node[]}
     */
  }, {
    key: "clone",
    value:
    /**
     * Clone the element.
     * @param {boolean} [deep=true]
     * @returns {Node}
     */
    function clone(deep) {
      return TinyHtml.clone(this, deep)[0];
    }
    /**
     * Normalize and validate nodes before DOM insertion.
     * Converts TinyNode-like structures or strings into DOM-compatible nodes.
     * @type {(where: string, ...nodes: (TinyNode | TinyNode[] | string)[]) => (Node | string)[]}
     * @readonly
     */
  }, {
    key: "append",
    value:
    /**
     * Appends child elements or strings to the end of the target element(s).
     *
     * @param {...(TinyNode | TinyNode[] | string)} children - The child elements or text to append.
     * @returns {TinyElement}
     */
    function append() {
      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
        children[_key] = arguments[_key];
      }
      return TinyHtml.append.apply(TinyHtml, [this].concat(children));
    }
    /**
     * Prepends child elements or strings to the beginning of the target element(s).
     *
     * @param {TinyElement} el - The target element(s) to receive children.
     * @param {...(TinyNode | TinyNode[] | string)} children - The child elements or text to prepend.
     * @returns {TinyElement}
     */
  }, {
    key: "prepend",
    value:
    /**
     * Prepends child elements or strings to the beginning of the target element(s).
     *
     * @param {...(TinyNode | TinyNode[] | string)} children - The child elements or text to prepend.
     * @returns {TinyElement}
     */
    function prepend() {
      for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        children[_key2] = arguments[_key2];
      }
      return TinyHtml.prepend.apply(TinyHtml, [this].concat(children));
    }
    /**
     * Inserts elements or strings immediately before the target element(s) in the DOM.
     *
     * @param {TinyElement} el - The target element(s) before which new content is inserted.
     * @param {...(TinyNode | TinyNode[] | string)} children - Elements or text to insert before the target.
     * @returns {TinyElement}
     */
  }, {
    key: "before",
    value:
    /**
     * Inserts elements or strings immediately before the target element(s) in the DOM.
     *
     * @param {...(TinyNode | TinyNode[] | string)} children - Elements or text to insert before the target.
     * @returns {TinyElement}
     */
    function before() {
      for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        children[_key3] = arguments[_key3];
      }
      return TinyHtml.before.apply(TinyHtml, [this].concat(children));
    }
    /**
     * Inserts elements or strings immediately after the target element(s) in the DOM.
     *
     * @param {TinyElement} el - The target element(s) after which new content is inserted.
     * @param {...(TinyNode | TinyNode[] | string)} children - Elements or text to insert after the target.
     * @returns {TinyElement}
     */
  }, {
    key: "after",
    value:
    /**
     * Inserts elements or strings immediately after the target element(s) in the DOM.
     *
     * @param {...(TinyNode | TinyNode[] | string)} children - Elements or text to insert after the target.
     * @returns {TinyElement}
     */
    function after() {
      for (var _len4 = arguments.length, children = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        children[_key4] = arguments[_key4];
      }
      return TinyHtml.after.apply(TinyHtml, [this].concat(children));
    }
    /**
     * Replaces the target element(s) in the DOM with new elements or text.
     *
     * @param {TinyElement} el - The element(s) to be replaced.
     * @param {...(TinyNode | TinyNode[] | string)} newNodes - New elements or text to replace the target.
     * @returns {TinyElement}
     */
  }, {
    key: "replaceWith",
    value:
    /**
     * Replaces the target element(s) in the DOM with new elements or text.
     *
     * @param {...(TinyNode | TinyNode[] | string)} newNodes - New elements or text to replace the target.
     * @returns {TinyElement}
     */
    function replaceWith() {
      for (var _len5 = arguments.length, newNodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        newNodes[_key5] = arguments[_key5];
      }
      return TinyHtml.replaceWith.apply(TinyHtml, [this].concat(newNodes));
    }
    /**
     * Appends the given element(s) to each target element in sequence.
     *
     * @param {TinyNode | TinyNode[]} el - The element(s) to append.
     * @param {TinyNode | TinyNode[]} targets - Target element(s) where content will be appended.
     * @returns {TinyNode|TinyNode[]}
     */
  }, {
    key: "appendTo",
    value:
    /**
     * Appends the given element(s) to each target element in sequence.
     *
     * @param {TinyNode | TinyNode[]} targets - Target element(s) where content will be appended.
     * @returns {TinyNode|TinyNode[]}
     */
    function appendTo(targets) {
      return TinyHtml.appendTo(this, targets);
    }
    /**
     * Prepends the given element(s) to each target element in sequence.
     *
     * @param {TinyElement | TinyElement[]} el - The element(s) to prepend.
     * @param {TinyElement | TinyElement[]} targets - Target element(s) where content will be prepended.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "prependTo",
    value:
    /**
     * Prepends the given element(s) to each target element in sequence.
     *
     * @param {TinyElement | TinyElement[]} targets - Target element(s) where content will be prepended.
     * @returns {TinyElement|TinyElement[]}
     */
    function prependTo(targets) {
      return TinyHtml.prependTo(this, targets);
    }
    /**
     * Inserts the element before a child of a given target, or before the target itself.
     *
     * @param {TinyNode | TinyNode[]} el - The element(s) to insert.
     * @param {TinyNode | TinyNode[]} target - The reference element where insertion happens.
     * @param {TinyNode | TinyNode[] | null} [child=null] - Optional child to insert before, defaults to target.
     * @returns {TinyNode|TinyNode[]}
     */
  }, {
    key: "insertBefore",
    value:
    /**
     * Inserts the element before a child of a given target, or before the target itself.
     *
     * @param {TinyNode | TinyNode[]} target - The reference element where insertion happens.
     * @param {TinyNode | TinyNode[] | null} [child=null] - Optional child to insert before, defaults to target.
     * @returns {TinyNode|TinyNode[]}
     */
    function insertBefore(target, child) {
      return TinyHtml.insertBefore(this, target, child);
    }
    /**
     * Inserts the element after a child of a given target, or after the target itself.
     *
     * @param {TinyNode | TinyNode[]} el - The element(s) to insert.
     * @param {TinyNode | TinyNode[]} target - The reference element where insertion happens.
     * @param {TinyNode | TinyNode[] | null} [child=null] - Optional child to insert after, defaults to target.
     * @returns {TinyNode|TinyNode[]}
     */
  }, {
    key: "insertAfter",
    value:
    /**
     * Inserts the element after a child of a given target, or after the target itself.
     *
     * @param {TinyNode | TinyNode[]} target - The reference element where insertion happens.
     * @param {TinyNode | TinyNode[] | null} [child=null] - Optional child to insert after, defaults to target.
     * @returns {TinyNode|TinyNode[]}
     */
    function insertAfter(target, child) {
      return TinyHtml.insertAfter(this, target, child);
    }
    /**
     * Replaces all target elements with the provided element(s).
     * If multiple targets exist, the inserted elements are cloned accordingly.
     *
     * @param {TinyNode | TinyNode[]} el - The new element(s) to insert.
     * @param {TinyNode | TinyNode[]} targets - The elements to be replaced.
     * @returns {TinyNode|TinyNode[]}
     */
  }, {
    key: "replaceAll",
    value:
    /**
     * Replaces all target elements with the provided element(s).
     * If multiple targets exist, the inserted elements are cloned accordingly.
     *
     * @param {TinyNode | TinyNode[]} targets - The elements to be replaced.
     * @returns {TinyNode|TinyNode[]}
     */
    function replaceAll(targets) {
      return TinyHtml.replaceAll(this, targets);
    }
  }, {
    key: "css",
    value:
    /**
     * Returns the full computed CSS styles for the given element.
     *
     * @returns {CSSStyleDeclaration} The computed style object for the element.
     */
    function css() {
      return TinyHtml.css(this);
    }
    /**
     * Returns the value of a specific computed CSS property from the given element as a string.
     *
     * @param {TinyElement} el - The element to retrieve the style property from.
     * @param {string} prop - The name of the CSS property (camelCase or kebab-case).
     * @returns {string|null} The value of the CSS property as a string, or null if not found or invalid.
     */
  }, {
    key: "cssString",
    value:
    /**
     * Returns the value of a specific computed CSS property from the given element as a string.
     *
     * @param {string} prop - The name of the CSS property (camelCase or kebab-case).
     * @returns {string|null} The value of the CSS property as a string, or null if not found or invalid.
     */
    function cssString(prop) {
      return TinyHtml.cssString(this, prop);
    }
    /**
     * Returns a subset of computed CSS styles based on the given list of properties.
     *
     * @param {TinyElement} el - The element to retrieve styles from.
     * @param {string[]} prop - An array of CSS property names to retrieve.
     * @returns {Partial<CSSStyleDeclaration>} An object containing the requested styles.
     */
  }, {
    key: "cssList",
    value:
    /**
     * Returns a subset of computed CSS styles based on the given list of properties.
     *
     * @param {string[]} prop - An array of CSS property names to retrieve.
     * @returns {Partial<CSSStyleDeclaration>} An object containing the requested styles.
     */
    function cssList(prop) {
      return TinyHtml.cssList(this, prop);
    }
    /**
     * Returns the computed CSS float value of a property.
     * @param {TinyElement} el - The element to inspect.
     * @param {string} prop - The CSS property.
     * @returns {number} - The parsed float value.
     */
  }, {
    key: "cssFloat",
    value:
    /**
     * Returns the computed CSS float value of a property.
     * @param {string} prop - The CSS property.
     * @returns {number} - The parsed float value.
     */
    function cssFloat(prop) {
      return TinyHtml.cssFloat(this, prop);
    }
    /**
     * Returns computed float values of multiple CSS properties.
     * @param {TinyElement} el - The element to inspect.
     * @param {string[]} prop - An array of CSS properties.
     * @returns {Record<string, number>} - Map of property to float value.
     */
  }, {
    key: "cssFloats",
    value:
    /**
     * Returns computed float values of multiple CSS properties.
     * @param {string[]} prop - An array of CSS properties.
     * @returns {Record<string, number>} - Map of property to float value.
     */
    function cssFloats(prop) {
      return TinyHtml.cssFloats(this, prop);
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Stores camelCase to kebab-case CSS property aliases.
     *
     * Used to normalize property names when interacting with `element.style` or `getComputedStyle`.
     *
     * ⚠️ This object should not be modified directly. Use `TinyHtml.cssPropAliases` instead to ensure reverse mappings stay in sync.
     *
     * Example of how to add a new alias:
     *
     * ```js
     * TinyHtml.cssPropAliases.tinyPudding = 'tiny-pudding';
     * ```
     *
     * This will automatically update `TinyHtml.cssPropRevAliases['tiny-pudding']` with `'tinyPudding'`.
     *
     * @type {Record<string | symbol, string>}
     */
  }, {
    key: "setStyle",
    value:
    /**
     * Sets one or more CSS inline style properties on the given element(s).
     *
     * - If `prop` is a string, the `value` will be applied to that property.
     * - If `prop` is an object, each key-value pair will be applied as a CSS property and value.
     *
     * @param {string|Object} prop - The property name or an object with key-value pairs
     * @param {string|null} [value=null] - The value to set (if `prop` is a string)
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
    function setStyle(prop, value) {
      return TinyHtml.setStyle(this, prop, value);
    }
    /**
     * Gets the value of a specific inline style property.
     *
     * Returns only the value set directly via the `style` attribute.
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - A single element to inspect.
     * @param {string} prop - The style property name to retrieve.
     * @returns {string} The style value of the specified property.
     */
  }, {
    key: "getStyle",
    value:
    /**
     * Gets the value of a specific inline style property.
     *
     * Returns only the value set directly via the `style` attribute.
     *
     * @param {string} prop - The style property name to retrieve.
     * @returns {string} The style value of the specified property.
     */
    function getStyle(prop) {
      return TinyHtml.getStyle(this, prop);
    }
    /**
     * Gets all inline styles defined directly on the element (`style` attribute).
     *
     * Returns an object with all property-value pairs in kebab-case format.
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - A single element to inspect.
     * @param {Object} [settings={}] - Optional configuration settings.
     * @param {boolean} [settings.camelCase=false] - If `true`, the property names will be converted to camelCase.
     * @param {boolean} [settings.rawAttr=false] - If `true`, reads the style string from the `style` attribute instead of using the style object.
     * @returns {Record<string, string>} All inline styles as an object.
     *
     * @throws {TypeError} If `camelCase` or `rawAttr` is not a boolean.
     */
  }, {
    key: "style",
    value:
    /**
     * Gets all inline styles defined directly on the element (`style` attribute).
     *
     * Returns an object with all property-value pairs in kebab-case format.
     *
     * @param {Object} [settings={}] - Optional configuration settings.
     * @param {boolean} [settings.camelCase=false] - If `true`, the property names will be converted to camelCase.
     * @param {boolean} [settings.rawAttr=false] - If `true`, reads the style string from the `style` attribute instead of using the style object.
     * @returns {Record<string, string>} All inline styles as an object.
     */
    function style(settings) {
      return TinyHtml.style(this, settings);
    }
    /**
     * Removes one or more inline CSS properties from the given element(s).
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - A single element or an array of elements.
     * @param {string|string[]} prop - A property name or an array of property names to remove.
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
  }, {
    key: "removeStyle",
    value:
    /**
     * Removes one or more inline CSS properties from the given element(s).
     *
     * @param {string|string[]} prop - A property name or an array of property names to remove.
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
    function removeStyle(prop) {
      return TinyHtml.removeStyle(this, prop);
    }
    /**
     * Toggles a CSS property value between two given values.
     *
     * The current computed value is compared to `val1`. If it matches, the property is set to `val2`. Otherwise, it is set to `val1`.
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - A single element or an array of elements.
     * @param {string} prop - The CSS property to toggle.
     * @param {string} val1 - The first value (used as "current" check).
     * @param {string} val2 - The second value (used as the "alternative").
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
  }, {
    key: "toggleStyle",
    value:
    /**
     * Toggles a CSS property value between two given values.
     *
     * The current computed value is compared to `val1`. If it matches, the property is set to `val2`. Otherwise, it is set to `val1`.
     *
     * @param {string} prop - The CSS property to toggle.
     * @param {string} val1 - The first value (used as "current" check).
     * @param {string} val2 - The second value (used as the "alternative").
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
    function toggleStyle(prop, val1, val2) {
      return TinyHtml.toggleStyle(this, prop, val1, val2);
    }
    /**
     * Removes all inline styles (`style` attribute) from the given element(s).
     *
     * @param {TinyElement|TinyElement[]} el - A single element or an array of elements.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "clearStyle",
    value:
    /**
     * Removes all inline styles (`style` attribute) from the given element(s).
     * @returns {TinyElement|TinyElement[]}
     */
    function clearStyle() {
      return TinyHtml.clearStyle(this);
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Focus the element.
     *
     * @param {TinyHtmlElement} el - The element or a selector string.
     * @returns {TinyHtmlElement}
     */
  }, {
    key: "focus",
    value:
    /**
     * Focus the element.
     * @returns {TinyHtmlElement}
     */
    function focus() {
      return TinyHtml.focus(this);
    }
    /**
     * Blur the element.
     *
     * @param {TinyHtmlElement} el - The element or a selector string.
     * @returns {TinyHtmlElement}
     */
  }, {
    key: "blur",
    value:
    /**
     * Blur the element.
     * @returns {TinyHtmlElement}
     */
    function blur() {
      return TinyHtml.blur(this);
    }
    /**
     * Interprets a value as a boolean `true` if it matches a common truthy representation.
     *
     * This method checks if the input is any of the common forms used to represent `true`,
     * such as the string `'true'`, `'1'`, `'on'`, the boolean `true`, or the number `1`.
     *
     * @param {string|boolean|number} [value] - The value to interpret as boolean.
     * @returns {boolean} `true` if the value represents a truthy state, otherwise `false`.
     */
  }, {
    key: "getDimension",
    value:
    /**
     * Gets the width or height of an element based on the box model.
     * @param {"width"|"height"} type - Dimension type.
     * @param {"content"|"padding"|"border"|"margin"} extra - Box model context.
     * @returns {number} - Computed dimension.
     */
    function getDimension(type, extra) {
      return TinyHtml.getDimension(this, type, extra);
    }
    /**
     * Sets the height of the element.
     * @param {TinyHtmlElement} el - Target element.
     * @param {string|number} value - Height value.
     * @throws {TypeError} If `value` is neither a string nor number.
     * @returns {TinyHtmlElement}
     */
  }, {
    key: "setHeight",
    value:
    /**
     * Sets the height of the element.
     * @param {string|number} value - Height value.
     * @returns {TinyHtmlElement}
     */
    function setHeight(value) {
      return TinyHtml.setHeight(this, value);
    }
    /**
     * Sets the width of the element.
     * @param {TinyHtmlElement} el - Target element.
     * @param {string|number} value - Width value.
     * @throws {TypeError} If `value` is neither a string nor number.
     * @returns {TinyHtmlElement}
     */
  }, {
    key: "setWidth",
    value:
    /**
     * Sets the width of the element.
     * @param {string|number} value - Width value.
     * @returns {TinyHtmlElement}
     */
    function setWidth(value) {
      return TinyHtml.setWidth(this, value);
    }
    /**
     * Returns content box height.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @returns {number}
     */
  }, {
    key: "height",
    value:
    /**
     * Returns content box height.
     * @returns {number}
     */
    function height() {
      return TinyHtml.height(this);
    }
    /**
     * Returns content box width.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @returns {number}
     */
  }, {
    key: "width",
    value:
    /**
     * Returns content box width.
     * @returns {number}
     */
    function width() {
      return TinyHtml.width(this);
    }
    /**
     * Returns padding box height.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @returns {number}
     */
  }, {
    key: "innerHeight",
    value:
    /**
     * Returns padding box height.
     * @returns {number}
     */
    function innerHeight() {
      return TinyHtml.innerHeight(this);
    }
    /**
     * Returns padding box width.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @returns {number}
     */
  }, {
    key: "innerWidth",
    value:
    /**
     * Returns padding box width.
     * @returns {number}
     */
    function innerWidth() {
      return TinyHtml.innerWidth(this);
    }
    /**
     * Returns outer height of the element, optionally including margin.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @param {boolean} [includeMargin=false] - Whether to include margin.
     * @returns {number}
     */
  }, {
    key: "outerHeight",
    value:
    /**
     * Returns outer height of the element, optionally including margin.
     * @param {boolean} [includeMargin=false] - Whether to include margin.
     * @returns {number}
     */
    function outerHeight(includeMargin) {
      return TinyHtml.outerHeight(this, includeMargin);
    }
    /**
     * Returns outer width of the element, optionally including margin.
     * @param {TinyElementAndWinAndDoc} el - Target element.
     * @param {boolean} [includeMargin=false] - Whether to include margin.
     * @returns {number}
     */
  }, {
    key: "outerWidth",
    value:
    /**
     * Returns outer width of the element, optionally including margin.
     * @param {boolean} [includeMargin=false] - Whether to include margin.
     * @returns {number}
     */
    function outerWidth(includeMargin) {
      return TinyHtml.outerWidth(this, includeMargin);
    }
    //////////////////////////////////////////////////
    /**
     * Applies an animation to one or multiple TinyElement instances.
     *
     * @param {TinyElement|TinyElement[]} el - A single TinyElement or an array of TinyElements to animate.
     * @param {Keyframe[] | PropertyIndexedKeyframes | null} keyframes - The keyframes used to define the animation.
     * @param {number | KeyframeAnimationOptions} [ops] - Timing or configuration options for the animation.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "animate",
    value:
    /**
     * Applies an animation to one or multiple TinyElement instances.
     *
     * @param {Keyframe[] | PropertyIndexedKeyframes | null} keyframes - The keyframes used to define the animation.
     * @param {number | KeyframeAnimationOptions} [ops] - Timing or configuration options for the animation.
     * @returns {TinyElement|TinyElement[]}
     */
    function animate(keyframes, ops) {
      return TinyHtml.animate(this, keyframes, ops);
    }
    /**
     * Gets the offset of the element relative to the document.
     * @param {TinyElement} el - Target element.
     * @returns {{top: number, left: number}}
     */
  }, {
    key: "offset",
    value:
    /**
     * Gets the offset of the element relative to the document.
     * @returns {{top: number, left: number}}
     */
    function offset() {
      return TinyHtml.offset(this);
    }
    /**
     * Gets the position of the element relative to its offset parent.
     * @param {TinyHtmlElement} el - Target element.
     * @returns {{top: number, left: number}}
     */
  }, {
    key: "position",
    value:
    /**
     * Gets the position of the element relative to its offset parent.
     * @returns {{top: number, left: number}}
     */
    function position() {
      return TinyHtml.position(this);
    }
    /**
     * Gets the closest positioned ancestor element.
     * @param {TinyHtmlElement} el - Target element.
     * @returns {HTMLElement} - Offset parent element.
     */
  }, {
    key: "offsetParent",
    value:
    /**
     * Gets the closest positioned ancestor element.
     * @returns {HTMLElement} - Offset parent element.
     */
    function offsetParent() {
      return TinyHtml.offsetParent(this);
    }
    /**
     * Gets the vertical scroll position.
     * @param {TinyElementAndWindow} el - Element or window.
     * @returns {number}
     */
  }, {
    key: "scrollTop",
    value:
    /**
     * Gets the vertical scroll position.
     * @returns {number}
     */
    function scrollTop() {
      return TinyHtml.scrollTop(this);
    }
    /**
     * Gets the horizontal scroll position.
     * @param {TinyElementAndWindow} el - Element or window.
     * @returns {number}
     */
  }, {
    key: "scrollLeft",
    value:
    /**
     * Gets the horizontal scroll position.
     * @returns {number}
     */
    function scrollLeft() {
      return TinyHtml.scrollLeft(this);
    }
    /**
     * Collection of easing functions used for scroll and animation calculations.
     * Each function receives a normalized time value (`t` from 0 to 1) and returns the eased progress.
     *
     * @type {Record<string, (t: number) => number>}
     */
  }, {
    key: "scrollToXY",
    value:
    /**
     * Smoothly scrolls one or more elements (or the window) to the specified X and Y coordinates
     * using a custom duration and easing function.
     *
     * If `duration` or a valid `easing` is not provided, the scroll will be performed immediately.
     *
     * @param {Object} [settings={}] - Configuration object for the scroll animation.
     * @param {number} [settings.targetX] - The horizontal scroll target in pixels.
     * @param {number} [settings.targetY] - The vertical scroll target in pixels.
     * @param {number} [settings.duration] - The duration of the animation in milliseconds.
     * @param {Easings} [settings.easing] - The easing function name to use for the scroll animation.
     * @param {OnScrollAnimation} [settings.onAnimation] - Optional callback invoked on each animation
     *   frame with the current scroll position, normalized animation time (`0` to `1`), and a completion flag.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
    function scrollToXY() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        targetX = _ref.targetX,
        targetY = _ref.targetY,
        duration = _ref.duration,
        easing = _ref.easing,
        onAnimation = _ref.onAnimation;
      return TinyHtml.scrollToXY(this, {
        targetX: targetX,
        targetY: targetY,
        duration: duration,
        easing: easing,
        onAnimation: onAnimation
      });
    }
    /**
     * Sets the vertical scroll position.
     * @param {TinyElementAndWindow|TinyElementAndWindow[]} el - Element or window.
     * @param {number} value - Scroll top value.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
  }, {
    key: "setScrollTop",
    value:
    /**
     * Sets the vertical scroll position.
     * @param {number} value - Scroll top value.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
    function setScrollTop(value) {
      return TinyHtml.setScrollTop(this, value);
    }
    /**
     * Sets the horizontal scroll position.
     * @param {TinyElementAndWindow|TinyElementAndWindow[]} el - Element or window.
     * @param {number} value - Scroll left value.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
  }, {
    key: "setScrollLeft",
    value:
    /**
     * Sets the horizontal scroll position.
     * @param {number} value - Scroll left value.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     */
    function setScrollLeft(value) {
      return TinyHtml.setScrollLeft(this, value);
    }
    /**
     * Returns the total border width and individual sides from `border{Side}Width` CSS properties.
     *
     * @param {TinyElement} el - The target DOM element.
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border widths, and each side individually.
     */
  }, {
    key: "borderWidth",
    value:
    /**
     * Returns the total border width and individual sides from `border{Side}Width` CSS properties.
     *
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border widths, and each side individually.
     */
    function borderWidth() {
      return TinyHtml.borderWidth(this);
    }
    /**
     * Returns the total border size and individual sides from `border{Side}` CSS properties.
     *
     * @param {TinyElement} el - The target DOM element.
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border sizes, and each side individually.
     */
  }, {
    key: "border",
    value:
    /**
     * Returns the total border size and individual sides from `border{Side}` CSS properties.
     *
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) border sizes, and each side individually.
     */
    function border() {
      return TinyHtml.border(this);
    }
    /**
     * Returns the total margin and individual sides from `margin{Side}` CSS properties.
     *
     * @param {TinyElement} el - The target DOM element.
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) margins, and each side individually.
     */
  }, {
    key: "margin",
    value:
    /**
     * Returns the total margin and individual sides from `margin{Side}` CSS properties.
     *
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) margins, and each side individually.
     */
    function margin() {
      return TinyHtml.margin(this);
    }
    /**
     * Returns the total padding and individual sides from `padding{Side}` CSS properties.
     *
     * @param {TinyElement} el - The target DOM element.
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) paddings, and each side individually.
     */
  }, {
    key: "padding",
    value:
    /**
     * Returns the total padding and individual sides from `padding{Side}` CSS properties.
     *
     * @returns {HtmlElBoxSides} - Total horizontal (x) and vertical (y) paddings, and each side individually.
     */
    function padding() {
      return TinyHtml.padding(this);
    }
    /////////////////////////////////////////////
    /**
     * Adds one or more CSS class names to the element.
     * @type {(el: TinyElement|TinyElement[], ...tokens: string[]) => (TinyElement|TinyElement[])} - One or more class names to add.
     */
  }, {
    key: "addClass",
    value:
    /**
     * Adds one or more CSS class names to the element.
     * @type {(...tokens: string[]) => (TinyElement|TinyElement[])} - One or more class names to add.
     */
    function addClass() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return TinyHtml.addClass.apply(TinyHtml, [this].concat(args));
    }
    /**
     * Removes one or more CSS class names from the element.
     * @type {(el: TinyElement|TinyElement[], ...tokens: string[]) => (TinyElement|TinyElement[])} - One or more class names to remove.
     */
  }, {
    key: "removeClass",
    value:
    /**
     * Removes one or more CSS class names from the element.
     * @type {(...tokens: string[]) => (TinyElement|TinyElement[])} - One or more class names to remove.
     */
    function removeClass() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return TinyHtml.removeClass.apply(TinyHtml, [this].concat(args));
    }
    /**
     * Replaces an existing class name with a new one.
     * @param {TinyElement|TinyElement[]} el - Target element.
     * @param {string} token - The class name to be replaced.
     * @param {string} newToken - The new class name to apply.
     * @returns {boolean[]} Whether the replacement was successful.
     * @throws {TypeError} If either argument is not a string.
     */
  }, {
    key: "replaceClass",
    value:
    /**
     * Replaces an existing class name with a new one.
     * @param {string} token - The class name to be replaced.
     * @param {string} newToken - The new class name to apply.
     * @returns {boolean} Whether the replacement was successful.
     * @throws {TypeError} If either argument is not a string.
     */
    function replaceClass(token, newToken) {
      return TinyHtml.replaceClass(this, token, newToken)[0];
    }
    /**
     * Returns the class name at the specified index.
     * @param {TinyElement} el - Target element.
     * @param {number} index - The index of the class name.
     * @returns {string|null} The class name at the index or null if not found.
     * @throws {TypeError} If the index is not a number.
     */
  }, {
    key: "classItem",
    value:
    /**
     * Returns the class name at the specified index.
     * @param {number} index - The index of the class name.
     * @returns {string|null} The class name at the index or null if not found.
     * @throws {TypeError} If the index is not a number.
     */
    function classItem(index) {
      return TinyHtml.classItem(this, index);
    }
    /**
     * Toggles a class name on the element with an optional force boolean.
     * @param {TinyElement|TinyElement[]} el - Target element.
     * @param {string} token - The class name to toggle.
     * @param {boolean} [force] - If true, adds the class; if false, removes it.
     * @returns {boolean[]} Whether the class is present after the toggle.
     * @throws {TypeError} If token is not a string or force is not a boolean.
     */
  }, {
    key: "toggleClass",
    value:
    /**
     * Toggles a class name on the element with an optional force boolean.
     * @param {string} token - The class name to toggle.
     * @param {boolean} force - If true, adds the class; if false, removes it.
     * @returns {boolean} Whether the class is present after the toggle.
     * @throws {TypeError} If token is not a string or force is not a boolean.
     */
    function toggleClass(token, force) {
      return TinyHtml.toggleClass(this, token, force)[0];
    }
    /**
     * Checks if the element contains the given class name.
     * @param {TinyElement} el - Target element.
     * @param {string} token - The class name to check.
     * @returns {boolean} True if the class is present, false otherwise.
     * @throws {TypeError} If token is not a string.
     */
  }, {
    key: "hasClass",
    value:
    /**
     * Checks if the element contains the given class name.
     * @param {string} token - The class name to check.
     * @returns {boolean} True if the class is present, false otherwise.
     * @throws {TypeError} If token is not a string.
     */
    function hasClass(token) {
      return TinyHtml.hasClass(this, token);
    }
    /**
     * Returns the number of classes applied to the element.
     * @param {TinyElement} el - Target element.
     * @returns {number} The number of classes.
     */
  }, {
    key: "classLength",
    value:
    /**
     * Returns the number of classes applied to the element.
     * @returns {number} The number of classes.
     */
    function classLength() {
      return TinyHtml.classLength(this);
    }
    /**
     * Returns all class names as an array of strings.
     * @param {TinyElement} el - Target element.
     * @returns {string[]} An array of class names.
     */
  }, {
    key: "classList",
    value:
    /**
     * Returns all class names as an array of strings.
     * @returns {string[]} An array of class names.
     */
    function classList() {
      return TinyHtml.classList(this);
    }
    /////////////////////////////////////////
    /**
     * Returns the tag name of the element.
     * @param {TinyElement} el - Target element.
     * @returns {string} The tag name in uppercase.
     */
  }, {
    key: "tagName",
    value:
    /**
     * Returns the tag name of the element.
     * @returns {string} The tag name in uppercase.
     */
    function tagName() {
      return TinyHtml.tagName(this);
    }
    /**
     * Returns the ID of the element.
     * @param {TinyElement} el - Target element.
     * @returns {string} The element's ID.
     */
  }, {
    key: "id",
    value:
    /**
     * Returns the ID of the element.
     * @returns {string} The element's ID.
     */
    function id() {
      return TinyHtml.id(this);
    }
    /**
     * Returns the text content of the element.
     * @param {TinyElement} el - Target element.
     * @returns {string|null} The text content or null if none.
     */
  }, {
    key: "text",
    value:
    /**
     * Returns the text content of the element.
     * @returns {string|null} The text content or null if none.
     */
    function text() {
      return TinyHtml.text(this);
    }
    /**
     * Set text content of elements.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} value
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "setText",
    value:
    /**
     * Set text content of the element.
     * @param {string} value
     * @returns {TinyElement|TinyElement[]}
     */
    function setText(value) {
      return TinyHtml.setText(this, value);
    }
    /**
     * Remove all child nodes from each element.
     * @param {TinyElement|TinyElement[]} el
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "empty",
    value:
    /**
     * Remove all child nodes of the element.
     * @returns {TinyElement|TinyElement[]}
     */
    function empty() {
      return TinyHtml.empty(this);
    }
    /**
     * Get the innerHTML of the element.
     * @param {TinyElement} el
     * @param {GetHTMLOptions} [ops]
     * @returns {string}
     */
  }, {
    key: "html",
    value:
    /**
     * Get the innerHTML of the element.
     * @param {GetHTMLOptions} [ops]
     * @returns {string}
     */
    function html(ops) {
      return TinyHtml.html(this, ops);
    }
    /**
     * Set the innerHTML of each element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} value
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "setHtml",
    value:
    /**
     * Set the innerHTML of the element.
     * @param {string} value
     * @returns {TinyElement|TinyElement[]}
     */
    function setHtml(value) {
      return TinyHtml.setHtml(this, value);
    }
    /** @readonly */
  }, {
    key: "setVal",
    value:
    /**
     * Sets the value of the current HTML value element (input, select, textarea, etc.).
     * Accepts strings, numbers, booleans or arrays of these values, or a callback function that computes them.
     *
     * @param {SetValueList|((el: InputElement, val: SetValueList) => SetValueList)} value - The value to assign or a function that returns it.
     * @returns {TinyInputElement|TinyInputElement[]}
     * @throws {Error} If the computed value is not a valid string or boolean.
     */
    function setVal(value) {
      return TinyHtml.setVal(this, value);
    }
    /**
     * Maps value types to their corresponding getter functions.
     * Each function extracts a value of a specific type from a compatible HTMLInputElement.
     * @readonly
     */
  }, {
    key: "_val",
    value:
    /**
     * Retrieves the raw value from the HTML input element.
     * If a custom value hook exists, it will be used first.
     *
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @param {string} where - The context/method name using this validation.
     * @returns {any} The raw value retrieved from the element or hook.
     * @readonly
     */
    function _val(where, type) {
      return TinyHtml._val(this, where, type);
    }
    /**
     * Gets the value of the current HTML value element.
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {SetValueList} The normalized value, with carriage returns removed.
     */
  }, {
    key: "val",
    value:
    /**
     * Gets the value of the current HTML value element.
     *
     * @returns {SetValueList} The normalized value, with carriage returns removed.
     */
    function val() {
      return TinyHtml.val(this);
    }
    /**
     * Gets the text of the current HTML value element (for text).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {string} The text value.
     * @throws {Error} If the element is not a string value.
     */
  }, {
    key: "valTxt",
    value:
    /**
     * Gets the text of the current HTML value element (for text).
     *
     * @returns {string} The text value.
     * @throws {Error} If the element is not a string value.
     */
    function valTxt() {
      return TinyHtml.valTxt(this);
    }
    /**
     * Internal helper to get a value from an input expected to return an array.
     *
     * @param {TinyInputElement} el - Target element.
     * @param {string} where - The method name or context using this validation (for error reporting).
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @returns {SetValueBase[]} - The validated value as an array.
     * @throws {Error} If the returned value is not an array.
     * @readonly
     */
  }, {
    key: "_valArr",
    value:
    /**
     * Internal helper to get a value from an input expected to return an array.
     *
     * @param {string} where - The method name or context using this validation (for error reporting).
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @returns {SetValueBase[]} - The validated value as an array.
     * @throws {Error} If the returned value is not an array.
     * @readonly
     */
    function _valArr(where, type) {
      return TinyHtml._valArr(this, where, type);
    }
    /**
     * Gets the raw value as a generic array of the current HTML value element (for select).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {SetValueBase[]} - The value cast as a generic array.
     * @throws {Error} If the value is not a valid array.
     */
  }, {
    key: "valArr",
    value:
    /**
     * Gets the raw value as a generic array of the current HTML value element (for select).
     *
     * @returns {SetValueBase[]} - The value cast as a generic array.
     * @throws {Error} If the value is not a valid array.
     */
    function valArr() {
      return TinyHtml.valArr(this);
    }
    /**
     * Gets the current value parsed as a number (for number/text).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {number} The numeric value.
     * @throws {Error} If the element is not a number-compatible input or value is NaN.
     */
  }, {
    key: "valNb",
    value:
    /**
     * Gets the current value parsed as a number (for number/text).
     *
     * @returns {number} The numeric value.
     * @throws {Error} If the element is not a number-compatible input or value is NaN.
     */
    function valNb() {
      return TinyHtml.valNb(this);
    }
    /**
     * Gets the current value parsed as a Date (for time/date).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {Date} The date value.
     * @throws {Error} If the element is not a date-compatible input.
     */
  }, {
    key: "valDate",
    value:
    /**
     * Gets the current value parsed as a Date (for time/date).
     *
     * @returns {Date} The date value.
     * @throws {Error} If the element is not a date-compatible input.
     */
    function valDate() {
      return TinyHtml.valDate(this);
    }
    /**
     * Checks if the input element is boolean (for checkboxes/radios).
     *
     * @param {TinyInputElement} el - Target element.
     * @returns {boolean} True if the input is considered checked (value === "on"), false otherwise.
     * @throws {Error} If the element is not a checkbox/radio input.
     */
  }, {
    key: "valBool",
    value:
    /**
     * Checks if the input element is boolean (for checkboxes/radios).
     *
     * @returns {boolean} True if the input is considered checked (value === "on"), false otherwise.
     * @throws {Error} If the element is not a checkbox/radio input.
     */
    function valBool() {
      return TinyHtml.valBool(this);
    }
    ////////////////////////////////////////////
    /**
     * Registers a listener for the "paste" event to extract files and text from the clipboard (e.g., when the user presses Ctrl+V).
     *
     * This method allows reacting to pasted content by providing separate callbacks for files and plain text.
     * Useful for building file upload areas, rich-text editors, or input enhancements.
     *
     * @param {TinyElementWithDoc|TinyElementWithDoc[]} el - The target element(s) where the "paste" event will be listened.
     * @param {Object} [settings={}] - Optional callbacks to handle clipboard content.
     * @param {(data: DataTransferItem, file: File) => void} [settings.onFilePaste] - Called for each file pasted from the clipboard (e.g., images).
     * @param {(data: DataTransferItem, text: string) => void} [settings.onTextPaste] - Called when plain text is pasted from the clipboard.
     * @returns {EventListenerOrEventListenerObject} The internal "paste" event handler used.
     */
  }, {
    key: "listenForPaste",
    value:
    /**
     * Registers a listener for the "paste" event to extract files and text from the clipboard (e.g., when the user presses Ctrl+V).
     *
     * This method allows reacting to pasted content by providing separate callbacks for files and plain text.
     * Useful for building file upload areas, rich-text editors, or input enhancements.
     *
     * @param {Object} [settings={}] - Optional callbacks to handle clipboard content.
     * @param {(data: DataTransferItem, file: File) => void} [settings.onFilePaste] - Called for each file pasted from the clipboard (e.g., images).
     * @param {(data: DataTransferItem, text: string) => void} [settings.onTextPaste] - Called when plain text is pasted from the clipboard.
     * @returns {EventListenerOrEventListenerObject} The internal "paste" event handler used.
     */
    function listenForPaste() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        onFilePaste = _ref2.onFilePaste,
        onTextPaste = _ref2.onTextPaste;
      return TinyHtml.listenForPaste(this, {
        onFilePaste: onFilePaste,
        onTextPaste: onTextPaste
      });
    }
    /**
     * Checks if the element has a listener for a specific event.
     *
     * @param {TinyEventTarget} el - The element to check.
     * @param {string} event - The event name to check.
     * @returns {boolean}
     */
  }, {
    key: "hasEventListener",
    value:
    /**
     * Checks if the element has a listener for a specific event.
     *
     * @param {string} event - The event name to check.
     * @returns {boolean}
     */
    function hasEventListener(event) {
      return TinyHtml.hasEventListener(this, event);
    }
    /**
     * Checks if the element has the exact handler registered for a specific event.
     *
     * @param {TinyEventTarget} el - The element to check.
     * @param {string} event - The event name to check.
     * @param {EventListenerOrEventListenerObject} handler - The handler function to check.
     * @returns {boolean}
     */
  }, {
    key: "hasExactEventListener",
    value:
    /**
     * Checks if the element has the exact handler registered for a specific event.
     *
     * @param {string} event - The event name to check.
     * @param {EventListenerOrEventListenerObject} handler - The handler function to check.
     * @returns {boolean}
     */
    function hasExactEventListener(event, handler) {
      return TinyHtml.hasExactEventListener(this, event, handler);
    }
    /**
     * Registers an event listener on the specified element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target to listen on.
     * @param {string} event - The event type (e.g. 'click', 'keydown').
     * @param {EventListenerOrEventListenerObject|null} handler - The callback function to run on event.
     * @param {EventRegistryOptions} [options] - Optional event listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "on",
    value:
    /**
     * Registers an event listener on the specified element.
     *
     * @param {string} event - The event type (e.g. 'click', 'keydown').
     * @param {EventListenerOrEventListenerObject|null} handler - The callback function to run on event.
     * @param {EventRegistryOptions} [options] - Optional event listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function on(event, handler, options) {
      return TinyHtml.on(this, event, handler, options);
    }
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target to listen on.
     * @param {string} event - The event type (e.g. 'click', 'keydown').
     * @param {EventListenerOrEventListenerObject} handler - The callback function to run on event.
     * @param {EventRegistryOptions} [options={}] - Optional event listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "once",
    value:
    /**
     * Registers an event listener that runs only once, then is removed.
     *
     * @param {string} event - The event type (e.g. 'click', 'keydown').
     * @param {EventListenerOrEventListenerObject} handler - The callback function to run on event.
     * @param {EventRegistryOptions} [options={}] - Optional event listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function once(event, handler) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return TinyHtml.once(this, event, handler, options);
    }
    /**
     * Removes a specific event listener from an element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target element.
     * @param {string} event - The event type.
     * @param {EventListenerOrEventListenerObject|null} handler - The function originally bound to the event.
     * @param {boolean|EventListenerOptions} [options] - Optional listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "off",
    value:
    /**
     * Removes a specific event listener from an element.
     *
     * @param {string} event - The event type.
     * @param {EventListenerOrEventListenerObject|null} handler - The function originally bound to the event.
     * @param {boolean|EventListenerOptions} [options] - Optional listener options.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function off(event, handler, options) {
      return TinyHtml.off(this, event, handler, options);
    }
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target element.
     * @param {string} event - The event type to remove (e.g. 'click').
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "offAll",
    value:
    /**
     * Removes all event listeners of a specific type from the element.
     *
     * @param {string} event - The event type to remove (e.g. 'click').
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function offAll(event) {
      return TinyHtml.offAll(this, event);
    }
    /**
     * Removes all event listeners of all types from the element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - The target element.
     * @param {((handler: EventListenerOrEventListenerObject|null, event: string) => boolean)|null} [filterFn=null] -
     *        Optional filter function to selectively remove specific handlers.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "offAllTypes",
    value:
    /**
     * Removes all event listeners of all types from the element.
     *
     * @param {((handler: EventListenerOrEventListenerObject|null, event: string) => boolean)|null} [filterFn=null] -
     *        Optional filter function to selectively remove specific handlers.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function offAllTypes() {
      var filterFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return TinyHtml.offAllTypes(this, filterFn);
    }
    /**
     * Triggers all handlers associated with a specific event on the given element.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} el - Target element where the event should be triggered.
     * @param {string} event - Name of the event to trigger.
     * @param {Event|CustomEvent|CustomEventInit} [payload] - Optional event object or data to pass.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
  }, {
    key: "trigger",
    value:
    /**
     * Triggers all handlers associated with a specific event on the given element.
     *
     * @param {string} event - Name of the event to trigger.
     * @param {Event|CustomEvent|CustomEventInit} [payload] - Optional event object or data to pass.
     * @returns {TinyEventTarget|TinyEventTarget[]}
     */
    function trigger(event) {
      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return TinyHtml.trigger(this, event, payload);
    }
    ///////////////////////////////////////////////////////////////
    /**
     * Property name normalization similar to jQuery's propFix.
     * @readonly
     */
  }, {
    key: "attr",
    value:
    /**
     * Get an attribute on an element.
     * @param {string} name
     * @returns {string|null}
     */
    function attr(name) {
      return TinyHtml.attr(this, name);
    }
    /**
     * Set an attribute on an element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name
     * @param {string|null} [value=null]
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "setAttr",
    value:
    /**
     * Set an attribute on an element.
     * @param {string} name
     * @param {string|null} [value=null]
     * @returns {TinyElement|TinyElement[]}
     */
    function setAttr(name, value) {
      return TinyHtml.setAttr(this, name, value);
    }
    /**
     * Remove attribute(s) from an element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name Space-separated list of attributes.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "removeAttr",
    value:
    /**
     * Remove attribute(s) from an element.
     * @param {string} name Space-separated list of attributes.
     * @returns {TinyElement|TinyElement[]}
     */
    function removeAttr(name) {
      return TinyHtml.removeAttr(this, name);
    }
    /**
     * Check if an attribute exists on an element.
     * @param {TinyElement} el
     * @param {string} name
     * @returns {boolean}
     */
  }, {
    key: "hasAttr",
    value:
    /**
     * Check if an attribute exists on an element.
     * @param {string} name
     * @returns {boolean}
     */
    function hasAttr(name) {
      return TinyHtml.hasAttr(this, name);
    }
    /**
     * Check if a property exists.
     * @param {TinyElement} el
     * @param {string} name
     * @returns {boolean}
     */
  }, {
    key: "hasProp",
    value:
    /**
     * Check if a property exists.
     * @param {string} name
     * @returns {boolean}
     */
    function hasProp(name) {
      return TinyHtml.hasProp(this, name);
    }
    /**
     * Set a property on an element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "addProp",
    value:
    /**
     * Set a property on an element.
     * @param {string} name
     * @returns {TinyElement|TinyElement[]}
     */
    function addProp(name) {
      return TinyHtml.addProp(this, name);
    }
    /**
     * Remove a property from an element.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "removeProp",
    value:
    /**
     * Remove a property from an element.
     * @param {string} name
     * @returns {TinyElement|TinyElement[]}
     */
    function removeProp(name) {
      return TinyHtml.removeProp(this, name);
    }
    /**
     * Toggle a boolean property.
     * @param {TinyElement|TinyElement[]} el
     * @param {string} name
     * @param {boolean} [force]
     */
  }, {
    key: "toggleProp",
    value:
    /**
     * Toggle a boolean property.
     * @param {string} name
     * @param {boolean} [force]
     */
    function toggleProp(name, force) {
      return TinyHtml.toggleProp(this, name, force);
    }
    /////////////////////////////////////////////////////
    /**
     * Removes an element from the DOM.
     * @param {TinyElement|TinyElement[]} el - The DOM element or selector to remove.
     * @returns {TinyElement|TinyElement[]}
     */
  }, {
    key: "remove",
    value:
    /**
     * Removes the element from the DOM.
     * @returns {TinyElement|TinyElement[]}
     */
    function remove() {
      return TinyHtml.remove(this);
    }
    /**
     * Returns the index of the first element within its parent or relative to a selector/element.
     *
     * @param {TinyElement} el - The element target
     * @param {string|TinyElement|null} [el2] - Optional target to compare index against.
     * @returns {number}
     */
  }, {
    key: "index",
    value:
    /**
     * Returns the index of the first element within its parent or relative to a selector/element.
     *
     * @param {string|TinyElement|null} [elem] - Optional target to compare index against.
     * @returns {number}
     */
    function index(elem) {
      return TinyHtml.index(this, elem);
    }
    ////////////////////////////////////////////////////////////////////
    /**
     * Creates a new DOMRect object by copying the base rect and applying optional additional dimensions.
     *
     * @param {DOMRect} rect - The base rectangle to be cloned and extended.
     * @param {Partial<DOMRect>} extraRect - Additional dimensions to apply to the base rect (e.g., extra padding or offset).
     * @returns {DOMRect} - A new DOMRect object with the combined dimensions.
     * @readonly
     */
  }, {
    key: "isCollWith",
    value:
    /**
     * Determines if two HTML elements are colliding, using a simple bounding box comparison.
     *
     * @param {TinyElement} el2 - The second element to compare.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} - `true` if the elements are colliding, `false` otherwise.
     */
    function isCollWith(el2, extraRect) {
      return TinyHtml.isCollWith(this, el2, extraRect);
    }
    /**
     * Determines if two HTML elements are colliding using a pixel-perfect collision algorithm.
     *
     * @param {TinyElement} el1 - The first element to compare.
     * @param {TinyElement} el2 - The second element to compare.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} - `true` if the elements are colliding with higher precision, `false` otherwise.
     */
  }, {
    key: "isCollPerfWith",
    value:
    /**
     * Determines if two HTML elements are colliding using a pixel-perfect collision algorithm.
     *
     * @param {TinyElement} el2 - The second element to compare.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} - `true` if the elements are colliding with higher precision, `false` otherwise.
     */
    function isCollPerfWith(el2, extraRect) {
      return TinyHtml.isCollPerfWith(this, el2, extraRect);
    }
    /**
     * Determines whether two elements are colliding with a directional lock mechanism.
     *
     * This function tracks the direction from which an element (`elem1`) initially collided with another,
     * and keeps the collision "locked" until the element exits the collision from the same direction.
     *
     * - If `isColliding` is true and no lock is stored yet, it saves the direction of entry.
     * - If `isColliding` is false but a previous lock exists, it checks if the element has exited
     *   in the same direction it entered to remove the lock.
     *
     * @param {boolean} isColliding - Indicates whether `rect1` and `rect2` are currently colliding.
     * @param {DOMRect} rect1 - The bounding box of the first element.
     * @param {DOMRect} rect2 - The bounding box of the second element.
     * @param {Element} elem1 - The element to track collision state for.
     * @param {CollisionDirLock} lockDirection - The direction from which the collision was first detected.
     * @returns {boolean} Returns `true` if the element is still considered colliding (locked), otherwise `false`.
     * @readonly
     */
  }, {
    key: "isCollWithLock",
    value:
    /**
     * Checks if two DOM elements are colliding on the screen, and locks the collision
     * until the element exits through the same side it entered.
     *
     * @param {TinyElement} el2 - Second DOM element (e.g. a container or boundary element).
     * @param {CollisionDirLock} lockDirection - Direction that must be respected to unlock the collision.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} True if collision is still active.
     */
    function isCollWithLock(el2, lockDirection, extraRect) {
      return TinyHtml.isCollWithLock(this, el2, lockDirection, extraRect);
    }
    /**
     * Checks if two DOM elements are colliding on the screen, and locks the collision
     * until the element exits through the same side it entered.
     *
     * @param {TinyElement} el1 - First DOM element (e.g. draggable or moving element).
     * @param {TinyElement} el2 - Second DOM element (e.g. a container or boundary element).
     * @param {CollisionDirLock} lockDirection - Direction that must be respected to unlock the collision.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} True if collision is still active.
     */
  }, {
    key: "isCollPerfWithLock",
    value:
    /**
     * Checks if two DOM elements are colliding on the screen, and locks the collision
     * until the element exits through the same side it entered.
     *
     * @param {TinyElement} el2 - Second DOM element (e.g. a container or boundary element).
     * @param {CollisionDirLock} lockDirection - Direction that must be respected to unlock the collision.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} True if collision is still active.
     */
    function isCollPerfWithLock(el2, lockDirection, extraRect) {
      return TinyHtml.isCollPerfWithLock(this, el2, lockDirection, extraRect);
    }
    /**
     * Resets all collision locks for a specific element (for all directions).
     *
     * @param {TinyElement} el - The element whose locks should be removed.
     * @returns {boolean} True if at least one lock was removed.
     */
  }, {
    key: "resetCollLock",
    value:
    /**
     * Resets the collision lock for a specific element.
     *
     * This removes any previously stored collision direction for the given element,
     * effectively unlocking its collision state.
     *
     * @returns {boolean} Returns `true` if a lock was removed, `false` if no lock was present.
     */
    function resetCollLock() {
      return TinyHtml.resetCollLock(this);
    }
    /**
     * Resets the collision lock for a specific element and direction.
     *
     * @param {TinyElement} el - The element whose lock should be removed.
     * @param {CollisionDirLock} direction - The direction to clear the lock from.
     * @returns {boolean} True if the lock was removed.
     */
  }, {
    key: "resetCollLockDir",
    value:
    /**
     * Resets the collision lock for a specific element and direction.
     *
     * @param {CollisionDirLock} direction - The direction to clear the lock from.
     * @returns {boolean} True if the lock was removed.
     */
    function resetCollLockDir(direction) {
      return TinyHtml.resetCollLockDir(this, direction);
    }
    //////////////////////////////////////////////////////////////////////////////
    /**
     * Checks if the given element is at least partially visible in the viewport.
     *
     * @param {TinyElement} el - The DOM element to check.
     * @returns {boolean} True if the element is partially in the viewport, false otherwise.
     */
  }, {
    key: "isInViewport",
    value:
    /**
     * Checks if the given element is at least partially visible in the viewport.
     *
     * @returns {boolean} True if the element is partially in the viewport, false otherwise.
     */
    function isInViewport() {
      return TinyHtml.isInViewport(this);
    }
    /**
     * Checks if the given element is fully visible in the viewport (top and bottom).
     *
     * @param {TinyElement} el - The DOM element to check.
     * @returns {boolean} True if the element is fully visible in the viewport, false otherwise.
     */
  }, {
    key: "isScrolledIntoView",
    value:
    /**
     * Checks if the given element is fully visible in the viewport (top and bottom).
     *
     * @returns {boolean} True if the element is fully visible in the viewport, false otherwise.
     */
    function isScrolledIntoView() {
      return TinyHtml.isScrolledIntoView(this);
    }
    /**
     * Checks if the given element is at least partially visible within the boundaries of a container.
     *
     * @param {TinyElement} el - The DOM element to check.
     * @param {TinyElement} cont - The container element acting as the viewport.
     * @returns {boolean} True if the element is partially visible within the container, false otherwise.
     */
  }, {
    key: "isInContainer",
    value:
    /**
     * Checks if the given element is at least partially visible within the boundaries of a container.
     *
     * @param {TinyElement} cont - The container element acting as the viewport.
     * @returns {boolean} True if the element is partially visible within the container, false otherwise.
     */
    function isInContainer(cont) {
      return TinyHtml.isInContainer(this, cont);
    }
    /**
     * Checks if the given element is fully visible within the boundaries of a container (top and bottom).
     *
     * @param {TinyElement} el - The DOM element to check.
     * @param {TinyElement} cont - The container element acting as the viewport.
     * @returns {boolean} True if the element is fully visible within the container, false otherwise.
     */
  }, {
    key: "isFullyInContainer",
    value:
    /**
     * Checks if the given element is fully visible within the boundaries of a container (top and bottom).
     *
     * @param {TinyElement} cont - The container element acting as the viewport.
     * @returns {boolean} True if the element is fully visible within the container, false otherwise.
     */
    function isFullyInContainer(cont) {
      return TinyHtml.isFullyInContainer(this, cont);
    }
    /**
     * Checks if an element has scrollable content.
     *
     * @param {TinyElement} el - The DOM element to check.
     * @returns {{ v: boolean, h: boolean }} - True if scroll is needed in that direction.
     */
  }, {
    key: "hasScroll",
    value:
    /**
     * Checks if an element has scrollable content.
     *
     * @returns {{ v: boolean, h: boolean }} - True if scroll is needed in that direction.
     */
    function hasScroll() {
      return TinyHtml.hasScroll(this);
    }
  }], [{
    key: "createElement",
    value:
    /**
     * Creates a new DOM element with the specified tag name and options, then wraps it in a TinyHtml instance.
     *
     * @param {string} tagName - The tag name of the element to create (e.g., 'div', 'span').
     * @param {ElementCreationOptions} ops - Optional settings for creating the element.
     * @returns {TinyHtml} A TinyHtml instance wrapping the newly created DOM element.
     * @throws {TypeError} If tagName is not a string or ops is not an object.
     */
    function createElement(tagName, ops) {
      if (typeof tagName !== 'string') throw new TypeError("[TinyHtml] createElement(): The tagName must be a string.");
      if (typeof ops !== 'undefined' && _typeof(ops) !== 'object') throw new TypeError("[TinyHtml] createElement(): The ops must be a object.");
      return new TinyHtml(document.createElement(tagName, ops));
    }
    /**
     * Creates a new TinyHtml instance that wraps a DOM TextNode.
     *
     * This method is useful when you want to insert raw text content into the DOM
     * without it being interpreted as HTML. The returned instance behaves like any
     * other TinyHtml element and can be appended or manipulated as needed.
     *
     * @param {string} value - The plain text content to be wrapped in a TextNode.
     * @returns {TinyHtml} A TinyHtml instance wrapping the newly created DOM TextNode.
     * @throws {TypeError} If the provided value is not a string.
     */
  }, {
    key: "createTextNode",
    value: function createTextNode(value) {
      if (typeof value !== 'string') throw new TypeError("[TinyHtml] createTextNode(): The value must be a string.");
      return new TinyHtml(document.createTextNode(value));
    }
    /**
     * Creates an HTMLElement or TextNode from an HTML string.
     * Supports both elements and plain text.
     *
     * @param {string} htmlString - The HTML string to convert.
     * @returns {TinyHtml} - A single HTMLElement or TextNode.
     */
  }, {
    key: "createElementFromHTML",
    value: function createElementFromHTML(htmlString) {
      var template = document.createElement('template');
      htmlString = htmlString.trim();
      // If it's only text (e.g., no "<" tag), return a TextNode
      if (!htmlString.startsWith('<')) {
        return TinyHtml.createTextNode(htmlString);
      }
      template.innerHTML = htmlString;
      if (!(template.content.firstChild instanceof Element)) throw new Error('');
      return new TinyHtml(template.content.firstChild);
    }
    /**
     * Queries the document for the first element matching the CSS selector and wraps it in a TinyHtml instance.
     *
     * @param {string} selector - A valid CSS selector string.
     * @param {Document|Element} elem - Target element.
     * @returns {TinyHtml|null} A TinyHtml instance wrapping the matched element.
     */
  }, {
    key: "query",
    value: function query(selector) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      var newEl = elem.querySelector(selector);
      if (!newEl) return null;
      return new TinyHtml(newEl);
    }
  }, {
    key: "queryAll",
    value: function queryAll(selector) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      var newEls = elem.querySelectorAll(selector);
      return TinyHtml.toTinyElm(_toConsumableArray(newEls));
    }
  }, {
    key: "getById",
    value: function getById(selector) {
      var newEl = document.getElementById(selector);
      if (!newEl) return null;
      return new TinyHtml(newEl);
    }
    /**
     * Retrieves all elements with the specified class name and wraps them in TinyHtml instances.
     *
     * @param {string} selector - The class name to search for.
     * @param {Document|Element} elem - Target element.
     * @returns {TinyHtml[]} An array of TinyHtml instances wrapping the found elements.
     */
  }, {
    key: "getByClassName",
    value: function getByClassName(selector) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      var newEls = elem.getElementsByClassName(selector);
      return TinyHtml.toTinyElm(_toConsumableArray(newEls));
    }
  }, {
    key: "getByName",
    value: function getByName(selector) {
      var newEls = document.getElementsByName(selector);
      return TinyHtml.toTinyElm(_toConsumableArray(newEls));
    }
    /**
     * Retrieves all elements with the specified local tag name within the given namespace URI,
     * and wraps them in TinyHtml instances.
     *
     * @param {string} localName - The local name (tag) of the elements to search for.
     * @param {string|null} [namespaceURI='http://www.w3.org/1999/xhtml'] - The namespace URI to search within.
     * @param {Document|Element} elem - Target element.
     * @returns {TinyHtml[]} An array of TinyHtml instances wrapping the found elements.
     */
  }, {
    key: "getByTagNameNS",
    value: function getByTagNameNS(localName) {
      var namespaceURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http://www.w3.org/1999/xhtml';
      var elem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
      var newEls = elem.getElementsByTagNameNS(namespaceURI, localName);
      return TinyHtml.toTinyElm(_toConsumableArray(newEls));
    }
  }, {
    key: "_preElemsTemplate",
    value: function _preElemsTemplate(elems, where, TheTinyElements, elemName) {
      /** @param {(TinyElement|EventTarget|null)[]} item */
      var checkElement = function checkElement(item) {
        return item.map(function (elem) {
          var result = elem instanceof TinyHtml ? elem._getElement(where) : elem;
          var allowed = false;
          var _iterator = _createForOfIteratorHelper(TheTinyElements),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var TheTinyElement = _step.value;
              if (result instanceof TheTinyElement) {
                allowed = true;
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (!allowed) throw new Error("[TinyHtml] Invalid element of the list \"".concat(elemName.join(','), "\" in ").concat(where, "()."));
          return result;
        });
      };
      if (!Array.isArray(elems)) return checkElement([elems]);
      return checkElement(elems);
    }
    /**
     * @param {TinyElement|EventTarget|null|(TinyElement|EventTarget|null)[]} elems
     * @param {string} where
     * @param {any[]} TheTinyElements
     * @param {string[]} elemName
     * @param {boolean} [canNull=false]
     * @returns {any}
     * @readonly
     */
  }, {
    key: "_preElemTemplate",
    value: function _preElemTemplate(elems, where, TheTinyElements, elemName) {
      var canNull = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      /** @param {(TinyElement|EventTarget|null)[]} item */
      var checkElement = function checkElement(item) {
        var elem = item[0];
        var result = elem instanceof TinyHtml ? elem._getElement(where) : elem;
        var allowed = false;
        var _iterator2 = _createForOfIteratorHelper(TheTinyElements),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var TheTinyElement = _step2.value;
            if (result instanceof TheTinyElement) {
              allowed = true;
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (canNull && (result === null || typeof result === 'undefined')) {
          result = null;
          allowed = true;
        }
        if (!allowed) throw new Error("[TinyHtml] Invalid element of the list \"".concat(elemName.join(','), "\" in ").concat(where, "()."));
        return result;
      };
      if (!Array.isArray(elems)) return checkElement([elems]);
      if (elems.length > 1) throw new Error("[TinyHtml] Invalid element amount in ".concat(where, "() (Received ").concat(elems.length, "/1)."));
      return checkElement(elems);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single element or array of elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Element[]} - Always returns an array of elements.
     * @readonly
     */
  }, {
    key: "_preElems",
    value: function _preElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [Element], ['Element']);
    }
    /**
     * Ensures the input is returned as an single element.
     * Useful to normalize operations across multiple or single elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single element or array of elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Element} - Always returns an single element.
     * @readonly
     */
  }, {
    key: "_preElem",
    value: function _preElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Element], ['Element']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single nodes.
     *
     * @param {TinyNode|TinyNode[]} elems - A single node or array of nodes.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Node[]} - Always returns an array of nodes.
     * @readonly
     */
  }, {
    key: "_preNodeElems",
    value: function _preNodeElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [Node], ['Node']);
    }
    /**
     * Ensures the input is returned as an single node.
     * Useful to normalize operations across multiple or single nodes.
     *
     * @param {TinyNode|TinyNode[]} elems - A single node or array of nodes.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Node} - Always returns an single node.
     * @readonly
     */
  }, {
    key: "_preNodeElem",
    value: function _preNodeElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Node], ['Node']);
    }
    /**
     * Ensures the input is returned as an single node.
     * Useful to normalize operations across multiple or single nodes.
     *
     * @param {TinyNode|TinyNode[]} elems - A single node or array of nodes.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {Node|null} - Always returns an single node or null.
     * @readonly
     */
  }, {
    key: "_preNodeElemWithNull",
    value: function _preNodeElemWithNull(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Node], ['Node'], true);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single html elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single html element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {HTMLElement[]} - Always returns an array of html elements.
     * @readonly
     */
  }, {
    key: "_preHtmlElems",
    value: function _preHtmlElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [HTMLElement], ['HTMLElement']);
    }
    /**
     * Ensures the input is returned as an single html element.
     * Useful to normalize operations across multiple or single html elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single html element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {HTMLElement} - Always returns an single html element.
     * @readonly
     */
  }, {
    key: "_preHtmlElem",
    value: function _preHtmlElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [HTMLElement], ['HTMLElement']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single event target elements.
     *
     * @param {TinyInputElement|TinyInputElement[]} elems - A single event target element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {InputElement[]} - Always returns an array of event target elements.
     * @readonly
     */
  }, {
    key: "_preInputElems",
    value: function _preInputElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLOptionElement], ['HTMLInputElement', 'HTMLSelectElement', 'HTMLTextAreaElement', 'HTMLOptionElement']);
    }
    /**
     * Ensures the input is returned as an single event target element.
     * Useful to normalize operations across multiple or single event target elements.
     *
     * @param {TinyInputElement|TinyInputElement[]} elems - A single event target element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {InputElement} - Always returns an single event target element.
     * @readonly
     */
  }, {
    key: "_preInputElem",
    value: function _preInputElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLOptionElement], ['HTMLInputElement', 'HTMLSelectElement', 'HTMLTextAreaElement', 'HTMLOptionElement']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single event target elements.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} elems - A single event target element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {EventTarget[]} - Always returns an array of event target elements.
     * @readonly
     */
  }, {
    key: "_preEventTargetElems",
    value: function _preEventTargetElems(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [EventTarget], ['EventTarget']);
    }
    /**
     * Ensures the input is returned as an single event target element.
     * Useful to normalize operations across multiple or single event target elements.
     *
     * @param {TinyEventTarget|TinyEventTarget[]} elems - A single event target element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {EventTarget} - Always returns an single event target element.
     * @readonly
     */
  }, {
    key: "_preEventTargetElem",
    value: function _preEventTargetElem(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [EventTarget], ['EventTarget']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single element/window elements.
     *
     * @param {TinyElementAndWindow|TinyElementAndWindow[]} elems - A single element/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementAndWindow[]} - Always returns an array of element/window elements.
     * @readonly
     */
  }, {
    key: "_preElemsAndWindow",
    value: function _preElemsAndWindow(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [Element, Window], ['Element', 'Window']);
    }
    /**
     * Ensures the input is returned as an single element/window element.
     * Useful to normalize operations across multiple or single element/window elements.
     *
     * @param {TinyElementAndWindow|TinyElementAndWindow[]} elems - A single element/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementAndWindow} - Always returns an single element/window element.
     * @readonly
     */
  }, {
    key: "_preElemAndWindow",
    value: function _preElemAndWindow(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Element, Window], ['Element', 'Window']);
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single element/window/document elements.
     *
     * @param {TinyElementAndWinAndDoc|TinyElementAndWinAndDoc[]} elems - A single element/document/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementAndWindow[]} - Always returns an array of element/document/window elements.
     * @readonly
     */
  }, {
    key: "_preElemsAndWinAndDoc",
    value: function _preElemsAndWinAndDoc(elems, where) {
      var result = TinyHtml._preElemsTemplate(elems, where, [Element, Window, Document], ['Element', 'Window', 'Document']);
      return result.map(function (elem) {
        return !(elem instanceof Document) ? elem : elem.documentElement;
      });
    }
    /**
     * Ensures the input is returned as an single element/window/document element.
     * Useful to normalize operations across multiple or single element/window/document elements.
     *
     * @param {TinyElementAndWinAndDoc|TinyElementAndWinAndDoc[]} elems - A single element/document/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementAndWindow} - Always returns an single element/document/window element.
     * @readonly
     */
  }, {
    key: "_preElemAndWinAndDoc",
    value: function _preElemAndWinAndDoc(elems, where) {
      var result = TinyHtml._preElemTemplate(elems, where, [Element, Window, Document], ['Element', 'Window', 'Document']);
      if (result instanceof Document) return result.documentElement;
      return result;
    }
    /**
     * Ensures the input is returned as an array.
     * Useful to normalize operations across multiple or single element with document elements.
     *
     * @param {TinyElementWithDoc|TinyElementWithDoc[]} elems - A single element with document element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementWithDoc[]} - Always returns an array of element with document elements.
     * @readonly
     */
  }, {
    key: "_preElemsWithDoc",
    value: function _preElemsWithDoc(elems, where) {
      return TinyHtml._preElemsTemplate(elems, where, [Element, Document], ['Element', 'Document']);
    }
    /**
     * Ensures the input is returned as an single element with document element.
     * Useful to normalize operations across multiple or single element with document elements.
     *
     * @param {TinyElementWithDoc|TinyElementWithDoc[]} elems - A single element/window element or array of html elements.
     * @param {string} where - The method or context name where validation is being called.
     * @returns {ElementWithDoc} - Always returns an single element/window element.
     * @readonly
     */
  }, {
    key: "_preElemWithDoc",
    value: function _preElemWithDoc(elems, where) {
      return TinyHtml._preElemTemplate(elems, where, [Element, Document], ['Element', 'Document']);
    }
    /**
     * Normalizes and converts one or more DOM elements (or TinyHtml instances)
     * into an array of `TinyHtml` instances.
     *
     * - If a plain DOM element is passed, it is wrapped into a `TinyHtml` instance.
     * - If a `TinyHtml` instance is already passed, it is preserved.
     * - If an array is passed, all elements inside are converted accordingly.
     *
     * This ensures consistent access to methods of the `TinyHtml` class regardless
     * of the input form.
     *
     * @param {TinyElement|TinyElement[]} elems - A single element or an array of elements (DOM or TinyHtml).
     * @returns {TinyHtml[]} An array of TinyHtml instances corresponding to the input elements.
     */
  }, {
    key: "toTinyElm",
    value: function toTinyElm(elems) {
      /** @param {TinyElement[]} item */
      var checkElement = function checkElement(item) {
        return item.map(function (elem) {
          return !(elem instanceof TinyHtml) ? new TinyHtml(elem) : elem;
        });
      };
      if (!Array.isArray(elems)) return checkElement([elems]);
      return checkElement(elems);
    }
    /**
     * Extracts native `Element` instances from one or more elements,
     * which can be either raw DOM elements or wrapped in `TinyHtml`.
     *
     * - If a `TinyHtml` instance is passed, its internal DOM element is extracted.
     * - If a raw DOM element is passed, it is returned as-is.
     * - If an array is passed, each element is processed accordingly.
     *
     * This function guarantees that the return value is always an array of
     * raw `Element` objects, regardless of whether the input was
     * a mix of `TinyHtml` or native DOM elements.
     *
     * @param {TinyElement|TinyElement[]} elems - A single element or an array of elements (DOM or TinyHtml`).
     * @returns {Element[]} An array of Element instances extracted from the input.
     */
  }, {
    key: "fromTinyElm",
    value: function fromTinyElm(elems) {
      /** @param {TinyElement[]} item */
      var checkElement = function checkElement(item) {
        return item.map(function (elem) {
          return /** @type {Element} */elem instanceof TinyHtml ? elem._getElement('fromTinyElm') : elem;
        });
      };
      if (!Array.isArray(elems)) return checkElement([elems]);
      return checkElement(elems);
    }
    /**
     * Filters an array of elements based on a selector, function, element, or array of elements.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {WinnowRequest} qualifier
     * @param {string} where - The context/method name using this validation.
     * @param {boolean} not Whether to invert the result (used for .not())
     * @returns {Element[]}
     */
  }, {
    key: "winnow",
    value: function winnow(elems, qualifier, where) {
      var not = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      if (typeof not !== 'boolean') throw new TypeError('The "not" must be a boolean.');
      if (typeof qualifier === 'function') {
        return TinyHtml._preElems(elems, where).filter(function (el, i) {
          return !!qualifier.call(el, i, el) !== not;
        });
      }
      if (qualifier instanceof Element) {
        return TinyHtml._preElems(elems, where).filter(function (el) {
          return el === qualifier !== not;
        });
      }
      if (Array.isArray(qualifier) || typeof qualifier !== 'string' &&
      // @ts-ignore
      qualifier.length != null) {
        return TinyHtml._preElems(elems, where).filter(function (el) {
          return qualifier.includes(el) !== not;
        });
      }
      // Assume it's a selector string
      var selector = qualifier;
      if (not) selector = ":not(".concat(selector, ")");
      return TinyHtml._preElems(elems, where).filter(function (el) {
        return el.nodeType === 1 && el.matches(selector);
      });
    }
    /**
     * Filters a set of elements by a CSS selector.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {string} selector
     * @param {boolean} not
     * @returns {Element[]}
     */
  }, {
    key: "filter",
    value: function filter(elems, selector) {
      var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (not) selector = ":not(".concat(selector, ")");
      return TinyHtml._preElems(elems, 'filter').filter(function (el) {
        return el.nodeType === 1 && el.matches(selector);
      });
    }
    /**
     * Returns only the elements matching the given selector or function.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {WinnowRequest} selector
     * @returns {Element[]}
     */
  }, {
    key: "filterOnly",
    value: function filterOnly(elems, selector) {
      return TinyHtml.winnow(elems, selector, 'filterOnly', false);
    }
    /**
     * Returns only the elements **not** matching the given selector or function.
     *
     * @param {TinyElement|TinyElement[]} elems
     * @param {WinnowRequest} selector
     * @returns {Element[]}
     */
  }, {
    key: "not",
    value: function not(elems, selector) {
      return TinyHtml.winnow(elems, selector, 'not', true);
    }
  }, {
    key: "find",
    value: function find(context, selector) {
      var result = [];
      var _iterator3 = _createForOfIteratorHelper(TinyHtml._preElems(context, 'find')),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var el = _step3.value;
          result.push.apply(result, _toConsumableArray(el.querySelectorAll(selector)));
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return _toConsumableArray(new Set(result));
    }
  }, {
    key: "is",
    value: function is(elems, selector) {
      return TinyHtml.winnow(elems, selector, 'is', false).length > 0;
    }
  }, {
    key: "has",
    value: function has(roots, target) {
      var targets = typeof target === 'string' ? _toConsumableArray(document.querySelectorAll(target)) : TinyHtml._preElems(target, 'has');
      return TinyHtml._preElems(roots, 'has').filter(function (root) {
        return targets.some(function (t) {
          return root && root.contains(t);
        });
      });
    }
  }, {
    key: "closest",
    value: function closest(els, selector, context) {
      var matched = [];
      var _iterator4 = _createForOfIteratorHelper(TinyHtml._preElems(els, 'closest')),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var el = _step4.value;
          /** @type {Element | null} */
          var current = el;
          while (current && current !== context) {
            if (current.nodeType === 1 && (typeof selector === 'string' ? current.matches(selector) : current === selector)) {
              matched.push(current);
              break;
            }
            current = current.parentElement;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return _toConsumableArray(new Set(matched));
    }
  }, {
    key: "isSameDom",
    value: function isSameDom(elem, otherElem) {
      return TinyHtml._preNodeElem(elem, 'isSameDom') === TinyHtml._preNodeElem(otherElem, 'isSameDom');
    }
  }, {
    key: "data",
    value:
    /**
     * Retrieves data associated with a DOM element.
     *
     * If a `key` is provided, the corresponding value is returned.
     * If no `key` is given, a shallow copy of all stored data is returned.
     *
     * @param {TinyElement} el - The DOM element.
     * @param {string|null} [key] - The specific key to retrieve from the data store.
     * @param {boolean} [isPrivate=false] - Whether to access the private data store.
     * @returns {ElementDataStore|undefined|any} - The stored value, all data, or undefined if the key doesn't exist.
     */
    function data(el, key) {
      var isPrivate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // Get or initialize the data object
      var data = TinyHtml._dataSelector[!isPrivate ? 'public' : 'private']('data', el);
      // Getter for all
      if (key === undefined || key === null) return _objectSpread({}, data);
      // Getter for specific key
      if (typeof key !== 'string') throw new TypeError('The key must be a string.');
      return data.hasOwnProperty(key) ? data[key] : undefined;
    }
  }, {
    key: "setData",
    value: function setData(el, key, value) {
      var isPrivate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var data = TinyHtml._dataSelector[!isPrivate ? 'public' : 'private']('setData', el);
      if (typeof key !== 'string') throw new TypeError('The key must be a string.');
      data[key] = value;
      return el;
    }
  }, {
    key: "_getSibling",
    value: function _getSibling(el, direction, where) {
      /** @type {Node|null} */
      var newCurrent = TinyHtml._preNodeElemWithNull(el, where);
      while (newCurrent && (newCurrent = newCurrent[direction]) && newCurrent.nodeType !== 1) {}
      if (!(newCurrent instanceof Node)) return null;
      return /** @type {ChildNode} */newCurrent;
    }
    /**
     * Get all sibling elements excluding the given one.
     *
     * @param {Node|null} start
     * @param {Node|null} [exclude]
     * @returns {ChildNode[]}
     * @readonly
     */
  }, {
    key: "_getSiblings",
    value: function _getSiblings(start, exclude) {
      /** @type {Node|null} */
      var st = start;
      var siblings = [];
      for (; st; st = st.nextSibling) {
        if (st.nodeType === 1 && st !== exclude) {
          siblings.push(st);
        }
      }
      return /** @type {ChildNode[]} */siblings;
    }
    /**
     * Traverse DOM in a direction collecting elements.
     *
     * @param {TinyNode} el
     * @param {"parentNode"|"nextSibling"|"previousSibling"} direction
     * @param {TinyNode|string} [until]
     * @param {string} [where='domDir']
     * @returns {ChildNode[]}
     */
  }, {
    key: "domDir",
    value: function domDir(el, direction, until) {
      var where = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'domDir';
      if (typeof direction !== 'string') throw new TypeError('The "direction" must be a string.');
      var elem = TinyHtml._preNodeElemWithNull(el, where);
      var matched = [];
      // @ts-ignore
      while (elem && (elem = elem[direction])) {
        if (elem.nodeType !== 1) continue;
        if (until && (typeof until === 'string' ?
        // @ts-ignore
        elem.matches(until) : elem === until)) break;
        matched.push(elem);
      }
      return /** @type {ChildNode[]} */matched;
    }
    /**
     * Returns the direct parent node of the given element, excluding document fragments.
     *
     * @param {TinyNode} el - The DOM node to find the parent of.
     * @returns {ParentNode|null} The parent node or null if not found.
     */
  }, {
    key: "parent",
    value: function parent(el) {
      var elem = TinyHtml._preNodeElemWithNull(el, 'parent');
      var parent = elem ? elem.parentNode : null;
      return parent && parent.nodeType !== 11 ? parent : null;
    }
  }, {
    key: "parents",
    value: function parents(el, until) {
      return TinyHtml.domDir(el, 'parentNode', until, 'parents');
    }
  }, {
    key: "next",
    value: function next(el) {
      return TinyHtml._getSibling(el, 'nextSibling', 'next');
    }
  }, {
    key: "prev",
    value: function prev(el) {
      return TinyHtml._getSibling(el, 'previousSibling', 'prev');
    }
  }, {
    key: "nextAll",
    value: function nextAll(el) {
      return TinyHtml.domDir(el, 'nextSibling', undefined, 'nextAll');
    }
  }, {
    key: "prevAll",
    value: function prevAll(el) {
      return TinyHtml.domDir(el, 'previousSibling', undefined, 'prevAll');
    }
  }, {
    key: "nextUntil",
    value: function nextUntil(el, until) {
      return TinyHtml.domDir(el, 'nextSibling', until, 'nextUtil');
    }
  }, {
    key: "prevUntil",
    value: function prevUntil(el, until) {
      return TinyHtml.domDir(el, 'previousSibling', until, 'prevUtil');
    }
  }, {
    key: "siblings",
    value: function siblings(el) {
      var elem = TinyHtml._preNodeElemWithNull(el, 'siblings');
      return TinyHtml._getSiblings(elem && elem.parentNode ? elem.parentNode.firstChild : null, elem);
    }
  }, {
    key: "children",
    value: function children(el) {
      var elem = TinyHtml._preNodeElemWithNull(el, 'children');
      return TinyHtml._getSiblings(elem ? elem.firstChild : null);
    }
  }, {
    key: "contents",
    value: function contents(el) {
      var elem = TinyHtml._preNodeElemWithNull(el, 'contents');
      if (elem instanceof HTMLIFrameElement && elem.contentDocument != null && Object.getPrototypeOf(elem.contentDocument)) {
        return [elem.contentDocument];
      }
      if (elem instanceof HTMLTemplateElement) {
        return Array.from((elem.content || elem).childNodes);
      }
      if (elem) return Array.from(elem.childNodes);
      return [];
    }
  }, {
    key: "clone",
    value: function clone(el) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (typeof deep !== 'boolean') throw new TypeError('The "deep" must be a boolean.');
      return TinyHtml._preNodeElems(el, 'clone').map(function (el) {
        return el.cloneNode(deep);
      });
    }
  }, {
    key: "_appendChecker",
    value: function _appendChecker(where) {
      var results = [];
      for (var _len8 = arguments.length, nodes = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
        nodes[_key8 - 1] = arguments[_key8];
      }
      var nds = [].concat(nodes);
      for (var index in nds) {
        if (typeof nds[index] !== 'string') {
          results.push(TinyHtml._preNodeElem(nds[index], where));
        } else results.push(nds[index]);
      }
      return results;
    }
    /**
     * Appends child elements or strings to the end of the target element(s).
     *
     * @param {TinyElement} el - The target element(s) to receive children.
     * @param {...(TinyNode | TinyNode[] | string)} children - The child elements or text to append.
     * @returns {TinyElement}
     */
  }, {
    key: "append",
    value: function append(el) {
      var elem = TinyHtml._preElem(el, 'append');
      for (var _len9 = arguments.length, children = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
        children[_key9 - 1] = arguments[_key9];
      }
      elem.append.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['append'].concat(children))));
      return el;
    }
  }, {
    key: "prepend",
    value: function prepend(el) {
      var elem = TinyHtml._preElem(el, 'prepend');
      for (var _len0 = arguments.length, children = new Array(_len0 > 1 ? _len0 - 1 : 0), _key0 = 1; _key0 < _len0; _key0++) {
        children[_key0 - 1] = arguments[_key0];
      }
      elem.prepend.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['prepend'].concat(children))));
      return el;
    }
  }, {
    key: "before",
    value: function before(el) {
      var elem = TinyHtml._preElem(el, 'before');
      for (var _len1 = arguments.length, children = new Array(_len1 > 1 ? _len1 - 1 : 0), _key1 = 1; _key1 < _len1; _key1++) {
        children[_key1 - 1] = arguments[_key1];
      }
      elem.before.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['before'].concat(children))));
      return el;
    }
  }, {
    key: "after",
    value: function after(el) {
      var elem = TinyHtml._preElem(el, 'after');
      for (var _len10 = arguments.length, children = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
        children[_key10 - 1] = arguments[_key10];
      }
      elem.after.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['after'].concat(children))));
      return el;
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(el) {
      var elem = TinyHtml._preElem(el, 'replaceWith');
      for (var _len11 = arguments.length, newNodes = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
        newNodes[_key11 - 1] = arguments[_key11];
      }
      elem.replaceWith.apply(elem, _toConsumableArray(TinyHtml._appendChecker.apply(TinyHtml, ['replaceWith'].concat(newNodes))));
      return el;
    }
  }, {
    key: "appendTo",
    value: function appendTo(el, targets) {
      var elems = TinyHtml._preNodeElems(el, 'appendTo');
      var tars = TinyHtml._preNodeElems(targets, 'appendTo');
      tars.forEach(function (target, i) {
        elems.forEach(function (elem) {
          return target.appendChild(i === tars.length - 1 ? elem : elem.cloneNode(true));
        });
      });
      return el;
    }
  }, {
    key: "prependTo",
    value: function prependTo(el, targets) {
      var elems = TinyHtml._preElems(el, 'prependTo');
      var tars = TinyHtml._preElems(targets, 'prependTo');
      tars.forEach(function (target, i) {
        elems.slice().reverse().forEach(function (elem) {
          return target.prepend(i === tars.length - 1 ? elem : elem.cloneNode(true));
        });
      });
      return el;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(el, target) {
      var child = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var elem = TinyHtml._preNodeElem(el, 'insertBefore');
      var targ = TinyHtml._preNodeElem(target, 'insertBefore');
      var childNode = TinyHtml._preNodeElemWithNull(child, 'insertBefore');
      if (!targ.parentNode) throw new Error('');
      targ.parentNode.insertBefore(elem, childNode || targ);
      return el;
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(el, target) {
      var child = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var elem = TinyHtml._preNodeElem(el, 'insertAfter');
      var targ = TinyHtml._preNodeElem(target, 'insertBefore');
      var childNode = TinyHtml._preNodeElemWithNull(child, 'insertBefore');
      if (!targ.parentNode) throw new Error('');
      targ.parentNode.insertBefore(elem, childNode || targ.nextSibling);
      return el;
    }
  }, {
    key: "replaceAll",
    value: function replaceAll(el, targets) {
      var elems = TinyHtml._preNodeElems(el, 'replaceAll');
      var tars = TinyHtml._preNodeElems(targets, 'replaceAll');
      tars.forEach(function (target, i) {
        var parent = target.parentNode;
        elems.forEach(function (elem) {
          if (parent) parent.replaceChild(i === tars.length - 1 ? elem : elem.cloneNode(true), target);
        });
      });
      return el;
    }
  }, {
    key: "isWindow",
    value: function isWindow(obj) {
      return obj != null && obj === obj.window;
    }
    /////////////////////////////////////////////////////
    /**
     * Returns the full computed CSS styles for the given element.
     *
     * @param {TinyElement} el - The element to retrieve styles from.
     * @returns {CSSStyleDeclaration} The computed style object for the element.
     */
  }, {
    key: "css",
    value: function css(el) {
      var elem = TinyHtml._preElem(el, 'css');
      return window.getComputedStyle(elem);
    }
  }, {
    key: "cssString",
    value: function cssString(el, prop) {
      var elem = TinyHtml._preElem(el, 'cssString');
      if (typeof prop !== 'string') throw new TypeError('The prop must be a string.');
      // @ts-ignore
      var val = window.getComputedStyle(elem)[prop];
      return typeof val === 'string' ? val : typeof val === 'number' ? val.toString() : null;
    }
  }, {
    key: "cssList",
    value: function cssList(el, prop) {
      var elem = TinyHtml._preElem(el, 'cssList');
      if (!Array.isArray(prop)) throw new TypeError('The prop must be an array of strings.');
      var css = window.getComputedStyle(elem);
      /** @type {Partial<CSSStyleDeclaration>} */
      var result = {};
      var _iterator5 = _createForOfIteratorHelper(prop),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var p = _step5.value;
          if (typeof p !== 'undefined') {
            // @ts-ignore
            result[p] = css.getPropertyValue(p);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return result;
    }
  }, {
    key: "cssFloat",
    value: function cssFloat(el, prop) {
      var elem = TinyHtml._preElem(el, 'cssFloat');
      if (typeof prop !== 'string') throw new TypeError('The prop must be a string.');
      // @ts-ignore
      var val = window.getComputedStyle(elem)[prop];
      return parseFloat(val) || 0;
    }
  }, {
    key: "cssFloats",
    value: function cssFloats(el, prop) {
      var elem = TinyHtml._preElem(el, 'cssFloats');
      if (!Array.isArray(prop)) throw new TypeError('The prop must be an array of strings.');
      var css = window.getComputedStyle(elem);
      /** @type {Record<string, number>} */
      var result = {};
      var _iterator6 = _createForOfIteratorHelper(prop),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var name = _step6.value;
          // @ts-ignore
          result[name] = parseFloat(css[name]) || 0;
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return result;
    }
  }, {
    key: "toStyleKc",
    value:
    /**
     * Converts a camelCase string to kebab-case
     * @param {string} str
     * @returns {string}
     */
    function toStyleKc(str) {
      if (typeof TinyHtml.cssPropAliases[str] === 'string') return TinyHtml.cssPropAliases[str];
      return str;
    }
    /**
     * Converts a kebab-case string to camelCase
     * @param {string} str
     * @returns {string}
     */
  }, {
    key: "toStyleCc",
    value: function toStyleCc(str) {
      if (typeof TinyHtml.cssPropRevAliases[str] === 'string') return TinyHtml.cssPropRevAliases[str];
      return str;
    }
    /**
     * Sets one or more CSS inline style properties on the given element(s).
     *
     * - If `prop` is a string, the `value` will be applied to that property.
     * - If `prop` is an object, each key-value pair will be applied as a CSS property and value.
     *
     * @param {TinyHtmlElement|TinyHtmlElement[]} el - The element to inspect.
     * @param {string|Object} prop - The property name or an object with key-value pairs
     * @param {string|null} [value=null] - The value to set (if `prop` is a string)
     * @returns {TinyHtmlElement|TinyHtmlElement[]}
     */
  }, {
    key: "setStyle",
    value: function setStyle(el, prop) {
      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      TinyHtml._preHtmlElems(el, 'setStyle').forEach(function (elem) {
        if (_typeof(prop) === 'object') {
          for (var _i = 0, _Object$entries = Object.entries(prop); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              k = _Object$entries$_i[0],
              v = _Object$entries$_i[1];
            elem.style.setProperty(TinyHtml.toStyleKc(k), typeof v === 'string' ? v : typeof v === 'number' ? "".concat(v, "px") : String(v));
          }
        } else elem.style.setProperty(TinyHtml.toStyleKc(prop), value);
      });
      return el;
    }
  }, {
    key: "getStyle",
    value: function getStyle(el, prop) {
      return TinyHtml._preHtmlElem(el, 'getStyle').style.getPropertyValue(TinyHtml.toStyleKc(prop));
    }
  }, {
    key: "style",
    value: function style(el) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref3$camelCase = _ref3.camelCase,
        camelCase = _ref3$camelCase === void 0 ? false : _ref3$camelCase,
        _ref3$rawAttr = _ref3.rawAttr,
        rawAttr = _ref3$rawAttr === void 0 ? false : _ref3$rawAttr;
      if (typeof camelCase !== 'boolean') throw new TypeError("\"camelCase\" must be a boolean. Received: ".concat(_typeof(camelCase)));
      if (typeof rawAttr !== 'boolean') throw new TypeError("\"rawAttr\" must be a boolean. Received: ".concat(_typeof(rawAttr)));
      var elem = TinyHtml._preHtmlElem(el, 'style');
      /** @type {Record<string, string>} */
      var result = {};
      if (rawAttr) {
        var raw = elem.getAttribute('style') || '';
        var entries = raw.split(';');
        var _iterator7 = _createForOfIteratorHelper(entries),
          _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var entry = _step7.value;
            var _entry$split = entry.split(':'),
              _entry$split2 = _slicedToArray(_entry$split, 2),
              rawProp = _entry$split2[0],
              rawVal = _entry$split2[1];
            if (!rawProp || !rawVal) continue;
            var prop = rawProp.trim();
            var value = rawVal.trim();
            result[camelCase ? TinyHtml.toStyleCc(prop) : prop] = value;
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      } else {
        var styles = elem.style;
        for (var i = 0; i < styles.length; i++) {
          var _prop = styles[i]; // Already in kebab-case
          var _value = styles.getPropertyValue(_prop);
          result[camelCase ? TinyHtml.toStyleCc(_prop) : _prop] = _value;
        }
      }
      return result;
    }
  }, {
    key: "removeStyle",
    value: function removeStyle(el, prop) {
      TinyHtml._preHtmlElems(el, 'removeStyle').forEach(function (elem) {
        if (Array.isArray(prop)) {
          var _iterator8 = _createForOfIteratorHelper(prop),
            _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var p = _step8.value;
              elem.style.removeProperty(TinyHtml.toStyleKc(p));
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        } else elem.style.removeProperty(TinyHtml.toStyleKc(prop));
      });
      return el;
    }
  }, {
    key: "toggleStyle",
    value: function toggleStyle(el, prop, val1, val2) {
      TinyHtml._preHtmlElems(el, 'toggleStyle').forEach(function (elem) {
        var current = TinyHtml.getStyle(elem, prop).trim();
        var newVal = current === TinyHtml.toStyleKc(val1) ? val2 : val1;
        TinyHtml.setStyle(elem, prop, newVal);
      });
      return el;
    }
  }, {
    key: "clearStyle",
    value: function clearStyle(el) {
      TinyHtml._preElems(el, 'clearStyle').forEach(function (elem) {
        return elem.removeAttribute('style');
      });
      return el;
    }
  }, {
    key: "focus",
    value: function focus(el) {
      var elem = TinyHtml._preHtmlElem(el, 'focus');
      elem.focus();
      return el;
    }
  }, {
    key: "blur",
    value: function blur(el) {
      var elem = TinyHtml._preHtmlElem(el, 'blur');
      elem.blur();
      return el;
    }
  }, {
    key: "boolCheck",
    value: function boolCheck(value) {
      if (typeof value !== 'undefined' && (value === 'true' || value === '1' || value === true || value === 'on' || typeof value === 'number' && value > 0)) {
        return true;
      } else {
        return false;
      }
    }
    //////////////////////////////////////////////////////////////////////
    /**
     * Sets the vertical scroll position of the window.
     * @param {number} value - Sets the scroll position.
     */
  }, {
    key: "setWinScrollTop",
    value: function setWinScrollTop(value) {
      if (typeof value !== 'number') throw new TypeError('The value must be a number.');
      TinyHtml.setScrollTop(window, value);
    }
    /**
     * Sets the horizontal scroll position of the window.
     * @param {number} value - Sets the scroll position.
     */
  }, {
    key: "setWinScrollLeft",
    value: function setWinScrollLeft(value) {
      if (typeof value !== 'number') throw new TypeError('The value must be a number.');
      TinyHtml.setScrollLeft(window, value);
    }
    /**
     * Gets the vertical scroll position of the window.
     * @returns {number} - The current scroll top value.
     */
  }, {
    key: "winScrollTop",
    value: function winScrollTop() {
      return window.scrollY || document.documentElement.scrollTop;
    }
    /**
     * Gets the horizontal scroll position of the window.
     * @returns {number} - The current scroll left value.
     */
  }, {
    key: "winScrollLeft",
    value: function winScrollLeft() {
      return window.scrollX || document.documentElement.scrollLeft;
    }
    /**
     * Returns the current height of the viewport.
     * @returns {number} - Viewport height in pixels.
     */
  }, {
    key: "winInnerHeight",
    value: function winInnerHeight() {
      return window.innerHeight || document.documentElement.clientHeight;
    }
    /**
     * Returns the current width of the viewport.
     * @returns {number} - Viewport width in pixels.
     */
  }, {
    key: "winInnerWidth",
    value: function winInnerWidth() {
      return window.innerWidth || document.documentElement.clientWidth;
    }
    /**
     * Checks if the page is currently scrolled to the very top.
     *
     * This method compares the current vertical scroll position with the total document height.
     * It's useful for detecting if the user has reached the top of the page.
     *
     * @returns {boolean} `true` if the page is scrolled to the top, otherwise `false`.
     */
  }, {
    key: "isPageTop",
    value: function isPageTop() {
      return window.scrollY === 0;
    }
    /**
     * Checks if the page is currently scrolled to the very bottom.
     *
     * This method uses the `scrollY` and `innerHeight` properties to determine if the
     * user has reached the end of the document.
     *
     * @returns {boolean} `true` if the page is scrolled to the bottom, otherwise `false`.
     */
  }, {
    key: "isPageBottom",
    value: function isPageBottom() {
      return window.innerHeight + window.scrollY >= document.body.offsetHeight;
    }
    /**
     * Gets the width or height of an element based on the box model.
     * @param {TinyElementAndWinAndDoc} el - The element or window.
     * @param {"width"|"height"} type - Dimension type.
     * @param {"content"|"padding"|"border"|"margin"} [extra='content'] - Box model context.
     * @returns {number} - Computed dimension.
     * @throws {TypeError} If `type` or `extra` is not a string.
     */
  }, {
    key: "getDimension",
    value: function getDimension(el, type) {
      var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'content';
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'getDimension');
      if (typeof type !== 'string') throw new TypeError('The type must be a string.');
      if (typeof extra !== 'string') throw new TypeError('The extra must be a string.');
      var name = type === 'width' ? 'Width' : 'Height';
      if (TinyHtml.isWindow(elem)) {
        return extra === 'margin' ?
        // @ts-ignore
        elem['inner' + name] :
        // @ts-ignore
        elem.document.documentElement['client' + name];
      }
      /** @type {Element} */
      var elHtml = elem;
      if (elHtml.nodeType === 9) {
        // @ts-ignore
        var doc = elHtml.documentElement;
        return Math.max(
        // @ts-ignore
        elHtml.body['scroll' + name], doc['scroll' + name],
        // @ts-ignore
        elHtml.body['offset' + name], doc['offset' + name], doc['client' + name]);
      }
      var size = elHtml.getBoundingClientRect()[type];
      /**
       * Auxiliary function to add measures on one side and the other
       * @param {string} prefix
       */
      function sumSides(prefix) {
        if (type === 'width') {
          return TinyHtml.cssFloat(elHtml, prefix + 'Left') + TinyHtml.cssFloat(elHtml, prefix + 'Right');
        } else {
          return TinyHtml.cssFloat(elHtml, prefix + 'Top') + TinyHtml.cssFloat(elHtml, prefix + 'Bottom');
        }
      }
      switch (extra) {
        case 'content':
          // remove padding + border
          size -= sumSides('padding');
          size -= sumSides('border');
          break;
        case 'padding':
          // remove border only (padding included in the bounding rect)
          size -= sumSides('border');
          break;
        case 'border':
          // bounding rect already includes border + padding, so do not move the size
          break;
        case 'margin':
          // adds margin (margin is out of bounding rect)
          size += sumSides('margin');
          break;
      }
      return size;
    }
  }, {
    key: "setHeight",
    value: function setHeight(el, value) {
      var elem = TinyHtml._preHtmlElem(el, 'setHeight');
      if (typeof value !== 'number' && typeof value !== 'string') throw new TypeError('The value must be a string or number.');
      elem.style.height = typeof value === 'number' ? "".concat(value, "px") : value;
      return el;
    }
  }, {
    key: "setWidth",
    value: function setWidth(el, value) {
      var elem = TinyHtml._preHtmlElem(el, 'setWidth');
      if (typeof value !== 'number' && typeof value !== 'string') throw new TypeError('The value must be a string or number.');
      elem.style.width = typeof value === 'number' ? "".concat(value, "px") : value;
      return el;
    }
  }, {
    key: "height",
    value: function height(el) {
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'height');
      return TinyHtml.getDimension(elem, 'height', 'content');
    }
  }, {
    key: "width",
    value: function width(el) {
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'width');
      return TinyHtml.getDimension(elem, 'width', 'content');
    }
  }, {
    key: "innerHeight",
    value: function innerHeight(el) {
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'innerHeight');
      return TinyHtml.getDimension(elem, 'height', 'padding');
    }
  }, {
    key: "innerWidth",
    value: function innerWidth(el) {
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'innerWidth');
      return TinyHtml.getDimension(elem, 'width', 'padding');
    }
  }, {
    key: "outerHeight",
    value: function outerHeight(el) {
      var includeMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (typeof includeMargin !== 'boolean') throw new TypeError('The "includeMargin" must be a boolean.');
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'outerHeight');
      return TinyHtml.getDimension(elem, 'height', includeMargin ? 'margin' : 'border');
    }
  }, {
    key: "outerWidth",
    value: function outerWidth(el) {
      var includeMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (typeof includeMargin !== 'boolean') throw new TypeError('The "includeMargin" must be a boolean.');
      var elem = TinyHtml._preElemAndWinAndDoc(el, 'outerWidth');
      return TinyHtml.getDimension(elem, 'width', includeMargin ? 'margin' : 'border');
    }
  }, {
    key: "animate",
    value: function animate(el, keyframes, ops) {
      TinyHtml._preElems(el, 'animate').forEach(function (elem) {
        return elem.animate(keyframes, ops);
      });
      return el;
    }
  }, {
    key: "offset",
    value: function offset(el) {
      var elem = TinyHtml._preElem(el, 'offset');
      var rect = elem.getBoundingClientRect();
      var scrollTop = window.scrollY || document.documentElement.scrollTop;
      var scrollLeft = window.scrollX || document.documentElement.scrollLeft;
      return {
        top: rect.top + scrollTop,
        left: rect.left + scrollLeft
      };
    }
  }, {
    key: "position",
    value: function position(el) {
      var elem = TinyHtml._preHtmlElem(el, 'position');
      var offsetParent;
      var offset;
      var parentOffset = {
        top: 0,
        left: 0
      };
      var computedStyle = window.getComputedStyle(elem);
      if (computedStyle.position === 'fixed') {
        offset = elem.getBoundingClientRect();
      } else {
        offset = TinyHtml.offset(elem);
        offsetParent = elem.offsetParent || document.documentElement;
        var _window$getComputedSt = window.getComputedStyle(offsetParent),
          _position = _window$getComputedSt.position;
        while (offsetParent instanceof HTMLElement && (offsetParent === document.body || offsetParent === document.documentElement) && _position === 'static') {
          offsetParent = offsetParent.parentNode;
        }
        if (offsetParent instanceof HTMLElement && offsetParent !== elem && offsetParent.nodeType === 1) {
          var _TinyHtml$cssFloats = TinyHtml.cssFloats(offsetParent, ['borderTopWidth', 'borderLeftWidth']),
            borderTopWidth = _TinyHtml$cssFloats.borderTopWidth,
            borderLeftWidth = _TinyHtml$cssFloats.borderLeftWidth;
          parentOffset = TinyHtml.offset(offsetParent);
          parentOffset.top += borderTopWidth;
          parentOffset.left += borderLeftWidth;
        }
      }
      return {
        top: offset.top - parentOffset.top - TinyHtml.cssFloat(elem, 'marginTop'),
        left: offset.left - parentOffset.left - TinyHtml.cssFloat(elem, 'marginLeft')
      };
    }
  }, {
    key: "offsetParent",
    value: function offsetParent(el) {
      var elem = TinyHtml._preHtmlElem(el, 'offsetParent');
      var offsetParent = elem.offsetParent;
      while (offsetParent instanceof HTMLElement && window.getComputedStyle(offsetParent).position === 'static') {
        offsetParent = offsetParent.offsetParent;
      }
      // Fallback to document.documentElement
      return offsetParent instanceof HTMLElement ? offsetParent : document.documentElement;
    }
  }, {
    key: "scrollTop",
    value: function scrollTop(el) {
      var elem = TinyHtml._preElemAndWindow(el, 'scrollTop');
      if (TinyHtml.isWindow(elem)) return elem.pageYOffset;
      // @ts-ignore
      if (elem.nodeType === 9) return elem.defaultView.pageYOffset;
      return elem.scrollTop;
    }
  }, {
    key: "scrollLeft",
    value: function scrollLeft(el) {
      var elem = TinyHtml._preElemAndWindow(el, 'scrollLeft');
      if (TinyHtml.isWindow(elem)) return elem.pageXOffset;
      // @ts-ignore
      if (elem.nodeType === 9) return elem.defaultView.pageXOffset;
      return elem.scrollLeft;
    }
  }, {
    key: "scrollToXY",
    value:
    /**
     * Smoothly scrolls one or more elements (or the window) to the specified X and Y coordinates
     * using a custom duration and easing function.
     *
     * If `duration` or a valid `easing` is not provided, the scroll will be performed immediately.
     *
     * @param {TinyElementAndWindow | TinyElementAndWindow[]} el - A single element, array of elements, or the window to scroll.
     * @param {Object} [settings={}] - Configuration object for the scroll animation.
     * @param {number} [settings.targetX] - The horizontal scroll target in pixels.
     * @param {number} [settings.targetY] - The vertical scroll target in pixels.
     * @param {number} [settings.duration] - The duration of the animation in milliseconds.
     * @param {Easings} [settings.easing] - The easing function name to use for the scroll animation.
     * @param {OnScrollAnimation} [settings.onAnimation] - Optional callback invoked on each animation
     *   frame with the current scroll position, normalized animation time (`0` to `1`), and a completion flag.
     * @returns {TinyElementAndWindow|TinyElementAndWindow[]}
     * @throws {TypeError} If `el` is not a valid element, array, or window.
     * @throws {TypeError} If `targetX` or `targetY` is defined but not a number.
     * @throws {TypeError} If `duration` is defined but not a number.
     * @throws {TypeError} If `easing` is defined but not a valid easing function name.
     * @throws {TypeError} If `onAnimation` is defined but not a function.
     */
    function scrollToXY(el) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        targetX = _ref4.targetX,
        targetY = _ref4.targetY,
        duration = _ref4.duration,
        easing = _ref4.easing,
        onAnimation = _ref4.onAnimation;
      if (targetX !== undefined && typeof targetX !== 'number') throw new TypeError('`targetX` must be a number if provided.');
      if (targetY !== undefined && typeof targetY !== 'number') throw new TypeError('`targetY` must be a number if provided.');
      if (duration !== undefined && typeof duration !== 'number') throw new TypeError('`duration` must be a number if provided.');
      if (easing !== undefined && typeof easing !== 'string') throw new TypeError('`easing` must be a string if provided.');
      if (easing !== undefined && typeof TinyHtml.easings[easing] !== 'function') throw new TypeError("Unknown easing function: \"".concat(easing, "\"."));
      if (onAnimation !== undefined && typeof onAnimation !== 'function') throw new TypeError('`onAnimation` must be a function if provided.');
      /**
       * Performs an instant scroll to the given coordinates.
       *
       * @param {ElementAndWindow} elem - The element or window to scroll.
       * @param {number} newX - The final horizontal scroll position.
       * @param {number} newY - The final vertical scroll position.
       * @param {number} time - Normalized progress value.
       */
      var executeScroll = function executeScroll(elem, newX, newY, time) {
        if (elem instanceof Window) {
          window.scrollTo(newX, newY);
        } else if (elem.nodeType === 9) {
          // @ts-ignore
          elem.defaultView.scrollTo(newX, newY);
        } else {
          var startX = elem instanceof Window ? window.scrollX : elem.scrollLeft;
          var startY = elem instanceof Window ? window.scrollY : elem.scrollTop;
          if (startX !== newX) elem.scrollLeft = newX;
          if (startY !== newY) elem.scrollTop = newY;
        }
        if (typeof onAnimation === 'function') onAnimation({
          x: newX,
          y: newY,
          isComplete: time >= 1,
          time: time
        });
      };
      TinyHtml._preElemsAndWindow(el, 'scrollToXY').forEach(function (elem) {
        var startX = elem instanceof Window ? window.scrollX : elem.scrollLeft;
        var startY = elem instanceof Window ? window.scrollY : elem.scrollTop;
        var targX = targetX !== null && targetX !== void 0 ? targetX : startX;
        var targY = targetY !== null && targetY !== void 0 ? targetY : startY;
        var changeX = targX - startX;
        var changeY = targY - startY;
        var ease = typeof easing === 'string' && TinyHtml.easings[easing] || null;
        if (typeof duration !== 'number' || typeof ease !== 'function') return executeScroll(elem, targX, targY, 1);
        var startTime = performance.now();
        var dur = duration !== null && duration !== void 0 ? duration : 0;
        /**
         * Animates the scroll position based on easing and time.
         *
         * @param {number} currentTime - Timestamp provided by requestAnimationFrame.
         */
        function animateScroll(currentTime) {
          if (typeof ease !== 'function') return;
          var time = Math.min(1, (currentTime - startTime) / dur);
          var easedTime = ease(time);
          var newX = startX + changeX * easedTime;
          var newY = startY + changeY * easedTime;
          executeScroll(elem, newX, newY, time);
          if (time < 1) requestAnimationFrame(animateScroll);
        }
        requestAnimationFrame(animateScroll);
      });
      return el;
    }
  }, {
    key: "setScrollTop",
    value: function setScrollTop(el, value) {
      if (typeof value !== 'number') throw new TypeError('ScrollTop value must be a number.');
      return TinyHtml.scrollToXY(el, {
        targetY: value
      });
    }
  }, {
    key: "setScrollLeft",
    value: function setScrollLeft(el, value) {
      if (typeof value !== 'number') throw new TypeError('ScrollLeft value must be a number.');
      return TinyHtml.scrollToXY(el, {
        targetX: value
      });
    }
  }, {
    key: "borderWidth",
    value: function borderWidth(el) {
      var elem = TinyHtml._preElem(el, 'borderWidth');
      var _TinyHtml$cssFloats2 = TinyHtml.cssFloats(elem, ['borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth']),
        left = _TinyHtml$cssFloats2.borderLeftWidth,
        right = _TinyHtml$cssFloats2.borderRightWidth,
        top = _TinyHtml$cssFloats2.borderTopWidth,
        bottom = _TinyHtml$cssFloats2.borderBottomWidth;
      var x = left + right;
      var y = top + bottom;
      return {
        x: x,
        y: y,
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }
  }, {
    key: "border",
    value: function border(el) {
      var elem = TinyHtml._preElem(el, 'border');
      var _TinyHtml$cssFloats3 = TinyHtml.cssFloats(elem, ['borderLeft', 'borderRight', 'borderTop', 'borderBottom']),
        left = _TinyHtml$cssFloats3.borderLeft,
        right = _TinyHtml$cssFloats3.borderRight,
        top = _TinyHtml$cssFloats3.borderTop,
        bottom = _TinyHtml$cssFloats3.borderBottom;
      var x = left + right;
      var y = top + bottom;
      return {
        x: x,
        y: y,
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }
  }, {
    key: "margin",
    value: function margin(el) {
      var elem = TinyHtml._preElem(el, 'margin');
      var _TinyHtml$cssFloats4 = TinyHtml.cssFloats(elem, ['marginLeft', 'marginRight', 'marginTop', 'marginBottom']),
        left = _TinyHtml$cssFloats4.marginLeft,
        right = _TinyHtml$cssFloats4.marginRight,
        top = _TinyHtml$cssFloats4.marginTop,
        bottom = _TinyHtml$cssFloats4.marginBottom;
      var x = left + right;
      var y = top + bottom;
      return {
        x: x,
        y: y,
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }
  }, {
    key: "padding",
    value: function padding(el) {
      var elem = TinyHtml._preElem(el, 'padding');
      var _TinyHtml$cssFloats5 = TinyHtml.cssFloats(elem, ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom']),
        left = _TinyHtml$cssFloats5.paddingLeft,
        right = _TinyHtml$cssFloats5.paddingRight,
        top = _TinyHtml$cssFloats5.paddingTop,
        bottom = _TinyHtml$cssFloats5.paddingBottom;
      var x = left + right;
      var y = top + bottom;
      return {
        x: x,
        y: y,
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }
  }, {
    key: "addClass",
    value: function addClass(el) {
      for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
        args[_key12 - 1] = arguments[_key12];
      }
      TinyHtml._preElems(el, 'addClass').forEach(function (elem) {
        var _elem$classList;
        return (_elem$classList = elem.classList).add.apply(_elem$classList, args);
      });
      return el;
    }
  }, {
    key: "removeClass",
    value: function removeClass(el) {
      for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
        args[_key13 - 1] = arguments[_key13];
      }
      TinyHtml._preElems(el, 'removeClass').forEach(function (elem) {
        var _elem$classList2;
        return (_elem$classList2 = elem.classList).remove.apply(_elem$classList2, args);
      });
      return el;
    }
  }, {
    key: "replaceClass",
    value: function replaceClass(el, token, newToken) {
      if (typeof token !== 'string') throw new TypeError('The "token" parameter must be a string.');
      if (typeof newToken !== 'string') throw new TypeError('The "newToken" parameter must be a string.');
      /** @type {boolean[]} */
      var result = [];
      TinyHtml._preElems(el, 'replaceClass').forEach(function (elem) {
        return result.push(elem.classList.replace(token, newToken));
      });
      return result;
    }
  }, {
    key: "classItem",
    value: function classItem(el, index) {
      var elem = TinyHtml._preElem(el, 'classItem');
      if (typeof index !== 'number') throw new TypeError('The "index" parameter must be a number.');
      return elem.classList.item(index);
    }
  }, {
    key: "toggleClass",
    value: function toggleClass(el, token, force) {
      if (typeof token !== 'string') throw new TypeError('The "token" parameter must be a string.');
      if (typeof force !== 'undefined' && typeof force !== 'boolean') throw new TypeError('The "force" parameter must be a boolean.');
      /** @type {boolean[]} */
      var result = [];
      TinyHtml._preElems(el, 'toggleClass').forEach(function (elem) {
        return result.push(elem.classList.toggle(token, force));
      });
      return result;
    }
  }, {
    key: "hasClass",
    value: function hasClass(el, token) {
      var elem = TinyHtml._preElem(el, 'hasClass');
      if (typeof token !== 'string') throw new TypeError('The "token" parameter must be a string.');
      return elem.classList.contains(token);
    }
  }, {
    key: "classLength",
    value: function classLength(el) {
      var elem = TinyHtml._preElem(el, 'classLength');
      return elem.classList.length;
    }
  }, {
    key: "classList",
    value: function classList(el) {
      var elem = TinyHtml._preElem(el, 'classList');
      return elem.classList.values().toArray();
    }
  }, {
    key: "tagName",
    value: function tagName(el) {
      var elem = TinyHtml._preElem(el, 'tagName');
      return elem.tagName;
    }
  }, {
    key: "id",
    value: function id(el) {
      var elem = TinyHtml._preElem(el, 'id');
      return elem.id;
    }
  }, {
    key: "text",
    value: function text(el) {
      var elem = TinyHtml._preElem(el, 'text');
      return elem.textContent;
    }
  }, {
    key: "setText",
    value: function setText(el, value) {
      if (typeof value !== 'string') throw new Error('Value is not a valid string.');
      TinyHtml._preElems(el, 'setText').forEach(function (el) {
        return el.textContent = value;
      });
      return el;
    }
  }, {
    key: "empty",
    value: function empty(el) {
      TinyHtml._preElems(el, 'empty').forEach(function (el) {
        return el.textContent = '';
      });
      return el;
    }
  }, {
    key: "html",
    value: function html(el, ops) {
      var elem = TinyHtml._preElem(el, 'html');
      return elem.getHTML(ops);
    }
  }, {
    key: "setHtml",
    value: function setHtml(el, value) {
      if (typeof value !== 'string') throw new Error('Value is not a valid string.');
      TinyHtml._preElems(el, 'setHtml').forEach(function (el) {
        return el.innerHTML = value;
      });
      return el;
    }
  }, {
    key: "setVal",
    value:
    /**
     * Sets the value of the current HTML value element (input, select, textarea, etc.).
     * Accepts strings, numbers, booleans or arrays of these values, or a callback function that computes them.
     *
     * @param {TinyInputElement|TinyInputElement[]} el - Target element.
     * @param {SetValueList|((el: InputElement, val: SetValueList) => SetValueList)} value - The value to assign or a function that returns it.
     * @throws {Error} If the computed value is not a valid string or boolean.
     * @returns {TinyInputElement|TinyInputElement[]}
     */
    function setVal(el, value) {
      TinyHtml._preInputElems(el, 'setVal').forEach(function (elem) {
        /**
         * @param {SetValueBase[]} array
         * @param {(v: SetValueBase, i: number) => SetValueBase} callback
         */
        var mapArray = function mapArray(array, callback) {
          var result = [];
          for (var i = 0; i < array.length; i++) {
            result.push(callback(array[i], i));
          }
          return result;
        };
        if (elem.nodeType !== 1) return;
        /** @type {SetValueList} */
        var valToSet = typeof value === 'function' ? value(elem, TinyHtml.val(elem)) : value;
        if (valToSet == null) {
          valToSet = '';
        } else if (typeof valToSet === 'number') {
          valToSet = String(valToSet);
        } else if (Array.isArray(valToSet)) {
          valToSet = mapArray(valToSet, function (v) {
            return v == null ? '' : String(v);
          });
        }
        // @ts-ignore
        var hook = TinyHtml._valHooks[elem.type] || TinyHtml._valHooks[elem.nodeName.toLowerCase()];
        if (!hook || typeof hook.set !== 'function' || hook.set(elem, valToSet, 'value') === undefined) {
          if (typeof valToSet !== 'string' && typeof valToSet !== 'boolean') throw new Error("Invalid setValue \"".concat(_typeof(valToSet), "\" value."));
          if (typeof valToSet === 'string') elem.value = valToSet;
        }
      });
      return el;
    }
  }, {
    key: "_getValByType",
    value:
    /**
     * Gets the value of an input element according to the specified type.
     *
     * @param {InputElement} elem - The input element to extract the value from.
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @param {string} where - The context/method name using this validation.
     * @returns {any} The extracted value, depending on the type.
     * @throws {Error} If the element is not an HTMLInputElement or if the type handler is invalid.
     * @readonly
     */
    function _getValByType(elem, type, where) {
      if (typeof type !== 'string') throw new TypeError('The "type" must be a string.');
      if (typeof where !== 'string') throw new TypeError('The "where" must be a string.');
      if (!(elem instanceof HTMLInputElement)) throw new Error("Provided element is not an HTMLInputElement in ".concat(where, "()."));
      if (typeof TinyHtml._valTypes[type] !== 'function') throw new Error("No handler found for type \"".concat(type, "\" in ").concat(where, "()."));
      // @ts-ignore
      return TinyHtml._valTypes[type](elem);
    }
    /**
     * Retrieves the raw value from the HTML input element.
     * If a custom value hook exists, it will be used first.
     *
     * @param {TinyInputElement} el - Target element.
     * @param {GetValueTypes} type - The type of value to retrieve ("string", "date", or "number").
     * @param {string} where - The context/method name using this validation.
     * @returns {any} The raw value retrieved from the element or hook.
     * @readonly
     */
  }, {
    key: "_val",
    value: function _val(el, where, type) {
      var elem = TinyHtml._preInputElem(el, where);
      // @ts-ignore
      var hook = TinyHtml._valHooks[elem.type] || TinyHtml._valHooks[elem.nodeName.toLowerCase()];
      if (hook && typeof hook.get === 'function') {
        var ret = hook.get(elem, 'value', type);
        if (ret !== undefined) return typeof ret === 'string' ? ret.replace(/\r/g, '') : ret;
      }
      return TinyHtml._getValByType(elem, type, where);
    }
  }, {
    key: "val",
    value: function val(el) {
      return /** @type {SetValueList} */TinyHtml._val(el, 'val', 'string');
    }
  }, {
    key: "valTxt",
    value: function valTxt(el) {
      /** @type {string} */
      var ret = TinyHtml._val(el, 'valTxt', 'string');
      if (typeof ret !== 'string' && ret !== null) throw new Error('Value is not a valid string.');
      return ret == null ? '' : typeof ret === 'string' ? ret.replace(/\r/g, '') : ret;
    }
  }, {
    key: "_valArr",
    value: function _valArr(el, where, type) {
      /** @type {SetValueBase[]} */
      var ret = TinyHtml._val(el, where, type);
      if (!Array.isArray(ret)) throw new Error("Value expected an array but got ".concat(_typeof(ret), "."));
      return ret;
    }
  }, {
    key: "valArr",
    value: function valArr(el) {
      return TinyHtml._valArr(el, 'valArr', 'string');
    }
  }, {
    key: "valNb",
    value: function valNb(el) {
      var elem = TinyHtml._preInputElem(el, 'valNb');
      if (!(elem instanceof HTMLInputElement)) throw new Error('Element must be an input element.');
      /** @type {number} */
      var result = TinyHtml._val(el, 'valNb', 'number');
      if (Number.isNaN(result)) throw new Error('Value is not a valid number.');
      return result;
    }
  }, {
    key: "valDate",
    value: function valDate(el) {
      var elem = TinyHtml._preInputElem(el, 'valDate');
      if (!(elem instanceof HTMLInputElement)) throw new Error('Element must be an input element.');
      /** @type {Date} */
      var result = TinyHtml._val(el, 'valDate', 'date');
      if (!(result instanceof Date)) throw new Error('Value is not a valid date.');
      return result;
    }
  }, {
    key: "valBool",
    value: function valBool(el) {
      var elem = TinyHtml._preInputElem(el, 'valBool');
      if (!(elem instanceof HTMLInputElement)) throw new Error('Element must be an input element.');
      return TinyHtml.val(elem) === 'on' ? true : false;
    }
  }, {
    key: "listenForPaste",
    value: function listenForPaste(el) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        onFilePaste = _ref5.onFilePaste,
        onTextPaste = _ref5.onTextPaste;
      if (typeof onFilePaste !== 'undefined' && typeof onFilePaste !== 'function') throw new TypeError('onFilePaste must be a function.');
      if (typeof onTextPaste !== 'undefined' && typeof onTextPaste !== 'function') throw new TypeError('onTextPaste must be a function.');
      /** @type {EventListenerOrEventListenerObject} */
      var pasteEvent = function pasteEvent(event) {
        var _event$clipboardData;
        if (!(event instanceof ClipboardEvent)) return;
        var items = ((_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.items) || [];
        var _iterator9 = _createForOfIteratorHelper(items),
          _step9;
        try {
          var _loop = function _loop() {
            var item = _step9.value;
            if (item.kind === 'file') {
              if (typeof onFilePaste === 'function') {
                var file = item.getAsFile();
                if (file) onFilePaste(item, file);
              }
            } else if (item.kind === 'string') {
              if (typeof onTextPaste === 'function') item.getAsString(function (text) {
                return onTextPaste(item, text);
              });
            }
          };
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
      };
      TinyHtml._preElemsWithDoc(el, 'listenForPaste').forEach(function (elem) {
        return TinyHtml.on(elem, 'paste', pasteEvent);
      });
      return pasteEvent;
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(el, event) {
      var elem = TinyHtml._preEventTargetElem(el, 'hasEventListener');
      if (!__eventRegistry.has(elem)) return false;
      var events = __eventRegistry.get(elem);
      return !!(events && Array.isArray(events[event]) && events[event].length > 0);
    }
  }, {
    key: "hasExactEventListener",
    value: function hasExactEventListener(el, event, handler) {
      var elem = TinyHtml._preEventTargetElem(el, 'hasExactEventListener');
      if (typeof handler !== 'function') throw new TypeError('The "handler" must be a function.');
      if (!__eventRegistry.has(elem)) return false;
      var events = __eventRegistry.get(elem);
      if (!events || !Array.isArray(events[event])) return false;
      return events[event].some(function (item) {
        return item.handler === handler;
      });
    }
  }, {
    key: "on",
    value: function on(el, event, handler, options) {
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'on').forEach(function (elem) {
        elem.addEventListener(event, handler, options);
        if (!__eventRegistry.has(elem)) __eventRegistry.set(elem, {});
        var events = __eventRegistry.get(elem);
        if (!events) return;
        if (!Array.isArray(events[event])) events[event] = [];
        events[event].push({
          handler: handler,
          options: options
        });
      });
      return el;
    }
  }, {
    key: "once",
    value: function once(el, event, handler) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'once').forEach(function (elem) {
        /** @type {EventListenerOrEventListenerObject} */
        var _wrapped = function wrapped(e) {
          TinyHtml.off(elem, event, _wrapped);
          if (typeof handler === 'function') handler(e);
        };
        TinyHtml.on(elem, event, _wrapped, typeof options === 'boolean' ? options : _objectSpread(_objectSpread({}, options), {}, {
          once: true
        }));
      });
      return el;
    }
  }, {
    key: "off",
    value: function off(el, event, handler, options) {
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'off').forEach(function (elem) {
        elem.removeEventListener(event, handler, options);
        var events = __eventRegistry.get(elem);
        if (events && events[event]) {
          events[event] = events[event].filter(function (entry) {
            return entry.handler !== handler;
          });
          if (events[event].length === 0) delete events[event];
        }
      });
      return el;
    }
  }, {
    key: "offAll",
    value: function offAll(el, event) {
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'offAll').forEach(function (elem) {
        var events = __eventRegistry.get(elem);
        if (events && events[event]) {
          var _iterator0 = _createForOfIteratorHelper(events[event]),
            _step0;
          try {
            for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
              var entry = _step0.value;
              elem.removeEventListener(event, entry.handler, entry.options);
            }
          } catch (err) {
            _iterator0.e(err);
          } finally {
            _iterator0.f();
          }
          delete events[event];
        }
      });
      return el;
    }
  }, {
    key: "offAllTypes",
    value: function offAllTypes(el) {
      var filterFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (filterFn !== null && typeof filterFn !== 'function') throw new TypeError('The "filterFn" must be a function.');
      TinyHtml._preEventTargetElems(el, 'offAllTypes').forEach(function (elem) {
        var events = __eventRegistry.get(elem);
        if (!events) return;
        for (var event in events) {
          var _iterator1 = _createForOfIteratorHelper(events[event]),
            _step1;
          try {
            for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
              var entry = _step1.value;
              if (typeof filterFn !== 'function' || filterFn(entry.handler, event)) {
                elem.removeEventListener(event, entry.handler, entry.options);
              }
            }
          } catch (err) {
            _iterator1.e(err);
          } finally {
            _iterator1.f();
          }
        }
        __eventRegistry["delete"](elem);
      });
      return el;
    }
  }, {
    key: "trigger",
    value: function trigger(el, event) {
      var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (typeof event !== 'string') throw new TypeError('The event name must be a string.');
      TinyHtml._preEventTargetElems(el, 'trigger').forEach(function (elem) {
        var evt = payload instanceof Event || payload instanceof CustomEvent ? payload : new CustomEvent(event, {
          bubbles: true,
          cancelable: true,
          detail: payload
        });
        elem.dispatchEvent(evt);
      });
      return el;
    }
  }, {
    key: "attr",
    value:
    /**
     * Get an attribute on an element.
     * @param {TinyElement} el
     * @param {string} name
     * @returns {string|null}
     */
    function attr(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      var elem = TinyHtml._preElem(el, 'attr');
      return elem.getAttribute(name);
    }
  }, {
    key: "setAttr",
    value: function setAttr(el, name) {
      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      if (value !== null && typeof value !== 'string') throw new TypeError('The "value" must be a string.');
      TinyHtml._preElems(el, 'setAttr').forEach(function (elem) {
        if (value === null) elem.removeAttribute(name);else elem.setAttribute(name, value);
      });
      return el;
    }
  }, {
    key: "removeAttr",
    value: function removeAttr(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      TinyHtml._preElems(el, 'removeAttr').forEach(function (elem) {
        return elem.removeAttribute(name);
      });
      return el;
    }
  }, {
    key: "hasAttr",
    value: function hasAttr(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      var elem = TinyHtml._preElem(el, 'hasAttr');
      return elem.hasAttribute(name);
    }
  }, {
    key: "hasProp",
    value: function hasProp(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      var elem = TinyHtml._preElem(el, 'hasProp');
      // @ts-ignore
      var propName = TinyHtml._propFix[name] || name;
      // @ts-ignore
      return !!elem[propName];
    }
  }, {
    key: "addProp",
    value: function addProp(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      TinyHtml._preElems(el, 'addProp').forEach(function (elem) {
        // @ts-ignore
        name = TinyHtml._propFix[name] || name;
        // @ts-ignore
        elem[name] = true;
      });
      return el;
    }
  }, {
    key: "removeProp",
    value: function removeProp(el, name) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      TinyHtml._preElems(el, 'removeProp').forEach(function (elem) {
        // @ts-ignore
        name = TinyHtml._propFix[name] || name;
        // @ts-ignore
        elem[name] = false;
      });
      return el;
    }
  }, {
    key: "toggleProp",
    value: function toggleProp(el, name, force) {
      if (typeof name !== 'string') throw new TypeError('The "name" must be a string.');
      if (typeof force !== 'undefined' && typeof force !== 'boolean') throw new TypeError('The "force" must be a boolean.');
      TinyHtml._preElems(el, 'toggleProp').forEach(function (elem) {
        // @ts-ignore
        var propName = TinyHtml._propFix[name] || name;
        // @ts-ignore
        var shouldEnable = force === undefined ? !elem[propName] : force;
        // @ts-ignore
        if (shouldEnable) TinyHtml.addProp(elem, name);else TinyHtml.removeProp(elem, name);
      });
    }
  }, {
    key: "remove",
    value: function remove(el) {
      TinyHtml._preElems(el, 'remove').forEach(function (elem) {
        return elem.remove();
      });
      return el;
    }
  }, {
    key: "index",
    value: function index(el) {
      var el2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var elem = TinyHtml._preElem(el, 'index');
      if (!elem) return -1;
      if (!el2) {
        var _elem$parentNode;
        return Array.prototype.indexOf.call(((_elem$parentNode = elem.parentNode) === null || _elem$parentNode === void 0 ? void 0 : _elem$parentNode.children) || [], elem);
      }
      if (el2) {
        var matchEls = typeof el2 === 'string' ? document.querySelectorAll(el2) : TinyHtml._preElems(el2, 'index');
        return Array.prototype.indexOf.call(matchEls, elem);
      }
      return -1;
    }
  }, {
    key: "_getCustomRect",
    value: function _getCustomRect(rect, extraRect) {
      /** @type {DOMRect} */
      var result = {
        height: 0,
        width: 0,
        x: 0,
        y: 0,
        bottom: 0,
        left: 0,
        right: 0,
        top: 0,
        toJSON: function toJSON() {
          throw new Error('Function not implemented.');
        }
      };
      for (var name in rect) {
        // @ts-ignore
        if (typeof rect[name] === 'number')
          // @ts-ignore
          result[name] = rect[name];
      }
      if (_typeof(extraRect) !== 'object' || extraRect === null || Array.isArray(extraRect)) throw new Error('');
      var _extraRect$height = extraRect.height,
        height = _extraRect$height === void 0 ? 0 : _extraRect$height,
        _extraRect$width = extraRect.width,
        width = _extraRect$width === void 0 ? 0 : _extraRect$width,
        _extraRect$top = extraRect.top,
        top = _extraRect$top === void 0 ? 0 : _extraRect$top,
        _extraRect$bottom = extraRect.bottom,
        bottom = _extraRect$bottom === void 0 ? 0 : _extraRect$bottom,
        _extraRect$left = extraRect.left,
        left = _extraRect$left === void 0 ? 0 : _extraRect$left,
        _extraRect$right = extraRect.right,
        right = _extraRect$right === void 0 ? 0 : _extraRect$right;
      if (typeof height !== 'number') throw new Error('');
      if (typeof width !== 'number') throw new Error('');
      if (typeof top !== 'number') throw new Error('');
      if (typeof bottom !== 'number') throw new Error('');
      if (typeof left !== 'number') throw new Error('');
      if (typeof right !== 'number') throw new Error('');
      // @ts-ignore
      result.height += height;
      // @ts-ignore
      result.width += width;
      // @ts-ignore
      result.top += top;
      // @ts-ignore
      result.bottom += bottom;
      // @ts-ignore
      result.left += left;
      // @ts-ignore
      result.right += right;
      return result;
    }
    /**
     * Determines if two HTML elements are colliding, using a simple bounding box comparison.
     *
     * @param {TinyElement} el1 - The first element to compare.
     * @param {TinyElement} el2 - The second element to compare.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} - `true` if the elements are colliding, `false` otherwise.
     */
  }, {
    key: "isCollWith",
    value: function isCollWith(el1, el2) {
      var extraRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var rect1 = TinyHtml._getCustomRect(TinyHtml._preElem(el1, 'isCollWith').getBoundingClientRect(), extraRect);
      var rect2 = TinyHtml._preElem(el2, 'isCollWith').getBoundingClientRect();
      return areElsColliding(rect1, rect2);
    }
  }, {
    key: "isCollPerfWith",
    value: function isCollPerfWith(el1, el2) {
      var extraRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var rect1 = TinyHtml._getCustomRect(TinyHtml._preElem(el1, 'isCollPerfWith').getBoundingClientRect(), extraRect);
      var rect2 = TinyHtml._preElem(el2, 'isCollPerfWith').getBoundingClientRect();
      return areElsPerfColliding(rect1, rect2);
    }
  }, {
    key: "_isCollWithLock",
    value: function _isCollWithLock(isColliding, rect1, rect2, elem1, lockDirection) {
      var lockMap = __elemCollision[lockDirection];
      if (isColliding) {
        // Save entry direction
        if (!lockMap.has(elem1)) {
          lockMap.set(elem1, true);
        }
        return true;
      }
      // Handle unlock logic
      if (lockMap.has(elem1)) {
        var shouldUnlock = false;
        switch (lockDirection) {
          case 'top':
            shouldUnlock = areElsCollTop(rect1, rect2);
            break;
          case 'bottom':
            shouldUnlock = areElsCollBottom(rect1, rect2);
            break;
          case 'left':
            shouldUnlock = areElsCollLeft(rect1, rect2);
            break;
          case 'right':
            shouldUnlock = areElsCollRight(rect1, rect2);
            break;
        }
        if (shouldUnlock) lockMap["delete"](elem1);
        return lockMap.has(elem1); // still colliding (locked)
      }
      return false;
    }
    /**
     * Checks if two DOM elements are colliding on the screen, and locks the collision
     * until the element exits through the same side it entered.
     *
     * @param {TinyElement} el1 - First DOM element (e.g. draggable or moving element).
     * @param {TinyElement} el2 - Second DOM element (e.g. a container or boundary element).
     * @param {CollisionDirLock} lockDirection - Direction that must be respected to unlock the collision.
     * @param {Partial<ObjRect>} [extraRect] - Optional values to expand the size of the first element's rect.
     * @returns {boolean} True if collision is still active.
     */
  }, {
    key: "isCollWithLock",
    value: function isCollWithLock(el1, el2, lockDirection) {
      var extraRect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var elem1 = TinyHtml._preElem(el1, 'isCollWithLock');
      var elem2 = TinyHtml._preElem(el2, 'isCollWithLock');
      var rect1 = TinyHtml._getCustomRect(elem1.getBoundingClientRect(), extraRect);
      var rect2 = elem2.getBoundingClientRect();
      var isColliding = areElsColliding(rect1, rect2);
      return TinyHtml._isCollWithLock(isColliding, rect1, rect2, elem1, lockDirection);
    }
  }, {
    key: "isCollPerfWithLock",
    value: function isCollPerfWithLock(el1, el2, lockDirection) {
      var extraRect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var elem1 = TinyHtml._preElem(el1, 'isCollPerfWithLock');
      var elem2 = TinyHtml._preElem(el2, 'isCollPerfWithLock');
      var rect1 = TinyHtml._getCustomRect(elem1.getBoundingClientRect(), extraRect);
      var rect2 = elem2.getBoundingClientRect();
      var isColliding = areElsPerfColliding(rect1, rect2);
      return TinyHtml._isCollWithLock(isColliding, rect1, rect2, elem1, lockDirection);
    }
  }, {
    key: "resetCollLock",
    value: function resetCollLock(el) {
      var elem = TinyHtml._preElem(el, 'resetCollLock');
      var removed = false;
      for (var _i2 = 0, _arr = /** @type {CollisionDirLock[]} */['top', 'bottom', 'left', 'right']; _i2 < _arr.length; _i2++) {
        var dir = _arr[_i2];
        if (__elemCollision[dir].has(elem)) {
          __elemCollision[dir]["delete"](elem);
          removed = true;
        }
      }
      return removed;
    }
  }, {
    key: "resetCollLockDir",
    value: function resetCollLockDir(el, direction) {
      var elem = TinyHtml._preElem(el, 'resetCollLockDir');
      var lockMap = __elemCollision[direction];
      if (lockMap.has(elem)) {
        lockMap["delete"](elem);
        return true;
      }
      return false;
    }
  }, {
    key: "isInViewport",
    value: function isInViewport(el) {
      var elem = TinyHtml._preElem(el, 'isInViewport');
      if (!elem.checkVisibility({
        contentVisibilityAuto: false,
        opacityProperty: false,
        visibilityProperty: false
      })) return false;
      var elementTop = TinyHtml.offset(elem).top;
      var elementBottom = elementTop + TinyHtml.outerHeight(elem);
      var viewportTop = TinyHtml.scrollTop(window);
      var viewportBottom = viewportTop + TinyHtml.height(window);
      return elementBottom > viewportTop && elementTop < viewportBottom;
    }
  }, {
    key: "isScrolledIntoView",
    value: function isScrolledIntoView(el) {
      var elem = TinyHtml._preElem(el, 'isScrolledIntoView');
      if (!elem.checkVisibility({
        contentVisibilityAuto: false,
        opacityProperty: false,
        visibilityProperty: false
      })) return false;
      var docViewTop = TinyHtml.scrollTop(window);
      var docViewBottom = docViewTop + TinyHtml.height(window);
      var elemTop = TinyHtml.offset(elem).top;
      var elemBottom = elemTop + TinyHtml.height(elem);
      return elemBottom <= docViewBottom && elemTop >= docViewTop;
    }
  }, {
    key: "isInContainer",
    value: function isInContainer(el, cont) {
      var elem = TinyHtml._preElem(el, 'isInContainer');
      var container = TinyHtml._preElem(cont, 'isInContainer');
      if (!elem.checkVisibility({
        contentVisibilityAuto: false,
        opacityProperty: false,
        visibilityProperty: false
      })) return false;
      var elemRect = elem.getBoundingClientRect();
      var containerRect = container.getBoundingClientRect();
      var verticallyVisible = elemRect.bottom > containerRect.top && elemRect.top < containerRect.bottom;
      var horizontallyVisible = elemRect.right > containerRect.left && elemRect.left < containerRect.right;
      return verticallyVisible && horizontallyVisible;
    }
  }, {
    key: "isFullyInContainer",
    value: function isFullyInContainer(el, cont) {
      var elem = TinyHtml._preElem(el, 'isScrolledIntoView');
      var container = TinyHtml._preElem(cont, 'isInContainer');
      if (!elem.checkVisibility({
        contentVisibilityAuto: false,
        opacityProperty: false,
        visibilityProperty: false
      })) return false;
      var elemRect = elem.getBoundingClientRect();
      var containerRect = container.getBoundingClientRect();
      var isFullyVisible = elemRect.top >= containerRect.top && elemRect.bottom <= containerRect.bottom && elemRect.left >= containerRect.left && elemRect.right <= containerRect.right;
      return isFullyVisible;
    }
  }, {
    key: "hasScroll",
    value: function hasScroll(el) {
      var elem = TinyHtml._preElem(el, 'hasScroll');
      return {
        v: elem.scrollHeight > elem.clientHeight,
        h: elem.scrollWidth > elem.clientWidth
      };
    }
  }]);
}();
_TinyHtml = TinyHtml;
/** @typedef {import('../basics/collision.mjs').ObjRect} ObjRect */
_defineProperty(TinyHtml, "Utils", _objectSpread({}, TinyCollision));
/**
 * Internal data selectors for accessing public or private data stores.
 *
 * @type {Record<string, (where: string, elem: TinyElement) => ElementDataStore>}
 * @readonly
 */
_defineProperty(TinyHtml, "_dataSelector", {
  "public": function _public(where, el) {
    var elem = _TinyHtml._preElem(el, where);
    var data = __elementDataMap.get(elem);
    if (!data) {
      data = {};
      __elementDataMap.set(elem, data);
    }
    return data;
  },
  "private": function _private(where, el) {
    if (!(el instanceof _TinyHtml)) throw new Error("Element must be a TinyHtml instance to execute ".concat(where, "()."));
    return el._data;
  }
});
var _cssPropAliases = {
  _: {
    alignContent: 'align-content',
    alignItems: 'align-items',
    alignSelf: 'align-self',
    animationDelay: 'animation-delay',
    animationDirection: 'animation-direction',
    animationDuration: 'animation-duration',
    animationFillMode: 'animation-fill-mode',
    animationIterationCount: 'animation-iteration-count',
    animationName: 'animation-name',
    animationPlayState: 'animation-play-state',
    animationTimingFunction: 'animation-timing-function',
    backfaceVisibility: 'backface-visibility',
    backgroundAttachment: 'background-attachment',
    backgroundBlendMode: 'background-blend-mode',
    backgroundClip: 'background-clip',
    backgroundColor: 'background-color',
    backgroundImage: 'background-image',
    backgroundOrigin: 'background-origin',
    backgroundPosition: 'background-position',
    backgroundRepeat: 'background-repeat',
    backgroundSize: 'background-size',
    borderBottom: 'border-bottom',
    borderBottomColor: 'border-bottom-color',
    borderBottomLeftRadius: 'border-bottom-left-radius',
    borderBottomRightRadius: 'border-bottom-right-radius',
    borderBottomStyle: 'border-bottom-style',
    borderBottomWidth: 'border-bottom-width',
    borderCollapse: 'border-collapse',
    borderColor: 'border-color',
    borderImage: 'border-image',
    borderImageOutset: 'border-image-outset',
    borderImageRepeat: 'border-image-repeat',
    borderImageSlice: 'border-image-slice',
    borderImageSource: 'border-image-source',
    borderImageWidth: 'border-image-width',
    borderLeft: 'border-left',
    borderLeftColor: 'border-left-color',
    borderLeftStyle: 'border-left-style',
    borderLeftWidth: 'border-left-width',
    borderRadius: 'border-radius',
    borderRight: 'border-right',
    borderRightColor: 'border-right-color',
    borderRightStyle: 'border-right-style',
    borderRightWidth: 'border-right-width',
    borderSpacing: 'border-spacing',
    borderStyle: 'border-style',
    borderTop: 'border-top',
    borderTopColor: 'border-top-color',
    borderTopLeftRadius: 'border-top-left-radius',
    borderTopRightRadius: 'border-top-right-radius',
    borderTopStyle: 'border-top-style',
    borderTopWidth: 'border-top-width',
    borderWidth: 'border-width',
    boxDecorationBreak: 'box-decoration-break',
    boxShadow: 'box-shadow',
    boxSizing: 'box-sizing',
    breakAfter: 'break-after',
    breakBefore: 'break-before',
    breakInside: 'break-inside',
    captionSide: 'caption-side',
    caretColor: 'caret-color',
    clipPath: 'clip-path',
    columnCount: 'column-count',
    columnFill: 'column-fill',
    columnGap: 'column-gap',
    columnRule: 'column-rule',
    columnRuleColor: 'column-rule-color',
    columnRuleStyle: 'column-rule-style',
    columnRuleWidth: 'column-rule-width',
    columnSpan: 'column-span',
    columnWidth: 'column-width',
    counterIncrement: 'counter-increment',
    counterReset: 'counter-reset',
    emptyCells: 'empty-cells',
    flexBasis: 'flex-basis',
    flexDirection: 'flex-direction',
    flexFlow: 'flex-flow',
    flexGrow: 'flex-grow',
    flexShrink: 'flex-shrink',
    flexWrap: 'flex-wrap',
    fontFamily: 'font-family',
    fontFeatureSettings: 'font-feature-settings',
    fontKerning: 'font-kerning',
    fontLanguageOverride: 'font-language-override',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontSynthesis: 'font-synthesis',
    fontVariant: 'font-variant',
    fontVariantAlternates: 'font-variant-alternates',
    fontVariantCaps: 'font-variant-caps',
    fontVariantEastAsian: 'font-variant-east-asian',
    fontVariantLigatures: 'font-variant-ligatures',
    fontVariantNumeric: 'font-variant-numeric',
    fontVariantPosition: 'font-variant-position',
    fontWeight: 'font-weight',
    gridArea: 'grid-area',
    gridAutoColumns: 'grid-auto-columns',
    gridAutoFlow: 'grid-auto-flow',
    gridAutoRows: 'grid-auto-rows',
    gridColumn: 'grid-column',
    gridColumnEnd: 'grid-column-end',
    gridColumnGap: 'grid-column-gap',
    gridColumnStart: 'grid-column-start',
    gridGap: 'grid-gap',
    gridRow: 'grid-row',
    gridRowEnd: 'grid-row-end',
    gridRowGap: 'grid-row-gap',
    gridRowStart: 'grid-row-start',
    gridTemplate: 'grid-template',
    gridTemplateAreas: 'grid-template-areas',
    gridTemplateColumns: 'grid-template-columns',
    gridTemplateRows: 'grid-template-rows',
    imageRendering: 'image-rendering',
    justifyContent: 'justify-content',
    letterSpacing: 'letter-spacing',
    lineBreak: 'line-break',
    lineHeight: 'line-height',
    listStyle: 'list-style',
    listStyleImage: 'list-style-image',
    listStylePosition: 'list-style-position',
    listStyleType: 'list-style-type',
    marginBottom: 'margin-bottom',
    marginLeft: 'margin-left',
    marginRight: 'margin-right',
    marginTop: 'margin-top',
    maskClip: 'mask-clip',
    maskComposite: 'mask-composite',
    maskImage: 'mask-image',
    maskMode: 'mask-mode',
    maskOrigin: 'mask-origin',
    maskPosition: 'mask-position',
    maskRepeat: 'mask-repeat',
    maskSize: 'mask-size',
    maskType: 'mask-type',
    maxHeight: 'max-height',
    maxWidth: 'max-width',
    minHeight: 'min-height',
    minWidth: 'min-width',
    mixBlendMode: 'mix-blend-mode',
    objectFit: 'object-fit',
    objectPosition: 'object-position',
    offsetAnchor: 'offset-anchor',
    offsetDistance: 'offset-distance',
    offsetPath: 'offset-path',
    offsetRotate: 'offset-rotate',
    outlineColor: 'outline-color',
    outlineOffset: 'outline-offset',
    outlineStyle: 'outline-style',
    outlineWidth: 'outline-width',
    overflowAnchor: 'overflow-anchor',
    overflowWrap: 'overflow-wrap',
    overflowX: 'overflow-x',
    overflowY: 'overflow-y',
    paddingBottom: 'padding-bottom',
    paddingLeft: 'padding-left',
    paddingRight: 'padding-right',
    paddingTop: 'padding-top',
    pageBreakAfter: 'page-break-after',
    pageBreakBefore: 'page-break-before',
    pageBreakInside: 'page-break-inside',
    perspectiveOrigin: 'perspective-origin',
    placeContent: 'place-content',
    placeItems: 'place-items',
    placeSelf: 'place-self',
    pointerEvents: 'pointer-events',
    rowGap: 'row-gap',
    scrollBehavior: 'scroll-behavior',
    scrollMargin: 'scroll-margin',
    scrollMarginBlock: 'scroll-margin-block',
    scrollMarginBlockEnd: 'scroll-margin-block-end',
    scrollMarginBlockStart: 'scroll-margin-block-start',
    scrollMarginBottom: 'scroll-margin-bottom',
    scrollMarginInline: 'scroll-margin-inline',
    scrollMarginInlineEnd: 'scroll-margin-inline-end',
    scrollMarginInlineStart: 'scroll-margin-inline-start',
    scrollMarginLeft: 'scroll-margin-left',
    scrollMarginRight: 'scroll-margin-right',
    scrollMarginTop: 'scroll-margin-top',
    scrollPadding: 'scroll-padding',
    scrollPaddingBlock: 'scroll-padding-block',
    scrollPaddingBlockEnd: 'scroll-padding-block-end',
    scrollPaddingBlockStart: 'scroll-padding-block-start',
    scrollPaddingBottom: 'scroll-padding-bottom',
    scrollPaddingInline: 'scroll-padding-inline',
    scrollPaddingInlineEnd: 'scroll-padding-inline-end',
    scrollPaddingInlineStart: 'scroll-padding-inline-start',
    scrollPaddingLeft: 'scroll-padding-left',
    scrollPaddingRight: 'scroll-padding-right',
    scrollPaddingTop: 'scroll-padding-top',
    scrollSnapAlign: 'scroll-snap-align',
    scrollSnapStop: 'scroll-snap-stop',
    scrollSnapType: 'scroll-snap-type',
    shapeImageThreshold: 'shape-image-threshold',
    shapeMargin: 'shape-margin',
    shapeOutside: 'shape-outside',
    tabSize: 'tab-size',
    tableLayout: 'table-layout',
    textAlign: 'text-align',
    textAlignLast: 'text-align-last',
    textCombineUpright: 'text-combine-upright',
    textDecoration: 'text-decoration',
    textDecorationColor: 'text-decoration-color',
    textDecorationLine: 'text-decoration-line',
    textDecorationStyle: 'text-decoration-style',
    textIndent: 'text-indent',
    textJustify: 'text-justify',
    textOrientation: 'text-orientation',
    textOverflow: 'text-overflow',
    textShadow: 'text-shadow',
    textTransform: 'text-transform',
    transformBox: 'transform-box',
    transformOrigin: 'transform-origin',
    transformStyle: 'transform-style',
    transitionDelay: 'transition-delay',
    transitionDuration: 'transition-duration',
    transitionProperty: 'transition-property',
    transitionTimingFunction: 'transition-timing-function',
    unicodeBidi: 'unicode-bidi',
    userSelect: 'user-select',
    verticalAlign: 'vertical-align',
    whiteSpace: 'white-space',
    willChange: 'will-change',
    wordBreak: 'word-break',
    wordSpacing: 'word-spacing',
    wordWrap: 'word-wrap',
    writingMode: 'writing-mode',
    zIndex: 'z-index',
    WebkitTransform: '-webkit-transform',
    WebkitTransition: '-webkit-transition',
    WebkitBoxShadow: '-webkit-box-shadow',
    MozBoxShadow: '-moz-box-shadow',
    MozTransform: '-moz-transform',
    MozTransition: '-moz-transition',
    msTransform: '-ms-transform',
    msTransition: '-ms-transition'
  }
};
/** @type {Record<string | symbol, string>} */
_defineProperty(TinyHtml, "cssPropAliases", new Proxy(_cssPropAliases._, {
  set: function set(target, camelCaseKey, kebabValue) {
    target[camelCaseKey] = kebabValue;
    // @ts-ignore
    _TinyHtml.cssPropRevAliases[kebabValue] = camelCaseKey;
    return true;
  }
}));
/** @type {Record<string | symbol, string>} */
_defineProperty(TinyHtml, "cssPropRevAliases", Object.fromEntries(Object.entries(_cssPropAliases._).map(function (_ref6) {
  var _ref7 = _slicedToArray(_ref6, 2),
    camel = _ref7[0],
    kebab = _ref7[1];
  return [kebab, camel];
})));
_defineProperty(TinyHtml, "easings", {
  linear: function linear(t) {
    return t;
  },
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
});
_defineProperty(TinyHtml, "_valHooks", {
  option: {
    /**
     * @param {HTMLOptionElement} elem
     * @returns {string|null}
     */
    get: function get(elem) {
      var val = elem.getAttribute('value');
      return val != null ? val : elem.textContent;
    }
  },
  select: {
    /**
     * @param {HTMLSelectElement} elem
     * @returns {(string | null)[] | string | null}
     */
    get: function get(elem) {
      var options = elem.options;
      var index = elem.selectedIndex;
      var isSingle = elem.type === 'select-one';
      var max = isSingle ? index + 1 : options.length;
      /** @type {(string | null)[] | null} */
      var values = [];
      var i = index < 0 ? max : isSingle ? index : 0;
      for (; i < max; i++) {
        var option = options[i];
        /** @type {HTMLSelectElement|null} */
        // @ts-ignore
        var parentNode = option.parentNode;
        if ((option.selected || i === index) && !option.disabled && (!parentNode || !parentNode.disabled || parentNode.tagName !== 'OPTGROUP')) {
          var val = _TinyHtml._valHooks.option.get(option);
          if (isSingle) return val;
          values.push(val);
        }
      }
      return values;
    },
    /**
     * @param {HTMLSelectElement} elem
     * @param {string[]|string} value
     */
    set: function set(elem, value) {
      var options = elem.options;
      var values = Array.isArray(value) ? value.map(String) : [String(value)];
      var optionSet = false;
      for (var i = 0; i < options.length; i++) {
        var option = options[i];
        var optionVal = _TinyHtml._valHooks.option.get(option);
        if (typeof optionVal === 'string' && (option.selected = values.includes(optionVal))) {
          optionSet = true;
        }
      }
      if (!optionSet) {
        elem.selectedIndex = -1;
      }
      return values;
    }
  },
  radio: {
    /**
     * @param {HTMLInputElement} elem
     * @returns {string}
     */
    get: function get(elem) {
      return elem.checked ? 'on' : 'off';
    },
    /**
     * @param {HTMLInputElement} elem
     * @param {string[]} value
     */
    set: function set(elem, value) {
      if (typeof value === 'boolean') {
        var label = elem.closest('label');
        if (value && label) {
          var otherRadios = label.querySelectorAll('input[type="radio"]');
          otherRadios.forEach(function (otherRadio) {
            if (otherRadio instanceof HTMLInputElement && otherRadio !== elem) otherRadio.checked = false;
          });
        }
        elem.checked = value;
        return value;
      }
    }
  },
  checkbox: {
    /**
     * @param {HTMLInputElement} elem
     * @returns {string}
     */
    get: function get(elem) {
      return elem.checked ? 'on' : 'off';
    },
    /**
     * @param {HTMLInputElement} elem
     * @param {boolean} value
     */
    set: function set(elem, value) {
      if (typeof value === 'boolean') {
        elem.checked = value;
        return value;
      }
    }
  }
});
_defineProperty(TinyHtml, "_valTypes", {
  /**
   * Gets the string value from any HTMLInputElement.
   * @type {(elem: HTMLInputElement) => string}
   */
  string: function string(elem) {
    return elem.value;
  },
  /**
   * Gets the value as a Date object from supported input types.
   * Valid only for types: "date", "datetime-local", "month", "time", "week".
   * Returns `null` if the field is empty or invalid.
   * @type {(elem: HTMLInputElement & { type: "date" | "datetime-local" | "month" | "time" | "week" }) => Date | null}
   */
  date: function date(elem) {
    return elem.valueAsDate;
  },
  /**
   * Gets the numeric value from supported input types.
   * Valid for types: "number", "range", "date", "time".
   * Returns `NaN` if the value is invalid or empty.
   * @type {(elem: HTMLInputElement & { type: "number" | "range" | "date" | "time" }) => number}
   */
  number: function number(elem) {
    return elem.valueAsNumber;
  }
});
_defineProperty(TinyHtml, "_propFix", {
  "for": 'htmlFor',
  "class": 'className'
});
var _default = exports["default"] = TinyHtml;

},{"../basics/collision.mjs":151}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _text = require("../basics/text.mjs");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * A utility class to manage browser notifications with sound and custom behavior.
 * Useful for triggering system notifications with optional sound, avatar icon, body truncation, and click actions.
 *
 * @class
 */
var _allowed = /*#__PURE__*/new WeakMap();
var _permissionRequested = /*#__PURE__*/new WeakMap();
var _audio = /*#__PURE__*/new WeakMap();
var _bodyLimit = /*#__PURE__*/new WeakMap();
var _defaultIcon = /*#__PURE__*/new WeakMap();
var _defaultOnClick = /*#__PURE__*/new WeakMap();
var TinyNotifications = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of TinyNotifications.
   *
   * @param {Object} [settings={}] - Optional settings to initialize the notification manager.
   * @param {string|HTMLAudioElement|null} [settings.audio] - Path or URL to the audio file for notification sounds.
   * @param {string|null} [settings.defaultIcon] - Default icon URL to be used in notifications.
   * @param {number} [settings.bodyLimit=100] - Maximum number of characters allowed in the notification body.
   * @param {(this: Notification, evt: Event) => any} [settings.defaultOnClick] - Default function to execute when a notification is clicked.
   * @throws {TypeError} If any of the parameters are of an invalid type.
   */
  function TinyNotifications() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$audio = _ref.audio,
      audio = _ref$audio === void 0 ? null : _ref$audio,
      _ref$defaultIcon = _ref.defaultIcon,
      defaultIcon = _ref$defaultIcon === void 0 ? null : _ref$defaultIcon,
      _ref$bodyLimit = _ref.bodyLimit,
      bodyLimit = _ref$bodyLimit === void 0 ? 100 : _ref$bodyLimit,
      _ref$defaultOnClick = _ref.defaultOnClick,
      defaultOnClick = _ref$defaultOnClick === void 0 ? function (event) {
        event.preventDefault();
        if (window.focus) window.focus();
        this.close();
      } : _ref$defaultOnClick;
    _classCallCheck(this, TinyNotifications);
    /** @type {boolean} Whether notifications are currently allowed by the user. */
    _classPrivateFieldInitSpec(this, _allowed, false);
    /** @type {boolean} Indicates whether the user has already requested permission at least once. */
    _classPrivateFieldInitSpec(this, _permissionRequested, false);
    /** @type {HTMLAudioElement|null} Audio element to play when a notification is triggered. */
    _classPrivateFieldInitSpec(this, _audio, null);
    /** @type {number} Maximum number of characters in the notification body. */
    _classPrivateFieldInitSpec(this, _bodyLimit, 100);
    /** @type {string|null} Default avatar icon URL for notifications. */
    _classPrivateFieldInitSpec(this, _defaultIcon, null);
    /** @type {(this: Notification, evt: Event) => any} Default handler when a notification is clicked. */
    _classPrivateFieldInitSpec(this, _defaultOnClick, void 0);
    if (!(audio instanceof HTMLAudioElement) && typeof audio !== 'string' && audio !== null) throw new TypeError('audio must be an instance of HTMLAudioElement or null.');
    if (defaultIcon !== null && typeof defaultIcon !== 'string') throw new TypeError('defaultIcon must be a string or null.');
    if (!Number.isFinite(bodyLimit) || bodyLimit < 0) throw new TypeError('bodyLimit must be a non-negative number.');
    if (typeof defaultOnClick !== 'function') throw new TypeError('defaultOnClick must be a function.');
    _classPrivateFieldSet(_audio, this, typeof audio !== 'string' ? audio : new Audio(audio));
    _classPrivateFieldSet(_defaultIcon, this, defaultIcon);
    _classPrivateFieldSet(_bodyLimit, this, bodyLimit);
    _classPrivateFieldSet(_defaultOnClick, this, defaultOnClick);
  }
  /**
   * Requests permission from the user to show notifications.
   * Updates the internal `#allowed` flag.
   *
   * @returns {Promise<boolean>} Resolves to `true` if permission is granted, otherwise `false`.
   */
  return _createClass(TinyNotifications, [{
    key: "requestPerm",
    value: function requestPerm() {
      var _this = this;
      var tinyThis = this;
      return new Promise(function (resolve, reject) {
        if (tinyThis.isCompatible()) {
          if (Notification.permission === 'default') {
            Notification.requestPermission().then(function (permission) {
              _classPrivateFieldSet(_permissionRequested, _this, true);
              _classPrivateFieldSet(_allowed, tinyThis, permission === 'granted');
              resolve(_classPrivateFieldGet(_allowed, tinyThis));
            })["catch"](reject);
          } else {
            _classPrivateFieldSet(_permissionRequested, _this, true);
            _classPrivateFieldSet(_allowed, tinyThis, Notification.permission === 'granted');
            resolve(_classPrivateFieldGet(_allowed, tinyThis));
          }
        } else {
          _classPrivateFieldSet(_permissionRequested, _this, true);
          _classPrivateFieldSet(_allowed, tinyThis, false);
          resolve(false);
        }
      });
    }
    /**
     * Checks if the Notification API is supported by the current browser.
     *
     * @returns {boolean} Returns `true` if notifications are supported, otherwise `false`.
     */
  }, {
    key: "isCompatible",
    value: function isCompatible() {
      return 'Notification' in window;
    }
    /**
     * Sends a browser notification with the provided title and configuration.
     * Truncates the body if necessary and plays a sound if configured.
     *
     * @param {string} title - The title of the notification.
     * @param {NotificationOptions & { vibrate?: number[] }} [config={}] - Optional configuration for the notification.
     * @returns {Notification|null} The created `Notification` instance, or `null` if permission is not granted.
     * @throws {TypeError} If the title is not a string or config is not a valid object.
     */
  }, {
    key: "send",
    value: function send(title) {
      var _this2 = this;
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!_classPrivateFieldGet(_permissionRequested, this)) throw new Error('You must call requestPerm() before sending a notification.');
      if (typeof title !== 'string') throw new TypeError('title must be a string.');
      if (_typeof(config) !== 'object' || config === null) throw new TypeError('config must be a non-null object.');
      if (!_classPrivateFieldGet(_allowed, this)) return null;
      var _config$icon = config.icon,
        icon = _config$icon === void 0 ? _classPrivateFieldGet(_defaultIcon, this) || undefined : _config$icon,
        _config$vibrate = config.vibrate,
        vibrate = _config$vibrate === void 0 ? [200, 100, 200] : _config$vibrate;
      var options = _objectSpread({}, config);
      if (typeof icon === 'string') options.icon = icon;
      if (Array.isArray(vibrate)) options.vibrate = vibrate;
      if (typeof options.body === 'string') options.body = (0, _text.safeTextTrim)(options.body, _classPrivateFieldGet(_bodyLimit, this));
      var notification = new Notification(title, options);
      notification.addEventListener('show', function () {
        if (!(_classPrivateFieldGet(_audio, _this2) instanceof HTMLAudioElement)) return;
        _classPrivateFieldGet(_audio, _this2).currentTime = 0;
        _classPrivateFieldGet(_audio, _this2).play()["catch"](function (err) {
          return console.error(err);
        });
      });
      if (typeof _classPrivateFieldGet(_defaultOnClick, this) === 'function') notification.addEventListener('click', _classPrivateFieldGet(_defaultOnClick, this));
      return notification;
    }
    // === Getters and Setters ===
    /**
     * Whether the requestPerm() method was already called.
     * @returns {boolean}
     */
  }, {
    key: "wasPermissionRequested",
    value: function wasPermissionRequested() {
      return _classPrivateFieldGet(_permissionRequested, this);
    }
    /**
     * Returns the current permission status.
     * @returns {boolean} `true` if permission was granted, otherwise `false`.
     */
  }, {
    key: "isAllowed",
    value: function isAllowed() {
      return _classPrivateFieldGet(_allowed, this);
    }
    /**
     * Gets the current notification audio.
     * @returns {HTMLAudioElement|null} The sound element, or `null` if not set.
     */
  }, {
    key: "getAudio",
    value: function getAudio() {
      return _classPrivateFieldGet(_audio, this);
    }
    /**
     * Sets the audio element used for notification sounds.
     * @param {HTMLAudioElement|string|null} value - A valid `HTMLAudioElement` or `null` to disable sound.
     * @throws {TypeError} If the value is not an `HTMLAudioElement` or `null`.
     */
  }, {
    key: "setAudio",
    value: function setAudio(value) {
      if (!(value instanceof HTMLAudioElement) && typeof value !== 'string' && value !== null) throw new TypeError('sound must be an instance of HTMLAudioElement or null.');
      _classPrivateFieldSet(_audio, this, typeof value !== 'string' ? value : new Audio(value));
    }
    /**
     * Gets the maximum length of the notification body text.
     * @returns {number} Number of characters allowed.
     */
  }, {
    key: "getBodyLimit",
    value: function getBodyLimit() {
      return _classPrivateFieldGet(_bodyLimit, this);
    }
    /**
     * Sets the maximum number of characters allowed in the notification body.
     * @param {number} value - A non-negative integer.
     * @throws {TypeError} If the value is not a valid non-negative number.
     */
  }, {
    key: "setBodyLimit",
    value: function setBodyLimit(value) {
      if (!Number.isFinite(value) || value < 0) throw new TypeError('bodyLimit must be a non-negative number.');
      _classPrivateFieldSet(_bodyLimit, this, value);
    }
    /**
     * Gets the default avatar icon URL.
     * @returns {string|null} The URL string or `null`.
     */
  }, {
    key: "getDefaultAvatar",
    value: function getDefaultAvatar() {
      return _classPrivateFieldGet(_defaultIcon, this);
    }
    /**
     * Sets the default avatar icon URL.
     * @param {string|null} value - A string URL or `null` to disable default icon.
     * @throws {TypeError} If the value is not a string or `null`.
     */
  }, {
    key: "setDefaultAvatar",
    value: function setDefaultAvatar(value) {
      if (!(typeof value === 'string' || value === null)) throw new TypeError('defaultIcon must be a string or null.');
      _classPrivateFieldSet(_defaultIcon, this, value);
    }
    /**
     * Gets the default click event handler for notifications.
     * @returns {(this: Notification, evt: Event) => any} The current click handler function.
     */
  }, {
    key: "getDefaultOnClick",
    value: function getDefaultOnClick() {
      return _classPrivateFieldGet(_defaultOnClick, this);
    }
    /**
     * Sets the default click event handler for notifications.
     * @param {(this: Notification, evt: Event) => any} value - A function to handle the notification click event.
     * @throws {TypeError} If the value is not a function.
     */
  }, {
    key: "setDefaultOnClick",
    value: function setDefaultOnClick(value) {
      if (typeof value !== 'function') throw new TypeError('defaultOnClick must be a function.');
      _classPrivateFieldSet(_defaultOnClick, this, value);
    }
  }]);
}();
var _default = exports["default"] = TinyNotifications;

},{"../basics/text.mjs":157}],169:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129}],170:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"dup":130}],171:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"_process":97,"dup":131}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _TinyHtml = _interopRequireDefault(require("./TinyHtml.mjs"));
var TinyCollision = _interopRequireWildcard(require("../basics/collision.mjs"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, "default": e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Represents the dimensions of a DOM element.
 *
 * @typedef {Object} NodeSizes
 * @property {number} height - The height of the element in pixels.
 * @property {number} width - The width of the element in pixels.
 */
/**
 * A callback function that receives node size change data and optionally returns a modified NodeSizes object.
 *
 * @callback NodeSizesEvent
 * @param {Element} elem - The DOM element whose size is being tracked.
 * @param {{ old: NodeSizes, now: NodeSizes }} sizes - The old and new size measurements of the element.
 * @param {{ old: number, now: number }} elemAmount - The number of matching elements before and after the update.
 * @returns {NodeSizes|undefined} A modified NodeSizes object to override the default measurement, or undefined to use the original.
 */
/**
 * A generic scroll-related event listener callback function.
 *
 * @callback ScrollListenersFunc
 * @param {any} payload - The data payload passed when the scroll event is triggered. The type may vary depending on the event.
 * @returns {void}
 */
/**
 * TinySmartScroller is a utility class designed to enhance and manage scroll behaviors within containers or the window.
 *
 * It enables advanced scroll monitoring, auto-scrolling to bottom, preserving scroll position during DOM changes,
 * and detecting visibility changes of elements. This is particularly useful for dynamic UIs like chat applications,
 * feed viewers, or live content containers.
 *
 * Features:
 * - Detects when the scroll reaches the top, bottom, or custom boundaries
 * - Supports automatic scrolling to the bottom unless the user scrolls away
 * - Observes DOM mutations and resizes, and adapts scroll position accordingly
 * - Emits scroll-related events such as 'onScrollBoundary', 'onAutoScroll', and 'onScrollPause'
 * - Includes customizable scroll correction filters for layout shift mitigation
 * - Handles media element load events (e.g. `<img>`, `<iframe>`, `<video>`) to prevent sudden scroll jumps
 *
 * This class is **not framework-dependent** and works with vanilla DOM elements and the window object.
 */
var _oldSizes = /*#__PURE__*/new WeakMap();
var _newSizes = /*#__PURE__*/new WeakMap();
var _newVisibles = /*#__PURE__*/new WeakMap();
var _oldVisibles = /*#__PURE__*/new WeakMap();
var _newVisiblesByTime = /*#__PURE__*/new WeakMap();
var _oldVisiblesByTime = /*#__PURE__*/new WeakMap();
var _scrollListeners = /*#__PURE__*/new WeakMap();
var _resizeObserver = /*#__PURE__*/new WeakMap();
var _mutationObserver = /*#__PURE__*/new WeakMap();
var _loadTags = /*#__PURE__*/new WeakMap();
var _handler = /*#__PURE__*/new WeakMap();
var _isAtBottom = /*#__PURE__*/new WeakMap();
var _isAtTop = /*#__PURE__*/new WeakMap();
var _isAtCustomTop = /*#__PURE__*/new WeakMap();
var _isAtCustomBottom = /*#__PURE__*/new WeakMap();
var _querySelector = /*#__PURE__*/new WeakMap();
var _useWindow = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _scrollPaused = /*#__PURE__*/new WeakMap();
var _autoScrollBottom = /*#__PURE__*/new WeakMap();
var _observeMutations = /*#__PURE__*/new WeakMap();
var _preserveScrollOnLayoutShift = /*#__PURE__*/new WeakMap();
var _debounceTime = /*#__PURE__*/new WeakMap();
var _elemAmount = /*#__PURE__*/new WeakMap();
var _elemOldAmount = /*#__PURE__*/new WeakMap();
var _lastKnownScrollBottomOffset = /*#__PURE__*/new WeakMap();
var _extraScrollBoundary = /*#__PURE__*/new WeakMap();
var _attributeFilter = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _sizeFilter = /*#__PURE__*/new WeakMap();
var TinySmartScroller = /*#__PURE__*/function () {
  /**
   * Creates a new instance of TinySmartScroller, attaching scroll and resize observers to manage
   * automatic scroll behaviors, layout shift correction, and visibility tracking.
   *
   * @param {Element|Window} target - The scroll container to monitor. Can be an element or `window`.
   * @param {Object} [options={}] - Optional settings to configure scroll behavior.
   * @param {number} [options.extraScrollBoundary=0] - Extra margin in pixels to extend scroll boundary detection.
   * @param {boolean} [options.autoScrollBottom=true] - Whether to auto-scroll to bottom on layout updates.
   * @param {boolean} [options.observeMutations=true] - Enables MutationObserver to detect DOM changes.
   * @param {boolean} [options.preserveScrollOnLayoutShift=true] - Prevents scroll jumps when layout changes.
   * @param {number} [options.debounceTime=100] - Debounce time in milliseconds for scroll events.
   * @param {string|null} [options.querySelector=null] - Optional CSS selector to filter observed child nodes.
   * @param {string[]|Set<string>|null} [options.attributeFilter=['class', 'style', 'src', 'data-*', 'height', 'width']]
   *     - Which attributes to observe for changes.
   */
  function TinySmartScroller(target) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$extraScrollBound = _ref.extraScrollBoundary,
      extraScrollBoundary = _ref$extraScrollBound === void 0 ? 0 : _ref$extraScrollBound,
      _ref$autoScrollBottom = _ref.autoScrollBottom,
      autoScrollBottom = _ref$autoScrollBottom === void 0 ? true : _ref$autoScrollBottom,
      _ref$observeMutations = _ref.observeMutations,
      observeMutations = _ref$observeMutations === void 0 ? true : _ref$observeMutations,
      _ref$preserveScrollOn = _ref.preserveScrollOnLayoutShift,
      preserveScrollOnLayoutShift = _ref$preserveScrollOn === void 0 ? true : _ref$preserveScrollOn,
      _ref$debounceTime = _ref.debounceTime,
      debounceTime = _ref$debounceTime === void 0 ? 100 : _ref$debounceTime,
      _ref$querySelector = _ref.querySelector,
      querySelector = _ref$querySelector === void 0 ? null : _ref$querySelector,
      _ref$attributeFilter = _ref.attributeFilter,
      attributeFilter = _ref$attributeFilter === void 0 ? ['class', 'style', 'src', 'data-*', 'height', 'width'] : _ref$attributeFilter;
    _classCallCheck(this, TinySmartScroller);
    /** @type {WeakMap<Element, NodeSizes>} */
    _classPrivateFieldInitSpec(this, _oldSizes, new WeakMap());
    /** @type {WeakMap<Element, NodeSizes>} */
    _classPrivateFieldInitSpec(this, _newSizes, new WeakMap());
    /** @type {WeakMap<Element, boolean>} */
    _classPrivateFieldInitSpec(this, _newVisibles, new WeakMap());
    /** @type {WeakMap<Element, boolean>} */
    _classPrivateFieldInitSpec(this, _oldVisibles, new WeakMap());
    /** @type {WeakMap<Element, boolean>} */
    _classPrivateFieldInitSpec(this, _newVisiblesByTime, new WeakMap());
    /** @type {WeakMap<Element, boolean>} */
    _classPrivateFieldInitSpec(this, _oldVisiblesByTime, new WeakMap());
    /** @type {Record<string, ScrollListenersFunc[]>} */
    _classPrivateFieldInitSpec(this, _scrollListeners, {});
    /** @type {ResizeObserver|null} */
    _classPrivateFieldInitSpec(this, _resizeObserver, null);
    /** @type {MutationObserver|null} */
    _classPrivateFieldInitSpec(this, _mutationObserver, null);
    /** @type {Set<string>} */
    _classPrivateFieldInitSpec(this, _loadTags, new Set(['IMG', 'IFRAME', 'VIDEO']));
    /** @type {null|EventListenerOrEventListenerObject} */
    _classPrivateFieldInitSpec(this, _handler, null);
    _classPrivateFieldInitSpec(this, _isAtBottom, false);
    _classPrivateFieldInitSpec(this, _isAtTop, false);
    _classPrivateFieldInitSpec(this, _isAtCustomTop, false);
    _classPrivateFieldInitSpec(this, _isAtCustomBottom, false);
    _classPrivateFieldInitSpec(this, _querySelector, '');
    _classPrivateFieldInitSpec(this, _useWindow, false);
    _classPrivateFieldInitSpec(this, _destroyed, false);
    _classPrivateFieldInitSpec(this, _scrollPaused, false);
    _classPrivateFieldInitSpec(this, _autoScrollBottom, false);
    _classPrivateFieldInitSpec(this, _observeMutations, false);
    _classPrivateFieldInitSpec(this, _preserveScrollOnLayoutShift, false);
    _classPrivateFieldInitSpec(this, _debounceTime, 0);
    _classPrivateFieldInitSpec(this, _elemAmount, 0);
    _classPrivateFieldInitSpec(this, _elemOldAmount, 0);
    _classPrivateFieldInitSpec(this, _lastKnownScrollBottomOffset, 0);
    _classPrivateFieldInitSpec(this, _extraScrollBoundary, 0);
    /** @type {Set<string>} */
    _classPrivateFieldInitSpec(this, _attributeFilter, void 0);
    /** @type {Element} */
    _classPrivateFieldInitSpec(this, _target, void 0);
    /** @type {Set<NodeSizesEvent>} */
    _classPrivateFieldInitSpec(this, _sizeFilter, new Set());
    // === target ===
    if (!(target instanceof Element || target === window)) throw new TypeError("TinySmartScroller: 'target' must be a DOM Element or 'window', but got ".concat(_typeof(target)));
    // === extraScrollBoundary ===
    if (typeof extraScrollBoundary !== 'number' || Number.isNaN(extraScrollBoundary)) throw new TypeError("TinySmartScroller: 'extraScrollBoundary' must be a valid number, received ".concat(extraScrollBoundary));
    // === autoScrollBottom ===
    if (typeof autoScrollBottom !== 'boolean') throw new TypeError("TinySmartScroller: 'autoScrollBottom' must be a boolean, received ".concat(_typeof(autoScrollBottom)));
    // === observeMutations ===
    if (typeof observeMutations !== 'boolean') throw new TypeError("TinySmartScroller: 'observeMutations' must be a boolean, received ".concat(_typeof(observeMutations)));
    // === preserveScrollOnLayoutShift ===
    if (typeof preserveScrollOnLayoutShift !== 'boolean') throw new TypeError("TinySmartScroller: 'preserveScrollOnLayoutShift' must be a boolean, received ".concat(_typeof(preserveScrollOnLayoutShift)));
    // === debounceTime ===
    if (typeof debounceTime !== 'number' || debounceTime < 0 || Number.isNaN(debounceTime)) throw new TypeError("TinySmartScroller: 'debounceTime' must be a non-negative number, received ".concat(debounceTime));
    // === querySelector ===
    if (querySelector !== null && typeof querySelector !== 'string') throw new TypeError("TinySmartScroller: 'querySelector' must be a string or null, received ".concat(_typeof(querySelector)));
    // === attributeFilter ===
    var isValidAttrList = attributeFilter === null || Array.isArray(attributeFilter) || attributeFilter instanceof Set;
    if (!isValidAttrList) throw new TypeError("TinySmartScroller: 'attributeFilter' must be an array, Set, or null. Got ".concat(_typeof(attributeFilter)));
    // Start values
    _classPrivateFieldSet(_target, this, target instanceof Window ? document.documentElement : target);
    _classPrivateFieldSet(_useWindow, this, target instanceof Window);
    _classPrivateFieldSet(_autoScrollBottom, this, autoScrollBottom);
    _classPrivateFieldSet(_observeMutations, this, observeMutations);
    _classPrivateFieldSet(_preserveScrollOnLayoutShift, this, preserveScrollOnLayoutShift);
    _classPrivateFieldSet(_debounceTime, this, debounceTime);
    _classPrivateFieldSet(_extraScrollBoundary, this, extraScrollBoundary);
    _classPrivateFieldSet(_querySelector, this, querySelector || '');
    _classPrivateFieldSet(_attributeFilter, this, new Set(attributeFilter || undefined));
    // Bind scroll
    /** @type {NodeJS.Timeout} */
    var timeout;
    _classPrivateFieldSet(_handler, this, function () {
      _this._scrollDataUpdater();
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        return _this._onScroll();
      }, _classPrivateFieldGet(_debounceTime, _this));
    });
    (_classPrivateFieldGet(_useWindow, this) ? window : _classPrivateFieldGet(_target, this)).addEventListener('scroll', _classPrivateFieldGet(_handler, this), {
      passive: true
    });
    // Mutations
    if (_classPrivateFieldGet(_observeMutations, this)) {
      this._observeMutations();
      this._observeResizes(_classPrivateFieldGet(_target, this).children);
    }
    this._scrollDataUpdater();
  }
  /**
   * Returns a size difference callback that only reacts when height changes, filtered by tag name.
   *
   * @param {string[]} filter - List of tag names to allow. If empty, all tags are accepted.
   * @returns {NodeSizesEvent} A function that compares previous and current height, returning height delta.
   */
  return _createClass(TinySmartScroller, [{
    key: "getSimpleOnHeight",
    value: function getSimpleOnHeight() {
      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (!Array.isArray(filter)) throw new TypeError('getSimpleOnHeight(filter): filter must be an array of tag names');
      return function (elem, sizes, amounts) {
        if (filter.length > 0 && !filter.includes(elem.tagName) || amounts.now !== amounts.old) return;
        var oldSize = sizes.old;
        var newSize = sizes.now;
        var height = newSize.height - oldSize.height;
        return {
          height: height,
          width: 0
        };
      };
    }
    /**
     * Adds a height difference callback to the size filter system.
     *
     * @param {string[]} filter - List of tag names to allow.
     * @returns {NodeSizesEvent} The added size difference callback.
     */
  }, {
    key: "addSimpleOnHeight",
    value: function addSimpleOnHeight(filter) {
      if (!Array.isArray(filter)) throw new TypeError('addSimpleOnHeight(filter): filter must be an array of tag names');
      var result = this.getSimpleOnHeight(filter);
      this.onSize(result);
      return result;
    }
    /**
     * Returns a list of all currently tracked load tags.
     *
     * @returns {string[]} Array of tag names.
     */
  }, {
    key: "getLoadTags",
    value: function getLoadTags() {
      return Array.from(_classPrivateFieldGet(_loadTags, this));
    }
    /**
     * Adds a new tag to the set of load tags.
     *
     * @param {string} tag - The tag name to add (e.g., 'IMG').
     */
  }, {
    key: "addLoadTag",
    value: function addLoadTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('addLoadTag(tag): tag must be a string');
      _classPrivateFieldGet(_loadTags, this).add(tag.toUpperCase());
    }
    /**
     * Removes a tag from the set of load tags.
     *
     * @param {string} tag - The tag name to remove.
     */
  }, {
    key: "removeLoadTag",
    value: function removeLoadTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('removeLoadTag(tag): tag must be a string');
      _classPrivateFieldGet(_loadTags, this)["delete"](tag.toUpperCase());
    }
    /**
     * Checks whether a tag is tracked as a load tag.
     *
     * @param {string} tag - The tag name to check.
     * @returns {boolean} True if the tag is being tracked.
     */
  }, {
    key: "hasLoadTag",
    value: function hasLoadTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('hasLoadTag(tag): tag must be a string');
      return _classPrivateFieldGet(_loadTags, this).has(tag.toUpperCase());
    }
    /**
     * Clears the set of load tags. If `addDefault` is true, it will reset to the default tags: 'IMG', 'IFRAME', and 'VIDEO'.
     *
     * @param {boolean} [addDefault=false] - Whether to restore the default tags after clearing.
     * @throws {TypeError} If `addDefault` is not a boolean.
     */
  }, {
    key: "resetLoadTags",
    value: function resetLoadTags() {
      var addDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (typeof addDefault !== 'boolean') throw new TypeError('resetLoadTags(addDefault): addDefault must be a boolean');
      _classPrivateFieldGet(_loadTags, this).clear();
      if (!addDefault) return;
      _classPrivateFieldGet(_loadTags, this).add('IMG');
      _classPrivateFieldGet(_loadTags, this).add('IFRAME');
      _classPrivateFieldGet(_loadTags, this).add('VIDEO');
    }
    /**
     * Returns a list of all currently tracked attribute filters.
     *
     * @returns {string[]} Array of attribute names.
     */
  }, {
    key: "getAttributeFilters",
    value: function getAttributeFilters() {
      return Array.from(_classPrivateFieldGet(_attributeFilter, this));
    }
    /**
     * Adds an attribute to the filter list.
     *
     * @param {string} attr - The attribute name to add.
     */
  }, {
    key: "addAttributeFilter",
    value: function addAttributeFilter(attr) {
      if (typeof attr !== 'string') throw new TypeError('addAttributeFilter(attr): attr must be a string');
      _classPrivateFieldGet(_attributeFilter, this).add(attr);
    }
    /**
     * Removes an attribute from the filter list.
     *
     * @param {string} attr - The attribute name to remove.
     */
  }, {
    key: "removeAttributeFilter",
    value: function removeAttributeFilter(attr) {
      if (typeof attr !== 'string') throw new TypeError('removeAttributeFilter(attr): attr must be a string');
      _classPrivateFieldGet(_attributeFilter, this)["delete"](attr);
    }
    /**
     * Checks whether a specific attribute is being filtered.
     *
     * @param {string} attr - The attribute name to check.
     * @returns {boolean} True if the attribute is being filtered.
     */
  }, {
    key: "hasAttributeFilter",
    value: function hasAttributeFilter(attr) {
      if (typeof attr !== 'string') throw new TypeError('hasAttributeFilter(attr): attr must be a string');
      return _classPrivateFieldGet(_attributeFilter, this).has(attr);
    }
    /**
     * Clears the set of observed attribute filters. If `addDefault` is true, it will reset to the default attributes:
     * 'class', 'style', 'src', 'data-*', 'height', and 'width'.
     *
     * @param {boolean} [addDefault=false] - Whether to restore the default attribute filters after clearing.
     * @throws {TypeError} If `addDefault` is not a boolean.
     */
  }, {
    key: "resetAttributeFilters",
    value: function resetAttributeFilters() {
      var _this2 = this;
      var addDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (typeof addDefault !== 'boolean') throw new TypeError('resetAttributeFilters(addDefault): addDefault must be a boolean');
      _classPrivateFieldGet(_attributeFilter, this).clear();
      if (!addDefault) return;
      ['class', 'style', 'src', 'data-*', 'height', 'width'].forEach(function (attr) {
        return _classPrivateFieldGet(_attributeFilter, _this2).add(attr);
      });
    }
    /**
     * Registers a custom node size change handler to the internal size filter set.
     *
     * @param {NodeSizesEvent} handler - Function that compares old and new sizes.
     */
  }, {
    key: "onSize",
    value: function onSize(handler) {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      if (typeof handler !== 'function') throw new TypeError('onSize(handler): handler must be a function');
      _classPrivateFieldGet(_sizeFilter, this).add(handler);
    }
    /**
     * Unregisters a previously registered size handler from the internal filter set.
     *
     * @param {NodeSizesEvent} handler - The handler function to remove.
     */
  }, {
    key: "offSize",
    value: function offSize(handler) {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      if (typeof handler !== 'function') throw new TypeError('offSize(handler): handler must be a function');
      _classPrivateFieldGet(_sizeFilter, this)["delete"](handler);
    }
    /**
     * Adds a scroll-related event listener.
     *
     * @param {string} event - Event name, such as 'onScrollBoundary' or 'onAutoScroll'.
     * @param {ScrollListenersFunc} handler - Callback function to be called when event fires.
     */
  }, {
    key: "on",
    value: function on(event, handler) {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      if (typeof event !== 'string') throw new TypeError('on(event, handler): event name must be a string');
      if (typeof handler !== 'function') throw new TypeError('on(event, handler): handler must be a function');
      if (!_classPrivateFieldGet(_scrollListeners, this)[event]) _classPrivateFieldGet(_scrollListeners, this)[event] = [];
      _classPrivateFieldGet(_scrollListeners, this)[event].push(handler);
    }
    /**
     * Removes a previously registered scroll-related event listener.
     *
     * @param {string} event - The name of the event to remove the handler from.
     * @param {ScrollListenersFunc} handler - The specific callback function to remove.
     */
  }, {
    key: "off",
    value: function off(event, handler) {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      if (typeof event !== 'string') throw new TypeError('off(event, handler): event name must be a string');
      if (typeof handler !== 'function') throw new TypeError('off(event, handler): handler must be a function');
      var listeners = _classPrivateFieldGet(_scrollListeners, this)[event];
      if (!Array.isArray(listeners)) return;
      var index = listeners.indexOf(handler);
      if (index !== -1) listeners.splice(index, 1);
      // Optionally clean up empty arrays (optional)
      if (listeners.length === 0) delete _classPrivateFieldGet(_scrollListeners, this)[event];
    }
    /**
     * Checks which elements inside the target are currently visible and updates internal maps.
     *
     * @returns {Map<Element, { oldIsVisible: boolean; isVisible: boolean }>} Visibility comparison results.
     */
  }, {
    key: "_scrollDataUpdater",
    value: function _scrollDataUpdater() {
      var _this3 = this;
      var results = new Map();
      _classPrivateFieldGet(_target, this).querySelectorAll(_classPrivateFieldGet(_querySelector, this) || '*').forEach(function (target) {
        var _classPrivateFieldGet2;
        var oldIsVisible = (_classPrivateFieldGet2 = _classPrivateFieldGet(_newVisibles, _this3).get(target)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : false;
        _classPrivateFieldGet(_oldVisibles, _this3).set(target, oldIsVisible);
        var isVisible = _TinyHtml["default"].isInContainer(_classPrivateFieldGet(_target, _this3), target);
        _classPrivateFieldGet(_newVisibles, _this3).set(target, isVisible);
        results.set(target, {
          oldIsVisible: oldIsVisible,
          isVisible: isVisible
        });
      });
      return results;
    }
    /**
     * Emits a scroll-related event to all registered listeners.
     *
     * @param {string} event - Event name.
     * @param {*} [payload] - Optional event data payload.
     */
  }, {
    key: "_emit",
    value: function _emit(event, payload) {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      if (typeof event !== 'string') throw new TypeError('_emit(event, payload): event name must be a string');
      (_classPrivateFieldGet(_scrollListeners, this)[event] || []).forEach(function (fn) {
        return fn(payload);
      });
    }
    /**
     * Handles scroll events, calculates position-related statuses, and emits appropriate events.
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      // Get values
      var scrollCache = this._scrollDataUpdater();
      var el = _classPrivateFieldGet(_target, this);
      var scrollTop = el.scrollTop;
      var scrollHeight = el.scrollHeight;
      var clientHeight = el.clientHeight;
      // Prepare sroll values
      var scrollResult = {
        scrollTop: scrollTop,
        scrollHeight: scrollHeight,
        clientHeight: clientHeight
      };
      var atResult = null;
      var atCustomResult = null;
      var atTop = scrollTop === 0;
      var atBottom = scrollTop + clientHeight >= scrollHeight - 1;
      var atCustomTop = scrollTop <= 0 + _classPrivateFieldGet(_extraScrollBoundary, this);
      var atCustomBottom = scrollTop + clientHeight >= scrollHeight - 1 - _classPrivateFieldGet(_extraScrollBoundary, this);
      // Scroll results
      if (atTop && atBottom) atResult = 'all';else if (atTop) atResult = 'top';else if (atBottom) atResult = 'bottom';
      if (atCustomTop && atCustomBottom) atCustomResult = 'all';else if (atCustomTop) atCustomResult = 'top';else if (atCustomBottom) atCustomResult = 'bottom';
      _classPrivateFieldSet(_isAtTop, this, atTop);
      _classPrivateFieldSet(_isAtBottom, this, atBottom);
      _classPrivateFieldSet(_isAtCustomTop, this, atCustomTop);
      _classPrivateFieldSet(_isAtCustomBottom, this, atCustomBottom);
      _classPrivateFieldSet(_scrollPaused, this, !(_classPrivateFieldGet(_autoScrollBottom, this) && _classPrivateFieldGet(_isAtBottom, this)));
      _classPrivateFieldSet(_lastKnownScrollBottomOffset, this, scrollHeight - scrollTop - clientHeight);
      // Send results
      this._emit('onScrollBoundary', _objectSpread(_objectSpread({
        status: atResult
      }, scrollResult), {}, {
        scrollCache: scrollCache
      }));
      this._emit('onExtraScrollBoundary', _objectSpread(_objectSpread({
        status: atCustomResult
      }, scrollResult), {}, {
        scrollCache: scrollCache
      }));
      if (!_classPrivateFieldGet(_scrollPaused, this)) {
        this._emit('onAutoScroll', _objectSpread(_objectSpread({}, scrollResult), {}, {
          scrollCache: scrollCache
        }));
      } else {
        this._emit('onScrollPause', _objectSpread(_objectSpread({}, scrollResult), {}, {
          scrollCache: scrollCache
        }));
      }
    }
    /**
     * Attempts to correct the scroll position when layout shifts happen, preserving the user position if needed.
     *
     * @param {Element[]} [targets=[]] - List of elements involved in the size change.
     */
  }, {
    key: "_fixScroll",
    value: function _fixScroll() {
      var _this4 = this;
      var targets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (_classPrivateFieldGet(_destroyed, this)) return;
      // === Validation ===
      if (!Array.isArray(targets)) throw new TypeError('_fixScroll: targets must be an array of Elements');
      // Get Scroll data
      var prevScrollHeight = _classPrivateFieldGet(_target, this).scrollHeight;
      var prevScrollTop = _classPrivateFieldGet(_target, this).scrollTop;
      var prevBottomOffset = _classPrivateFieldGet(_target, this).scrollHeight - _classPrivateFieldGet(_target, this).scrollTop - _classPrivateFieldGet(_target, this).clientHeight;
      // Get new size
      var newScrollHeight = _classPrivateFieldGet(_target, this).scrollHeight;
      var heightDelta = newScrollHeight - prevScrollHeight;
      /** @type {() => NodeSizes} */
      var calculateScrollSize = function calculateScrollSize() {
        // Run size getter
        var scrollSize = {
          height: 0,
          width: 0
        };
        var _iterator = _createForOfIteratorHelper(targets),
          _step;
        try {
          var _loop = function _loop() {
            var target = _step.value;
            var tgOs = _classPrivateFieldGet(_oldSizes, _this4).get(target) || {
              height: 0,
              width: 0
            };
            var tgNs = _classPrivateFieldGet(_newSizes, _this4).get(target) || {
              height: 0,
              width: 0
            };
            _classPrivateFieldGet(_sizeFilter, _this4).forEach(function (fn) {
              /** @type {NodeSizes| undefined} */
              var sizes = fn(target, {
                old: tgOs,
                now: tgNs
              }, {
                old: _classPrivateFieldGet(_elemOldAmount, _this4),
                now: _classPrivateFieldGet(_elemAmount, _this4)
              });
              // Fix size
              if (_classPrivateFieldGet(_newVisibles, _this4).get(target) || _classPrivateFieldGet(_newVisiblesByTime, _this4).get(target)) {
                if (typeof sizes !== 'undefined' && _typeof(sizes) !== 'object') throw new Error('_fixScroll: size filter must return an object or undefined');
                if (typeof sizes === 'undefined') return;
                scrollSize.height = sizes.height;
                scrollSize.width = sizes.width;
              }
            });
          };
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
          }
          // Checker
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (typeof scrollSize.height !== 'number' && scrollSize.height < 0) throw new Error('_fixScroll: invalid scrollSize.height value');
        if (typeof scrollSize.width !== 'number' && scrollSize.width < 0) throw new Error('_fixScroll: invalid scrollSize.width value');
        if (scrollSize.height !== 0 || scrollSize.width !== 0) {
          var _iterator2 = _createForOfIteratorHelper(targets),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _classPrivateFieldGet3, _classPrivateFieldGet4;
              var target = _step2.value;
              _classPrivateFieldGet(_newVisiblesByTime, _this4).set(target, (_classPrivateFieldGet3 = _classPrivateFieldGet(_newVisibles, _this4).get(target)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : false);
              _classPrivateFieldGet(_oldVisiblesByTime, _this4).set(target, (_classPrivateFieldGet4 = _classPrivateFieldGet(_oldVisibles, _this4).get(target)) !== null && _classPrivateFieldGet4 !== void 0 ? _classPrivateFieldGet4 : false);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        return scrollSize;
      };
      // Fix scroll size
      if (_classPrivateFieldGet(_elemOldAmount, this) > 0 && _TinyHtml["default"].hasScroll(_classPrivateFieldGet(_target, this)).v && _classPrivateFieldGet(_autoScrollBottom, this) && _classPrivateFieldGet(_preserveScrollOnLayoutShift, this) && !_classPrivateFieldGet(_isAtBottom, this) && !_classPrivateFieldGet(_isAtTop, this)) {
        var scrollSize = calculateScrollSize();
        // Complete
        _classPrivateFieldGet(_target, this).scrollTop = prevScrollTop + heightDelta + scrollSize.height;
        if (scrollSize.width > 0) _classPrivateFieldGet(_target, this).scrollLeft = _classPrivateFieldGet(_target, this).scrollLeft + scrollSize.width;
      }
      // Normal stuff
      else if (!_classPrivateFieldGet(_scrollPaused, this) && _classPrivateFieldGet(_autoScrollBottom, this)) {
        calculateScrollSize();
        this.scrollToBottom();
      } else if (!_classPrivateFieldGet(_autoScrollBottom, this) && !_classPrivateFieldGet(_isAtBottom, this)) {
        calculateScrollSize();
        _classPrivateFieldGet(_target, this).scrollTop = _classPrivateFieldGet(_target, this).scrollHeight - _classPrivateFieldGet(_target, this).clientHeight - prevBottomOffset;
      }
    }
    /**
     * Sets up a MutationObserver to watch for DOM changes and react accordingly to maintain scroll consistency.
     */
  }, {
    key: "_observeMutations",
    value: function _observeMutations() {
      var _this5 = this;
      _classPrivateFieldSet(_mutationObserver, this, new MutationObserver(function (mutations) {
        if (_classPrivateFieldGet(_destroyed, _this5)) return;
        _this5._scrollDataUpdater();
        _classPrivateFieldSet(_elemOldAmount, _this5, _classPrivateFieldGet(_elemAmount, _this5));
        _classPrivateFieldSet(_elemAmount, _this5, _classPrivateFieldGet(_target, _this5).childElementCount);
        mutations.forEach(function (mutation) {
          mutation.addedNodes.forEach(function (node) {
            if (!(node instanceof Element) || node.nodeType !== 1) return;
            _this5._observeResizes([node]);
            _this5._listenLoadEvents(node);
            if (_classPrivateFieldGet(_querySelector, _this5)) {
              var children = node.querySelectorAll(_classPrivateFieldGet(_querySelector, _this5));
              _this5._observeResizes(children);
              _this5._listenLoadEvents(children);
            }
          });
        });
        _this5._fixScroll();
      }));
      // Install observer
      _classPrivateFieldGet(_mutationObserver, this).observe(_classPrivateFieldGet(_target, this), {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: _classPrivateFieldGet(_attributeFilter, this).size > 0 ? Array.from(_classPrivateFieldGet(_attributeFilter, this)) : undefined
      });
    }
    /**
     * Adds a ResizeObserver to monitor elements' size changes and trigger layout adjustments.
     *
     * @param {NodeListOf<Element>|Element[]|HTMLCollection} elements - Elements to observe.
     */
  }, {
    key: "_observeResizes",
    value: function _observeResizes(elements) {
      var _this6 = this;
      // Add resize observer
      if (!_classPrivateFieldGet(_resizeObserver, this)) {
        _classPrivateFieldSet(_resizeObserver, this, new ResizeObserver(function (entries) {
          if (_classPrivateFieldGet(_destroyed, _this6)) return;
          _this6._scrollDataUpdater();
          /** @type {Element[]} */
          var targets = [];
          var _iterator3 = _createForOfIteratorHelper(entries),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var entry = _step3.value;
              // Target
              var target = entry.target;
              // Update old size
              var oldSize = _classPrivateFieldGet(_newSizes, _this6).get(target);
              if (oldSize) _classPrivateFieldGet(_oldSizes, _this6).set(target, oldSize);
              // Set new size
              var _entry$contentRect = entry.contentRect,
                width = _entry$contentRect.width,
                height = _entry$contentRect.height;
              _classPrivateFieldGet(_newSizes, _this6).set(target, {
                width: width,
                height: height
              });
              targets.push(target);
            }
            // Animation frame
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          _this6._fixScroll(targets);
        }));
      }
      // Execute observer
      Array.from(elements).forEach(function (el) {
        if (!_classPrivateFieldGet(_resizeObserver, _this6)) throw new Error('_observeResizes: ResizeObserver instance is not initialized');
        _classPrivateFieldGet(_resizeObserver, _this6).observe(el);
      });
    }
    /**
     * Listens for media/content load events (e.g., images, iframes, videos) to trigger scroll updates.
     *
     * @param {NodeListOf<Element>|Element} elements - Target element(s) to listen on.
     */
  }, {
    key: "_listenLoadEvents",
    value: function _listenLoadEvents(elements) {
      var _this7 = this;
      if (_classPrivateFieldGet(_destroyed, this)) return;
      var list = elements instanceof NodeList ? Array.from(elements) : [elements];
      list.forEach(function (el) {
        if (_classPrivateFieldGet(_loadTags, _this7).has(el.tagName)) {
          // @ts-ignore
          if (!el.complete) {
            el.addEventListener('load', function () {
              _this7._scrollDataUpdater();
              if (!_classPrivateFieldGet(_scrollPaused, _this7) && _classPrivateFieldGet(_autoScrollBottom, _this7)) {
                _this7.scrollToBottom();
              }
            });
          }
        }
      });
    }
    /**
     * Returns the internal scroll container element being monitored.
     *
     * @returns {Element} The DOM element used as the scroll container target.
     */
  }, {
    key: "target",
    get: function get() {
      return _classPrivateFieldGet(_target, this);
    }
    /**
     * Returns the previous size of a given element, or undefined if not tracked.
     *
     * @param {Element} el - The DOM element to query.
     * @returns {NodeSizes|null} The old size, or undefined.
     */
  }, {
    key: "getOldSize",
    value: function getOldSize(el) {
      var _classPrivateFieldGet5;
      return (_classPrivateFieldGet5 = _classPrivateFieldGet(_oldSizes, this).get(el)) !== null && _classPrivateFieldGet5 !== void 0 ? _classPrivateFieldGet5 : null;
    }
    /**
     * Returns the current size of a given element, or undefined if not tracked.
     *
     * @param {Element} el - The DOM element to query.
     * @returns {NodeSizes|null} The new size, or undefined.
     */
  }, {
    key: "getNewSize",
    value: function getNewSize(el) {
      var _classPrivateFieldGet6;
      return (_classPrivateFieldGet6 = _classPrivateFieldGet(_newSizes, this).get(el)) !== null && _classPrivateFieldGet6 !== void 0 ? _classPrivateFieldGet6 : null;
    }
    /**
     * Returns whether the given element was visible in the last scroll update.
     *
     * @param {Element} el - The DOM element to check.
     * @returns {boolean} True if visible, false if not, or undefined if not tracked.
     */
  }, {
    key: "wasVisible",
    value: function wasVisible(el) {
      var _classPrivateFieldGet7;
      return (_classPrivateFieldGet7 = _classPrivateFieldGet(_oldVisibles, this).get(el)) !== null && _classPrivateFieldGet7 !== void 0 ? _classPrivateFieldGet7 : false;
    }
    /**
     * Returns whether the given element is currently visible.
     *
     * @param {Element} el - The DOM element to check.
     * @returns {boolean} True if visible, false if not, or undefined if not tracked.
     */
  }, {
    key: "isVisible",
    value: function isVisible(el) {
      var _classPrivateFieldGet8;
      return (_classPrivateFieldGet8 = _classPrivateFieldGet(_newVisibles, this).get(el)) !== null && _classPrivateFieldGet8 !== void 0 ? _classPrivateFieldGet8 : false;
    }
    /**
     * Returns whether the element was visible in the last time-based visibility check.
     *
     * @param {Element} el - The DOM element to check.
     * @returns {boolean} Visibility state from the previous timed check.
     */
  }, {
    key: "wasTimedVisible",
    value: function wasTimedVisible(el) {
      var _classPrivateFieldGet9;
      return (_classPrivateFieldGet9 = _classPrivateFieldGet(_oldVisiblesByTime, this).get(el)) !== null && _classPrivateFieldGet9 !== void 0 ? _classPrivateFieldGet9 : false;
    }
    /**
     * Returns whether the element is currently visible in the time-based check.
     *
     * @param {Element} el - The DOM element to check.
     * @returns {boolean} Visibility state from the current timed check.
     */
  }, {
    key: "isTimedVisible",
    value: function isTimedVisible(el) {
      var _classPrivateFieldGet0;
      return (_classPrivateFieldGet0 = _classPrivateFieldGet(_newVisiblesByTime, this).get(el)) !== null && _classPrivateFieldGet0 !== void 0 ? _classPrivateFieldGet0 : false;
    }
    /**
     * Sets the extra scroll boundary margin used when determining if the user is at a "custom" bottom or top.
     *
     * @param {number} value - Pixels of additional margin to use.
     */
  }, {
    key: "setExtraScrollBoundary",
    value: function setExtraScrollBoundary(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) throw new TypeError('setExtraScrollBoundary(value): value must be a valid number');
      _classPrivateFieldSet(_extraScrollBoundary, this, value);
    }
    /**
     * Returns the current extra scroll boundary setting.
     *
     * @returns {number}
     */
  }, {
    key: "getExtraScrollBoundary",
    value: function getExtraScrollBoundary() {
      return _classPrivateFieldGet(_extraScrollBoundary, this);
    }
    /**
     * Returns the last known distance (in pixels) from the bottom of the scroll container.
     *
     * @returns {number}
     */
  }, {
    key: "getLastKnownScrollBottomOffset",
    value: function getLastKnownScrollBottomOffset() {
      return _classPrivateFieldGet(_lastKnownScrollBottomOffset, this);
    }
    /**
     * Forces the scroll position to move to the very bottom of the target.
     */
  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      _classPrivateFieldGet(_target, this).scrollTop = _classPrivateFieldGet(_target, this).scrollHeight;
    }
    /**
     * Forces the scroll position to move to the very top of the target.
     */
  }, {
    key: "scrollToTop",
    value: function scrollToTop() {
      _classPrivateFieldGet(_target, this).scrollTop = 0;
    }
    /**
     * Checks if the user is within the defined extra scroll boundary from the bottom.
     *
     * @returns {boolean}
     */
  }, {
    key: "isUserAtCustomBottom",
    value: function isUserAtCustomBottom() {
      return _classPrivateFieldGet(_isAtCustomBottom, this);
    }
    /**
     * Checks if the user is within the defined extra scroll boundary from the top.
     *
     * @returns {boolean}
     */
  }, {
    key: "isUserAtCustomTop",
    value: function isUserAtCustomTop() {
      return _classPrivateFieldGet(_isAtCustomTop, this);
    }
    /**
     * Returns true if the user is currently scrolled to the bottom of the element.
     *
     * @returns {boolean}
     */
  }, {
    key: "isUserAtBottom",
    value: function isUserAtBottom() {
      return _classPrivateFieldGet(_isAtBottom, this);
    }
    /**
     * Returns true if the user is currently scrolled to the top of the element.
     *
     * @returns {boolean}
     */
  }, {
    key: "isUserAtTop",
    value: function isUserAtTop() {
      return _classPrivateFieldGet(_isAtTop, this);
    }
    /**
     * Returns true if automatic scrolling is currently paused.
     *
     * @returns {boolean}
     */
  }, {
    key: "isScrollPaused",
    value: function isScrollPaused() {
      return _classPrivateFieldGet(_scrollPaused, this);
    }
    /**
     * Returns whether the target is the window object.
     *
     * @returns {boolean} True if the scroll target is window, false otherwise.
     */
  }, {
    key: "isWindow",
    value: function isWindow() {
      return _classPrivateFieldGet(_useWindow, this);
    }
    /**
     * Returns whether the instance has been destroyed.
     *
     * @returns {boolean} True if the instance is destroyed, false otherwise.
     */
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return _classPrivateFieldGet(_destroyed, this);
    }
    /**
     * Returns whether auto-scroll-to-bottom is enabled.
     *
     * @returns {boolean} True if auto-scroll is active, false otherwise.
     */
  }, {
    key: "getAutoScrollBottom",
    value: function getAutoScrollBottom() {
      return _classPrivateFieldGet(_autoScrollBottom, this);
    }
    /**
     * Returns whether MutationObserver is enabled.
     *
     * @returns {boolean} True if mutation observation is active, false otherwise.
     */
  }, {
    key: "getObserveMutations",
    value: function getObserveMutations() {
      return _classPrivateFieldGet(_observeMutations, this);
    }
    /**
     * Returns whether layout shift protection is enabled.
     *
     * @returns {boolean} True if scroll preservation is active, false otherwise.
     */
  }, {
    key: "getPreserveScrollOnLayoutShift",
    value: function getPreserveScrollOnLayoutShift() {
      return _classPrivateFieldGet(_preserveScrollOnLayoutShift, this);
    }
    /**
     * Returns the debounce delay in milliseconds used for scroll events.
     *
     * @returns {number} Debounce delay time.
     */
  }, {
    key: "getDebounceTime",
    value: function getDebounceTime() {
      return _classPrivateFieldGet(_debounceTime, this);
    }
    /**
     * Returns the current number of matching elements observed inside the scroll target.
     *
     * @returns {number} Current count of matching elements.
     */
  }, {
    key: "getElemAmount",
    value: function getElemAmount() {
      return _classPrivateFieldGet(_elemAmount, this);
    }
    /**
     * Returns the previous known count of matching elements from the last update.
     *
     * @returns {number} Previous count of matching elements.
     */
  }, {
    key: "getPrevElemAmount",
    value: function getPrevElemAmount() {
      return _classPrivateFieldGet(_elemOldAmount, this);
    }
    /**
     * Returns the query selector string used to filter observed elements.
     *
     * @returns {string} The CSS selector string, or an empty string if none was provided.
     */
  }, {
    key: "getQuerySelector",
    value: function getQuerySelector() {
      return _classPrivateFieldGet(_querySelector, this);
    }
    /**
     * Disconnects all listeners, observers, and clears memory structures.
     * Once destroyed, this instance should no longer be used.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (_classPrivateFieldGet(_destroyed, this)) return;
      _classPrivateFieldSet(_destroyed, this, true);
      // Disconnects MutationObserver
      if (_classPrivateFieldGet(_mutationObserver, this)) {
        _classPrivateFieldGet(_mutationObserver, this).disconnect();
        _classPrivateFieldSet(_mutationObserver, this, null);
      }
      // Disconnect ResizeObserver
      if (_classPrivateFieldGet(_resizeObserver, this)) {
        _classPrivateFieldGet(_resizeObserver, this).disconnect();
        _classPrivateFieldSet(_resizeObserver, this, null);
      }
      // Removes scroll listener
      var target = _classPrivateFieldGet(_useWindow, this) ? window : _classPrivateFieldGet(_target, this);
      if (_classPrivateFieldGet(_handler, this)) target.removeEventListener('scroll', _classPrivateFieldGet(_handler, this));
      // Clean the WeakMaps
      _classPrivateFieldSet(_oldSizes, this, new WeakMap());
      _classPrivateFieldSet(_newSizes, this, new WeakMap());
      _classPrivateFieldSet(_newVisibles, this, new WeakMap());
      _classPrivateFieldSet(_oldVisibles, this, new WeakMap());
      _classPrivateFieldSet(_newVisiblesByTime, this, new WeakMap());
      _classPrivateFieldSet(_oldVisiblesByTime, this, new WeakMap());
      // Cleans listeners and filters
      _classPrivateFieldSet(_scrollListeners, this, {});
      _classPrivateFieldGet(_sizeFilter, this).clear();
      _classPrivateFieldGet(_loadTags, this).clear();
    }
  }]);
}();
_defineProperty(TinySmartScroller, "Utils", _objectSpread(_objectSpread({}, TinyCollision), {}, {
  TinyHtml: _TinyHtml["default"]
}));
var _default = exports["default"] = TinySmartScroller;

},{"../basics/collision.mjs":151,"./TinyHtml.mjs":167}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _el = /*#__PURE__*/new WeakMap();
var _openTag = /*#__PURE__*/new WeakMap();
var _closeTag = /*#__PURE__*/new WeakMap();
/**
 * A full-featured text range editor for `<input>` and `<textarea>` elements,
 * including advanced utilities for BBCode or similar tag-based markup editing.
 */
var TinyTextRangeEditor = /*#__PURE__*/function () {
  /**
   * @param {HTMLInputElement | HTMLTextAreaElement} elem - The target editable input or textarea element.
   * @param {Object} [settings={}] - Optional tag symbol customization.
   * @param {string} [settings.openTag='['] - The character or symbol used to start a tag (e.g., `'['`).
   * @param {string} [settings.closeTag=']'] - The character or symbol used to end a tag (e.g., `']'`).
   */
  function TinyTextRangeEditor(elem) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$openTag = _ref.openTag,
      openTag = _ref$openTag === void 0 ? '[' : _ref$openTag,
      _ref$closeTag = _ref.closeTag,
      closeTag = _ref$closeTag === void 0 ? ']' : _ref$closeTag;
    _classCallCheck(this, TinyTextRangeEditor);
    /** @type {HTMLInputElement | HTMLTextAreaElement} */
    _classPrivateFieldInitSpec(this, _el, void 0);
    /** @type {string} */
    _classPrivateFieldInitSpec(this, _openTag, void 0);
    /** @type {string} */
    _classPrivateFieldInitSpec(this, _closeTag, void 0);
    if (!(elem instanceof HTMLInputElement || elem instanceof HTMLTextAreaElement)) throw new TypeError('Element must be an input or textarea.');
    if (typeof openTag !== 'string') throw new TypeError('openTag must be a string.');
    if (typeof closeTag !== 'string') throw new TypeError('closeTag must be a string.');
    _classPrivateFieldSet(_el, this, elem);
    _classPrivateFieldSet(_openTag, this, openTag);
    _classPrivateFieldSet(_closeTag, this, closeTag);
  }
  /** @returns {string} The current open tag symbol. */
  return _createClass(TinyTextRangeEditor, [{
    key: "getOpenTag",
    value: function getOpenTag() {
      return _classPrivateFieldGet(_openTag, this);
    }
    /** @returns {string} The current close tag symbol. */
  }, {
    key: "getCloseTag",
    value: function getCloseTag() {
      return _classPrivateFieldGet(_closeTag, this);
    }
    /** @param {string} tag - New open tag symbol to use (e.g., `'['`). */
  }, {
    key: "setOpenTag",
    value: function setOpenTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('Open tag must be a string.');
      _classPrivateFieldSet(_openTag, this, tag);
    }
    /** @param {string} tag - New close tag symbol to use (e.g., `']'`). */
  }, {
    key: "setCloseTag",
    value: function setCloseTag(tag) {
      if (typeof tag !== 'string') throw new TypeError('Close tag must be a string.');
      _classPrivateFieldSet(_closeTag, this, tag);
    }
    /**
     * Ensures the element has focus.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "ensureFocus",
    value: function ensureFocus() {
      if (document.activeElement !== _classPrivateFieldGet(_el, this)) _classPrivateFieldGet(_el, this).focus();
      return this;
    }
    /**
     * Focus the element.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "focus",
    value: function focus() {
      _classPrivateFieldGet(_el, this).focus();
      return this;
    }
    /** @returns {{ start: number, end: number }} The current selection range. */
  }, {
    key: "getSelectionRange",
    value: function getSelectionRange() {
      var _classPrivateFieldGet2, _classPrivateFieldGet3;
      return {
        start: (_classPrivateFieldGet2 = _classPrivateFieldGet(_el, this).selectionStart) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : NaN,
        end: (_classPrivateFieldGet3 = _classPrivateFieldGet(_el, this).selectionEnd) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : NaN
      };
    }
    /**
     * Sets the current selection range.
     * @param {number} start - Start index.
     * @param {number} end - End index.
     * @param {boolean} [preserveScroll=true] - Whether to preserve scroll position.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "setSelectionRange",
    value: function setSelectionRange(start, end) {
      var preserveScroll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (typeof start !== 'number' || typeof end !== 'number') throw new TypeError('start and end must be numbers.');
      if (typeof preserveScroll !== 'boolean') throw new TypeError('preserveScroll must be a boolean.');
      var scrollTop = _classPrivateFieldGet(_el, this).scrollTop;
      var scrollLeft = _classPrivateFieldGet(_el, this).scrollLeft;
      _classPrivateFieldGet(_el, this).setSelectionRange(start, end);
      if (preserveScroll) {
        _classPrivateFieldGet(_el, this).scrollTop = scrollTop;
        _classPrivateFieldGet(_el, this).scrollLeft = scrollLeft;
      }
      return this;
    }
    /** @returns {string} The full current text value. */
  }, {
    key: "getValue",
    value: function getValue() {
      return _classPrivateFieldGet(_el, this).value;
    }
    /**
     * Sets the full value of the element.
     * @param {string} value - The new value to assign.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      if (typeof value !== 'string') throw new TypeError('Value must be a string.');
      _classPrivateFieldGet(_el, this).value = value;
      return this;
    }
    /** @returns {string} The currently selected text. */
  }, {
    key: "getSelectedText",
    value: function getSelectedText() {
      var _this$getSelectionRan = this.getSelectionRange(),
        start = _this$getSelectionRan.start,
        end = _this$getSelectionRan.end;
      return _classPrivateFieldGet(_el, this).value.slice(start, end);
    }
    /**
     * Inserts text at the current selection, replacing any selected content.
     * @param {string} text - The text to insert.
     * @param {Object} [settings={}] - Optional auto-spacing behavior.
     * @param {'start' | 'end' | 'preserve'} [settings.newCursor='end'] - Controls caret position after insertion.
     * @param {boolean} [settings.autoSpacing=false]
     * @param {boolean} [settings.autoSpaceLeft=false]
     * @param {boolean} [settings.autoSpaceRight=false]
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "insertText",
    value: function insertText(text) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$newCursor = _ref2.newCursor,
        newCursor = _ref2$newCursor === void 0 ? 'end' : _ref2$newCursor,
        _ref2$autoSpacing = _ref2.autoSpacing,
        autoSpacing = _ref2$autoSpacing === void 0 ? false : _ref2$autoSpacing,
        _ref2$autoSpaceLeft = _ref2.autoSpaceLeft,
        autoSpaceLeft = _ref2$autoSpaceLeft === void 0 ? autoSpacing : _ref2$autoSpaceLeft,
        _ref2$autoSpaceRight = _ref2.autoSpaceRight,
        autoSpaceRight = _ref2$autoSpaceRight === void 0 ? autoSpacing : _ref2$autoSpaceRight;
      if (typeof text !== 'string') throw new TypeError('Text must be a string.');
      if (!['start', 'end', 'preserve'].includes(newCursor)) throw new TypeError("newCursor must be one of 'start', 'end', or 'preserve'.");
      if (typeof autoSpacing !== 'boolean') throw new TypeError('autoSpacing must be a boolean.');
      if (typeof autoSpaceLeft !== 'boolean') throw new TypeError('autoSpaceLeft must be a boolean.');
      if (typeof autoSpaceRight !== 'boolean') throw new TypeError('autoSpaceRight must be a boolean.');
      var _this$getSelectionRan2 = this.getSelectionRange(),
        start = _this$getSelectionRan2.start,
        end = _this$getSelectionRan2.end;
      var value = _classPrivateFieldGet(_el, this).value;
      var leftChar = value[start - 1] || '';
      var rightChar = value[end] || '';
      var addLeft = autoSpaceLeft && leftChar && !/\s/.test(leftChar);
      var addRight = autoSpaceRight && rightChar && !/\s/.test(rightChar);
      var finalText = "".concat(addLeft ? ' ' : '').concat(text).concat(addRight ? ' ' : '');
      var newValue = value.slice(0, start) + finalText + value.slice(end);
      this.setValue(newValue);
      var cursorPos = start;
      if (newCursor === 'end') cursorPos = start + finalText.length;else if (newCursor === 'preserve') cursorPos = start;
      this.setSelectionRange(cursorPos, cursorPos);
      return this;
    }
    /**
     * Deletes the currently selected text.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "deleteSelection",
    value: function deleteSelection() {
      this.insertText('');
      return this;
    }
    /**
     * Replaces the selection using a transformation function.
     * @param {(selected: string) => string} transformer - Function that modifies the selected text.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "transformSelection",
    value: function transformSelection(transformer) {
      if (typeof transformer !== 'function') throw new TypeError('transformer must be a function.');
      var _this$getSelectionRan3 = this.getSelectionRange(),
        start = _this$getSelectionRan3.start;
      var selected = this.getSelectedText();
      var transformed = transformer(selected);
      this.insertText(transformed);
      this.setSelectionRange(start, start + transformed.length);
      return this;
    }
    /**
     * Surrounds current selection with prefix and suffix.
     * @param {string} prefix - Text to insert before.
     * @param {string} suffix - Text to insert after.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "surroundSelection",
    value: function surroundSelection(prefix, suffix) {
      if (typeof prefix !== 'string' || typeof suffix !== 'string') throw new TypeError('prefix and suffix must be strings.');
      var selected = this.getSelectedText();
      this.insertText("".concat(prefix).concat(selected).concat(suffix));
      return this;
    }
    /**
     * Moves the caret by a given offset.
     * @param {number} offset - Characters to move.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "moveCaret",
    value: function moveCaret(offset) {
      if (typeof offset !== 'number') throw new TypeError('offset must be a number.');
      var _this$getSelectionRan4 = this.getSelectionRange(),
        start = _this$getSelectionRan4.start;
      var pos = Math.max(0, start + offset);
      this.setSelectionRange(pos, pos);
      return this;
    }
    /**
     * Selects all content in the field.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "selectAll",
    value: function selectAll() {
      this.setSelectionRange(0, _classPrivateFieldGet(_el, this).value.length);
      return this;
    }
    /**
     * Expands the current selection by character amounts.
     * @param {number} before - Characters to expand to the left.
     * @param {number} after - Characters to expand to the right.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "expandSelection",
    value: function expandSelection(before, after) {
      if (typeof before !== 'number' || typeof after !== 'number') throw new TypeError('before and after must be numbers.');
      var _this$getSelectionRan5 = this.getSelectionRange(),
        start = _this$getSelectionRan5.start,
        end = _this$getSelectionRan5.end;
      var newStart = Math.max(0, start - before);
      var newEnd = Math.min(_classPrivateFieldGet(_el, this).value.length, end + after);
      this.setSelectionRange(newStart, newEnd);
      return this;
    }
    /**
     * Replaces all regex matches in the content.
     * @param {RegExp} regex - Regex to match.
     * @param {(match: string) => string} replacer - Replacement function.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "replaceAll",
    value: function replaceAll(regex, replacer) {
      if (!(regex instanceof RegExp)) throw new TypeError('regex must be a RegExp.');
      if (typeof replacer !== 'function') throw new TypeError('replacer must be a function.');
      var newValue = _classPrivateFieldGet(_el, this).value.replace(regex, replacer);
      this.setValue(newValue);
      return this;
    }
    /**
     * Replaces all regex matches within the currently selected text.
     *
     * @param {RegExp} regex - Regular expression to match inside selection.
     * @param {(match: string) => string} replacer - Function to replace each match.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "replaceInSelection",
    value: function replaceInSelection(regex, replacer) {
      if (!(regex instanceof RegExp)) throw new TypeError('regex must be a RegExp.');
      if (typeof replacer !== 'function') throw new TypeError('replacer must be a function.');
      var _this$getSelectionRan6 = this.getSelectionRange(),
        start = _this$getSelectionRan6.start,
        end = _this$getSelectionRan6.end;
      var original = _classPrivateFieldGet(_el, this).value;
      var selected = original.slice(start, end);
      var replaced = selected.replace(regex, replacer);
      var updated = original.slice(0, start) + replaced + original.slice(end);
      this.setValue(updated);
      this.setSelectionRange(start, start + replaced.length);
      return this;
    }
    /**
     * Toggles a code around the current selection.
     * If it's already wrapped, unwraps it.
     * @param {string} codeName - The code to toggle.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "toggleCode",
    value: function toggleCode(codeName) {
      if (typeof codeName !== 'string') throw new TypeError('codeName must be a string.');
      var selected = this.getSelectedText();
      if (selected.startsWith(codeName) && selected.endsWith(codeName)) {
        var unwrapped = selected.slice(codeName.length, selected.length - codeName.length);
        this.insertText(unwrapped);
      } else {
        this.insertText("".concat(codeName).concat(selected).concat(codeName));
      }
      return this;
    }
    /**
     * Converts a list of attributes into a string suitable for tag insertion.
     *
     * This method supports both standard key-value attribute objects (e.g., `{ key: "value" }`)
     * and boolean-style attribute arrays (e.g., `[ "disabled", "autofocus" ]`).
     *
     * - Attributes passed as an array will render as boolean attributes (e.g., `disabled autofocus`)
     * - Attributes passed as an object will render as `key="value"` pairs (or just `key` if the value is an empty string)
     *
     * @param {Record<string, string> | string[]} attributes - The attributes to serialize into a tag string.
     *   - If an array: treated as a list of boolean-style attributes.
     *   - If an object: treated as key-value pairs.
     *
     * @throws {TypeError} If the array contains non-strings, or the object contains non-string values.
     * @returns {string} A string of serialized attributes for use inside a tag.
     *
     * @example
     * // Using object attributes
     * _insertAttr({ size: "12", color: "red" });
     * // Returns: 'size="12" color="red"'
     *
     * @example
     * // Using boolean attributes
     * _insertAttr(["disabled", "autofocus"]);
     * // Returns: 'disabled autofocus'
     *
     * @example
     * // Using mixed/empty object values
     * _insertAttr({ checked: "", class: "btn" });
     * // Returns: 'checked class="btn"'
     */
  }, {
    key: "_insertAttr",
    value: function _insertAttr(attributes) {
      // Reuse attribute logic
      var attrStr = '';
      if (Array.isArray(attributes)) {
        // string[]
        if (!attributes.every(function (attr) {
          return typeof attr === 'string';
        })) throw new TypeError('All entries in attributes array must be strings.');
        attrStr = attributes.map(function (attr) {
          return "".concat(attr);
        }).join(' ');
      } else if (_typeof(attributes) === 'object' && attributes !== null) {
        // Record<string, string>
        attrStr = Object.entries(attributes).map(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            val = _ref4[1];
          if (typeof val !== 'string') throw new TypeError('All entries in attributes object must be strings.');
          return "".concat(key).concat(val.length > 0 ? "=\"".concat(val, "\"") : '');
        }).join(' ');
      } else {
        throw new TypeError('attributes must be an object or an array of strings.');
      }
      return attrStr;
    }
    /**
     * Wraps the current selection with a tag, optionally including attributes.
     *
     * @param {string} tagName - The tag name (e.g., `b`, `color`, etc.).
     * @param {Record<string,string> | string[]} [attributes={}] - Optional attributes for the opening tag.
     *   - If an object: key-value pairs (e.g., `{ color: "red" }` → `color="red"`).
     *   - If an array: boolean attributes (e.g., `["disabled", "readonly"]`).
     *
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "wrapWithTag",
    value: function wrapWithTag(tagName) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (typeof tagName !== 'string') throw new TypeError('tagName must be a string.');
      var attrStr = this._insertAttr(attributes);
      var openTag = attrStr ? "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName, " ").concat(attrStr).concat(_classPrivateFieldGet(_closeTag, this)) : "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      var closeTag = "".concat(_classPrivateFieldGet(_openTag, this), "/").concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      this.surroundSelection(openTag, closeTag);
      return this;
    }
    /**
     * Inserts a tag with optional inner content.
     * @param {string} tagName - The tag to insert.
     * @param {string} [content=''] - Optional content between tags.
     * @param {Record<string,string> | string[]} [attributes={}] - Optional attributes or list of empty attributes.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "insertTag",
    value: function insertTag(tagName) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (typeof tagName !== 'string') throw new TypeError('tagName must be a string.');
      if (typeof content !== 'string') throw new TypeError('content must be a string.');
      var attrStr = this._insertAttr(attributes);
      var open = attrStr ? "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName, " ").concat(attrStr).concat(_classPrivateFieldGet(_closeTag, this)) : "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      var close = "".concat(_classPrivateFieldGet(_openTag, this), "/").concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      this.insertText("".concat(open).concat(content).concat(close));
      return this;
    }
    /**
     * Inserts a self-closing tag.
     * @param {string} tagName - The tag name.
     * @param {Record<string,string> | string[]} [attributes={}] - Optional attributes or list of empty attributes.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "insertSelfClosingTag",
    value: function insertSelfClosingTag(tagName) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (typeof tagName !== 'string') throw new TypeError('tagName must be a string.');
      var attrStr = this._insertAttr(attributes);
      var tag = attrStr ? "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName, " ").concat(attrStr).concat(_classPrivateFieldGet(_closeTag, this)) : "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
      this.insertText(tag);
      return this;
    }
    /**
     * Toggles a tag around the current selection.
     * Supports tags with attributes. If already wrapped, it unwraps.
     * @param {string} tagName - The tag to toggle.
     * @param {Record<string,string> | string[]} [attributes={}] - Optional attributes to apply when wrapping.
     * @returns {TinyTextRangeEditor}
     */
  }, {
    key: "toggleTag",
    value: function toggleTag(tagName) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (typeof tagName !== 'string') throw new TypeError('tagName must be a string.');
      var selected = this.getSelectedText();
      // Regex: opening tag with optional attributes, and closing tag
      var openRegex = new RegExp("^\\[".concat(tagName, "(\\s+[^\\]]*)?\\]"));
      var closeRegex = new RegExp("\\[/".concat(tagName, "\\]$"));
      var hasOpen = openRegex.test(selected);
      var hasClose = closeRegex.test(selected);
      if (hasOpen && hasClose) {
        var unwrapped = selected.replace(openRegex, '') // remove opening tag
        .replace(closeRegex, ''); // remove closing tag
        this.insertText(unwrapped);
      } else {
        var attrStr = this._insertAttr(attributes);
        var open = attrStr ? "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName, " ").concat(attrStr).concat(_classPrivateFieldGet(_closeTag, this)) : "".concat(_classPrivateFieldGet(_openTag, this)).concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
        var close = "".concat(_classPrivateFieldGet(_openTag, this), "/").concat(tagName).concat(_classPrivateFieldGet(_closeTag, this));
        this.insertText("".concat(open).concat(selected).concat(close));
      }
      return this;
    }
  }]);
}();
var _default = exports["default"] = TinyTextRangeEditor;

},{}],174:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"dup":132}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var defaultWords = ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit', 'sed', 'do', 'eiusmod', 'tempor', 'incididunt', 'ut', 'labore', 'et', 'dolore', 'magna', 'aliqua'];
var defaultEmojis = ['😂', '🌈', '🤖', '💥', '🐸', '🍕', '🦄', '🧠', '🧬', '🚀', '🫠', '💫', '🍩', '👾', '🎉', '🥴', '🐙', '🧃', '🪐', '🎈', '🧸', '👻', '🥳', '🍭', '💖', '😺', '🌮', '🪅', '🎮', '🥓', '🍮'];
var defaultNouns = ['pudding', 'bean', 'snuggle', 'bloop', 'jelly', 'unicorn', 'floof', 'giggle', 'bubble', 'muffin', 'puff', 'pickle', 'goblin', 'waffle', 'sprinkle', 'cupcake', 'fizzle', 'marshmallow', 'duckling', 'sock', 'cloud', 'teacup', 'nugget', 'gnome', 'hug', 'moonbean', 'crayon', 'jiggle', 'glitter', 'carrot', 'goober'];
var defaultVerbs = ['wiggles', 'bounces', 'flies', 'splats', 'scoots', 'giggles', 'wigglesnacks', 'twirls', 'boops', 'pops', 'sings', 'hugs', 'floats', 'glows', 'flaps', 'mlems', 'dances', 'puddles', 'nomnoms', 'wigglejumps', 'sniffs', 'tumbles', 'slides', 'chirps', 'burps', 'sparkles', 'waddles', 'rambles', 'blinks', 'mews'];
var defaultAdjectives = ['fluffy', 'silly', 'yummy', 'squishy', 'wobbly', 'magical', 'tiny', 'sleepy', 'wiggly', 'bubbly', 'glittery', 'fuzzy', 'jiggly', 'sparkly', 'giggly', 'crunchy', 'goofy', 'soft', 'mushy', 'sweet', 'loopy', 'floaty', 'bonkers', 'chewy', 'ticklish', 'dreamy', 'pastel', 'cozy', 'teensy', 'grumbly'];
var defaultTemplates = [
// 🧁 Tiny
'Boop!', 'Wiggle achieved.', 'Oops, {noun} everywhere!', 'Tiny {adj} {noun}, big {adj} {noun}.', 'Snuggle initiated with a {adj} {noun}.', '{adj} vibes only, powered by {noun}.', 'No {noun}, no {noun}.', 'Bounce first, {verb} later.', 'Mlem. {verb}. {noun}.', '{noun} go brrr and {verb}.', 'Why not? {noun} did. Then {noun} followed.',
// 🍬 Simple
'A {adj} {noun} just {verb} near the {adj} window.', 'That {adj} {noun} stole my {noun}!', 'Look, a {adj} {noun} trying to {verb} again!', 'Every {noun} deserves a {adj} nap.', 'The {adj} {noun} is my {adj} spirit animal.', 'Someone call the {noun}, it’s {verb}ing and {verb}ing again!', 'Don’t touch the {adj} {noun}. It {verb}s loudly.', '{noun} forgot how {noun}s work and just {verb}ed.',
// 🍩 Averages
'There once was a {adj} {noun} who loved to {verb} with a {adj} {noun} all day.', 'Apparently, {noun}s are banned from {verb}ing and {verb}ing in the {noun} library.', 'That {adj} noise? Just a {noun} learning to {verb} on a {adj} {noun}.', 'I saw a {adj} {noun} {verb} so hard, it became a {adj} muffin.', 'The {adj} {noun} met a {adj} pickle and everything {verb}ed.', '{noun}s are like {noun}: {adj}, unpredictable, and wiggly.', 'Don’t judge a {adj} {noun} by its ability to {verb}, or by its {adj} hat.', 'All I wanted was peace, but a {adj} {noun} with a {adj} {noun} had other plans.',
// 🍓 Giants
'One {adj} morning, a {adj} {noun} decided it was finally time to {verb}, but halfway through, it tripped on a {noun} and turned into a {adj} marshmallow.', 'I tried to be {adj} today, but then a {noun} {verb}ed across my {noun} and typed “asdfgh{noun}” repeatedly.', 'If you think you’ve seen everything, wait until a {adj} {noun} {verb}s on a {noun} wearing {adj} socks with tiny {noun}s.', 'No one ever believed the stories about the ancient {adj} {noun} who could {verb} with such {adj} grace that entire {noun}s turned pink out of embarrassment.', 'A curious {adj} {noun} wandered into a {noun} shop, not knowing that its destiny involved twelve {adj} {noun}s, one rubber {noun}, and a suspiciously quiet {adj} llama.',
// 🍒 Giants and narratives
'In a land where every {adj} {noun} was made of pudding and the sky was {adj} whipped cream, one brave {adj} {noun} set out to discover the legendary Spoon of {noun}s, facing obstacles like bouncing {noun}s, sassy {noun}s, and the Great Wobble of the {noun}.', 'Once upon a {adj} time, long before the {noun}s learned to {verb}, there existed a tiny {adj} {noun} who dreamed of swimming in a pool made entirely of {adj} glitter pudding while {verb}ing off-key lullabies to passing {noun}s with monocles.', 'The Council of {noun}s gathered in {adj} secret when the sacred {adj} {noun} started to {verb} uncontrollably, threatening the entire {adj} dessert-based civilization with spontaneous {noun} jiggles and uncontainable {noun} fits across the {noun}.',
// ☎️ Chats and chats
'Hey... do you ever wonder if {noun}s dream of {noun}s?', 'Okay but hear me out: what if the {adj} {noun} could actually {verb} backwards?', 'Can we talk about the {noun} that just {verb}ed and vanished?', 'So I was talking to a {noun}, and it told me to stop being {adj}. Rude.', 'Not to alarm you, but there’s a {adj} {noun} behind you doing the {verb}.', 'Why does this {noun} keep staring at me like I owe it pudding?', 'Is this a safe space to admit I accidentally {verb}ed a {noun}?', 'I just walked into the room and someone shouted “{adj} {noun}!” — what did I miss?', 'Wait... we were supposed to bring a {noun}? No one told me!', 'Okay but what if the {adj} {noun} has feelings too?', 'Be honest, do I look like a {noun} that forgot how to {verb}?', 'If I say "oops", do I still have to explain why the {noun} is glowing?', 'I don’t know what’s going on but I brought snacks and a confused {noun}.', 'Do you think pudding knows it’s pudding? Just a thought.', 'Is this about the time I {verb}ed the {adj} {noun} by accident? Because I can explain.',
// 🌀 Confusions, unexpected entrances, lost people
'Wait, are we talking about {noun}s or am I on the wrong chat again?', 'What is this group even about? I just saw "pudding" and joined.', 'Hi! I have no idea what’s happening but I’m here and I brought a {noun}.', 'I blinked and now there’s a {adj} {noun} in charge of everything.', 'Can someone please explain why the {noun} is floating and chanting?', 'Okay who gave the {noun} access to glitter and emotional support pickles?', 'I came for a calm discussion and now there’s a {adj} battle between {noun}s.', 'Not sure if I’m early, late, or inside a {noun} dream.', 'I was gone for 3 minutes and now someone’s riding a {noun} into the pudding realm.', 'This isn’t the pudding appreciation group, is it? ...oh no.', 'So... who summoned the {adj} {noun} this time? Be honest.', 'I came here for vibes and stayed for the {noun}s.', 'Does anyone else hear faint giggling or is that just the {adj} {noun} again?', 'I feel like I missed step one, two, and also three of this conversation.', 'All I asked was “what’s up?” and now I’m emotionally attached to a {noun}.',
// 💬 More interactive chat style
'Me: "I’ll be normal today." Also me: *{verb}s into a meeting riding a {adj} {noun}*', '"It’s just pudding," they said. "It can’t hurt you," they said. They were wrong.', 'I said one nice thing to a {noun} and now it follows me everywhere.', 'Can we take a moment to appreciate how the {adj} {noun} is just vibing?', 'Who put a tiny hat on the {noun}? Because that’s adorable.', 'My life has been different ever since the {noun} started {verb}ing.', 'Raise your hand if you’ve ever been personally attacked by a {adj} {noun}.', '"Don’t be weird," they said. So I became a {noun} instead.', 'Do {noun}s have feelings? Asking for a {adj} friend.', 'I trusted the {noun} and all I got was a glitter-covered sock.', 'Plot twist: the {adj} {noun} was inside us all along.',
// Mini cute explosions and chaos
'The {adj} {noun} {verb} and {verb} all over the {adj} {noun}!', 'Oops! {noun}s {verb}ed into the {adj} {noun} while {verb}ing crazily.', '{adj}, {adj}, and more {adj} {noun}s just {verb}ed by!', 'Why does the {adj} {noun} keep {verb}ing and {verb}ing without stopping?', 'Look! A {adj} {noun}, a {adj} {noun}, and a {noun} all {verb}ing together!', 'Sometimes, the {noun} just {verb}s, then {verb}s again, and never stops being {adj}.',
// Phrases with repetition and multiple spaces for chaos
'{noun}, {noun}, and {noun} — all {verb}ing and {verb}ing in a {adj} {noun}.', 'I saw a {adj} {noun} {verb}, then another {noun} {verb}ing with a {adj} {noun}.', 'The {noun} {verb}s {verb} while the {adj} {noun} {verb}s and the {noun} just {verb}s.', 'Can a {adj} {noun} {verb} {verb} without a {adj} {noun} watching?',
// Phrases with interactions and breaks for fun
'Whoa! The {adj} {noun} just {verb}ed... and then {verb}ed again!', 'Hey... did you see that {adj} {noun} {verb} over there?', 'Umm, the {noun} is {verb}ing but also {verb}ing and {verb}ing!', 'Lol! {noun}s {verb} so {adj}ly, it’s impossible not to giggle.',
// Mini exaggerated and cute dialogues
'"Hey! What’s up?" asked the {adj} {noun}, who {verb}ed loudly.', '"I’m just a {adj} {noun} trying to {verb}, you know?"', '"Did you see the {adj} {noun} that just {verb}ed in the pudding?"', '"No way! The {noun} {verb}s better than me!"', '"Wait, the {adj} {noun} said it would {verb}, but it {verb}ed instead!"',
// Extensive, crazy and fun narrative phrases
'Once upon a {adj} {noun}, a group of {adj} {noun}s {verb}ed through the {adj} forest, singing {adj} songs and eating {noun}s made of pudding.', 'The legend tells of a {adj} {noun} who could {verb} faster than any {noun} ever seen, leaving trails of {adj} sparkles behind.', 'Every day, the {adj} {noun} would {verb} around the {adj} meadow, trying to convince the {noun}s to join the grand pudding party.', 'No one knows why the {adj} {noun} suddenly {verb}ed and then {verb}ed again, but everyone agrees it was the cutest thing they ever saw.', 'In the kingdom of {adj} {noun}s, only the bravest {noun} dared to {verb} the giant pudding monster, armed with nothing but {adj} smiles and jellybeans.',
// Total cases with many placeholders
'{adj} {noun} {verb} {verb} {verb} {noun} {verb} {adj} {noun} {verb} {noun}!', '{noun} {noun} {verb} {adj} {noun} and then {verb} {verb} the {adj} {noun}.', '{verb} the {adj} {noun}, then {verb} the {noun} while {verb}ing {adj}ly.', 'Can the {adj} {noun} {verb} and {verb} the {adj} {noun} at the same time?', '{noun} {verb} {noun} {verb}, but the {adj} {noun} {verb}s better.',
// Frases with cute interjections and silly sounds
'Boop! The {adj} {noun} just {verb}ed in the pudding.', 'Bloop bloop, the {noun} is {verb}ing all over again!', 'Mlem mlem, a {adj} {noun} {verb}s quietly in the corner.', 'Splat! {noun} {verb}ed right on the {adj} {noun}.', 'Yum! A {adj} {noun} just {verb}ed in my mouth.',
// Phrases with silly questions
'Do {noun}s really {verb} when nobody’s watching?', 'Why does the {adj} {noun} always {verb} at midnight?', 'Can a {noun} be too {adj} to {verb} properly?', 'Is it normal for a {adj} {noun} to {verb} three times in a row?', 'Who taught the {noun} to {verb} like that?',
// Frases of confusion and fun surprises
'Wait, did the {adj} {noun} just {verb} itself?', 'I can’t believe the {noun} {verb}ed into a {adj} {noun}!', 'Suddenly, a {adj} {noun} appeared and started to {verb} wildly.', 'That {noun} was {verb}ing so {adj}ly it broke the pudding meter.', 'Everyone’s talking about the {adj} {noun} that {verb}ed out of nowhere.'];
/**
 * @typedef {'mixed'|'readable'|'chaotic'|'natural'} RandomMsgModes
 * Defines how the message content is generated:
 * - `mixed`: Combines readable words, gibberish, symbols, emojis, etc.
 * - `readable`: Focuses on human-readable words only.
 * - `chaotic`: Pure chaos, mostly gibberish and symbols.
 * - `natural`: Uses structured grammar templates to form silly but proper sentences.
 */
/**
 * @typedef {'inline'|'end'|'none'} EmojiPlacement
 * Controls where emojis are placed:
 * - `inline`: Emojis may appear throughout the text.
 * - `end`: Emojis appear at the end of lines.
 * - `none`: No emojis will be used.
 */
/**
 * @typedef {Object} MsgGenConfig
 * Configuration object for customizing message generation.
 *
 * @property {number} minLength - Minimum total length (in characters) of the final generated text.
 * @property {number} maxLength - Maximum total length (in characters) of the final generated text.
 * @property {boolean} readable - Whether to favor readable word-like strings.
 * @property {boolean} useEmojis - Whether emojis are allowed in the generated content.
 * @property {boolean} includeNumbers - Whether random numbers can appear in the text.
 * @property {boolean} includeSymbols - Whether random symbols (e.g., !@#) are included.
 * @property {boolean} allowWeirdSpacing - Enables fun spacing effects (e.g., extra spaces, newlines, uppercase words).
 *
 * @property {string[]} emojiSet - List of emojis to choose from. Overrides default set if provided.
 * @property {string[]} wordSet - List of base words used in readable and mixed modes.
 *
 * @property {RandomMsgModes} mode - Determines the overall generation strategy (`mixed`, `readable`, `chaotic`, or `natural`).
 *
 * @property {Object} grammar - Grammar configuration used when `mode` is set to `'natural'`.
 * @property {string[]} grammar.templates - Sentence templates using placeholders (`{noun}`, `{verb}`, `{adj}`).
 * @property {string[]} grammar.nouns - List of nouns to insert into `{noun}` placeholders.
 * @property {string[]} grammar.verbs - List of verbs to insert into `{verb}` placeholders.
 * @property {string[]} grammar.adjectives - List of adjectives to insert into `{adj}` placeholders.
 *
 * @property {boolean} repeatWords - If false, avoids repeating the same word within a single generation.
 * @property {EmojiPlacement} emojiPlacement - Controls how emojis are placed in the text.
 *
 * @property {Object} [paragraphs] - Optional paragraph configuration.
 * @property {number} paragraphs.min - Minimum number of paragraphs to generate.
 * @property {number} paragraphs.max - Maximum number of paragraphs to generate.
 *
 * @property {Object} line - Configuration for line-based generation.
 * @property {number} line.minLength - Minimum number of characters per line.
 * @property {number} line.maxLength - Maximum number of characters per line.
 * @property {number} line.emojiChance - Probability (0 to 1) that a line will end with an emoji when allowed.
 */
/**
 * UltraRandomMsgGen - Phrase templates and word lists
 *
 * Portions of the templates, word sets, and phrase structures
 * were generated and expanded by ChatGPT (OpenAI).
 *
 * This content was crafted to produce innocent, playful, and diverse
 * random messages focused on a pudding-themed, whimsical style.
 *
 * @class
 */
var UltraRandomMsgGen = /*#__PURE__*/function () {
  /**
   * Creates an instance of UltraRandomMsgGen.
   *
   * @param {Object} [config={}] - Configuration object to customize the generator.
   * @param {number} [config.minLength=10] - Minimum total length (in characters) of generated text.
   * @param {number} [config.maxLength=300] - Maximum total length (in characters) of generated text.
   * @param {boolean} [config.readable=true] - Whether to generate readable words or random strings.
   * @param {boolean} [config.useEmojis=true] - Whether to include emojis in the generated text.
   * @param {boolean} [config.includeNumbers=true] - Whether to include numbers randomly.
   * @param {boolean} [config.includeSymbols=true] - Whether to include symbols randomly.
   * @param {boolean} [config.allowWeirdSpacing=false] - Whether to allow weird spacing (newlines, extra spaces, uppercase).
   * @param {string[]} [config.emojiSet] - Array of emojis to use (defaults to internal emoji set).
   * @param {string[]} [config.wordSet] - Array of words to use (defaults to internal word set).
   * @param {RandomMsgModes} [config.mode='mixed'] - Mode of text generation.
   * @param {Object} [config.grammar] - Grammar configuration with templates and word categories.
   * @param {string[]} [config.grammar.templates] - Array of string templates with placeholders for generating sentences.
   * @param {string[]} [config.grammar.nouns] - Array of noun strings for template substitution.
   * @param {string[]} [config.grammar.verbs] - Array of verb strings for template substitution.
   * @param {string[]} [config.grammar.adjectives] - Array of adjective strings for template substitution.
   * @param {boolean} [config.repeatWords=true] - Whether to allow repeating words in the output.
   * @param {EmojiPlacement} [config.emojiPlacement='inline'] - Placement mode for emojis in generated text.
   * @param {Object} [config.paragraphs] - Paragraph configuration object or null for single block text.
   * @param {number} [config.paragraphs.min] - Minimum number of paragraphs to generate.
   * @param {number} [config.paragraphs.max] - Maximum number of paragraphs to generate.
   * @param {Object} [config.line] - Line configuration for generated text.
   * @param {number} [config.line.minLength=20] - Minimum length (characters) per line.
   * @param {number} [config.line.maxLength=120] - Maximum length (characters) per line.
   * @param {number} [config.line.emojiChance=0.3] - Probability (0–1) of placing emoji per line.
   */
  function UltraRandomMsgGen() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, UltraRandomMsgGen);
    /** @type {MsgGenConfig} */
    _defineProperty(this, "config", {
      minLength: 10,
      maxLength: 300,
      readable: true,
      useEmojis: true,
      includeNumbers: true,
      includeSymbols: true,
      allowWeirdSpacing: false,
      emojiSet: [],
      wordSet: [],
      mode: 'mixed',
      // 'mixed', 'readable', 'chaotic'
      grammar: {
        templates: [],
        nouns: [],
        verbs: [],
        adjectives: []
      },
      repeatWords: true,
      emojiPlacement: 'inline',
      // 'inline' | 'end' | 'none'
      line: {
        minLength: 20,
        maxLength: 120,
        emojiChance: 0.3 // 30% chance per line
      }
    });
    this.symbols = '!@#$%^&*()-_=+[]{}|;:,.<>?/\\~'.split('');
    var minLength = config.minLength,
      maxLength = config.maxLength,
      readable = config.readable,
      useEmojis = config.useEmojis,
      includeNumbers = config.includeNumbers,
      includeSymbols = config.includeSymbols,
      allowWeirdSpacing = config.allowWeirdSpacing,
      emojiSet = config.emojiSet,
      wordSet = config.wordSet,
      mode = config.mode,
      grammar = config.grammar,
      repeatWords = config.repeatWords,
      emojiPlacement = config.emojiPlacement,
      paragraphs = config.paragraphs,
      line = config.line;
    // Validations
    if (minLength !== undefined && (!Number.isInteger(minLength) || minLength < 1)) {
      throw new TypeError('config.minLength must be an integer >= 1');
    }
    if (maxLength !== undefined && (!Number.isInteger(maxLength) || maxLength < 1)) {
      throw new TypeError('config.maxLength must be an integer >= 1');
    }
    if (minLength !== undefined && maxLength !== undefined && minLength > maxLength) {
      throw new RangeError('config.minLength cannot be greater than config.maxLength');
    }
    if (readable !== undefined && typeof readable !== 'boolean') {
      throw new TypeError('config.readable must be a boolean');
    }
    if (useEmojis !== undefined && typeof useEmojis !== 'boolean') {
      throw new TypeError('config.useEmojis must be a boolean');
    }
    if (includeNumbers !== undefined && typeof includeNumbers !== 'boolean') {
      throw new TypeError('config.includeNumbers must be a boolean');
    }
    if (includeSymbols !== undefined && typeof includeSymbols !== 'boolean') {
      throw new TypeError('config.includeSymbols must be a boolean');
    }
    if (allowWeirdSpacing !== undefined && typeof allowWeirdSpacing !== 'boolean') {
      throw new TypeError('config.allowWeirdSpacing must be a boolean');
    }
    if (emojiSet !== undefined && !Array.isArray(emojiSet)) {
      throw new TypeError('config.emojiSet must be an array of strings');
    }
    if (wordSet !== undefined && !Array.isArray(wordSet)) {
      throw new TypeError('config.wordSet must be an array of strings');
    }
    if (mode !== undefined && !['mixed', 'readable', 'chaotic', 'natural'].includes(mode)) {
      throw new RangeError('config.mode must be one of: "mixed", "readable", "chaotic", "natural');
    }
    if (grammar !== undefined) {
      if (_typeof(grammar) !== 'object' || grammar === null) {
        throw new TypeError('config.grammar must be an object');
      }
      var templates = grammar.templates,
        nouns = grammar.nouns,
        verbs = grammar.verbs,
        adjectives = grammar.adjectives;
      if (templates !== undefined && !Array.isArray(templates)) {
        throw new TypeError('config.grammar.templates must be an array of strings');
      }
      if (nouns !== undefined && !Array.isArray(nouns)) {
        throw new TypeError('config.grammar.nouns must be an array of strings');
      }
      if (verbs !== undefined && !Array.isArray(verbs)) {
        throw new TypeError('config.grammar.verbs must be an array of strings');
      }
      if (adjectives !== undefined && !Array.isArray(adjectives)) {
        throw new TypeError('config.grammar.adjectives must be an array of strings');
      }
    }
    if (repeatWords !== undefined && typeof repeatWords !== 'boolean') {
      throw new TypeError('config.repeatWords must be a boolean');
    }
    if (emojiPlacement !== undefined && !['inline', 'end', 'none'].includes(emojiPlacement)) {
      throw new RangeError('config.emojiPlacement must be one of: "inline", "end", "none"');
    }
    if (paragraphs !== undefined) {
      if (_typeof(paragraphs) !== 'object') {
        throw new TypeError('config.paragraphs must be an object or null');
      }
      var min = paragraphs.min,
        max = paragraphs.max;
      if (min !== undefined && (!Number.isInteger(min) || min < 1)) {
        throw new TypeError('config.paragraphs.min must be an integer >= 1');
      }
      if (max !== undefined && (!Number.isInteger(max) || max < 1)) {
        throw new TypeError('config.paragraphs.max must be an integer >= 1');
      }
      if (min !== undefined && max !== undefined && min > max) {
        throw new RangeError('config.paragraphs.min cannot be greater than config.paragraphs.max');
      }
    }
    if (line !== undefined) {
      if (_typeof(line) !== 'object' || line === null) {
        throw new TypeError('config.line must be an object');
      }
      var lineMin = line.minLength,
        lineMax = line.maxLength,
        emojiChance = line.emojiChance;
      if (lineMin !== undefined && (!Number.isInteger(lineMin) || lineMin < 1)) {
        throw new TypeError('config.line.minLength must be an integer >= 1');
      }
      if (lineMax !== undefined && (!Number.isInteger(lineMax) || lineMax < 1)) {
        throw new TypeError('config.line.maxLength must be an integer >= 1');
      }
      if (lineMin !== undefined && lineMax !== undefined && lineMin > lineMax) {
        throw new RangeError('config.line.minLength cannot be greater than config.line.maxLength');
      }
      if (emojiChance !== undefined && (typeof emojiChance !== 'number' || emojiChance < 0 || emojiChance > 1)) {
        throw new RangeError('config.line.emojiChance must be a number between 0 and 1');
      }
    }
    this.config.emojiSet = [].concat(defaultEmojis);
    this.config.wordSet = [].concat(defaultWords);
    this.config.grammar.templates = [].concat(defaultTemplates);
    this.config.grammar.nouns = [].concat(defaultNouns);
    this.config.grammar.verbs = [].concat(defaultVerbs);
    this.config.grammar.adjectives = [].concat(defaultAdjectives);
    Object.assign(this.config, config);
  }
  /**
   * Merges new configuration values into the current instance.
   * @param {Object} newConfig - Object with one or more configuration overrides.
   * @returns {UltraRandomMsgGen} - The instance for chaining.
   */
  return _createClass(UltraRandomMsgGen, [{
    key: "configure",
    value: function configure() {
      var newConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.assign(this.config, newConfig);
      return this;
    }
    /**
     * Replaces the entire list of grammar templates.
     * @param {...string[]} templates - One or more arrays or strings containing sentence templates.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setGrammarTemplates",
    value: function setGrammarTemplates() {
      for (var _len = arguments.length, templates = new Array(_len), _key = 0; _key < _len; _key++) {
        templates[_key] = arguments[_key];
      }
      this.config.grammar.templates = templates.flat();
      return this;
    }
    /**
     * Adds new grammar templates to the existing list.
     * @param {...string[]} templates - One or more arrays or strings containing sentence templates.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addGrammarTemplates",
    value: function addGrammarTemplates() {
      var _this$config$grammar$;
      for (var _len2 = arguments.length, templates = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        templates[_key2] = arguments[_key2];
      }
      (_this$config$grammar$ = this.config.grammar.templates).push.apply(_this$config$grammar$, _toConsumableArray(templates.flat()));
      return this;
    }
    /**
     * Replaces the list of noun words used in grammar templates.
     * @param {...string[]} nouns - One or more arrays or strings of nouns.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setGrammarNouns",
    value: function setGrammarNouns() {
      for (var _len3 = arguments.length, nouns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        nouns[_key3] = arguments[_key3];
      }
      this.config.grammar.nouns = nouns.flat();
      return this;
    }
    /**
     * Adds noun words to the existing list used in grammar templates.
     * @param {...string[]} nouns - One or more arrays or strings of nouns.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addGrammarNouns",
    value: function addGrammarNouns() {
      var _this$config$grammar$2;
      for (var _len4 = arguments.length, nouns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        nouns[_key4] = arguments[_key4];
      }
      (_this$config$grammar$2 = this.config.grammar.nouns).push.apply(_this$config$grammar$2, _toConsumableArray(nouns.flat()));
      return this;
    }
    /**
     * Replaces the list of verb words used in grammar templates.
     * @param {...string[]} verbs - One or more arrays or strings of verbs.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setGrammarVerbs",
    value: function setGrammarVerbs() {
      for (var _len5 = arguments.length, verbs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        verbs[_key5] = arguments[_key5];
      }
      this.config.grammar.verbs = verbs.flat();
      return this;
    }
    /**
     * Adds verb words to the existing list used in grammar templates.
     * @param {...string[]} verbs - One or more arrays or strings of verbs.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addGrammarVerbs",
    value: function addGrammarVerbs() {
      var _this$config$grammar$3;
      for (var _len6 = arguments.length, verbs = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        verbs[_key6] = arguments[_key6];
      }
      (_this$config$grammar$3 = this.config.grammar.verbs).push.apply(_this$config$grammar$3, _toConsumableArray(verbs.flat()));
      return this;
    }
    /**
     * Replaces the list of adjective words used in grammar templates.
     * @param {...string[]} adjectives - One or more arrays or strings of adjectives.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setGrammarAdjectives",
    value: function setGrammarAdjectives() {
      for (var _len7 = arguments.length, adjectives = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        adjectives[_key7] = arguments[_key7];
      }
      this.config.grammar.adjectives = adjectives.flat();
      return this;
    }
    /**
     * Adds adjective words to the existing list used in grammar templates.
     * @param {...string[]} adjectives - One or more arrays or strings of adjectives.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addGrammarAdjectives",
    value: function addGrammarAdjectives() {
      var _this$config$grammar$4;
      for (var _len8 = arguments.length, adjectives = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        adjectives[_key8] = arguments[_key8];
      }
      (_this$config$grammar$4 = this.config.grammar.adjectives).push.apply(_this$config$grammar$4, _toConsumableArray(adjectives.flat()));
      return this;
    }
    /**
     * Removes specific grammar templates from the current list.
     * @param {...string[]} templates - One or more arrays or strings of templates to remove.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeGrammarTemplates",
    value: function removeGrammarTemplates() {
      for (var _len9 = arguments.length, templates = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        templates[_key9] = arguments[_key9];
      }
      var removeSet = new Set(templates.flat());
      this.config.grammar.templates = this.config.grammar.templates.filter(function (t) {
        return !removeSet.has(t);
      });
      return this;
    }
    /**
     * Removes specific noun words from the grammar noun list.
     * @param {...string[]} nouns - One or more arrays or strings of nouns to remove.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeGrammarNouns",
    value: function removeGrammarNouns() {
      for (var _len0 = arguments.length, nouns = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {
        nouns[_key0] = arguments[_key0];
      }
      var removeSet = new Set(nouns.flat());
      this.config.grammar.nouns = this.config.grammar.nouns.filter(function (n) {
        return !removeSet.has(n);
      });
      return this;
    }
    /**
     * Removes specific verb words from the grammar verb list.
     * @param {...string[]} verbs - One or more arrays or strings of verbs to remove.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeGrammarVerbs",
    value: function removeGrammarVerbs() {
      for (var _len1 = arguments.length, verbs = new Array(_len1), _key1 = 0; _key1 < _len1; _key1++) {
        verbs[_key1] = arguments[_key1];
      }
      var removeSet = new Set(verbs.flat());
      this.config.grammar.verbs = this.config.grammar.verbs.filter(function (v) {
        return !removeSet.has(v);
      });
      return this;
    }
    /**
     * Removes specific adjective words from the grammar adjective list.
     * @param {...string[]} adjectives - One or more arrays or strings of adjectives to remove.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeGrammarAdjectives",
    value: function removeGrammarAdjectives() {
      for (var _len10 = arguments.length, adjectives = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        adjectives[_key10] = arguments[_key10];
      }
      var removeSet = new Set(adjectives.flat());
      this.config.grammar.adjectives = this.config.grammar.adjectives.filter(function (a) {
        return !removeSet.has(a);
      });
      return this;
    }
    /**
     * Replaces the entire word set used in readable/mixed modes.
     * @param {...string[]} words - One or more arrays or strings of words.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setWords",
    value: function setWords() {
      for (var _len11 = arguments.length, words = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        words[_key11] = arguments[_key11];
      }
      this.config.wordSet = words.flat();
      return this;
    }
    /**
     * Adds new words to the word set used in readable/mixed modes.
     * @param {...string[]} words - One or more arrays or strings of words.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addWords",
    value: function addWords() {
      var _this$config$wordSet;
      for (var _len12 = arguments.length, words = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        words[_key12] = arguments[_key12];
      }
      (_this$config$wordSet = this.config.wordSet).push.apply(_this$config$wordSet, _toConsumableArray(words.flat()));
      return this;
    }
    /**
     * Removes specific words from the word set.
     * @param {...string[]} words - Words to be removed.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeWords",
    value: function removeWords() {
      for (var _len13 = arguments.length, words = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        words[_key13] = arguments[_key13];
      }
      var removeSet = new Set(words.flat());
      this.config.wordSet = this.config.wordSet.filter(function (word) {
        return !removeSet.has(word);
      });
      return this;
    }
    /**
     * Replaces the emoji set used in generated output.
     * @param {...string[]} emojis - One or more arrays or strings of emojis.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "setEmojis",
    value: function setEmojis() {
      for (var _len14 = arguments.length, emojis = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        emojis[_key14] = arguments[_key14];
      }
      this.config.emojiSet = emojis.flat();
      return this;
    }
    /**
     * Adds new emojis to the emoji set.
     * @param {...string[]} emojis - One or more arrays or strings of emojis.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "addEmojis",
    value: function addEmojis() {
      var _this$config$emojiSet;
      for (var _len15 = arguments.length, emojis = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        emojis[_key15] = arguments[_key15];
      }
      (_this$config$emojiSet = this.config.emojiSet).push.apply(_this$config$emojiSet, _toConsumableArray(emojis.flat()));
      return this;
    }
    /**
     * Removes specific emojis from the emoji set.
     * @param {...string[]} emojis - Emojis to be removed.
     * @returns {UltraRandomMsgGen} - The instance for chaining.
     */
  }, {
    key: "removeEmojis",
    value: function removeEmojis() {
      for (var _len16 = arguments.length, emojis = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        emojis[_key16] = arguments[_key16];
      }
      var removeSet = new Set(emojis.flat());
      this.config.emojiSet = this.config.emojiSet.filter(function (emoji) {
        return !removeSet.has(emoji);
      });
      return this;
    }
    /**
     * Returns a random item from an array.
     * @private
     * @param {string[]} array - Array to pick from.
     * @returns {string} - Random item from array.
     */
  }, {
    key: "_getRandomItem",
    value: function _getRandomItem(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    /**
     * Generates a single random content chunk based on the mode and settings.
     * @private
     * @returns {string} - A chunk (word, emoji, symbol, number, etc.).
     */
  }, {
    key: "_generateChunk",
    value: function _generateChunk() {
      var _this$config = this.config,
        wordSet = _this$config.wordSet,
        emojiSet = _this$config.emojiSet,
        includeNumbers = _this$config.includeNumbers,
        includeSymbols = _this$config.includeSymbols,
        useEmojis = _this$config.useEmojis,
        readable = _this$config.readable,
        mode = _this$config.mode,
        emojiPlacement = _this$config.emojiPlacement;
      if (mode === 'natural') {
        return this._generateNaturalSentence();
      }
      var pools = [];
      if (readable || mode === 'readable' || mode === 'mixed') {
        pools.push(this._getRandomItem(wordSet));
      }
      if (mode === 'chaotic' || mode === 'mixed') {
        pools.push(Math.random().toString(36).slice(2));
      }
      if (includeNumbers) {
        pools.push(Math.floor(Math.random() * 99999).toString());
      }
      if (includeSymbols) {
        pools.push(this._getRandomItem(this.symbols));
      }
      if (emojiPlacement === 'inline' && useEmojis && emojiSet.length) {
        pools.push(this._getRandomItem(emojiSet));
      }
      return this._getRandomItem(pools);
    }
    /**
     * Generates a natural sentence by replacing placeholders in a template.
     * @private
     * @returns {string} - A generated sentence.
     */
  }, {
    key: "_generateNaturalSentence",
    value: function _generateNaturalSentence() {
      var _this = this;
      var _this$config$grammar = this.config.grammar,
        templates = _this$config$grammar.templates,
        nouns = _this$config$grammar.nouns,
        verbs = _this$config$grammar.verbs,
        adjectives = _this$config$grammar.adjectives;
      var template = this._getRandomItem(templates);
      return template.replace(/{noun}/g, function () {
        return _this._getRandomItem(nouns);
      }).replace(/{verb}/g, function () {
        return _this._getRandomItem(verbs);
      }).replace(/{adj}/g, function () {
        return _this._getRandomItem(adjectives);
      });
    }
    /**
     * Generates a single line of text with target length and rules.
     * @private
     * @param {number} targetLength - Target character length for the line.
     * @param {Set<string>} [seenWords] - Set of already used words (for avoiding repeats).
     * @returns {string} - A generated line.
     */
  }, {
    key: "_generateLine",
    value: function _generateLine(targetLength, seenWords) {
      var _this$config2 = this.config,
        allowWeirdSpacing = _this$config2.allowWeirdSpacing,
        repeatWords = _this$config2.repeatWords,
        readable = _this$config2.readable,
        emojiSet = _this$config2.emojiSet,
        useEmojis = _this$config2.useEmojis,
        emojiPlacement = _this$config2.emojiPlacement,
        line = _this$config2.line;
      var parts = [];
      seenWords !== null && seenWords !== void 0 ? seenWords : seenWords = new Set();
      while (parts.join(' ').length < targetLength) {
        var chunk = this._generateChunk();
        if (!repeatWords && seenWords.has(chunk)) continue;
        seenWords.add(chunk);
        if (allowWeirdSpacing) {
          if (Math.random() < 0.1) chunk = '\n' + chunk;
          if (Math.random() < 0.1) chunk = '   ' + chunk;
          if (Math.random() < 0.05) chunk = chunk.toUpperCase();
        }
        parts.push(chunk);
      }
      var lineText = parts.join(readable ? ' ' : '');
      if (emojiPlacement === 'end' && useEmojis && emojiSet.length && Math.random() < ((line === null || line === void 0 ? void 0 : line.emojiChance) || 0)) {
        lineText += ' ' + this._getRandomItem(emojiSet);
      }
      return lineText;
    }
    /**
     * Generates lines to form a paragraph based on total length.
     * @private
     * @param {number} totalLength - Total target character count for the paragraph.
     * @returns {string[]} - Array of lines that form the paragraph.
     */
  }, {
    key: "_generateParagraphLines",
    value: function _generateParagraphLines(totalLength) {
      var line = this.config.line;
      var lines = [];
      var seenWords = new Set();
      var currentTotal = 0;
      while (currentTotal < totalLength) {
        var lineLength = Math.floor(Math.random() * (line.maxLength - line.minLength + 1) + line.minLength);
        var adjustedLength = Math.min(lineLength, totalLength - currentTotal);
        lines.push(this._generateLine(adjustedLength, seenWords));
        currentTotal += adjustedLength;
      }
      return lines;
    }
    /**
     * Generates the final random message, which can be a paragraph or block of lines.
     * Uses full configuration rules (grammar, symbols, emojis, etc).
     * @returns {string} - A full generated message.
     */
  }, {
    key: "generate",
    value: function generate() {
      var _this$config3 = this.config,
        minLength = _this$config3.minLength,
        maxLength = _this$config3.maxLength,
        paragraphs = _this$config3.paragraphs;
      var totalLength = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
      if (paragraphs && _typeof(paragraphs) === 'object') {
        var paraCount = Math.floor(Math.random() * (paragraphs.max - paragraphs.min + 1)) + paragraphs.min;
        var approxLength = Math.floor(totalLength / paraCount);
        var paragraphsArray = [];
        for (var i = 0; i < paraCount; i++) {
          var lines = this._generateParagraphLines(approxLength);
          paragraphsArray.push(lines.join('\n'));
        }
        return paragraphsArray.join('\n\n');
      }
      return this._generateParagraphLines(totalLength).join('\n');
    }
  }]);
}();
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultWords", defaultWords);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultEmojis", defaultEmojis);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultNouns", defaultNouns);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultVerbs", defaultVerbs);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultAdjectives", defaultAdjectives);
/** @type {string[]} */
_defineProperty(UltraRandomMsgGen, "defaultTemplates", defaultTemplates);
var _default = exports["default"] = UltraRandomMsgGen;

},{}],176:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.createSingleton = exports.animateFill = void 0;
exports.delegate = delegate;
exports.sticky = exports.roundArrow = exports.inlinePositioning = exports.hideAll = exports.followCursor = void 0;
var _core = require("@popperjs/core");
/**!
* tippy.js v6.3.7
* (c) 2017-2021 atomiks
* MIT License
*/

var ROUND_ARROW = exports.roundArrow = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }
  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (obj[key] !== undefined) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement('div');
}
function isElement(value) {
  return ['Element', 'Fragment'].some(function (type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, 'NodeList');
}
function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements),
    element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body

  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
    clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
      popperState = _ref.popperState,
      props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
  // `webkitTransitionEnd`...

  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    box[method](event, listener);
  });
}
/**
 * Compared to xxx.contains, this function works for dom structures with shadow
 * dom
 */

function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener('blur', onWindowBlur);
}
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var isIE11 = isBrowser ?
// @ts-ignore
!!window.msCrypto : false;
function createMemoryLeakWarning(method) {
  var txt = method === 'destroy' ? 'n already-' : ' ';
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [getDevMessage(message),
  // title
  'color: #00C584; font-size: 1.3em; font-weight: bold;',
  // message
  'line-height: 1.5',
  // footer
  'color: #a6a095;'];
} // Assume warnings and errors never have the same message

var visitedMessages;
if (process.env.NODE_ENV !== "production") {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: 'fade',
  arrow: true,
  content: '',
  inertia: false,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: 'auto',
    expanded: 'auto'
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: '',
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  onClickOutside: function onClickOutside() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps(partialProps) {
  /* istanbul ignore else */
  if (process.env.NODE_ENV !== "production") {
    validateProps(partialProps, []);
  }
  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
      defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps);
}
function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys = Object.keys(partialProps);
  keys.forEach(function (prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function (plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
  });
}
var innerHTML = function innerHTML() {
  return 'innerHTML';
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow = div();
  if (value === true) {
    arrow.className = ARROW_CLASS;
  } else {
    arrow.className = SVG_ARROW_CLASS;
    if (isElement(value)) {
      arrow.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow, value);
    }
  }
  return arrow;
}
function setContent(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, '');
    content.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box: box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute('data-state', 'hidden');
  box.setAttribute('tabindex', '-1');
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');
  setContent(content, instance.props);
  popper.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper),
      box = _getChildren.box,
      content = _getChildren.content,
      arrow = _getChildren.arrow;
    if (nextProps.theme) {
      box.setAttribute('data-theme', nextProps.theme);
    } else {
      box.removeAttribute('data-theme');
    }
    if (typeof nextProps.animation === 'string') {
      box.setAttribute('data-animation', nextProps.animation);
    } else {
      box.removeAttribute('data-animation');
    }
    if (nextProps.inertia) {
      box.setAttribute('data-inertia', '');
    } else {
      box.removeAttribute('data-inertia');
    }
    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box.setAttribute('role', nextProps.role);
    } else {
      box.removeAttribute('role');
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow) {
        box.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box.removeChild(arrow);
        box.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow) {
      box.removeChild(arrow);
    }
  }
  return {
    popper: popper,
    onUpdate: onUpdate
  };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away

render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`

var mountedInstances = [];
function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
  // 🔒 Private members
  // ===========================================================================

  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget; // ===========================================================================
  // 🔑 Public members
  // ===========================================================================

  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: div(),
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    hideWithInteractivity: hideWithInteractivity,
    enable: enable,
    disable: disable,
    unmount: unmount,
    destroy: destroy
  }; // TODO: Investigate why this early return causes a TDZ error in the tests —
  // it doesn't seem to happen in the browser

  /* istanbul ignore if */

  if (!props.render) {
    if (process.env.NODE_ENV !== "production") {
      errorWhen(true, 'render() function has not been supplied.');
    }
    return instance;
  } // ===========================================================================
  // Initial mutations
  // ===========================================================================

  var _props$render = props.render(instance),
    popper = _props$render.popper,
    onUpdate = _props$render.onUpdate;
  popper.setAttribute('data-tippy-root', '');
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook('onCreate', [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding

  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function () {
    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
    }
  });
  return instance; // ===========================================================================
  // 🔒 Private methods
  // ===========================================================================

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;

    // @ts-ignore
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }
  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
    popper.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    // Moved finger to scroll instead of an intentional tap outside
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === 'mousedown') {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

    if (instance.props.interactive && actualContains(popper, actualTarget)) {
      return;
    } // Clicked on the event listeners target

    if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
        return;
      }
    } else {
      invokeHook('onClickOutside', [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener('mousedown', onDocumentPress, true);
    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener('mousedown', onDocumentPress, true);
    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise

    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(box, 'add', listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, {
        passive: true
      });
      on('touchend', onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }
      on(eventType, onTrigger);
      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;
        case 'focus':
          on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;
        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
        eventType = _ref.eventType,
        handler = _ref.handler,
        options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips

    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
      var _instance$popperInsta;
      var instance = popper._tippy;
      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state) {
        return {
          popperRect: popper.getBoundingClientRect(),
          popperState: state,
          props: props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper

    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
      popperOptions = _instance$props2.popperOptions,
      placement = _instance$props2.placement,
      offset = _instance$props2.offset,
      getReferenceClientRect = _instance$props2.getReferenceClientRect,
      moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: '$$tippy',
      enabled: true,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref2) {
        var state = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
            box = _getDefaultTemplateCh.box;
          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
            if (attr === 'placement') {
              box.setAttribute('data-placement', state.placement);
            } else {
              if (state.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, '');
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: 'offset',
      options: {
        offset: offset
      }
    }, {
      name: 'preventOverflow',
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: 'flip',
      options: {
        padding: 5
      }
    }, {
      name: 'computeStyles',
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: 'arrow',
        options: {
          element: arrow,
          padding: 3
        }
      });
    }
    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = (0, _core.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {
      placement: placement,
      onFirstUpdate: onFirstUpdate,
      modifiers: modifiers
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper needs to read its dimensions

    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    /* istanbul ignore else */

    if (process.env.NODE_ENV !== "production") {
      // Accessibility check
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
      touchValue = _getNormalizedTouchSe[0],
      touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.

    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  } // ===========================================================================
  // 🔑 Public methods
  // ===========================================================================

  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    } // Ensure stale aria-expanded attributes are removed

    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
      // and the nested ones get re-rendered first.
      // https://github.com/atomiks/tippyjs-react/issues/177
      // TODO: find a cleaner / more efficient solution(!)

      getNestedPopperTree().forEach(function (nestedPopper) {
        // React (and other UI libs likely) requires a rAF wrapper as it flushes
        // its work in one
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook('onAfterUpdate', [instance, partialProps]);
  }
  function setContent(content) {
    instance.setProps({
      content: content
    });
  }
  function show() {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
    } // Early bail-out

    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.

    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }
    invokeHook('onShow', [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'visible';
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper.style.transition = 'none';
    } // If flipping to the opposite side after hiding at least once, the
    // animation will use the wrong placement without resetting the duration

    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
        box = _getDefaultTemplateCh2.box,
        content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true; // reflow

      void popper.offsetHeight;
      popper.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
          _box = _getDefaultTemplateCh3.box,
          _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], 'visible');
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
      // popper has been positioned for the first time

      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook('onMount', [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook('onShown', [instance]);
        });
      }
    };
    mount();
  }
  function hide() {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
    } // Early bail-out

    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook('onHide', [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'hidden';
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
        box = _getDefaultTemplateCh4.box,
        content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], 'hidden');
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
    }
    getDocument().addEventListener('mousemove', debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
    // tree by default. This seems mainly for interactive tippies, but we should
    // find a workaround if possible

    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }
    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook('onHidden', [instance]);
  }
  function destroy() {
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  /* istanbul ignore else */

  if (process.env.NODE_ENV !== "production") {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins
  });
  var elements = getArrayOfElements(targets);
  /* istanbul ignore else */

  if (process.env.NODE_ENV !== "production") {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
  }
  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var hideAll = exports.hideAll = function hideAll(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    excludedReferenceOrInstance = _ref.exclude,
    duration = _ref.duration;
  mountedInstances.forEach(function (instance) {
    var isExcluded = false;
    if (excludedReferenceOrInstance) {
      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
    }
    if (!isExcluded) {
      var originalDuration = instance.props.duration;
      instance.setProps({
        duration: duration
      });
      instance.hide();
      if (!instance.state.isDestroyed) {
        instance.setProps({
          duration: originalDuration
        });
      }
    }
  });
};

// every time the popper is destroyed (i.e. a new target), removing the styles
// and causing transitions to break for singletons when the console is open, but
// most notably for non-transform styles being used, `gpuAcceleration: false`.

var applyStylesModifier = Object.assign({}, _core.applyStyles, {
  effect: function effect(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    } // intentionally return no cleanup function
    // return () => { ... }
  }
});
var createSingleton = exports.createSingleton = function createSingleton(tippyInstances, optionalProps) {
  var _optionalProps$popper;
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== "production") {
    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));
  }
  var individualInstances = tippyInstances;
  var references = [];
  var triggerTargets = [];
  var currentTarget;
  var overrides = optionalProps.overrides;
  var interceptSetPropsCleanups = [];
  var shownOnCreate = false;
  function setTriggerTargets() {
    triggerTargets = individualInstances.map(function (instance) {
      return normalizeToArray(instance.props.triggerTarget || instance.reference);
    }).reduce(function (acc, item) {
      return acc.concat(item);
    }, []);
  }
  function setReferences() {
    references = individualInstances.map(function (instance) {
      return instance.reference;
    });
  }
  function enableInstances(isEnabled) {
    individualInstances.forEach(function (instance) {
      if (isEnabled) {
        instance.enable();
      } else {
        instance.disable();
      }
    });
  }
  function interceptSetProps(singleton) {
    return individualInstances.map(function (instance) {
      var originalSetProps = instance.setProps;
      instance.setProps = function (props) {
        originalSetProps(props);
        if (instance.reference === currentTarget) {
          singleton.setProps(props);
        }
      };
      return function () {
        instance.setProps = originalSetProps;
      };
    });
  } // have to pass singleton, as it maybe undefined on first call

  function prepareInstance(singleton, target) {
    var index = triggerTargets.indexOf(target); // bail-out

    if (target === currentTarget) {
      return;
    }
    currentTarget = target;
    var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
      acc[prop] = individualInstances[index].props[prop];
      return acc;
    }, {});
    singleton.setProps(Object.assign({}, overrideProps, {
      getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {
        var _references$index;
        return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();
      }
    }));
  }
  enableInstances(false);
  setReferences();
  setTriggerTargets();
  var plugin = {
    fn: function fn() {
      return {
        onDestroy: function onDestroy() {
          enableInstances(true);
        },
        onHidden: function onHidden() {
          currentTarget = null;
        },
        onClickOutside: function onClickOutside(instance) {
          if (instance.props.showOnCreate && !shownOnCreate) {
            shownOnCreate = true;
            currentTarget = null;
          }
        },
        onShow: function onShow(instance) {
          if (instance.props.showOnCreate && !shownOnCreate) {
            shownOnCreate = true;
            prepareInstance(instance, references[0]);
          }
        },
        onTrigger: function onTrigger(instance, event) {
          prepareInstance(instance, event.currentTarget);
        }
      };
    }
  };
  var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
    plugins: [plugin].concat(optionalProps.plugins || []),
    triggerTarget: triggerTargets,
    popperOptions: Object.assign({}, optionalProps.popperOptions, {
      modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])
    })
  }));
  var originalShow = singleton.show;
  singleton.show = function (target) {
    originalShow(); // first time, showOnCreate or programmatic call with no params
    // default to showing first instance

    if (!currentTarget && target == null) {
      return prepareInstance(singleton, references[0]);
    } // triggered from event (do nothing as prepareInstance already called by onTrigger)
    // programmatic call with no params when already visible (do nothing again)

    if (currentTarget && target == null) {
      return;
    } // target is index of instance

    if (typeof target === 'number') {
      return references[target] && prepareInstance(singleton, references[target]);
    } // target is a child tippy instance

    if (individualInstances.indexOf(target) >= 0) {
      var ref = target.reference;
      return prepareInstance(singleton, ref);
    } // target is a ReferenceElement

    if (references.indexOf(target) >= 0) {
      return prepareInstance(singleton, target);
    }
  };
  singleton.showNext = function () {
    var first = references[0];
    if (!currentTarget) {
      return singleton.show(0);
    }
    var index = references.indexOf(currentTarget);
    singleton.show(references[index + 1] || first);
  };
  singleton.showPrevious = function () {
    var last = references[references.length - 1];
    if (!currentTarget) {
      return singleton.show(last);
    }
    var index = references.indexOf(currentTarget);
    var target = references[index - 1] || last;
    singleton.show(target);
  };
  var originalSetProps = singleton.setProps;
  singleton.setProps = function (props) {
    overrides = props.overrides || overrides;
    originalSetProps(props);
  };
  singleton.setInstances = function (nextInstances) {
    enableInstances(true);
    interceptSetPropsCleanups.forEach(function (fn) {
      return fn();
    });
    individualInstances = nextInstances;
    enableInstances(false);
    setReferences();
    setTriggerTargets();
    interceptSetPropsCleanups = interceptSetProps(singleton);
    singleton.setProps({
      triggerTarget: triggerTargets
    });
  };
  interceptSetPropsCleanups = interceptSetProps(singleton);
  return singleton;
};
var BUBBLING_EVENTS_MAP = {
  mouseover: 'mouseenter',
  focusin: 'focus',
  click: 'click'
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */

function delegate(targets, props) {
  /* istanbul ignore else */
  if (process.env.NODE_ENV !== "production") {
    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
  }
  var listeners = [];
  var childTippyInstances = [];
  var disabled = false;
  var target = props.target;
  var nativeProps = removeProperties(props, ['target']);
  var parentProps = Object.assign({}, nativeProps, {
    trigger: 'manual',
    touch: false
  });
  var childProps = Object.assign({
    touch: defaultProps.touch
  }, nativeProps, {
    showOnCreate: true
  });
  var returnValue = tippy(targets, parentProps);
  var normalizedReturnValue = normalizeToArray(returnValue);
  function onTrigger(event) {
    if (!event.target || disabled) {
      return;
    }
    var targetNode = event.target.closest(target);
    if (!targetNode) {
      return;
    } // Get relevant trigger with fallbacks:
    // 1. Check `data-tippy-trigger` attribute on target node
    // 2. Fallback to `trigger` passed to `delegate()`
    // 3. Fallback to `defaultProps.trigger`

    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

    if (targetNode._tippy) {
      return;
    }
    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
      return;
    }
    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {
      return;
    }
    var instance = tippy(targetNode, childProps);
    if (instance) {
      childTippyInstances = childTippyInstances.concat(instance);
    }
  }
  function on(node, eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    node.addEventListener(eventType, handler, options);
    listeners.push({
      node: node,
      eventType: eventType,
      handler: handler,
      options: options
    });
  }
  function addEventListeners(instance) {
    var reference = instance.reference;
    on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);
    on(reference, 'mouseover', onTrigger);
    on(reference, 'focusin', onTrigger);
    on(reference, 'click', onTrigger);
  }
  function removeEventListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
        eventType = _ref.eventType,
        handler = _ref.handler,
        options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function applyMutations(instance) {
    var originalDestroy = instance.destroy;
    var originalEnable = instance.enable;
    var originalDisable = instance.disable;
    instance.destroy = function (shouldDestroyChildInstances) {
      if (shouldDestroyChildInstances === void 0) {
        shouldDestroyChildInstances = true;
      }
      if (shouldDestroyChildInstances) {
        childTippyInstances.forEach(function (instance) {
          instance.destroy();
        });
      }
      childTippyInstances = [];
      removeEventListeners();
      originalDestroy();
    };
    instance.enable = function () {
      originalEnable();
      childTippyInstances.forEach(function (instance) {
        return instance.enable();
      });
      disabled = false;
    };
    instance.disable = function () {
      originalDisable();
      childTippyInstances.forEach(function (instance) {
        return instance.disable();
      });
      disabled = true;
    };
    addEventListeners(instance);
  }
  normalizedReturnValue.forEach(applyMutations);
  return returnValue;
}
var animateFill = exports.animateFill = {
  name: 'animateFill',
  defaultValue: false,
  fn: function fn(instance) {
    var _instance$props$rende;

    // @ts-ignore
    if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {
      if (process.env.NODE_ENV !== "production") {
        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');
      }
      return {};
    }
    var _getChildren = getChildren(instance.popper),
      box = _getChildren.box,
      content = _getChildren.content;
    var backdrop = instance.props.animateFill ? createBackdropElement() : null;
    return {
      onCreate: function onCreate() {
        if (backdrop) {
          box.insertBefore(backdrop, box.firstElementChild);
          box.setAttribute('data-animatefill', '');
          box.style.overflow = 'hidden';
          instance.setProps({
            arrow: false,
            animation: 'shift-away'
          });
        }
      },
      onMount: function onMount() {
        if (backdrop) {
          var transitionDuration = box.style.transitionDuration;
          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
          // tooltip element. `clip-path` is the other alternative but is not
          // well-supported and is buggy on some devices.

          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          setVisibilityState([backdrop], 'visible');
        }
      },
      onShow: function onShow() {
        if (backdrop) {
          backdrop.style.transitionDuration = '0ms';
        }
      },
      onHide: function onHide() {
        if (backdrop) {
          setVisibilityState([backdrop], 'hidden');
        }
      }
    };
  }
};
function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  setVisibilityState([backdrop], 'hidden');
  return backdrop;
}
var mouseCoords = {
  clientX: 0,
  clientY: 0
};
var activeInstances = [];
function storeMouseCoords(_ref) {
  var clientX = _ref.clientX,
    clientY = _ref.clientY;
  mouseCoords = {
    clientX: clientX,
    clientY: clientY
  };
}
function addMouseCoordsListener(doc) {
  doc.addEventListener('mousemove', storeMouseCoords);
}
function removeMouseCoordsListener(doc) {
  doc.removeEventListener('mousemove', storeMouseCoords);
}
var followCursor = exports.followCursor = {
  name: 'followCursor',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;
    var doc = getOwnerDocument(instance.props.triggerTarget || reference);
    var isInternalUpdate = false;
    var wasFocusEvent = false;
    var isUnmounted = true;
    var prevProps = instance.props;
    function getIsInitialBehavior() {
      return instance.props.followCursor === 'initial' && instance.state.isVisible;
    }
    function addListener() {
      doc.addEventListener('mousemove', onMouseMove);
    }
    function removeListener() {
      doc.removeEventListener('mousemove', onMouseMove);
    }
    function unsetGetReferenceClientRect() {
      isInternalUpdate = true;
      instance.setProps({
        getReferenceClientRect: null
      });
      isInternalUpdate = false;
    }
    function onMouseMove(event) {
      // If the instance is interactive, avoid updating the position unless it's
      // over the reference element
      var isCursorOverReference = event.target ? reference.contains(event.target) : true;
      var followCursor = instance.props.followCursor;
      var clientX = event.clientX,
        clientY = event.clientY;
      var rect = reference.getBoundingClientRect();
      var relativeX = clientX - rect.left;
      var relativeY = clientY - rect.top;
      if (isCursorOverReference || !instance.props.interactive) {
        instance.setProps({
          // @ts-ignore - unneeded DOMRect properties
          getReferenceClientRect: function getReferenceClientRect() {
            var rect = reference.getBoundingClientRect();
            var x = clientX;
            var y = clientY;
            if (followCursor === 'initial') {
              x = rect.left + relativeX;
              y = rect.top + relativeY;
            }
            var top = followCursor === 'horizontal' ? rect.top : y;
            var right = followCursor === 'vertical' ? rect.right : x;
            var bottom = followCursor === 'horizontal' ? rect.bottom : y;
            var left = followCursor === 'vertical' ? rect.left : x;
            return {
              width: right - left,
              height: bottom - top,
              top: top,
              right: right,
              bottom: bottom,
              left: left
            };
          }
        });
      }
    }
    function create() {
      if (instance.props.followCursor) {
        activeInstances.push({
          instance: instance,
          doc: doc
        });
        addMouseCoordsListener(doc);
      }
    }
    function destroy() {
      activeInstances = activeInstances.filter(function (data) {
        return data.instance !== instance;
      });
      if (activeInstances.filter(function (data) {
        return data.doc === doc;
      }).length === 0) {
        removeMouseCoordsListener(doc);
      }
    }
    return {
      onCreate: create,
      onDestroy: destroy,
      onBeforeUpdate: function onBeforeUpdate() {
        prevProps = instance.props;
      },
      onAfterUpdate: function onAfterUpdate(_, _ref2) {
        var followCursor = _ref2.followCursor;
        if (isInternalUpdate) {
          return;
        }
        if (followCursor !== undefined && prevProps.followCursor !== followCursor) {
          destroy();
          if (followCursor) {
            create();
            if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {
              addListener();
            }
          } else {
            removeListener();
            unsetGetReferenceClientRect();
          }
        }
      },
      onMount: function onMount() {
        if (instance.props.followCursor && !wasFocusEvent) {
          if (isUnmounted) {
            onMouseMove(mouseCoords);
            isUnmounted = false;
          }
          if (!getIsInitialBehavior()) {
            addListener();
          }
        }
      },
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          mouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY
          };
        }
        wasFocusEvent = event.type === 'focus';
      },
      onHidden: function onHidden() {
        if (instance.props.followCursor) {
          unsetGetReferenceClientRect();
          removeListener();
          isUnmounted = true;
        }
      }
    };
  }
};
function getProps(props, modifier) {
  var _props$popperOptions;
  return {
    popperOptions: Object.assign({}, props.popperOptions, {
      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {
        var name = _ref.name;
        return name !== modifier.name;
      }), [modifier])
    })
  };
}
var inlinePositioning = exports.inlinePositioning = {
  name: 'inlinePositioning',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;
    function isEnabled() {
      return !!instance.props.inlinePositioning;
    }
    var placement;
    var cursorRectIndex = -1;
    var isInternalUpdate = false;
    var triedPlacements = [];
    var modifier = {
      name: 'tippyInlinePositioning',
      enabled: true,
      phase: 'afterWrite',
      fn: function fn(_ref2) {
        var state = _ref2.state;
        if (isEnabled()) {
          if (triedPlacements.indexOf(state.placement) !== -1) {
            triedPlacements = [];
          }
          if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {
            triedPlacements.push(state.placement);
            instance.setProps({
              // @ts-ignore - unneeded DOMRect properties
              getReferenceClientRect: function getReferenceClientRect() {
                return _getReferenceClientRect(state.placement);
              }
            });
          }
          placement = state.placement;
        }
      }
    };
    function _getReferenceClientRect(placement) {
      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
    }
    function setInternalProps(partialProps) {
      isInternalUpdate = true;
      instance.setProps(partialProps);
      isInternalUpdate = false;
    }
    function addModifier() {
      if (!isInternalUpdate) {
        setInternalProps(getProps(instance.props, modifier));
      }
    }
    return {
      onCreate: addModifier,
      onAfterUpdate: addModifier,
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          var rects = arrayFrom(instance.reference.getClientRects());
          var cursorRect = rects.find(function (rect) {
            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
          });
          var index = rects.indexOf(cursorRect);
          cursorRectIndex = index > -1 ? index : cursorRectIndex;
        }
      },
      onHidden: function onHidden() {
        cursorRectIndex = -1;
      }
    };
  }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
  // Not an inline element, or placement is not yet known
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  } // There are two rects and they are disjoined

  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
    return clientRects[cursorRectIndex] || boundingRect;
  }
  switch (currentBasePlacement) {
    case 'top':
    case 'bottom':
      {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === 'top';
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top: top,
          bottom: bottom,
          left: left,
          right: right,
          width: width,
          height: height
        };
      }
    case 'left':
    case 'right':
      {
        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function (rect) {
          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;
        var _width = _right - _left;
        var _height = _bottom - _top;
        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }
    default:
      {
        return boundingRect;
      }
  }
}
var sticky = exports.sticky = {
  name: 'sticky',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
      popper = instance.popper;
    function getReference() {
      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
    }
    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }
    var prevRefRect = null;
    var prevPopRect = null;
    function updatePosition() {
      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;
      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
        if (instance.popperInstance) {
          instance.popperInstance.update();
        }
      }
      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;
      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }
    return {
      onMount: function onMount() {
        if (instance.props.sticky) {
          updatePosition();
        }
      }
    };
  }
};
function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
  }
  return true;
}
tippy.setDefaultProps({
  render: render
});
var _default = exports["default"] = tippy;

}).call(this)}).call(this,require('_process'))
},{"@popperjs/core":27,"_process":97}],177:[function(require,module,exports){
module.exports=function(e){var r={};function t(n){if(r[n])return r[n].exports;var a=r[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var a in e)t.d(n,a,function(r){return e[r]}.bind(null,a));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=0)}([function(e,r,t){"use strict";t.r(r),t.d(r,"validateHTMLColorName",(function(){return l})),t.d(r,"validateHTMLColorSpecialName",(function(){return i})),t.d(r,"validateHTMLColorHex",(function(){return u})),t.d(r,"validateHTMLColorRgb",(function(){return g})),t.d(r,"validateHTMLColorHsl",(function(){return y})),t.d(r,"validateHTMLColorHwb",(function(){return L})),t.d(r,"validateHTMLColorLab",(function(){return S})),t.d(r,"validateHTMLColorLch",(function(){return m})),t.d(r,"validateHTMLColor",(function(){return G}));const n=e=>e&&"string"==typeof e,a=["AliceBlue","AntiqueWhite","Aqua","Aquamarine","Azure","Beige","Bisque","Black","BlanchedAlmond","Blue","BlueViolet","Brown","BurlyWood","CadetBlue","Chartreuse","Chocolate","Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","DarkBlue","DarkCyan","DarkGoldenrod","DarkGray","DarkGrey","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","DarkOrange","DarkOrchid","DarkRed","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray","DarkSlateGrey","DarkTurquoise","DarkViolet","DeepPink","DeepSkyBlue","DimGray","DimGrey","DodgerBlue","FireBrick","FloralWhite","ForestGreen","Fuchsia","Gainsboro","GhostWhite","Gold","Goldenrod","Gray","Grey","Green","GreenYellow","HoneyDew","HotPink","IndianRed","Indigo","Ivory","Khaki","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral","LightCyan","LightGoldenrodYellow","LightGray","LightGrey","LightGreen","LightPink","LightSalmon","LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSlateGrey","LightSteelBlue","LightYellow","Lime","LimeGreen","Linen","Magenta","Maroon","MediumAquamarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen","MediumSlateBlue","MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue","MintCream","MistyRose","Moccasin","NavajoWhite","Navy","OldLace","Olive","OliveDrab","Orange","OrangeRed","Orchid","PaleGoldenrod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip","PeachPuff","Peru","Pink","Plum","PowderBlue","Purple","RebeccaPurple","Red","RosyBrown","RoyalBlue","SaddleBrown","Salmon","SandyBrown","SeaGreen","SeaShell","Sienna","Silver","SkyBlue","SlateBlue","SlateGray","SlateGrey","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle","Tomato","Turquoise","Violet","Wheat","White","WhiteSmoke","Yellow","YellowGreen"],o=["currentColor","inherit","transparent"],l=e=>{let r=!1;return n(e)&&a.map(t=>(e.toLowerCase()===t.toLowerCase()&&(r=!0),null)),r},i=e=>{let r=!1;return n(e)&&o.map(t=>(e.toLowerCase()===t.toLowerCase()&&(r=!0),null)),r},u=e=>{if(n(e)){const r=/^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$/i;return e&&r.test(e)}return!1},d="(([\\d]{0,5})((\\.([\\d]{1,5}))?))",s=`(${d}%)`,c="(([0-9]|[1-9][0-9]|100)%)",f=`(${c}|(0?((\\.([\\d]{1,5}))?))|1)`,h=`([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?)([\\s]{1,5})${`(((${c}))|(0?((\\.([\\d]{1,5}))?))|1))?`}([\\s]{0,5})\\)`,$="(-?(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360)(deg)?)",g=e=>{if(n(e)){const r="([\\s]{0,5})([\\d]{1,5})%?([\\s]{0,5}),?",t="((([\\s]{0,5}),?([\\s]{0,5}))|(([\\s]{1,5})))",n=new RegExp(`^(rgb)a?\\(${`${r}${t}`}${`${r}${t}`}${`${r}${t}`}(${"(\\/?([\\s]{0,5})(0?\\.?([\\d]{1,5})%?([\\s]{0,5}))?|1|0)"})?\\)$`);return e&&n.test(e)}return!1},y=e=>{if(n(e)){const r=new RegExp(`^(hsl)a?\\((([\\s]{0,5})(${$}|${"(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-9][0-9]|400)grad)"}|${"((([0-5])?\\.([\\d]{1,5})|6\\.([0-9]|1[0-9]|2[0-8])|[0-6])rad)"}|${"((0?((\\.([\\d]{1,5}))?)|1)turn)"})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${c})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${c})([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?|,?)([\\s]{0,5})(((${c}))|(0?((\\.([\\d]{1,5}))?))|1))?\\)$`);return e&&r.test(e)}return!1},L=e=>{if(n(e)){const r=new RegExp(`^(hwb\\(([\\s]{0,5})${$}([\\s]{1,5}))((0|${c})([\\s]{1,5}))((0|${c})${h}$`);return e&&r.test(e)}return!1},S=e=>{if(n(e)){const r="(-?(([0-9]|[1-9][0-9]|1[0-5][0-9])((\\.([\\d]{1,5}))?)?|160))",t=new RegExp(`^(lab\\(([\\s]{0,5})${s}([\\s]{1,5})${r}([\\s]{1,5})${r}${h}$`);return e&&t.test(e)}return!1},m=e=>{if(n(e)){const r="((([0-9]|[1-9][0-9])?((\\.([\\d]{1,5}))?)|100)(%)?)",t=""+d,n=`((${$})|(0|${f})|(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360))`,a=`(\\/([\\s]{0,5})${f})`,o=new RegExp(`^lch\\(${`(([\\s]{0,5})${r}([\\s]{1,5})${t}([\\s]{1,5})${n}([\\s]{0,5})(${a})?)`}\\)$`);return e&&o.test(e)}return!1},G=e=>!!(e&&u(e)||g(e)||y(e)||L(e)||S(e)||m(e));r.default=e=>!!(e&&u(e)||l(e)||i(e)||g(e)||y(e)||L(e)||S(e)||m(e))}]);
},{}]},{},[1]);
